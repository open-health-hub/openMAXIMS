//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Billy Mahon using IMS Development Environment (version 1.22 build 50124.900)
// Copyright (C) 1995-2005 IMS MAXIMS plc. All rights reserved.

package ims.spinalinjuries.domain.impl;

import java.util.ArrayList;
import java.util.List;

import ims.admin.domain.HcpAdmin;
import ims.admin.domain.impl.HcpAdminImpl;
import ims.clinicaladmin.domain.Vertebrallevels;
import ims.clinicaladmin.domain.impl.VertebrallevelsImpl;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.vo.ClinicalContactShortVo;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.VertebrallevelVoCollection;
import ims.core.vo.lookups.ContactType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.impl.DomainImpl;
import ims.framework.enumerations.SortOrder;
import ims.generalmedical.vo.AdmisNeuroInterpretVo;
import ims.generalmedical.vo.NeuroInterpretShortVo;
import ims.generalmedical.vo.NeuroInterpretShortVoCollection;
import ims.generalmedical.vo.NeuroInterpretVo;
import ims.generalmedical.vo.NeuroInterpretVoCollection;
import ims.generalmedical.vo.NeuroMotorExaminationVo;
import ims.generalmedical.vo.NeuroSensationExaminationVo;
import ims.generalmedical.vo.domain.NeuroInterpretShortVoAssembler;
import ims.generalmedical.vo.domain.NeuroInterpretVoAssembler;
import ims.medical.domain.objects.NeuInterpret;
import ims.spinalinjuries.domain.MedNeuroMotor;
import ims.spinalinjuries.domain.MedNeuroSensation;

public class MedNeuroInterpImpl extends DomainImpl implements ims.spinalinjuries.domain.MedNeuroInterp, ims.domain.impl.Transactional
{
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	* List of HCP's
	*/
	public HcpLiteVoCollection listHcpLiteByName(String hcpName)
	{
		HcpAdmin impl = (HcpAdmin) getDomainImpl(HcpAdminImpl.class);
		return impl.listHcpLiteByName(hcpName);

	}

	public VertebrallevelVoCollection listVertebralLevel(Boolean activeOnly) 
	{
		Vertebrallevels impl = (Vertebrallevels) getDomainImpl(VertebrallevelsImpl.class);
		return impl.listVertebralLevel(Boolean.TRUE);	
	}

	public AdmisNeuroInterpretVo saveAdmisNeuroInterpret(AdmisNeuroInterpretVo admisNeuroInterpret, ClinicalContactShortVo contact) throws StaleObjectException, UniqueKeyViolationException 
	{
		if (!admisNeuroInterpret.isValidated())
			throw new DomainRuntimeException("Neuro Interpret has not been validated");

		DomainFactory factory = getDomainFactory();

		if(admisNeuroInterpret.getNeuroInterpretIsNotNull()){
			if (admisNeuroInterpret.getNeuroInterpret().getID_NeuInterpret() == null && admisNeuroInterpret.getNeuroInterpret().getClinicalContactIsNotNull())//Inserting a record
			{
				StringBuffer hql = new StringBuffer();
				hql.append("from NeuInterpret as ner where ner.clinicalContact.id = :CCID and ner.isRIE is null");
				java.util.List list = getDomainFactory().find(hql.toString(), "CCID",admisNeuroInterpret.getNeuroInterpret().getClinicalContact().getID_ClinicalContact());
				if (list == null || list.size() > 0)
					throw new UniqueKeyViolationException(" The screen will be refreshed.");
			}
			
			NeuInterpret doNeuInterpret = NeuroInterpretVoAssembler.extractNeuInterpret(factory, admisNeuroInterpret.getNeuroInterpret());
			factory.save(doNeuInterpret);
			admisNeuroInterpret.setNeuroInterpret(NeuroInterpretVoAssembler.create(doNeuInterpret));
		}
		
		return admisNeuroInterpret;
	}

	public NeuroMotorExaminationVo getNeuroMotorRecord(ClinicalContactShortVo contact) 
	{
		MedNeuroMotor medNeuroMotor = (MedNeuroMotor)getDomainImpl(MedNeuroMotorImpl.class);
		return medNeuroMotor.getNeuroMotorRecord(contact, null);
	}

	public AdmisNeuroInterpretVo getAdmisNeuroInterpret(ClinicalContactShortVo contact, NeuroInterpretShortVo neuroInterpret) 
	{
		DomainFactory factory = getDomainFactory();
		
		AdmisNeuroInterpretVo voAdmisNeuroInterpret = new AdmisNeuroInterpretVo();
		if(neuroInterpret != null)
		{
			voAdmisNeuroInterpret.setNeuroInterpret(get(neuroInterpret));
			return voAdmisNeuroInterpret;
		}
		else
		{
			ArrayList markers = new ArrayList();
			ArrayList values = new ArrayList();
		
			
			NeuroInterpretVoCollection collNeuroInterpretVo = new NeuroInterpretVoCollection();
			String hql = " from NeuInterpret neuInterpret"; 
			StringBuffer condStr = new StringBuffer();
			String andStr = " ";
		
			markers = new ArrayList();
			values = new ArrayList();
		
			if(contact.getID_ClinicalContactIsNotNull())
			{
				condStr.append(andStr + " neuInterpret.clinicalContact.id = :id_ClinicalContact"); 
				markers.add("id_ClinicalContact");
				values.add(contact.getID_ClinicalContact());
				andStr = " and ";
			}	
			
			if (andStr.equals(" and "))
				hql += " where ";
		
			hql += condStr.toString();
			collNeuroInterpretVo = NeuroInterpretVoAssembler.createNeuroInterpretVoCollectionFromNeuInterpret(factory.find(hql, markers, values));
			if(collNeuroInterpretVo.size()>0)
				voAdmisNeuroInterpret.setNeuroInterpret(collNeuroInterpretVo.get(0));
		
			return voAdmisNeuroInterpret;
		}
	}

	public NeuroSensationExaminationVo getNeuroSensationExamination(ClinicalContactShortVo contact) 
	{
		MedNeuroSensation medNeuroSensation = (MedNeuroSensation)getDomainImpl(MedNeuroSensationImpl.class);
		return medNeuroSensation.getNeuroSensationRecord(contact, null);
	}

	public NeuroInterpretShortVoCollection listNeuroInterpret(ClinicalContactShortVo voClinicalContactShort)
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer();
		String query = "from NeuInterpret neuInterpret ";
		ArrayList markers= new ArrayList();
		ArrayList values = new ArrayList();
		String andStr = " ";

		if(voClinicalContactShort!=null)
		{
			hql.append(andStr + " neuInterpret.clinicalContact.id = :cc");
			markers.add("cc");
			values.add(voClinicalContactShort.getID_ClinicalContact());
			andStr = " and ";
		}
		
		if (markers.size() > 0) query += " where ";
		query += hql.toString();	
		
		List neuros = factory.find(query,markers,values);
		NeuroInterpretShortVoCollection voNeuroInterpretShortColl = NeuroInterpretShortVoAssembler.createNeuroInterpretShortVoCollectionFromNeuInterpret(neuros);
		if(voNeuroInterpretShortColl != null && voNeuroInterpretShortColl.size() > 0)
			return voNeuroInterpretShortColl.sort(SortOrder.DESCENDING);
		else	
			return null;
	}
	
	public NeuroInterpretShortVoCollection listNeuroInterpretByCareContext(CareContextRefVo refCareContext) {
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer();
		String query = "from NeuInterpret neuInterpret ";
		ArrayList markers= new ArrayList();
		ArrayList values = new ArrayList();
		String andStr = " ";

		if(refCareContext.getID_CareContextIsNotNull())
		{
			hql.append(andStr + " neuInterpret.careContext.id = :cc");
			markers.add("cc");
			values.add(refCareContext.getID_CareContext());
			andStr = " and ";
		}
		
		if (markers.size() > 0) query += " where ";
		query += hql.toString();	
		
		List neuros = factory.find(query,markers,values);
		NeuroInterpretShortVoCollection voNeuroInterpretShortColl = NeuroInterpretShortVoAssembler.createNeuroInterpretShortVoCollectionFromNeuInterpret(neuros);
		if(voNeuroInterpretShortColl != null)
			return voNeuroInterpretShortColl.sort(SortOrder.DESCENDING);
		else	
			return null;
	}

	public AdmisNeuroInterpretVo getAdmisNeuroInterpretByCareContext(CareContextRefVo careContext, NeuroInterpretShortVo neuroInterpret) {
		DomainFactory factory = getDomainFactory();

		AdmisNeuroInterpretVo voAdmisNeuroInterpret = new AdmisNeuroInterpretVo();
		
		if(neuroInterpret != null)
		{
			voAdmisNeuroInterpret.setNeuroInterpret(get(neuroInterpret));
			return voAdmisNeuroInterpret;
		}
		else
		{
			ArrayList markers = new ArrayList();
			ArrayList values = new ArrayList();
		
			NeuroInterpretVoCollection collNeuroInterpretVo = new NeuroInterpretVoCollection();
			String hql = " from NeuInterpret neuInterpret"; 
			StringBuffer condStr = new StringBuffer();
			String andStr = " ";
		
			markers = new ArrayList();
			values = new ArrayList();
		
			if(careContext.getID_CareContextIsNotNull())
			{
				condStr.append(andStr + " neuInterpret.careContext.id = :id_CareContext"); 
				markers.add("id_CareContext");
				values.add(careContext.getID_CareContext());
				andStr = " and ";
			}	
			
			if (andStr.equals(" and "))
				hql += " where ";
		
			hql += condStr.toString();
			collNeuroInterpretVo = NeuroInterpretVoAssembler.createNeuroInterpretVoCollectionFromNeuInterpret(factory.find(hql, markers, values));
			if(collNeuroInterpretVo.size()>0)
				voAdmisNeuroInterpret.setNeuroInterpret(collNeuroInterpretVo.get(0));
			
		}
		
		return voAdmisNeuroInterpret;
	}

	private NeuroInterpretVo get(NeuroInterpretShortVo neuroInterpret) {
		if(neuroInterpret == null)
			throw new DomainRuntimeException("Invalid need neuro - interpretation record to get");

		return NeuroInterpretVoAssembler.create((NeuInterpret) getDomainFactory().getDomainObject(NeuInterpret.class,neuroInterpret.getID_NeuInterpret()));
	}

	public NeuroMotorExaminationVo getSpinalMedicalAdmissionMotorByCareContext(CareContextRefVo voCareContextRef)
	{
		MedNeuroMotor medNeuroMotor = (MedNeuroMotor)getDomainImpl(MedNeuroMotorImpl.class);
		return medNeuroMotor.getSpinalMedicalAdmissionMotorByCareContext(voCareContextRef);
	}

	public NeuroSensationExaminationVo getSpinalMedicalAdmissionSensationByCareContext(CareContextRefVo voCareContext)
	{
		MedNeuroSensation medNeuroSensation = (MedNeuroSensation) getDomainImpl(MedNeuroSensationImpl.class);
		return medNeuroSensation.getSpinalMedicalAdmissionSensationByCareContext(voCareContext);
	}

	public AdmisNeuroInterpretVo getSpinalMedicalAdmissionInterpretByCareContext(CareContextRefVo voCareContextRef)
	{
		DomainFactory factory = getDomainFactory();

		AdmisNeuroInterpretVo voAdmisNeuroInterpret = new AdmisNeuroInterpretVo();
	
		List motor =   factory.find(" from NeuInterpret int where int.clinicalContact.id = " + 
				"( select cons.id from CareContext con join con.clinicalContacts cons where cons.contactType = :type and con.id = :idcare)",
				new String[]{"type", "idcare" },
				new Object[]{ getDomLookup(ContactType.SPINALMEDICALADMISSION),voCareContextRef.getID_CareContext()});

		NeuroInterpretVoCollection collNeuroInterpretVo = NeuroInterpretVoAssembler.createNeuroInterpretVoCollectionFromNeuInterpret(motor);
		if(collNeuroInterpretVo != null && collNeuroInterpretVo.size()>0)
		{
			voAdmisNeuroInterpret.setNeuroInterpret(collNeuroInterpretVo.get(0));
			return voAdmisNeuroInterpret;
		}
		else
			return null;
	}

}
