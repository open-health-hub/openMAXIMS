//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Rory Fitzpatrick using IMS Development Environment (version 1.60 build 2833.15418)
// Copyright (C) 1995-2007 IMS MAXIMS plc. All rights reserved.

package ims.pathways.domain.impl;

import java.util.ArrayList;
import java.util.List;
import ims.core.admin.domain.objects.ProviderSystem;
import ims.domain.DomainFactory;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.ocrr.vo.ProviderSystemVoCollection;
import ims.ocrr.vo.domain.ProviderSystemVoAssembler;
import ims.pathways.configuration.domain.objects.RTTEvent;
import ims.pathways.domain.base.impl.BaseRTTEventConfigurationImpl;
import ims.pathways.vo.RTTEventVo;
import ims.pathways.vo.domain.RTTEventVoAssembler;

public class RTTEventConfigurationImpl extends BaseRTTEventConfigurationImpl
{

	private static final long serialVersionUID = 1L;

	/**
	* saveSurgeryDetails
	*/
	/**
	* getRTTEvent
	*/
	public ims.pathways.vo.RTTEventVo getRTTEvent(ims.pathways.configuration.vo.RTTEventRefVo rtteventRefVo)
	{
		if(rtteventRefVo == null)
			throw new RuntimeException("Cannot get RTTEventVo for null RTTEventRefVo");
		
		return RTTEventVoAssembler.create((RTTEvent)getDomainFactory().getDomainObject(RTTEvent.class, rtteventRefVo.getID_RTTEvent()));
	}

	/**
	* listRTTEvents
	*/
	public ims.pathways.vo.RTTEventVoCollection listRTTEvents(ims.pathways.vo.RTTEventVo rttEventVo)
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer(" ");
		String query = "from RTTEvent rtt ";
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		String andStr = " ";
		
		if (rttEventVo.getActionIsNotNull())
		{
			hql.append(andStr + " rtt.action = :id_action");
			markers.add("id_action");
			values.add(getDomLookup(rttEventVo.getAction()));			
			andStr = " and ";
		}
		if (rttEventVo.getNameIsNotNull())
		{
			hql.append(andStr + " rtt.upperName like :name");
			markers.add("name");
			values.add(rttEventVo.getName().toUpperCase() + "%");
			andStr = " and ";
		}
		if (rttEventVo.getPASCodeIsNotNull())
		{
			hql.append(andStr + " rtt.pASCode = :id_PASCode");
			markers.add("id_PASCode");
			values.add(rttEventVo.getPASCode());			
			andStr = " and ";
		}
		if (rttEventVo.getNationalCodeIsNotNull())
		{
			hql.append(andStr + " rtt.nationalCode = :id_NCode");
			markers.add("id_NCode");
			values.add(rttEventVo.getNationalCode());			
			andStr = " and ";
		}
		
		
		if (andStr == " and ")
			query += " where ";
		hql.append(" order by rtt.providerSystem.id asc, rtt.upperName asc");
		
		query += hql.toString();

		List rttList = factory.find(query, markers, values);
		
		return RTTEventVoAssembler.createRTTEventVoCollectionFromRTTEvent(rttList); 
	}

	public ProviderSystemVoCollection listProviderSystems() 
	{
		DomainFactory factory = getDomainFactory();
		return ProviderSystemVoAssembler.createProviderSystemVoCollectionFromProviderSystem(factory.listDomainObjects(ProviderSystem.class)).sort();
	}

	public RTTEventVo saveRTTEvent(RTTEventVo rtteventVo) throws StaleObjectException, UniqueKeyViolationException 
	{
		if(rtteventVo == null)
			throw new RuntimeException("Cannot save null RTTEventVo");
		
		if(rtteventVo.isValidated() == false)
			throw new CodingRuntimeException("RTTEventVo is not validated");
			
		DomainFactory factory = getDomainFactory();

		if (!rtteventVo.getID_RTTEventIsNotNull())
		{
			List l = factory.find("from RTTEvent rtt where upperName = :rttName", new String[]{"rttName"}, new Object[]{rtteventVo.getName().toUpperCase()});
			if (l.size() > 0)
				throw new UniqueKeyViolationException("RTT Event record called \"" + rtteventVo.getName() + "\" already exists. Duplicates not allowed.");

			List listPasCode = factory.find("from RTTEvent rtt where pASCode = :pascode", new String[]{"pascode"}, new Object[]{rtteventVo.getPASCode()});
			if (listPasCode.size() > 0)
				throw new UniqueKeyViolationException("RTT Event record with External System code \"" + rtteventVo.getPASCode() + "\" already exists. Duplicates not allowed.");
		}

		RTTEvent doRTTEvent = RTTEventVoAssembler.extractRTTEvent(factory, rtteventVo);
		doRTTEvent.setUpperName(rtteventVo.getName().toUpperCase());
		try 
		{
			factory.save(doRTTEvent);
		}
		catch (UnqViolationUncheckedException e)
		{
			throw new UniqueKeyViolationException("An RTT Event with this name already exists, Please change", e);			
		}
		
		return RTTEventVoAssembler.create(doRTTEvent);
	}
}
