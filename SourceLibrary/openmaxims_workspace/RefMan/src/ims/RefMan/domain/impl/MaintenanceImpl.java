// This code was generated by Daniel Laffan using IMS Development Environment (version 1.62 build 3126.20282)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.RefMan.domain.impl;

import ims.RefMan.domain.BookAppointment;
import ims.RefMan.domain.ClinicList;
import ims.RefMan.domain.base.impl.BaseMaintenanceImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.choose_book.domain.objects.ActionRequest;
import ims.choose_book.domain.objects.ConvId;
import ims.choose_book.domain.objects.Conversation;
import ims.choose_book.domain.objects.PdsRequest;
import ims.choose_book.domain.objects.SdsRequest;
import ims.choose_book.domain.objects.SeqPoint;
import ims.choose_book.vo.ActionRequestRefVo;
import ims.choose_book.vo.PdsRequestRefVoCollection;
import ims.choose_book.vo.SdsRequestRefVoCollection;
import ims.chooseandbook.vo.ActionRequestVoCollection;
import ims.chooseandbook.vo.PdsRequestVoCollection;
import ims.chooseandbook.vo.SdsRequestLiteVoCollection;
import ims.chooseandbook.vo.domain.ActionRequestVoAssembler;
import ims.chooseandbook.vo.domain.PdsRequestVoAssembler;
import ims.chooseandbook.vo.domain.SdsRequestLiteVoAssembler;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.core.vo.PatientShort;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.lookups.PatIdType;
import ims.core.vo.lookups.YesNo;
import ims.domain.DomainFactory;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.Sch_Booking;
import ims.scheduling.domain.objects.Session_Slot;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.SessionSlotVo;
import ims.scheduling.vo.Session_SlotRefVo;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.SessionSlotVoAssembler;
import ims.scheduling.vo.lookups.Status_Reason;

import java.util.ArrayList;
import java.util.List;


public class MaintenanceImpl extends BaseMaintenanceImpl
{
	public static final int BOOKED_APPTS=1;
	public static final int CANCELLED_APPTS=2;
	
	private static final int SLOTS_NOT_SENT=2;
	private static final int ACK_NOT_RECEIVED=3;

	private static final long serialVersionUID = 1L;

	public ims.core.vo.ServiceShortVoCollection listActiveService()
	{
		BookAppointment impl = (BookAppointment) getDomainImpl(BookAppointmentImpl.class);
		return impl.listActiveService();
	}

	/**
	* listProfileLiteByService
	*/
	public ims.scheduling.vo.ProfileLiteVoCollection listProfileLiteByService(ims.core.clinical.vo.ServiceRefVo service)
	{
		BookAppointment impl = (BookAppointment) getDomainImpl(BookAppointmentImpl.class);
		return impl.listProfileLiteByService(service);
	}

	/**
	* listSessionSlots
	*/
	public ims.scheduling.vo.SessionSlotVoCollection listSessionSlots(ims.core.clinical.vo.ServiceRefVo service, ims.scheduling.vo.Sch_ProfileRefVo profile, ims.framework.utils.Date dateFrom, ims.framework.utils.Date dateTo, Integer slotType)
	{		
		if(slotType == null)
			throw new CodingRuntimeException("Invalid parameter value slotType supplied");
		
		DomainFactory factory = getDomainFactory();

		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		
		String hql = "select slot from Session_Slot as slot left join slot.appointment as appt ";
		String andStr = " where ";
		
		if(dateFrom != null)
		{
			hql +=  andStr + "(appt.appointmentDate >= :fromDate or slot.sessDateTime >= :fromDate)";
			markers.add("fromDate");
			values.add(dateFrom.getDate());
			andStr = " and ";
		}
		
		if(dateTo != null)
		{
			hql +=  andStr + "(appt.appointmentDate <= :toDate or slot.sessDateTime <= :toDate)";
			markers.add("toDate");
			values.add(dateTo.getDate());
			andStr = " and ";
		}
		
		if(service != null && service.getID_ServiceIsNotNull())
		{
			hql += andStr + " slot.session.service.id = :idService ";
			markers.add("idService");
			values.add(service.getID_Service());
			andStr = " and ";
		}
		
		if(profile != null && profile.getID_Sch_ProfileIsNotNull())
		{
			hql += andStr + " slot.session.sch_Profile.id = :idProfile ";
			markers.add("idProfile");
			values.add(profile.getID_Sch_Profile());
			andStr = " and ";
		}
	
		// wdev-5745, depending on the slot type provided, we could be looking for cancelled provisional
		// or provisional only - depends on the tab that was enabled at the time
		if (slotType == BOOKED_APPTS)
		{
			markers.add("openProv");
			values.add(Status_Reason.PROVISIONAL.getID());
			hql += andStr + " appt.apptStatus.id = :openProv ";
		}
		else if (slotType == CANCELLED_APPTS)
		{
			markers.add("cancelProv");
			markers.add("cancelPending");
			values.add(Status_Reason.CANCEL_PROVISIONAL.getID());
			values.add(Status_Reason.CANCELLED_PENDING_APPT.getID());
			hql += andStr + " (appt.apptStatus.id = :cancelProv or ((slot.status.id = :cancelProv or slot.status.id = :cancelPending) and appt is null)) ";
			
		}

		List slots = factory.find(hql, markers, values);
		return SessionSlotVoAssembler.createSessionSlotVoCollectionFromSession_Slot(slots);
	}

	public PatientShort getBookingPatient(Booking_AppointmentVo voAppt)
	{
		ClinicList impl = (ClinicList) getDomainImpl(ClinicListImpl.class);
		return impl.getBookingPatient(voAppt);
	}

	public void cancelAppt(Booking_AppointmentVo appt) throws StaleObjectException
	{
		// wdev-5745 Confirm the cancellation of this appointment
		DomainFactory factory = getDomainFactory();
		Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, appt);
		
		// wdev-6079 clear association between appointment and slot
		if (doAppt.getSessionSlot() != null)
		{
			doAppt.getSessionSlot().clearUBRN();
			doAppt.getSessionSlot().setAppointment(null);
			doAppt.getSessionSlot().setIsActive(Boolean.TRUE);  // wdev-6097
			doAppt.getSessionSlot().setStatus(getDomLookup(Status_Reason.SLOTOPENED));
			doAppt.setSessionSlot(null);
		}
		
		factory.save(doAppt);
	}

	public void cancelSlot(Session_SlotRefVo sessionSlot) throws StaleObjectException
	{
		//	wdev-5745 Confirm the cancellation of this slot
		DomainFactory factory = getDomainFactory();
		
		Session_Slot doSlot = (Session_Slot) factory.getDomainObject(Session_Slot.class, sessionSlot.getID_Session_Slot());
		doSlot.setStatus(getDomLookup(Status_Reason.CANCELLED));
		doSlot.setStatusReason(getDomLookup(Status_Reason.CANCELLATIONCONFIRMATION));
		ims.scheduling.domain.objects.SessionSlotStatus doStat = new ims.scheduling.domain.objects.SessionSlotStatus();
		doStat.setDateTime(new java.util.Date());
		doStat.setStatus(doSlot.getStatus());
		doStat.setStatusReason(doSlot.getStatusReason());
		doSlot.getStatusReasonHistory().add(doStat);
		factory.save(doSlot);
		return;
		
	}

	public void saveSlot(SessionSlotVo slot) throws StaleObjectException
	{
		if(slot == null)
			throw new CodingRuntimeException("slot parameter is null in method saveSlot");
		if(!slot.isValidated())
			throw new CodingRuntimeException("slot parameter has note been validate in method saveSlot");
		
		DomainFactory factory = getDomainFactory();
		Session_Slot doSlot = SessionSlotVoAssembler.extractSession_Slot(factory, slot);
		factory.save(doSlot);
	}

	/**
	 * wdev-8721
	 * confirmAppt
	 * This method will save the slot details and place PDS and SDS requests
	 * if not set for the referral
	 */
	public void confirmAppt(SessionSlotVo slot) throws StaleObjectException
	{
		if(slot == null)
			throw new CodingRuntimeException("slot parameter is null in method confirmAppt");
		if(!slot.isValidated())
			throw new CodingRuntimeException("slot parameter has note been validate in method confirmAppt");
		
		ArrayList markers = new ArrayList<String>();
		ArrayList values = new ArrayList<Object>();
		DomainFactory factory = getDomainFactory();
		
		
		Session_Slot doSlot = SessionSlotVoAssembler.extractSession_Slot(factory, slot);
		factory.save(doSlot);
		
		String hql = " select c from CatsReferral c join c.appointments as appts where appts.id = :appt";
		markers.add("appt");
		values.add(doSlot.getAppointment().getId());
		List refLst = factory.find(hql, markers, values); 
		
		if (refLst != null && refLst.size() > 0)
		{
			CatsReferral domRef = (CatsReferral) refLst.get(0);
			if (domRef != null)
			{
				domRef.setConsultationAppt(doSlot.getAppointment());
				factory.save(domRef);
			}
		}
		
		PatientShort pat2 = PatientShortAssembler.create(doSlot.getAppointment().getPatient());
		String nhsn=null;
		if (pat2 != null && pat2.getPatientIdentifier(PatIdType.NHSN) != null)
			nhsn = pat2.getPatientIdentifier(PatIdType.NHSN).getIdValue();
		if (nhsn != null)
		{
			markers.clear();
			values.clear();
			hql = " from ims.choose_book.domain.objects.PdsRequest p where p.nhsn = :nhsn";
			markers.add("nhsn");
			values.add(nhsn);
			List lst = factory.find(hql, markers, values);

			PdsRequest request;
			if (lst != null && lst.size() > 0)
			{
				request = (PdsRequest) lst.get(0);
			}
			else
			{
				request = new PdsRequest();
				request.setDateTimeRequested(new java.util.Date());
			}
			request.setActive(Boolean.TRUE);
			request.setNhsn(nhsn); 
			request.setComments("Placement for PDS Request following Maintenance Conf Appt");
			factory.save(request);
		}
		
		hql = "from Sch_Booking c where c.firstAppointment.id = :appt";
		markers.clear();
		values.clear();
		markers.add("appt");
		values.add(doSlot.getAppointment().getId());
		List lst = factory.find(hql, markers, values);
		// There will only be one booking for this first appointment
		if (lst != null && lst.size() >0)
		{
			Sch_Booking booking = (Sch_Booking) lst.get(0);
			if (booking != null && booking.getReferrerSdsId() != null && booking.getReferrerSdsOrgId() != null)  // wdev-6450 it's ok to have null sdsRoleId
			{
				hql = " from ims.choose_book.domain.objects.SdsRequest s where s.referrerSdsId = :sdsId and s.referrerSdsRoleId = :sdsRoleId and s.referrerSdsOrgId = :sdsOrgId and s.appointment = :appt";
				markers.clear();
				values.clear();
				markers.add("sdsId");
				markers.add("sdsRoleId");
				markers.add("sdsOrgId");
				markers.add("appt");
				values.add(booking.getReferrerSdsId());
				values.add(booking.getReferrerSdsRoleId());
				values.add(booking.getReferrerSdsOrgId());
				values.add(doSlot.getAppointment().getId());
				lst = factory.find(hql, markers, values);

				SdsRequest request;
				if (lst != null && lst.size() > 0)
				{
					request = (SdsRequest) lst.get(0);
					request.setDateTimeLastChecked(new java.util.Date());
				}
				else
				{
					request = new SdsRequest();
					request.setDateTimeRequested(new java.util.Date());
					request.getSystemInformation().setCreationDateTime(new java.util.Date());
					request.getSystemInformation().setCreationUser("ICAB");
				}
				request.setActive(Boolean.TRUE);
				request.setReferrerSdsId(booking.getReferrerSdsId());
				request.setReferrerSdsRoleId(booking.getReferrerSdsRoleId());
				request.setReferrerSdsOrgId(booking.getReferrerSdsOrgId());
				request.setAppointment(doSlot.getAppointment().getId());
				request.setComments("Placement from Maintenance following Appt Conf");
				factory.save(request);
			}
		}
	}
	
	public ActionRequestVoCollection listSlotPolls(Date dateFrom, Date dateTo)
	{
		DomainFactory factory = getDomainFactory();
		
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		
		String dateCriteria = "";
		
		if(dateFrom != null && dateTo == null)
		{
			dateCriteria = " and req.requestDate >= :fromDate ";
			markers.add("fromDate");
			values.add(dateFrom.getDate());
		}
		
		if(dateFrom != null && dateTo != null)
		{
			dateCriteria = " and req.requestDate between :fromDate and :toDate ";
			markers.add("fromDate");
			values.add(dateFrom.getDate());
			markers.add("toDate");
			values.add(dateTo.getDate());
		}
		if(dateFrom == null && dateTo != null)
		{
			dateCriteria = " and  req.requestDate <= :toDate ";
			markers.add("toDate");
			values.add(dateTo.getDate());
		}
		
		// Current Seqpoint 2=REQ_ACK_SENT (but no slots), 3=SLOTS_DATA_SENT (no ack received)
		String hql = " select req from ActionRequest req, Conversation conv " + 
						"where conv.cid.convId = req.convId and conv.cid.cpaId = req.cpaId and conv.current.id in (" + SLOTS_NOT_SENT + "," + ACK_NOT_RECEIVED + ")" +
						"and req.requestType = :requestType " + dateCriteria;
							
		markers.add("requestType");
		values.add(getDomLookup(ActionRequestType.SLOTS_LIST));
		List requests = factory.find(hql, markers, values);
		return ActionRequestVoAssembler.createActionRequestVoCollectionFromActionRequest(requests);
	}

	/**
	 * resubmitSlotPoll
     * The purpose of this action is to allow the user to re-send the list of available slots
     * to choose and book.
     * The impl code will check the current status.  If it was previously sent, but no ack received,
     * it will set the conversation current status to 2, and update the active flag on this action request - updating the stat comment.
     * It the slot response was never sent (i.e. current = 2) it will simply set the active flag to true as a new conversation will
     * be started.
	 * @throws StaleObjectException 
	 */
	public void resubmitSlotPoll(ActionRequestRefVo request) throws StaleObjectException 
	{
		DomainFactory factory = getDomainFactory();
		
		ActionRequest domRequest = (ActionRequest) factory.getDomainObject(ActionRequest.class, request.getID_ActionRequest());
		
		// We want to get the current status of the associated conversation for this request
		ConvId convId = ConvId.getConvIdFromconv_idx(factory, domRequest.getConvId(), domRequest.getCpaId());
		if (convId != null)
		{
			Conversation conv = Conversation.getConversationFromCid(factory, convId.getId());
			if (conv != null)
			{
				if (conv.getCurrent().getId() == SLOTS_NOT_SENT)  // Slot Poll was never sent, so we just update the active status on this record
				{
					domRequest.setActive(Boolean.TRUE);
					domRequest.setStatComment("Resubmit requested from Maintenance Screen as Slots were never sent - " + new java.util.Date());
					factory.save(domRequest);
				}
				else if (conv.getCurrent().getId() == ACK_NOT_RECEIVED)
				{
					// The respond Slots was sent to Choose and Book, and No ACK returned.
					// Set the current value back to 2 so that ICAB will pick it up and re-generate
					// the slots list
					SeqPoint domSeq = (SeqPoint) factory.getDomainObject(SeqPoint.class, SLOTS_NOT_SENT);
					conv.setCurrent(domSeq);
					factory.save(conv);
					domRequest.setActive(Boolean.TRUE);
					domRequest.setStatComment("Resubmit requested from Maintenance Screen as ACK was not received - " + new java.util.Date());
					factory.save(domRequest);
				}
			}
		}
	}

	public void resubmitPdsRequest(PdsRequestRefVoCollection requests) throws StaleObjectException
	{
		if (requests == null || requests.size() == 0)
			return;
		
		DomainFactory factory = getDomainFactory();
		for (int i=0; i<requests.size(); i++)
		{
			PdsRequest domReq = (PdsRequest) factory.getDomainObject(PdsRequest.class, requests.get(i).getID_PdsRequest());
			domReq.setActive(Boolean.TRUE);
			domReq.setComments("Resubmit requested from Maintenance");
			factory.save(domReq);
		}
	}
	
	

	public PdsRequestVoCollection listPdsRequests(Date dateFrom, Date dateTo, Boolean failedRequestsOnly, String nhsn, Date dateUpdatedFrom, Date dateUpdatedTo) 
	{
		DomainFactory factory = getDomainFactory();
		
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		
		String dateCriteria = "";
		String dateUpdatedCriteria = "";
		String andStr=" where ";
		
		///////////////////////////////////////////////////////////////////////////////////////
		//Date From and DateTo
		if(dateFrom != null && dateTo == null)
		{
			dateCriteria = andStr + " req.dateTimeRequested >= :fromDate ";
			markers.add("fromDate");
			values.add(new DateTime(dateFrom, new Time("00:00:00")).getJavaDate());
			andStr=" and ";
		}
		
		if(dateFrom != null && dateTo != null)
		{
			dateCriteria = andStr + " req.dateTimeRequested between :fromDate and :toDate ";
			markers.add("fromDate");
			values.add(new DateTime(dateFrom, new Time("00:00:00")).getJavaDate());
			markers.add("toDate");
			values.add(new DateTime(dateTo, new Time("23:59:59")).getJavaDate());
			andStr=" and ";
		}
		if(dateFrom == null && dateTo != null)
		{
			dateCriteria = andStr + " req.dateTimeRequested <= :toDate ";
			markers.add("toDate");
			values.add(new DateTime(dateTo, new Time("23:59:59")).getJavaDate());
			andStr=" and ";
		}
		///////////////////////////////////////////////////////////////////////////////////////
		
		///////////////////////////////////////////////////////////////////////////////////////
		//Date Updated From and Date Updated To
		if(dateUpdatedFrom != null && dateUpdatedTo == null)
		{
			dateUpdatedCriteria = andStr + " req.dateTimeLastChecked >= :updatedFromDate ";
			markers.add("updatedFromDate");
			values.add(new DateTime(dateUpdatedFrom, new Time("00:00:00")).getJavaDate());
			andStr=" and ";
		}
		
		if(dateUpdatedFrom != null && dateUpdatedTo != null)
		{
			dateUpdatedCriteria = andStr + " req.dateTimeLastChecked between :updatedFromDate and :updatedToDate ";
			markers.add("updatedFromDate");
			values.add(new DateTime(dateUpdatedFrom, new Time("00:00:00")).getJavaDate());
			markers.add("updatedToDate");
			values.add(new DateTime(dateUpdatedTo, new Time("23:59:59")).getJavaDate());
			andStr=" and ";
		}
		if(dateUpdatedFrom == null && dateUpdatedTo != null)
		{
			dateUpdatedCriteria = andStr + " req.dateTimeLastChecked <= :updatedToDate ";
			markers.add("updatedToDate");
			values.add(new DateTime(dateUpdatedTo, new Time("23:59:59")).getJavaDate());
			andStr=" and ";
		}
		///////////////////////////////////////////////////////////////////////////////////////
		
		if (failedRequestsOnly != null && failedRequestsOnly.booleanValue())
		{
			dateCriteria += andStr + " req.success.id = :failed ";
			markers.add("failed");
			values.add(YesNo.NO.getId());
			andStr=" and ";
		}
		
		if (nhsn != null && nhsn.length() > 0)
		{
			dateCriteria += andStr + " req.nhsn = :nhsn";
			markers.add("nhsn");
			values.add(nhsn);
		}
		String hql = " from PdsRequest req " + dateCriteria + dateUpdatedCriteria;						
		List requests = factory.find(hql, markers, values);
		return PdsRequestVoAssembler.createPdsRequestVoCollectionFromPdsRequest(requests);

	}

	public SdsRequestLiteVoCollection listSdsRequest(Date dateFrom, Date dateTo, Date dateUpdatedFrom, Date dateUpdatedTo)
	{		
		DomainFactory factory = getDomainFactory();
		
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		
		String dateCriteria = "";
		String dateUpdatedCriteria = "";
		String andStr=" where ";
		
		///////////////////////////////////////////////////////////////////////////////////////
		//Date From and DateTo
		if(dateFrom != null && dateTo == null)
		{
			dateCriteria = andStr + " req.dateTimeRequested >= :fromDate ";
			markers.add("fromDate");
			values.add(new DateTime(dateFrom, new Time("00:00:00")).getJavaDate());
			andStr=" and ";
		}
		
		if(dateFrom != null && dateTo != null)
		{
			dateCriteria = andStr + " req.dateTimeRequested between :fromDate and :toDate ";
			markers.add("fromDate");
			values.add(new DateTime(dateFrom, new Time("00:00:00")).getJavaDate());
			markers.add("toDate");
			values.add(new DateTime(dateTo, new Time("23:59:59")).getJavaDate());
			andStr=" and ";
		}
		if(dateFrom == null && dateTo != null)
		{
			dateCriteria = andStr + " req.dateTimeRequested <= :toDate ";
			markers.add("toDate");
			values.add(new DateTime(dateTo, new Time("23:59:59")).getJavaDate());
			andStr=" and ";
		}
		///////////////////////////////////////////////////////////////////////////////////////
		
		///////////////////////////////////////////////////////////////////////////////////////
		//Date Updated From and Date Updated To
		if(dateUpdatedFrom != null && dateUpdatedTo == null)
		{
			dateUpdatedCriteria = andStr + " req.dateTimeLastChecked >= :updatedFromDate ";
			markers.add("updatedFromDate");
			values.add(new DateTime(dateUpdatedFrom, new Time("00:00:00")).getJavaDate());
			andStr=" and ";
		}
		
		if(dateUpdatedFrom != null && dateUpdatedTo != null)
		{
			dateUpdatedCriteria = andStr + " req.dateTimeLastChecked between :updatedFromDate and :updatedToDate ";
			markers.add("updatedFromDate");
			values.add(new DateTime(dateUpdatedFrom, new Time("00:00:00")).getJavaDate());
			markers.add("updatedToDate");
			values.add(new DateTime(dateUpdatedTo, new Time("23:59:59")).getJavaDate());
			andStr=" and ";
		}
		if(dateUpdatedFrom == null && dateUpdatedTo != null)
		{
			dateUpdatedCriteria = andStr + " req.dateTimeLastChecked <= :updatedToDate ";
			markers.add("updatedToDate");
			values.add(new DateTime(dateUpdatedTo, new Time("23:59:59")).getJavaDate());
			andStr=" and ";
		}
		///////////////////////////////////////////////////////////////////////////////////////
		
		String hql = " from SdsRequest req " + dateCriteria + dateUpdatedCriteria;						
		List requests = factory.find(hql, markers, values);
		return SdsRequestLiteVoAssembler.createSdsRequestLiteVoCollectionFromSdsRequest(requests);
	}

	public void resubmitSdsRequest(SdsRequestRefVoCollection requests) throws StaleObjectException
	{
		if (requests == null || requests.size() == 0)
			return;
		
		DomainFactory factory = getDomainFactory();
		for (int i=0; i<requests.size(); i++)
		{
			SdsRequest domReq = (SdsRequest) factory.getDomainObject(SdsRequest.class, requests.get(i).getID_SdsRequest());
			domReq.setActive(Boolean.TRUE);
			domReq.setComments("Resubmit requested from Maintenance");
			factory.save(domReq);
		}
	}
}
