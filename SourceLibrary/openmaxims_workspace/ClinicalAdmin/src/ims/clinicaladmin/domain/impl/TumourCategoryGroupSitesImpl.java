//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Catalin Tomozei using IMS Development Environment (version 1.53 build 2656.22861)
// Copyright (C) 1995-2007 IMS MAXIMS plc. All rights reserved.

package ims.clinicaladmin.domain.impl;

import ims.assessment.vo.UserAssessmentLiteVoCollection;
import ims.assessment.vo.domain.UserAssessmentLiteVoAssembler;
import ims.clinicaladmin.domain.HistopathologicGradeConfig;
import ims.clinicaladmin.domain.base.impl.BaseTumourCategoryGroupSitesImpl;
import ims.clinicaladmin.vo.HistopathologicGradeVoCollection;
import ims.clinicaladmin.vo.TNMStagingClassificationVersionLiteVoCollection;
import ims.clinicaladmin.vo.TumourCategoryListVo;
import ims.clinicaladmin.vo.TumourCategoryListVoCollection;
import ims.clinicaladmin.vo.TumourCategoryVersionGroupsLiteVo;
import ims.clinicaladmin.vo.TumourCategoryVo;
import ims.clinicaladmin.vo.TumourGroupListVo;
import ims.clinicaladmin.vo.TumourGroupSiteOverallStagingVo;
import ims.clinicaladmin.vo.TumourGroupSiteOverallStagingVoCollection;
import ims.clinicaladmin.vo.TumourGroupSiteTNMValueVoCollection;
import ims.clinicaladmin.vo.TumourGroupVo;
import ims.clinicaladmin.vo.TumourHistologyVo;
import ims.clinicaladmin.vo.TumourSiteListVo;
import ims.clinicaladmin.vo.TumourSiteListVoCollection;
import ims.clinicaladmin.vo.TumourSiteVo;
import ims.clinicaladmin.vo.domain.HistopathologicGradeVoAssembler;
import ims.clinicaladmin.vo.domain.TNMStagingClassificationVersionLiteVoAssembler;
import ims.clinicaladmin.vo.domain.TumourCategoryListVoAssembler;
import ims.clinicaladmin.vo.domain.TumourCategoryVersionGroupsLiteVoAssembler;
import ims.clinicaladmin.vo.domain.TumourCategoryVoAssembler;
import ims.clinicaladmin.vo.domain.TumourGroupListVoAssembler;
import ims.clinicaladmin.vo.domain.TumourGroupSiteOverallStagingVoAssembler;
import ims.clinicaladmin.vo.domain.TumourGroupSiteTNMValueVoAssembler;
import ims.clinicaladmin.vo.domain.TumourGroupVoAssembler;
import ims.clinicaladmin.vo.domain.TumourHistologyVoAssembler;
import ims.clinicaladmin.vo.domain.TumourSiteListVoAssembler;
import ims.clinicaladmin.vo.domain.TumourSiteVoAssembler;
import ims.core.vo.TaxonomyMapCollection;
import ims.core.vo.domain.TaxonomyMapAssembler;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.oncology.configuration.domain.objects.TumourCategory;
import ims.oncology.configuration.domain.objects.TumourCategoryVersionGroups;
import ims.oncology.configuration.domain.objects.TumourGroup;
import ims.oncology.configuration.domain.objects.TumourGroupSiteOverallStaging;
import ims.oncology.configuration.domain.objects.TumourHistology;
import ims.oncology.configuration.domain.objects.TumourSite;
import ims.oncology.configuration.vo.TumourCategoryRefVo;
import ims.oncology.configuration.vo.TumourGroupClassificationRefVoCollection;
import ims.oncology.configuration.vo.TumourGroupRefVo;
import ims.oncology.configuration.vo.TumourGroupSiteTNMValueRefVo;
import ims.oncology.configuration.vo.TumourHistologyRefVo;
import ims.oncology.configuration.vo.TumourSiteRefVo;
import ims.oncology.vo.TumourGroupClassificationVoCollection;
import ims.oncology.vo.domain.TumourGroupClassificationVoAssembler;
import ims.oncology.vo.lookups.TNMType;
import ims.vo.ValueObject;
import ims.vo.ValueObjectRef;

import java.util.ArrayList;
import java.util.List;

public class TumourCategoryGroupSitesImpl extends BaseTumourCategoryGroupSitesImpl
{

	private static final long	serialVersionUID	= 1L;

	public TumourCategoryListVoCollection listCategory(Boolean isActive)
	{
		DomainFactory factory = getDomainFactory();
		String hqlString = "from TumourCategory";
		return TumourCategoryListVoAssembler.createTumourCategoryListVoCollectionFromTumourCategory(factory.find(hqlString));
	}

	public TumourCategoryVo getCategory(TumourCategoryRefVo voRef)
	{
		if (voRef == null || voRef.getID_TumourCategory() == null)
			throw new DomainRuntimeException("Invalid category");

		DomainFactory factory = getDomainFactory();
		TumourCategory domainObject = (TumourCategory) factory.getDomainObject(voRef);
		return TumourCategoryVoAssembler.create(domainObject);
	}

	public TumourCategoryListVo getCategoryList(TumourCategoryRefVo voRef)
	{
		if (voRef == null || voRef.getID_TumourCategory() == null)
			throw new DomainRuntimeException("Invalid category");

		DomainFactory factory = getDomainFactory();
		TumourCategory domainObject = (TumourCategory) factory.getDomainObject(voRef);
		return TumourCategoryListVoAssembler.create(domainObject);
	}

	public TumourGroupVo getGroup(TumourGroupRefVo voRef)
	{
		if (voRef == null || voRef.getID_TumourGroup() == null)
			throw new DomainRuntimeException("Invalid group");

		DomainFactory factory = getDomainFactory();
		TumourGroup domainObject = (TumourGroup) factory.getDomainObject(voRef);
		return TumourGroupVoAssembler.create(domainObject);
	}

	public TumourGroupListVo getGroupList(TumourGroupRefVo voRef)
	{
		if (voRef == null || voRef.getID_TumourGroup() == null)
			throw new DomainRuntimeException("Invalid group");

		DomainFactory factory = getDomainFactory();
		TumourGroup domainObject = (TumourGroup) factory.getDomainObject(voRef);
		return TumourGroupListVoAssembler.create(domainObject);
	}

	public TumourSiteVo getSite(TumourSiteRefVo voRef)
	{
		if (voRef == null || voRef.getID_TumourSite() == null)
			throw new DomainRuntimeException("Invalid site");

		DomainFactory factory = getDomainFactory();
		TumourSite domainObject = (TumourSite) factory.getDomainObject(voRef);
		return TumourSiteVoAssembler.create(domainObject);
	}

	public TumourHistologyVo getHistology(TumourHistologyRefVo voRef)
	{
		if (voRef == null || voRef.getID_TumourHistology() == null)
			throw new DomainRuntimeException("Invalid histology");

		DomainFactory factory = getDomainFactory();
		TumourHistology domainObject = (TumourHistology) factory.getDomainObject(voRef);
		return TumourHistologyVoAssembler.create(domainObject);
	}

	public TumourGroupSiteTNMValueVoCollection getTNMValueForGroup(TumourGroupRefVo voRef)
	{
		return TumourGroupSiteTNMValueVoAssembler.createTumourGroupSiteTNMValueVoCollectionFromTumourGroupSiteTNMValue(
				getDomainFactory().find("select t2_1 from TumourGroup as t1_1 join t1_1.tNMValues as t2_1 where t1_1.id = :id", new String[]{"id"}, new Object[]{voRef.getID_TumourGroup()}));
	}

	public TaxonomyMapCollection getTaxonomyMapForHistology(TumourHistologyRefVo refVo)
	{
		return TaxonomyMapAssembler.createTaxonomyMapCollectionFromTaxonomyMap(
				getDomainFactory().find("select t2_1 from TumourHistology as t1_1 join t1_1.taxonomyMap as t2_1 where t1_1.id = :id", new String[]{"id"}, new Object[]{refVo.getID_TumourHistology()}));
	}

	public TaxonomyMapCollection getTaxonomyMapForTNM(TumourGroupSiteTNMValueRefVo refVo)
	{
		return TaxonomyMapAssembler.createTaxonomyMapCollectionFromTaxonomyMap(
				getDomainFactory().find("select t2_1 from TumourGroupSiteTNMValue as t1_1 join t1_1.taxonomyMap as t2_1 where t1_1.id = :id", new String[]{"id"}, new Object[]{refVo.getID_TumourGroupSiteTNMValue()}));
	}

	public TumourGroupSiteTNMValueVoCollection getTNMValueForSite(TumourSiteRefVo voRef, TNMType type)
	{
		String hql = "select t2_1 from TumourSite as t1_1 join t1_1.tNMValues as t2_1 where t1_1.id = :id ";

		String[] strings = new String[]{"id"};
		Object[] objects = new Object[]{voRef.getID_TumourSite()};

		if (type != null)
		{
			hql += "and t2_1.tNMType.id = :idType";
			strings = new String[]{"id", "idType"};
			objects = new Object[]{voRef.getID_TumourSite(), type.getTypeId()};
		}

		return TumourGroupSiteTNMValueVoAssembler.createTumourGroupSiteTNMValueVoCollectionFromTumourGroupSiteTNMValue(getDomainFactory().find(hql, strings, objects));
	}

	public TumourSiteListVoCollection getSiteWhoHasTNM(TumourGroupRefVo voRef)
	{
		String hql = "select t2_1 from TumourGroup as t1_1 join t1_1.sites as t2_1 where t1_1.id = :id and t2_1.hasSiteSpecificTNM = 1";
		return TumourSiteListVoAssembler.createTumourSiteListVoCollectionFromTumourSite(getDomainFactory().find(hql, new String[]{"id"}, new Object[]{voRef.getID_TumourGroup()}));
	}

	public TumourSiteListVo getSiteList(TumourSiteRefVo voRef)
	{
		if (voRef == null || voRef.getID_TumourSite() == null)
			throw new DomainRuntimeException("Invalid site");

		DomainFactory factory = getDomainFactory();
		TumourSite domainObject = (TumourSite) factory.getDomainObject(voRef);
		return TumourSiteListVoAssembler.create(domainObject);
	}

	public TumourGroupClassificationVoCollection getOtherClassification(TumourGroupClassificationRefVoCollection voRef)
	{
		if (voRef == null)
			throw new DomainRuntimeException("Invalid Tumour Group staging Classification");

		DomainFactory factory = getDomainFactory();
		StringBuilder hqlString = new StringBuilder("from TumourGroupClassification tgc");
		// ( in (:ids))
		int size = voRef.size();
		if (size > 0)
			hqlString.append(" where tgc.id in (");
		for (int i = 0; i < voRef.size(); i++)
		{
			if (i > 0)
				hqlString.append(",");
			hqlString.append(voRef.get(i).getID_TumourGroupClassification());
		}

		if (size > 0)
			hqlString.append(")");

		return TumourGroupClassificationVoAssembler.createTumourGroupClassificationVoCollectionFromTumourGroupClassification(factory.find(hqlString.toString()));
	}

	public TumourCategoryVo saveCategory(TumourCategoryVo record) throws StaleObjectException, UniqueKeyViolationException
	{
		if (record == null)
			throw new DomainRuntimeException("Invalid record");

		if (!record.isValidated())
			throw new CodingRuntimeException("Record not validated");

		DomainFactory factory = getDomainFactory();
		TumourCategory domainRecord = TumourCategoryVoAssembler.extractTumourCategory(factory, record);

		try
		{
			factory.save(domainRecord);
		}
		catch (UnqViolationUncheckedException e)
		{
			throw new UniqueKeyViolationException(e);
		}

		return TumourCategoryVoAssembler.create(domainRecord);
	}

	public TumourCategoryVersionGroupsLiteVo saveVersion(TumourCategoryVersionGroupsLiteVo version, TumourCategoryListVo category)
															throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException
	{
		if (version == null || category == null)
			throw new DomainRuntimeException("Invalid record to save");
		
		if (!version.isValidated() || !category.isValidated())
			throw new DomainRuntimeException("Record to save not validated");
		
		TumourCategory domCategory = (TumourCategory) getDomainFactory().getDomainObject(category);
		TumourCategoryVersionGroups domVersion = TumourCategoryVersionGroupsLiteVoAssembler.extractTumourCategoryVersionGroups(getDomainFactory(), version);
		
		if (version.getID_TumourCategoryVersionGroupsIsNotNull())
		{
			// Actually an edit - no need to save at category level
			getDomainFactory().save(domVersion);
			
			return TumourCategoryVersionGroupsLiteVoAssembler.create(domVersion);
		}
		
		// A new version is created - we need to save at Category level
		domCategory.getVersionGroups().add(domVersion);
		
		getDomainFactory().save(domCategory);
		
		return TumourCategoryVersionGroupsLiteVoAssembler.create(domVersion);
	}
	

	public TumourGroupVo saveGroup(TumourGroupVo voGroup, TumourCategoryVersionGroupsLiteVo version) throws StaleObjectException, UniqueKeyViolationException
	{
		if (voGroup == null || version == null)
			throw new DomainRuntimeException("Invalid record to save");
		
		if (!voGroup.isValidated() || !version.isValidated())
			throw new DomainRuntimeException("Record to save not validated");
		
		TumourCategoryVersionGroups domVersion = (TumourCategoryVersionGroups) getDomainFactory().getDomainObject(version);
		TumourGroup domGroup = TumourGroupVoAssembler.extractTumourGroup(getDomainFactory(), voGroup);
		
		if (voGroup.getID_TumourGroupIsNotNull())
		{
			// Actually an edit - no need to save at version level
			getDomainFactory().save(domGroup);
			
			return TumourGroupVoAssembler.create(domGroup);
		}
		
		// A new group is created - we need to save the group at Version level
		domVersion.getGroups().add(domGroup);
		
		getDomainFactory().save(domVersion);

		return TumourGroupVoAssembler.create(domGroup);
	}

	public TumourSiteVo saveSite(TumourSiteVo record, TumourGroupListVo voGroup) throws StaleObjectException, UniqueKeyViolationException
	{
		if (record == null || voGroup == null)
			throw new DomainRuntimeException("Invalid record to save");
		
		if (!record.isValidated() || !voGroup.isValidated())
			throw new DomainRuntimeException("Record to save not validated");
		
		TumourGroup domGroup = (TumourGroup) getDomainFactory().getDomainObject(voGroup);
		TumourSite domSite = TumourSiteVoAssembler.extractTumourSite(getDomainFactory(), record);
		
		if (record.getID_TumourSiteIsNotNull())
		{
			// Actually an edit - no need to save at group level
			getDomainFactory().save(domSite);
			
			return TumourSiteVoAssembler.create(domSite);
		}
		
		// A new site record is created - we need to save at group level
		domGroup.getSites().add(domSite);
		
		getDomainFactory().save(domGroup);

		return TumourSiteVoAssembler.create(domSite);
	}

	public HistopathologicGradeVoCollection listAllTumourDiffs()
	{
		HistopathologicGradeConfig impl = (HistopathologicGradeConfig) getDomainImpl(HistopathologicGradeConfigImpl.class);
		return impl.listHistopathologicGrade();
	}

	public HistopathologicGradeVoCollection listTumourDiffsForGroup(TumourGroupRefVo voRef)
	{
		if (voRef == null)
			throw new DomainRuntimeException("Invalid Value Object");

		String hql = "select t2_1 from TumourGroup as t1_1 join t1_1.differentation as t2_1 where t1_1.id = :id ";

		String[] strings = new String[]{"id"};
		Object[] objects = new Object[]{voRef.getID_TumourGroup()};

		return HistopathologicGradeVoAssembler.createHistopathologicGradeVoCollectionFromHistopathologicGrade(getDomainFactory().find(hql, strings, objects));
	}

	public TumourGroupSiteOverallStagingVoCollection getOverallStaging(ValueObject vo)
	{
		if (vo == null)
			throw new DomainRuntimeException("Invalid Value Object");

		String hql = "";
		String[] strings = new String[]{"id"};
		Object[] objects = null;

		if (vo instanceof TumourGroupRefVo)
		{
			// hql = "select t1_1 from TumourGroupSiteOverallStaging as t1_1 left join t1_1.tGroup as t2_1 left join t1_1.tSite as t3_1 where t2_1.id = :id and t3_1.id is null and t1_1.isActive = 1";
			hql = "select t1_1 from TumourGroupSiteOverallStaging as t1_1 left join t1_1.tGroup as t2_1 left join t1_1.tSite as t3_1  where t2_1.id = :id and t3_1.id is null";
			objects = new Object[]{((TumourGroupRefVo) vo).getID_TumourGroup()};
		}
		else if (vo instanceof TumourSiteRefVo)
		{
			// hql = "select t1_1 from TumourGroupSiteOverallStaging as t1_1 join t1_1.tSite as t2_1 where t2_1.id = :id and t1_1.isActive = 1";
			hql = "select t1_1 from TumourGroupSiteOverallStaging as t1_1 join t1_1.tSite as t2_1 where t2_1.id = :id";
			objects = new Object[]{((TumourSiteRefVo) vo).getID_TumourSite()};
		}

		List find = getDomainFactory().find(hql, strings, objects, 360);

		Long start = System.currentTimeMillis();

		TumourGroupSiteOverallStagingVoCollection createTumourGroupSiteOverallStagingVoCollectionFromTumourGroupSiteOverallStaging = TumourGroupSiteOverallStagingVoAssembler.createTumourGroupSiteOverallStagingVoCollectionFromTumourGroupSiteOverallStaging(find);
		Long end = System.currentTimeMillis() - start;
		System.out.println(end);
		return createTumourGroupSiteOverallStagingVoCollectionFromTumourGroupSiteOverallStaging;
	}
	
	public Boolean countForOverallPrognostic(TumourGroupRefVo group)
	{
		if (group == null || !group.getID_TumourGroupIsNotNull())
			throw new DomainRuntimeException("Can not check for non-group value");
		
		String hql = "select count(prg.id) from PrognosticGrouping as prg left join prg.tGroup as grp where grp.id = :ID and prg.isRIE is null";
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("ID"); paramValues.add(group.getID_TumourGroup());
		
		List list = getDomainFactory().find(hql, paramNames, paramValues);
		
		if (list.size() >= 1)
			return ((Long) list.get(0)).intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
		
		return Boolean.FALSE;
	}


	public Integer countForOverallStaging(ValueObjectRef voRef)
	{
		if (voRef == null)
			throw new DomainRuntimeException("Invalid Value Object");

		String hql = "";
		String[] strings = new String[]{"id"};
		Object[] objects = null;

		Long start = System.currentTimeMillis();

		if (voRef instanceof TumourGroupRefVo)
		{
			hql = "select count(t1_1.id) from TumourGroupSiteOverallStaging as t1_1 join t1_1.tGroup as t2_1 where t2_1.id = :id ";
			objects = new Object[]{((TumourGroupRefVo) voRef).getID_TumourGroup()};
		}
		else if (voRef instanceof TumourSiteRefVo)
		{
			hql = "select count(t1_1.id) from TumourGroupSiteOverallStaging as t1_1 join t1_1.tSite as t2_1 where t2_1.id = :id ";
			objects = new Object[]{((TumourSiteRefVo) voRef).getID_TumourSite()};
		}

		Long end = System.currentTimeMillis();
		Long result = end - start;
		System.out.println(result);

		List find = getDomainFactory().find(hql, strings, objects);

		if (find.size() == 0)
			return 0;

		return ((Long) find.get(0)).intValue();
	}

	public Integer countForActiveGroupOrSite(ValueObject voRef)
	{
		if (voRef == null)
			throw new DomainRuntimeException("Invalid Value Object");

		String hql = "";
		String[] strings = new String[]{"id"};
		Object[] objects = null;

		if (voRef instanceof TumourCategoryRefVo)
		{
			hql = "select count(tg.id) from TumourCategory as tc join tc.versionGroups as vers join vers.groups as tg where tc.id = :id and tg.isActive = true";
			objects = new Object[]{((TumourCategoryRefVo) voRef).getID_TumourCategory()};
		}
		else if (voRef instanceof TumourGroupRefVo)
		{
			hql = "select count(ts.id) from TumourGroup as tg join tg.sites as ts where tg.id = :id and ts.isActive = true";
			objects = new Object[]{((TumourGroupRefVo) voRef).getID_TumourGroup()};
		}

		List find = getDomainFactory().find(hql, strings, objects);

		if (find.size() == 0)
			return 0;

		return ((Long) find.get(0)).intValue();
	}

	public TumourGroupSiteOverallStagingVoCollection saveOverall(TumourGroupSiteOverallStagingVoCollection voCollOverall) throws StaleObjectException
	{
		if (voCollOverall == null)
			return null;

		DomainFactory factory = getDomainFactory();
		TumourGroupSiteOverallStaging doOverall = null;
		ArrayList<TumourGroupSiteOverallStaging> boColl = new ArrayList<TumourGroupSiteOverallStaging>();
		TumourGroupSiteOverallStagingVoCollection returnColl = new TumourGroupSiteOverallStagingVoCollection();

		int size = voCollOverall.size();
		for (int i = 0; i < size; i++)
		{
			TumourGroupSiteOverallStagingVo voOverall = voCollOverall.get(i);
			doOverall = TumourGroupSiteOverallStagingVoAssembler.extractTumourGroupSiteOverallStaging(factory, voOverall);
			factory.save(doOverall);
			boColl.add(doOverall);
		}

		for (int i = 0; i < boColl.size(); i++)
		{
			returnColl.add(TumourGroupSiteOverallStagingVoAssembler.create(boColl.get(i)));
		}

		return returnColl;
	}

	public TNMStagingClassificationVersionLiteVoCollection listVersions(TumourCategoryListVo category)
	{
		if (category == null || !category.getID_TumourCategoryIsNotNull())
			throw new DomainRuntimeException("Can not search with no category provided");
		
		StringBuilder query = new StringBuilder();
		query.append(" select version from TNMStagingClassificationVersion as version where (version.status.id = :ACTIVE or version.status.id = :PRE_ACTIVE) ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("ACTIVE");
		paramValues.add(PreActiveActiveInactiveStatus.ACTIVE.getID());
		
		paramNames.add("PRE_ACTIVE");
		paramValues.add(PreActiveActiveInactiveStatus.PREACTIVE.getID());
		
		if (category.getVersionGroupsIsNotNull() && category.getVersionGroups().size() > 0)
		{
			query.append(" and  version not in ");
			query.append(" (select vers from TumourCategory as category left join category.versionGroups as vgroup left join vgroup.tNMVersion as vers where category.id = :CAT_ID)");

			paramNames.add("CAT_ID");
			paramValues.add(category.getID_TumourCategory());
		}
		
		return TNMStagingClassificationVersionLiteVoAssembler.createTNMStagingClassificationVersionLiteVoCollectionFromTNMStagingClassificationVersion(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	public UserAssessmentLiteVoCollection listUserAssessments(String assessmentName)
	{
		if (assessmentName == null)
			throw new DomainRuntimeException("Parameter value expected for assessment name");
		
		StringBuilder query = new StringBuilder();
		query.append("select userAssess from UserAssessment as userAssess where userAssess.name like :NAME and userAssess.activeStatus.id = :ACTIVE");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("NAME");
		paramValues.add(assessmentName);
		
		paramNames.add("ACTIVE");
		paramValues.add(PreActiveActiveInactiveStatus.ACTIVE.getID());

		return UserAssessmentLiteVoAssembler.createUserAssessmentLiteVoCollectionFromUserAssessment(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	public HistopathologicGradeVoCollection listDefaultDifferentiations()
	{
		String query = " from HistopathologicGrade as tDiff where (tDiff.isDefault = 1) ";
		
		return HistopathologicGradeVoAssembler.createHistopathologicGradeVoCollectionFromHistopathologicGrade(getDomainFactory().find(query)).sort();
	}
}
