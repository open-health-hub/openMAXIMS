//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by George Cristian Josan using IMS Development Environment (version 1.80 build 4035.27320)
// Copyright (C) 1995-2011 IMS MAXIMS. All rights reserved.

package ims.clinicaladmin.forms.selecttumourhistology;

import ims.clinicaladmin.forms.selecttumourhistology.GenForm.grdTumourHistologyRow;
import ims.clinicaladmin.vo.TumourHistologyLiteVo;
import ims.clinicaladmin.vo.TumourHistologyLiteVoCollection;
import ims.clinicaladmin.vo.TumourHistologyVo;
import ims.configuration.gen.ConfigFlag;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.framework.enumerations.DialogResult;
import ims.framework.enumerations.FormMode;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.exceptions.FormOpenException;
import ims.framework.exceptions.PresentationLogicException;

public class Logic extends BaseLogic
{
	private static final long serialVersionUID = 1L;

	// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Event Handlers region
	// ---------------------------------------------------------------------------------------------------------------------------------------------------------------

	@Override
	protected void onFormOpen(Object[] args) throws ims.framework.exceptions.PresentationLogicException
	{
		// Initialise form (local and global context, context menu)
		initialize();
		// Refresh screen data
		open();
	}

	@Override
	protected void onFormModeChanged()
	{
		// Update controls state
		updateControlsState();
	}


	@Override
	protected void onImbSearchClick() throws PresentationLogicException
	{
		// Clear selected record from local context
		form.getLocalContext().setSelectedHistology(null);
		
		// Search for results & populate them to the screen
		searchHistology();
		
		// Update controls state
		updateControlsState();
	}

	@Override
	protected void onImbClearClick() throws PresentationLogicException
	{
		// Clear screen & search controls
		clearScreen();
		form.txtHistology().setValue(null);

		// Clear selected record from local context
		form.getLocalContext().setSelectedHistology(null);
		
		// Update controls state
		updateControlsState();
	}

	@Override
	protected void onGrdTumourHistologySelectionChanged() throws PresentationLogicException
	{
		// Update local context
		form.getLocalContext().setSelectedHistology(domain.get(form.grdTumourHistology().getValue()));
		// Populate instance controls
		populateInstanceControls(form.getLocalContext().getSelectedHistology());
		// Update controls state
		updateControlsState();
	}

	@Override
	protected void onGrdTumourHistologySelectionCleared() throws PresentationLogicException
	{
		// Clear local context selection
		form.getLocalContext().setSelectedHistology(null);
		// Populate instance controls
		populateInstanceControls(form.getLocalContext().getSelectedHistology());
		// Update controls state
		updateControlsState();
	}

	@Override
	protected void onBtnSelectClick() throws ims.framework.exceptions.PresentationLogicException
	{
		// Set selected histology to global context to be passed back to calling form
		form.getGlobalContext().ClinicalAdmin.setTumourHistology(form.grdTumourHistology().getValue());
		
		// If selected value is null then crash the application because
		// 	Select button should not be enabled if the selected record is null
		//	and we need to prevent passing invalid data to calling form
		if (!form.getGlobalContext().ClinicalAdmin.getTumourHistologyIsNotNull())
			throw new CodingRuntimeException("ERROR - nothing is selected");
		
		// Close the dialog with OK value
		engine.close(DialogResult.OK);
	}

	@Override
	protected void onBtnSaveClick() throws ims.framework.exceptions.PresentationLogicException
	{
		if (save())
			open();
	}

	@Override
	protected void onBtnCancelClick() throws ims.framework.exceptions.PresentationLogicException
	{
		open();
	}

	@Override
	protected void onContextMenuItemClick(int menuItemID, ims.framework.Control sender) throws ims.framework.exceptions.PresentationLogicException
	{
		switch (menuItemID)
		{
			case GenForm.ContextMenus.GenericGrid.Add:
				newInstance();
				break;
				
			case GenForm.ContextMenus.GenericGrid.Update:
				updateInstance();
				break;
		}
	}
	

	// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
	//	Form presentation functions
	// ---------------------------------------------------------------------------------------------------------------------------------------------------------------

	/**
	 * Function used to initialize the form.
	 * Will set default values to global & local contexts, set visibility of context menus
	 */
	public void initialize() throws FormOpenException
	{
		// Initialise context menu
		form.getContextMenus().hideAllGenericGridMenuItems();

		// Clear global context
		form.getGlobalContext().ClinicalAdmin.setTumourHistology(null);
		// Clear local context
		form.getLocalContext().setSelectedHistology(null);
	}

	/**
	 * Function used to refresh the screen.
	 * Will perform search if required, populate instance controls with selected record (if any)
	 * and set the form to VIEW mode.
	 * 
	 * @param performSearch - if set to <b>true</b> a search will be performed 
	 */
	public void open() throws ims.framework.exceptions.PresentationLogicException
	{
		// Get the value for the selected record
		form.getLocalContext().setSelectedHistology(domain.get(form.getLocalContext().getSelectedHistology()));
		
		// Add selected record to grid & populate instance controls if needed
		populateSelectedRecordToScreen(form.getLocalContext().getSelectedHistology());
		
		// Set form in VIEW mode
		form.setMode(FormMode.VIEW);
	}

	/**
	 * Function used to search & display Tumour Histologies to screen.
	 */
	private void searchHistology()
	{
		// Perform search into database and return all records matching search criteria
		TumourHistologyLiteVoCollection histologies = domain.list(form.txtHistology().getValue());
		
		// Clear screen (less the search controls)
		clearScreen();
		
		// Display "No results found" message if none were found
		if (histologies == null || histologies.size() == 0)
		{
			engine.showMessage("No results found to match search criteria.");
		}

		// List histologies
		populateHistologyGrid(histologies);

		// Reselect histology edited or created
		form.grdTumourHistology().setValue(form.getLocalContext().getSelectedHistology());
		form.getLocalContext().setSelectedHistology(domain.get(form.grdTumourHistology().getValue()));

		// Populate instance controls with selected histology
		populateInstanceControls(form.getLocalContext().getSelectedHistology());
	}

	/**
	 * Function used to prepare screen and context to create a new record.
	 * 
	 * Will clear grid selection, current record local context, instance controls and set the form in EDIT mode.
	 */
	public void newInstance() throws ims.framework.exceptions.PresentationLogicException
	{
		// Clear grid selection
		form.grdTumourHistology().setValue(null);
		// Clear local context selection
		form.getLocalContext().setSelectedHistology(null);
		// Clear instance controls
		clearInstanceControls();
		// Set form to EDIT mode
		form.setMode(FormMode.EDIT);
	}

	/**
	 * Function used to prepare screen for updating a record
	 * 
	 * Will set the form in EDIT mode.
	 */
	public void updateInstance()
	{
		// Set form to EDIT mode
		form.setMode(FormMode.EDIT);
	}

	/**
	 *	Function used to record a histology record.
	 *
	 *	@return - <b>true</b> if the save was successful or <b>false</b> if it failed
	 */
	public boolean save() throws ims.framework.exceptions.PresentationLogicException
	{
		try
		{
			// Get data from screen
			form.getLocalContext().setSelectedHistology(populateDataFromInstanceControls(form.getLocalContext().getSelectedHistology()));

			// Validate data
			String[] errors = form.getLocalContext().getSelectedHistology().validate();

			if (errors != null && errors.length > 0)
			{
				engine.showErrors(errors);
				return false;
			}

			// Attempt to save data
			form.getLocalContext().setSelectedHistology(domain.save(form.getLocalContext().getSelectedHistology()));

			// Save was a success
			return true;
		}
		// Treat exceptions
		catch (StaleObjectException e)
		{
			e.printStackTrace();
			engine.showMessage(ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue());
			open();
			return false;
		}
		catch (ForeignKeyViolationException e)
		{
			e.printStackTrace();
			engine.showMessage(e.getMessage());
			return false;
		}
		catch (UniqueKeyViolationException e)
		{
			e.printStackTrace();
			engine.showMessage(e.getMessage());
			return false;
		}
		catch (UnqViolationUncheckedException e)
		{
			e.printStackTrace();
			engine.showMessage("Taxonomy Mapping is registered to another record");
			return false;
		}
	}

	/**
	 * Function used to clear the screen, except the search controls.
	 * Will only clear controls, not local or global contexts.
	 */
	private void clearScreen()
	{
		// Clear grid rows
		form.grdTumourHistology().getRows().clear();

		// Clear instance controls
		clearInstanceControls();
	}

	/**
	 * Function used to clear instance controls.
	 * Will only clear controls, not local or global contexts.
	 */
	public void clearInstanceControls()
	{
		form.ctnDetails().txtDescription().setValue(null);
		form.ctnDetails().ccTaxonomyCodes().clear();
	}

	/**
	 * Function used to update the state of controls & context menus
	 * based on the context
	 */
	public void updateControlsState()
	{
		// Update collapsed state of the container
		form.ctnDetails().setCollapsed(FormMode.VIEW.equals(form.getMode()) && form.getLocalContext().getSelectedHistologyIsNotNull());
		// Set mode for Taxonomy component
		form.ctnDetails().ccTaxonomyCodes().setComponentMode(form.getMode());
		
		// Set controls state in VIEW mode
		if (FormMode.VIEW.equals(form.getMode()))
		{
			// Set select button control enabled only when a histology record is visible
			form.btnSelect().setEnabled(form.grdTumourHistology().getValue() != null);
			form.btnSelect().setVisible(true);
		}

		// Update state of context menus
		updateContextMenuOptions();
	}

	/**
	 * Function used to update the state of context menus
	 */
	private void updateContextMenuOptions()
	{
		// New option must always be enabled in VIEW mode
		form.getContextMenus().getGenericGridAddItem().setVisible(FormMode.VIEW.equals(form.getMode()));
		// Edit option must enabled only in VIEW mode and when a histology record is visible 
		form.getContextMenus().getGenericGridUpdateItem().setVisible(FormMode.VIEW.equals(form.getMode()) && form.grdTumourHistology().getValue() != null);
	}

	// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
	//	Data exchange functions
	// ---------------------------------------------------------------------------------------------------------------------------------------------------------------

	/**
	 * Function used to add or update in grid TumourHistologyVo record
	 * and populate instance controls with it's value.
	 */
	private void populateSelectedRecordToScreen(TumourHistologyVo histology)
	{
		// Check passed histology - if it null, clear instance controls and exit the function
		if (histology == null)
		{
			clearInstanceControls();
			return;
		}
		
		
		// Check if we need to add a new row for histology or update a current row

			// Step 1 - Attempt to select a row with histology as a value 
    		form.grdTumourHistology().setValue(histology);

    		// Step 2 - If no row was found add a new row to grid
    		grdTumourHistologyRow row = form.grdTumourHistology().getSelectedRow();
    		if (row == null) row = form.grdTumourHistology().getRows().newRow();
    		
    		// Step 3 - Populate the row with histology value
    		populateHistologyGridRow(histology, row);
    		
			// Step 4 - Select populated row
			form.grdTumourHistology().setValue(histology);
			
			// Step 5 - Populate instance controls
			populateInstanceControls(histology);
	}

	/**
	 *	Function used to populate the grid with a collection of TumourHistologyLiteVoCollection items.
	 *	Will clear the grid of previous records from it. 
	 */
	private void populateHistologyGrid(TumourHistologyLiteVoCollection list)
	{
		// Clear grid
		form.grdTumourHistology().getRows().clear();
		// Reset scroll position
		form.grdTumourHistology().resetScrollPosition();

		// Check collection for null
		if (list == null)
			return;

		// Populate grid
		for (TumourHistologyLiteVo histology : list)
		{
			if (histology == null)
				continue;
			
			// Create a new row in grid
			grdTumourHistologyRow newRow = form.grdTumourHistology().getRows().newRow();
			// Update grid row with histology value
			populateHistologyGridRow(histology, newRow);
		}
	}

	/**
	 *	Function used to update a grid row with a TumourHistologyLiteVo value.
	 *	It assumes that both the row and histology value are not null. The function will crash the application 
	 */
	private void populateHistologyGridRow(TumourHistologyLiteVo histology, grdTumourHistologyRow row)
	{
		// Check parameters, crash if either one is null
		if (histology == null || row == null)
			throw new CodingRuntimeException("Logical Exception - neither histology, nor row can be null");
		
		// Set column values
		row.setColHistology(histology.getHistologyDescription());
		row.setColActive(Boolean.TRUE.equals(histology.getIsActive()));

		// Set row values
		row.setValue(histology);
	}

	/**
	 * Function used to populate instance controls from a TumourHistolgoyVo record
	 * If the value is null will only clear the instance controls.
	 */
	private void populateInstanceControls(TumourHistologyVo histology)
	{
		// Clear instance controls
		clearInstanceControls();

		// Check parameter for null value
		if (histology == null)
			return;

		// Set instance controls values from histology
		form.ctnDetails().txtDescription().setValue(histology.getHistologyDescription());
		form.ctnDetails().ccTaxonomyCodes().setValue(histology.getTaxonomyMap());
	}

	/**
	 * Function used to update a TumourHistolgoyVo record with values from instance controls.
	 * If the record passed is null a new TumourHistologyVo record will be created an returned.
	 */
	private TumourHistologyVo populateDataFromInstanceControls(TumourHistologyVo histology)
	{
		// If histology record pass is null, create a new active TumourHistologyVo record
		if (histology == null)
		{
			histology = new TumourHistologyVo();
			histology.setIsActive(Boolean.TRUE);
		}
		
		// Update histology with values from instance controls
		histology.setHistologyDescription(form.ctnDetails().txtDescription().getValue());
		histology.setTaxonomyMap(form.ctnDetails().ccTaxonomyCodes().getValue());

		// Return update histology
		return histology;
	}
}
