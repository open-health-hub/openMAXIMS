//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.22 build 50223.1030)
// Copyright (C) 1995-2005 IMS MAXIMS plc. All rights reserved.

package ims.admin.domain.impl;

import ims.admin.helper.Keywords;
import ims.admin.vo.PrinterVo;
import ims.admin.vo.domain.PrinterVoAssembler;
import ims.core.configuration.domain.objects.Printer;
import ims.core.resource.place.domain.objects.Clinic;
import ims.core.resource.place.domain.objects.LocSite;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.domain.objects.Organisation;
import ims.core.resource.place.vo.ClinicRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.resource.place.vo.OrganisationRefVo;
import ims.core.vo.ClinicListVo;
import ims.core.vo.ClinicListVoCollection;
import ims.core.vo.ClinicVo;
import ims.core.vo.LocMostVo;
import ims.core.vo.LocMostVoCollection;
import ims.core.vo.LocShortMappingsVo;
import ims.core.vo.LocShortMappingsVoCollection;
import ims.core.vo.LocShortVo;
import ims.core.vo.LocShortVoCollection;
import ims.core.vo.LocSiteLiteVoCollection;
import ims.core.vo.LocSiteShortVo;
import ims.core.vo.LocSiteVo;
import ims.core.vo.LocSiteVoCollection;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.OrgLiteVo;
import ims.core.vo.OrgLiteVoCollection;
import ims.core.vo.OrgShortVo;
import ims.core.vo.OrgShortVoCollection;
import ims.core.vo.OrganisationVo;
import ims.core.vo.OrganisationVoCollection;
import ims.core.vo.domain.ClinicVoAssembler;
import ims.core.vo.domain.LocMostVoAssembler;
import ims.core.vo.domain.LocShortMappingsVoAssembler;
import ims.core.vo.domain.LocShortVoAssembler;
import ims.core.vo.domain.LocSiteLiteVoAssembler;
import ims.core.vo.domain.LocSiteShortVoAssembler;
import ims.core.vo.domain.LocSiteVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.OrgLiteVoAssembler;
import ims.core.vo.domain.OrgShortVoAssembler;
import ims.core.vo.domain.OrganisationVoAssembler;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.OrganisationType;
import ims.core.vo.lookups.TaxonomyType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.domain.impl.DomainImpl;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.IPrinter;
import ims.utils.Logging;
import ims.vo.ValueObjectRef;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;

public class OrganisationAndLocationImpl extends DomainImpl implements ims.admin.domain.OrganisationAndLocation, ims.domain.impl.Transactional
{
	private static final long	serialVersionUID	= 1L;
	static final Logger				LOGGER				= Logging.getLogger(OrganisationAndLocationImpl.class);
	private static final HashMap<String, LocShortVo>	REMOTE_LOC_CACHE	= new HashMap<String, LocShortVo>();

	/**
	 * List Oraganisations
	 */
	public ims.core.vo.OrganisationVoCollection listOrganisation(ims.core.vo.OrganisationVo organisation, Boolean excludeGPs, Boolean activeOnly)
	{
		DomainFactory factory = getDomainFactory();

		String hql = " from Organisation o ";
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();
		String andStr = " ";
		if (organisation == null)
			organisation = new OrganisationVo();

		List orgs = null;

		condStr.append(andStr + " o.type.id != " + OrganisationType.SUPPLIER.getID());
		andStr = " and ";

		if (excludeGPs != null && excludeGPs.booleanValue())
		{
			condStr.append(andStr + " (o.type != :GP or o.type.id is null)");
			markers.add("GP");
			values.add(getDomLookup(OrganisationType.GPP));
			condStr.append(andStr + " (o.type != :PCT or o.type.id is null)");
			markers.add("PCT");
			values.add(getDomLookup(OrganisationType.NHS_PCT));
			andStr = " and ";

		}

		if (activeOnly != null && activeOnly.booleanValue())
		{
			condStr.append(andStr + " o.isActive = :isActive");
			markers.add("isActive");
			values.add(activeOnly);
			andStr = " and ";
		}

		if (organisation.getParentOrganisation() == null)
		{
			condStr.append(andStr + " o.parentOrganisation is null");

			hql += " where ";
			hql += condStr.toString();
			
			hql += " order by o.name";

			orgs = factory.find(hql, markers, values);
		}
		else
		{
			condStr.append(" o.parentOrganisation.id = :parentOrg");
			markers.add("parentOrg");
			values.add(organisation.getParentOrganisation().getID_Organisation());
			andStr = " and ";

			hql += " where ";
			hql += condStr.toString();
			
			hql += " order by o.name";

			orgs = factory.find(hql, markers, values);
		}
		
		OrganisationVoCollection voCollOrgs = OrganisationVoAssembler.createOrganisationVoCollectionFromOrganisation(orgs);
		return voCollOrgs;
	}

	public OrgShortVoCollection listOrganisationsShort(OrgShortVo filter)
	{
		List orgs = listDomOrganisation(filter);

		OrgShortVoCollection voCollOrgShorts = OrgShortVoAssembler.createOrgShortVoCollectionFromOrganisation(orgs);
		voCollOrgShorts.sort();
		return voCollOrgShorts;
	}

	public OrgLiteVoCollection listOrganisationsLite(OrgShortVo filter)
	{
		List orgs = listDomOrganisation(filter);
		
		OrgLiteVoCollection voCollOrg = OrgLiteVoAssembler.createOrgLiteVoCollectionFromOrganisation(orgs);
		voCollOrg.sort();
		return voCollOrg;
	}

	private List listDomOrganisation(OrgShortVo filter)
	{
		DomainFactory factory = getDomainFactory();

		String hql = " from Organisation o where o.type.id != " + OrganisationType.SUPPLIER.getID() + " and o.type.id != " + OrganisationType.GPP.getID();//wdev-5364
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();
		String andStr = " ";

		List orgs = null;

		if (filter.getNameIsNotNull() && filter.getName().length() > 0)
		{
			condStr.append(" o.upperName like :OrgName");
			markers.add("OrgName");
			values.add(filter.getName().toUpperCase() + "%");
			andStr = " and ";

			hql += andStr + condStr.toString();
			orgs = factory.find(hql, markers, values);
		}
		else
		{
			orgs = factory.find(hql);
		}
		return orgs;
	}

	private void populateLocationCollection(LocMostVoCollection voCollLocationSite, LocMostVoCollection voCollLocations)
	{
		for (int i = 0; i < voCollLocationSite.size(); i++)
		{
			if (voCollLocationSite.get(i).getIsVirtualIsNotNull()
				&& ! voCollLocationSite.get(i).getIsVirtual().booleanValue()) //wdev-2730
			{
				voCollLocations.add(voCollLocationSite.get(i));
			}
			populateLocationCollection(voCollLocationSite.get(i).getLocations(), voCollLocations);
		}

	}

	public ims.core.vo.OrganisationVo saveOrganisation(ims.core.vo.OrganisationVo organisation) throws UniqueKeyViolationException, StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		HashMap<?,?> map = new HashMap<Object, Object>();
		Organisation doOrg = OrganisationVoAssembler.extractOrganisation(factory, organisation,map);
		
		if (!(organisation.getTypeIsNotNull() && organisation.getType().equals(OrganisationType.GPP)))
		{
			// uniqueness constraint removed form the database - must be implemented in code. 
			if (checkOrganisationNameisUnique(organisation.getName(), organisation) != null)
			{
				throw new UniqueKeyViolationException("A record with the same name already exists, Please change");
			}
		}
		
		try
		{
			doOrg.setUpperNames();
			factory.save(doOrg);
			
			//WDEV-10574
			REMOTE_LOC_CACHE.clear();
		}
		catch (UnqViolationUncheckedException e)
		{
			String dupMessage = Keywords.checkDuplicateTaxonomy(factory, doOrg, "codeMappings", organisation.getCodeMappings(), "getName");
			
			if(dupMessage != null)
				throw new UniqueKeyViolationException(dupMessage);
			
			//WDEV-12600 - Check if the child location don't contain duplicate mappings
			if (organisation.getRelatedOrganisationsIsNotNull())
			{
				checkChildsForDuplicateTaxonoy(organisation.getRelatedOrganisations(), map, factory);
			}
			//WDEV-12600 - Check if the child location don't contain duplicate mappings
			if (organisation.getLocationSitesIsNotNull())
			{
				checkChildsForDuplicateTaxonoy(organisation.getLocationSites(), map, factory);

			}
			
			throw new UniqueKeyViolationException("A record with the same details already exists, Please change", e);
		}
		return OrganisationVoAssembler.create(doOrg);
	}

	
	private void checkChildsForDuplicateTaxonoy(LocSiteVoCollection childs,Map<?, ?> doMap,DomainFactory factory) throws UniqueKeyViolationException
	{
			if (childs == null || doMap==null)
				return;
			
			for (int i = 0 ; i < childs.size(); i++)
			{
				LocSiteVo locMostVo = childs.get(i);
				Object doObj = doMap.get(locMostVo);
				//If doObj is null it means that nothing has changed in that record and hibernate didn't instantiated that record
				if (doObj instanceof Location)
				{
					//I'm using new Location(((Location) doObj).getId(),((Location) doObj).getVersion()) because LocSite extends Location 
					//and it's possible to have a Location with same mappings and not a LocSite.
					Location loc =(Location) doObj;
					String dupMessage = Keywords.checkDuplicateTaxonomy(factory,new Location(loc.getId(),loc.getVersion()), "codeMappings", locMostVo.getCodeMappings(), "getName");
					if (dupMessage!=null)
						throw new UniqueKeyViolationException(dupMessage);
				}
			}
	}
	
	private void checkChildsForDuplicateTaxonoy(OrganisationVoCollection  childs,Map<?, ?> doMap,DomainFactory factory) throws UniqueKeyViolationException
	{
		if (childs == null || doMap==null)
			return;
		
		for (int i = 0 ; i < childs.size(); i++)
		{
			OrganisationVo orgVo = childs.get(i);
			Object doObj = doMap.get(orgVo);
			//If doObj is null it means that nothing changed in that record and hibernate didn't instantiated that record
			if (doObj instanceof Organisation)
			{
				String dupMessage = Keywords.checkDuplicateTaxonomy(factory,doObj, "codeMappings", orgVo.getCodeMappings(), "getName");
				if (dupMessage!=null)
					throw new UniqueKeyViolationException(dupMessage);
			}
		}
	}
	

	/**
	 * Save a location site and any locations
	 */
	public ims.core.vo.LocSiteVo saveLocationSite(ims.core.vo.LocSiteVo locationSite) throws StaleObjectException, UniqueKeyViolationException
	{
		if (!locationSite.isValidated())
			throw new DomainRuntimeException("Location Site not Validated.");
			
		DomainFactory factory = getDomainFactory();
		HashMap<?,?> map = new HashMap<Object, Object>();
		LocSite doLocationSite = LocSiteVoAssembler.extractLocSite(factory, locationSite,map);

//		 uniqueness constraint removed form the database - must be implemented in code. 
		if (checkLocationSiteNameIsUnique(locationSite.getName(), locationSite.getID_Location())!= null )
		{
			throw new UniqueKeyViolationException("A record with the same name already exists, Please change");
		}
		
		try
		{
			doLocationSite.setUpperNames();
			factory.save(doLocationSite);
			//WDEV-10574
			REMOTE_LOC_CACHE.clear();
		}
		catch (UnqViolationUncheckedException e)
		{
			String dupMessage = Keywords.checkDuplicateTaxonomy(factory, doLocationSite, "codeMappings", locationSite.getCodeMappings(), "getName");
			
			if(dupMessage != null)
				throw new UniqueKeyViolationException(dupMessage);
			
			//WDEV-12600 - Check if the child location don't contain duplicate mappings
			if (locationSite.getLocationsIsNotNull())
			{
				checkChildsForDuplicateTaxonoy(locationSite.getLocations(), map, factory);

			}

			throw new UniqueKeyViolationException("An Location Site with this name already exists, Please change", e);			
		}
		return LocSiteVoAssembler.create(doLocationSite);
	}

	

	/**
	 * Save Location
	 */
	public LocMostVo saveLocation(LocMostVo location) throws StaleObjectException, UniqueKeyViolationException
	{
		if (!location.isValidated())
			throw new DomainRuntimeException("Location not Validated.");

		DomainFactory factory = getDomainFactory();

		HashMap<?,?> map = new HashMap<Object, Object>();
		Location doLocation = LocMostVoAssembler.extractLocation(factory, location,map);

		// uniqueness constraint removed form the database - must be implemented in code. 
		if (checkLocationNameIsUnique(location.getName(), location.getID_Location())!= null )
		{
			throw new UniqueKeyViolationException("A record with the same name already exists, Please change");
		}
		
		try
		{
			doLocation.setUpperNames();
			factory.save(doLocation);
			
			// wdev-6404 Clear REMOTE_LOC_CACHE on save
			REMOTE_LOC_CACHE.clear();
		}
		catch (UnqViolationUncheckedException e)
		{
			String dupMessage = Keywords.checkDuplicateTaxonomy(factory, doLocation, "codeMappings", location.getCodeMappings(), "getName");
			if(dupMessage != null)
				throw new UniqueKeyViolationException(dupMessage);
			//WDEV-12600 - Check if the child location don't contain duplicate mappings
			if (location.getLocationsIsNotNull())
			{
				checkChildsForDuplicateTaxonoy(location.getLocations(), map, factory);

			}
		

			throw new UniqueKeyViolationException("An Location with this name already exists, Please change", e);			
		}
		return LocMostVoAssembler.create(doLocation);
	}

	private void checkChildsForDuplicateTaxonoy(LocMostVoCollection childs,Map<?, ?> doMap,DomainFactory factory) throws UniqueKeyViolationException
	{
		for (int i = 0 ; i < childs.size(); i++)
		{
			LocMostVo locMostVo = childs.get(i);
			Object doObj = doMap.get(locMostVo);
			if (doObj instanceof Location)
			{
				String dupMessage = Keywords.checkDuplicateTaxonomy(factory, doObj, "codeMappings", locMostVo.getCodeMappings(), "getName");
				if (dupMessage!=null)
					throw new UniqueKeyViolationException(dupMessage);
			}
		}
	}

	/**
	 * Move an existing organisation to a new location
	 */
	@SuppressWarnings("unchecked")
	public void moveOrganisation(ims.core.vo.OrganisationVo orgToMove, ims.core.vo.OrganisationVo currentParent, ims.core.vo.OrganisationVo destParent) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();

		Organisation doOrgToMove = OrganisationVoAssembler.extractOrganisation(factory, orgToMove);
		Organisation doOrgCurrentParent = OrganisationVoAssembler.extractOrganisation(factory, currentParent);
		Organisation doOrgDestParent = OrganisationVoAssembler.extractOrganisation(factory, destParent);

		if (doOrgCurrentParent != null)
		{
			doOrgToMove.setParentOrganisation(null);
			doOrgCurrentParent.getRelatedOrganisations().remove(doOrgToMove);
		}
		if (doOrgDestParent != null)
		{
			doOrgToMove.setParentOrganisation(doOrgDestParent);
			doOrgDestParent.getRelatedOrganisations().add(doOrgToMove);
		}
		doOrgToMove.setUpperNames();
		factory.save(doOrgToMove);
		
		//WDEV-10574
		REMOTE_LOC_CACHE.clear();
	}

	/**
	 * Move a location site
	 */
	@SuppressWarnings("unchecked")
	public void moveLocSite(ims.core.vo.LocSiteVo locSiteToMove, OrgShortVo currentParent, OrgShortVo destParent) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();

		LocSite doLocSite = LocSiteVoAssembler.extractLocSite(factory, locSiteToMove);
		Organisation doOrgCurrentParent = OrgShortVoAssembler.extractOrganisation(factory, currentParent);
		Organisation doOrgDestParent = OrgShortVoAssembler.extractOrganisation(factory, destParent);

		//strange hibernate(v3) error was being generated here and session refresh problems so hence the factory.refresh() calls
		doLocSite.setParentOrganisation(doOrgDestParent);
		doOrgCurrentParent.getLocationSites().remove(doLocSite);
		factory.refresh(doOrgCurrentParent);
		doOrgDestParent.getLocationSites().add(doLocSite);
		factory.save(doLocSite);
		factory.refresh(doOrgCurrentParent);
		
		//WDEV-10574
		REMOTE_LOC_CACHE.clear();		
	}

	/**
	 * moveLocation
	 */
	@SuppressWarnings("unchecked")
	public void moveLocation(LocMostVo locToMove, ims.core.vo.LocSiteVo locSiteCurrentParent, LocMostVo locCurrentParent, ims.core.vo.LocSiteVo locSiteDestParent, LocMostVo locDestParent) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();

		Location doLocToMove = LocMostVoAssembler.extractLocation(factory, locToMove);
		Location doLocCurrentParent = LocMostVoAssembler.extractLocation(factory, locCurrentParent);
		Location doLocDestParent = LocMostVoAssembler.extractLocation(factory, locDestParent);

		LocSite doLocSiteCurrentParent = LocSiteVoAssembler.extractLocSite(factory, locSiteCurrentParent);
		LocSite doLocSiteDestParent = LocSiteVoAssembler.extractLocSite(factory, locSiteDestParent);

		if (doLocCurrentParent != null)
		{
			doLocToMove.setParentLocation(null);
			if (doLocCurrentParent.getLocations().size() > 0)
				doLocCurrentParent.getLocations().remove(doLocToMove);
		}
		else if (doLocSiteCurrentParent != null)
		{
			doLocToMove.setParentLocation(null);
			if (doLocSiteCurrentParent.getLocations().size() > 0)
				doLocSiteCurrentParent.getLocations().remove(doLocToMove);
		}

		if (locSiteDestParent != null)
		{
			doLocToMove.setParentLocation(doLocSiteDestParent);
			doLocSiteDestParent.getLocations().add(doLocToMove);
		}
		else if (locDestParent != null)
		{
			doLocToMove.setParentLocation(doLocDestParent);
			doLocDestParent.getLocations().add(doLocToMove);
		}
		if(doLocCurrentParent != null)
			factory.refresh(doLocCurrentParent);
		if(doLocSiteCurrentParent != null)
			factory.refresh(doLocSiteCurrentParent);
		
		factory.save(doLocToMove);
		
		//WDEV-10574
		REMOTE_LOC_CACHE.clear();

	}

	public OrganisationVo getOrganisation(Integer id)
	{
		DomainFactory factory = getDomainFactory();
		return OrganisationVoAssembler.create((Organisation) factory.getDomainObject(Organisation.class, id));
	}

	public LocSiteVo getLocSite(Integer id)
	{
		DomainFactory factory = getDomainFactory();
		return LocSiteVoAssembler.create((LocSite) factory.getDomainObject(LocSite.class, id));
	}
	//wdev-12855
	public LocMostVo getLocMost(Integer id) 
	{
		DomainFactory factory = getDomainFactory();
		return LocMostVoAssembler.create((Location)factory.getDomainObject(Location.class, id));
	}
	public PrinterVo getPrinter(IPrinter printer)
	{
		if (printer == null)
			throw new CodingRuntimeException("printer cannot be null in method getPrinter");
			
		DomainFactory factory = getDomainFactory();
		return PrinterVoAssembler.create((Printer) factory.getDomainObject(Printer.class, printer.getIPrinterId()));
	}
	
	public void deleteOrganisation(OrganisationVo orgToDelete) throws ForeignKeyViolationException
	{
		DomainFactory factory = getDomainFactory();

		Organisation doOrganisation = OrganisationVoAssembler.extractOrganisation(factory, orgToDelete);
		Organisation doParentOrg = doOrganisation.getParentOrganisation();
		if (doParentOrg != null)
		{
			doParentOrg.getRelatedOrganisations().remove(doOrganisation);
		}
		
		// WDEV - 12551 - Display an appropriate message
		// when deleting fails
		try
		{
			factory.delete(doOrganisation);
		}
		catch (Exception ex)
		{
			throw new ForeignKeyViolationException("Organization is in use and can not be deleted.");
		}
	}

	public void deleteLocation(LocMostVo locToDelete) throws ForeignKeyViolationException
	{
		DomainFactory factory = getDomainFactory();

		Location doLocation = LocMostVoAssembler.extractLocation(factory, locToDelete);

		if (doLocation.getServices().size() > 0)
		{
			throw new ForeignKeyViolationException("There are Services associated with this Location. Cannot delete.");
		}
		if (doLocation.getActivityLimitGroup().size() > 0)
		{
			throw new ForeignKeyViolationException("There are Activity Limits associated with this Location. Cannot delete.");
		}

		Location doParentLocation = doLocation.getParentLocation();
		if (doParentLocation != null)
			doParentLocation.getLocations().remove(doLocation);

		// WDEV - 12551 - Display an appropriate message
		// when deleting fails
		try
		{
			factory.delete(doLocation);
		}
		catch (Exception ex)
		{
			throw new ForeignKeyViolationException("Location is in use and can not be deleted.");
		}
	}

	public void deleteLocSite(LocSiteVo locSiteToDelete) throws ForeignKeyViolationException
	{
		DomainFactory factory = getDomainFactory();

		LocSite doLocSite = LocSiteVoAssembler.extractLocSite(factory, locSiteToDelete);

		if (doLocSite.getServices().size() > 0)
		{
			throw new ForeignKeyViolationException("There are Services associated with this Location Site. Cannot delete.");
		}
		if (doLocSite.getActivityLimitGroup().size() > 0)
		{
			throw new ForeignKeyViolationException("There are Activity Limits associated with this Location Site. Cannot delete.");
		}

		Organisation doParentOrganisation = doLocSite.getParentOrganisation();
		if (doParentOrganisation != null)
			doParentOrganisation.getLocationSites().remove(doLocSite);

		// WDEV - 12551 - Display an appropriate message
		// when deleting fails
		try
		{
			factory.delete(doLocSite);
		}
		catch (Exception ex)
		{
			throw new ForeignKeyViolationException("Location Site is in use and can not be deleted.");
		}
	}

	public LocMostVoCollection listLocation(LocMostVo locationFilter)
	{
		List locations;
		if (locationFilter == null)
		{
//			wdev-2730
			StringBuffer hql = new StringBuffer();
			hql.append(" from LocSite as ls");
			hql.append(" where");
			hql.append(" and ls.isActive =:active");
			hql.append(" and ls.isRIE is null");
			hql.append(" and ls.isVirtual =:virtual");

			locations = getDomainFactory().find(hql.toString(), new String[]{"active", "virtual"}, new Object[]{Boolean.TRUE, Boolean.FALSE});
		}
		else
		{
			locations = listLocationsByParentLocation(locationFilter.getType(),locationFilter.getParentLocation(),locationFilter.getIsActive(),locationFilter.getReferringHospital(),locationFilter.getTreatingHosp(), null);
		}
		
		return LocMostVoAssembler.createLocMostVoCollectionFromLocation(locations).sort();
	}
	
	/**
	 * Method wil step into the structure and retrieve from all sub-levels items that match the search criteria
	 * 
	 * @param type
	 * @param parentLocation
	 * @param isActive
	 * @param referringHospital
	 * @param treatingHosp
	 * @param name
	 * @return
	 */
	@SuppressWarnings("unchecked")
	private List listLocationsByParentLocation(LocationType type, LocationRefVo parentLocation, Boolean isActive, Boolean referringHospital, Boolean treatingHosp, String name)
	{
		//WDEV-6887
		if(name != null)
		{
			String[] arr = null;
			if(name.contains("%"))
			{
				arr = name.split("%");
				if(arr.length > 0)
					name = arr[0] + "%";
				else
					name = "%";
			}
		}

		if(parentLocation == null)
			return listLocations(type, isActive, referringHospital, treatingHosp, name);
		
		DomainFactory factory = getDomainFactory();
		Location doLocation = (Location) factory.getDomainObject(Location.class, parentLocation.getID_Location());
		ArrayList listItems = new ArrayList();
		buildLocationsList(doLocation, listItems, type, isActive, referringHospital, treatingHosp, name);

		return listItems;
	}

	private void buildLocationsList(Location location, ArrayList<Location> listItems, LocationType type, Boolean isActive, Boolean referringHospital, Boolean treatingHosp, String name)
	{
		Iterator it = location.getLocations().iterator();
		while(it.hasNext())
		{
			Location doLocation = (Location) it.next();
			if(doLocation.getType().equals(getDomLookup(type)) 
				&& doLocation.isIsActive().equals(isActive) 
				&& (referringHospital == null || doLocation.isReferringHospital().equals(referringHospital)) 
				&& (treatingHosp == null || doLocation.isTreatingHosp().equals(treatingHosp)) 
				&& (name == null || name.equals("%") || doLocation.getUpperName().indexOf(name.toUpperCase()) > -1)
				&& doLocation.isIsVirtual().equals(Boolean.FALSE)) //wdev-2730
			{
				listItems.add(doLocation);
			}
			
			buildLocationsList(doLocation, listItems, type, isActive, referringHospital, treatingHosp, name);
		}
	}

	public LocMostVoCollection listLocSite(OrgShortVo organisation)
	{
		LocMostVoCollection voCollLocation = new LocMostVoCollection();
		DomainFactory factory = getDomainFactory();
		Organisation doOrganisation = (Organisation) factory.getDomainObject(Organisation.class, organisation.getID_Organisation());
		populateLocationCollection(LocMostVoAssembler.createLocMostVoCollectionFromLocation(doOrganisation.getLocationSites()), voCollLocation);
		return voCollLocation;
	}


	public LocSiteLiteVoCollection listLocSite(String locationName)
	{
		String location = locationName != null ? locationName.toUpperCase() + "%" : "%%";

		StringBuffer hql = new StringBuffer();
		hql.append(" from LocSite as ls");
		hql.append(" where");
		hql.append(" ls.upperName like :locationName");
		hql.append(" and ls.isActive =:active");
		hql.append(" and ls.isRIE is null");
		hql.append(" and ls.isVirtual =:virtual");//wdev-2730

		List list = getDomainFactory().find(hql.toString(), new String[]{"locationName", "active", "virtual"}, new Object[]{location, Boolean.TRUE, Boolean.FALSE});

		return LocSiteLiteVoAssembler.createLocSiteLiteVoCollectionFromLocSite(list);
	}
	
	public OrganisationVoCollection listRootOrgs()
	{
		OrganisationVo filter = new OrganisationVo();
		filter.setParent(null);
		return this.listOrganisation(filter, Boolean.TRUE, Boolean.TRUE);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see ims.admin.domain.OrganisationAndLocation#getLocationByLocalCode(java.lang.String,
	 *      ims.core.vo.lookups.LocationType)
	 */
	public LocShortVo getLocationByLocalCode(String localCode, LocationType codeSpecifier)
	{
		if (localCode == null || localCode.equals(""))
			return null;
		if (LOGGER.isInfoEnabled())
			LOGGER.info("Location reverse Lookup Call. localCode:" + localCode);

		if (REMOTE_LOC_CACHE.get(localCode) != null)
		{
			if (LOGGER.isInfoEnabled())
				LOGGER.info("Location reverse Lookup Cache Hit. localCode:" + localCode);
			return REMOTE_LOC_CACHE.get(localCode);
		}
		DomainFactory factory = getDomainFactory();

		String hql = null;
		List locs = null;

		if (codeSpecifier == null)
		{
			hql = " from Location l " +
			" join l.codeMappings as cm" +
			" where cm.taxonomyName = :taxType " + 
			" and cm.taxonomyCode = :localCode ";

			locs = factory.find(hql,new String[]{"taxType", "localCode"}, new Object[]{getDomLookup(TaxonomyType.PAS),localCode});
		}
		else
		{
			hql = " from Location l " +
			" join l.codeMappings as cm" +
			" where cm.taxonomyName = :taxType " + 
			" and cm.taxonomyCode = :localCode " +
			" and l.type = :codeSpecifier ";

			locs = factory.find(hql,new String[]{"taxType", "localCode", "codeSpecifier"}, new Object[]{getDomLookup(TaxonomyType.PAS),localCode,getDomLookup(codeSpecifier)});
		}

		if (locs != null && locs.size() == 1)
		{
			LocShortVo loc = LocShortVoAssembler.create((Location) locs.get(0));
			REMOTE_LOC_CACHE.put(localCode, loc);
			return loc;
		}
		else if (locs != null && locs.size() > 1)
		{
			throw new DomainRuntimeException("Non unique hit on Location by LocalCode " + localCode);
		}
		return null;
	}
		
	public LocMostVo getLocationByPostCode(String postCode) 
	{
		if (postCode == null)
			return null;

		DomainFactory factory = getDomainFactory();
		String hql = " from Location l where l.address.postCode = :postCode ";

		List locList = factory.find(hql,new String[]{"postCode"}, new Object[]{postCode});

		if (locList != null && locList.size() == 1)
		{
			return LocMostVoAssembler.create((Location) locList.get(0));
		}
		else if (locList != null && locList.size() > 1)
		{
			throw new DomainRuntimeException("Non unique hit on Location by Post Code " + postCode);
		}
		return null;
	}
	
	
	public LocSiteShortVo getLocSiteByPostCode(String postCode) 
	{
		if (postCode == null)
			return null;

		DomainFactory factory = getDomainFactory();
		String hql = " from LocSite l where l.address.postCode = :postCode ";

		List locList = factory.find(hql,new String[]{"postCode"}, new Object[]{postCode});

		if (locList != null && locList.size() == 1)
		{
			return LocSiteShortVoAssembler.create((LocSite) locList.get(0));
		}
		else if (locList != null && locList.size() > 1)
		{
			throw new DomainRuntimeException("Non unique hit on LocationSite by Post Code " + postCode);
		}
		return null;
	}
	
	private LocSite getDomLocSiteByTaxonomyType(String extId, TaxonomyType taxonomyType)
	{
		return (LocSite)getDomLocationByTaxonomyType(extId, taxonomyType, LocSite.class);		
	}

	private Location getDomLocationByTaxonomyType(String extId, TaxonomyType taxonomyType)
	{
		return getDomLocationByTaxonomyType(extId, taxonomyType, Location.class);
	}

	private Location getDomLocationByTaxonomyType(String extId, TaxonomyType taxonomyType, Class clazz)
	{
		if (extId == null || taxonomyType == null)
			return null;

		String objName = (clazz.equals(Location.class)) ? "Location" : "LocSite";
		DomainFactory factory = getDomainFactory();
		String hql = " from " + objName + " l " +
		" join l.codeMappings as cm" +
		" where cm.taxonomyName = :taxType " + 
		" and cm.taxonomyCode = :extId ";

		List locList = factory.find(hql,new String[]{"taxType", "extId"}, new Object[]{getDomLookup(taxonomyType),extId});

		if (locList != null && locList.size() == 1)
		{
			return (Location) locList.get(0);
		}
		else if (locList != null && locList.size() > 1)
		{
			throw new DomainRuntimeException("Non unique hit on Location by TaxonomyType " + taxonomyType.getText() + " and code " + extId);
		}
		else
			return null;
	}

	public LocShortMappingsVo getLocationByTaxonomyType(String extId, TaxonomyType taxonomyType) 
	{
		return LocShortMappingsVoAssembler.create(getDomLocationByTaxonomyType(extId, taxonomyType));
	}

	public LocSiteVo getLocSiteByTaxonomyType(String extId, TaxonomyType taxType) 
	{
		return LocSiteVoAssembler.create(getDomLocSiteByTaxonomyType(extId, taxType));
	}
	
	public LocSiteShortVo getLocSiteShortByTaxonomyType(String extId, TaxonomyType taxType)
	{
		return LocSiteShortVoAssembler.create(getDomLocSiteByTaxonomyType(extId, taxType));
	}

	public LocationLiteVo getLocationLiteByTaxonomyType(String extId, TaxonomyType taxType)
	{
		return LocationLiteVoAssembler.create(getDomLocationByTaxonomyType(extId, taxType));
	}

	private Organisation getDomOrganisationByTaxonomyType(String extId, TaxonomyType taxonomyType)
	{
		if (extId == null || taxonomyType == null)
			return null;

		DomainFactory factory = getDomainFactory();
		String hql = " from Organisation o " +
		" join o.codeMappings as cm" +
		" where cm.taxonomyName = :taxType " + 
		" and cm.taxonomyCode = :extId ";

		List orgList = factory.find(hql,new String[]{"taxType", "extId"}, new Object[]{getDomLookup(taxonomyType),extId});

		if (orgList != null && orgList.size() == 1)
		{
			return (Organisation) orgList.get(0);
		}
		else if (orgList != null && orgList.size() > 1)
		{
			throw new DomainRuntimeException("Non unique hit on Organisation by TaxonomyType " + taxonomyType.getText() + " and code " + extId);
		}
		return null;
	}
	
	public OrgLiteVo getOrgLiteByTaxonomyType(String extId, TaxonomyType taxonomyType)
	{
		return OrgLiteVoAssembler.create(getDomOrganisationByTaxonomyType(extId, taxonomyType));
	}
	
	public OrganisationVo getOrganisationByTaxonomyType(String extId, TaxonomyType taxonomyType) 
	{
		return OrganisationVoAssembler.create(getDomOrganisationByTaxonomyType(extId, taxonomyType));
	}
	
	
	/*
	 * (non-Javadoc)
	 * 
	 * @see ims.admin.domain.OrganisationAndLocation#listLocationsMin(ims.core.vo.lookups.LocationType)
	 */
	public ClinicListVoCollection listLocationsMin(LocationType locType)
	{
		DomainFactory factory = getDomainFactory();
		ClinicListVoCollection voCollReturn = new ClinicListVoCollection();
		List lstClinics = factory.find("from Location l where l.type = :type and l.isActive= :isActive and l.isVirtual= :isVirtual", new String[]{"type", "isActive", "isVirtual"}, new Object[]{getDomLookup(locType), Boolean.TRUE, Boolean.FALSE});//wdev-2730

		for (Iterator iter = lstClinics.iterator(); iter.hasNext();)
		{
			Location doLocation = (Location) iter.next();
			ClinicListVo voBaseList = new ClinicListVo();
			voBaseList.setSingleID(doLocation.getId());
			voBaseList.setBoolValue(doLocation.isIsActive());
			voBaseList.setName(doLocation.getName());
			voBaseList.setDescription(doLocation.getExtCode(TaxonomyType.PAS.getId()));

			voCollReturn.add(voBaseList);
		}

		return voCollReturn;
	}

	public OrganisationVoCollection listRootOrgsNoGpp()
	{
		OrganisationVo filter = new OrganisationVo();
		filter.setParent(null);
		return listOrganisation(filter, Boolean.TRUE, Boolean.FALSE); 
	}

	public OrganisationVoCollection listActiveRootOrgsNoGpp()
	{
		OrganisationVo filter = new OrganisationVo();
		filter.setParent(null);
		return listOrganisation(filter, Boolean.TRUE, Boolean.TRUE); 
	}

	public OrganisationVoCollection listActiveRootOrgsWithGpp()
	{
		OrganisationVo filter = new OrganisationVo();
		filter.setParent(null);
		return listOrganisation(filter, Boolean.FALSE, Boolean.TRUE); 
	}

	public void setOrgActiveState(OrganisationRefVo orgVo, Boolean state) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		Organisation org = (Organisation)factory.getDomainObject(Organisation.class, orgVo.getID_Organisation());
		org.setIsActive(state);
		factory.save(org);
		//WDEV-10574
		REMOTE_LOC_CACHE.clear();
	}

	public void setLocationActiveState(LocationRefVo locVo, Boolean state) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		Location loc = (Location)factory.getDomainObject(Location.class, locVo.getID_Location());
		loc.setIsActive(state);
		factory.save(loc);		

		//WDEV-10574
		REMOTE_LOC_CACHE.clear();

	}
	
	public ClinicVo getClinicByTaxonomyCode(TaxonomyType type,String taxCode)
	{
		DomainFactory factory = getDomainFactory();
		String hql="select clinic from Clinic as clinic left join clinic.codeMappings as codeMappings " +
				"where (codeMappings.taxonomyCode = :code and codeMappings.taxonomyName =:name )";
		List clinics=factory.find(hql, new String []{"code", "name"},new Object []{taxCode, getDomLookup(type)});
		if (clinics.size()!=0)
		{
			Clinic clinic=(Clinic)clinics.get(0);
			return ClinicVoAssembler.create(clinic);
		}
		else
		{
			return null;
		}
	}

	public ClinicVo saveClinic(ClinicVo clinic) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		
		Clinic domClinic = ClinicVoAssembler.extractClinic(factory, clinic);
		
		// wdev-3603 set uppernames if null
		
		//wdev-14268 , set uppernames at every save
		domClinic.setUpperNames();
		
		factory.save(domClinic);
		
		//WDEV-10574
		REMOTE_LOC_CACHE.clear();
		
		return ClinicVoAssembler.create(domClinic);
	}

	private List listLocations(LocationType locType, Boolean activeOnly, Boolean includeReferringHosp, Boolean includeTreatingHosp, String name)
	{
		DomainFactory factory = getDomainFactory();
		
		List locations;

		String hql = " from Location loc ";
		StringBuffer condStr = new StringBuffer();
		String andStr = " ";

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();

		if (locType != null)
		{
			condStr.append(andStr + " loc.type = :locType");
			markers.add("locType");
			values.add(getDomLookup(locType));
			andStr = " and ";
		}
		if (activeOnly != null && activeOnly.booleanValue())
		{
			condStr.append(andStr + " loc.isActive = :active");
			markers.add("active");
			values.add(activeOnly);
			andStr = " and ";
		}
		if (includeReferringHosp != null && includeReferringHosp.booleanValue())
		{
			condStr.append(andStr + " loc.referringHospital = :referring");
			markers.add("referring");
			values.add(includeReferringHosp);
			andStr = " and ";
		}
		if (includeTreatingHosp != null && includeTreatingHosp.booleanValue())
		{
			condStr.append(andStr + " loc.treatingHosp = :treating");
			markers.add("treating");
			values.add(includeTreatingHosp);
			andStr = " and ";
		}		
		if (name != null)
		{
			condStr.append(andStr + " loc.upperName like :name");
			markers.add("name");
			values.add(name.toUpperCase() + "%");
			andStr = " and ";
		}
		
		//WDEV-7175 - exclude surgeries
		if(locType == null || locType != LocationType.SURGERY)
		{
			condStr.append(andStr + " loc.type <> :surgery ");
			markers.add("surgery");
			values.add(getDomLookup(LocationType.SURGERY));
			andStr = " and ";
		}
		
		//wdev-2730
		condStr.append(andStr + "loc.isVirtual =:isVirtual");
		markers.add("isVirtual");
		values.add(Boolean.FALSE);

		if (andStr.equals(" and "))
		{
			hql += " where ";
		}

		hql += condStr.toString();
		hql += " ORDER BY loc.upperName";						// WDEV-13930
		locations = factory.find(hql, markers, values);
		return locations;
	}
	
	public LocSiteLiteVoCollection listCCAs()
	{
		List locations = listLocations(LocationType.CCA,Boolean.TRUE,null,null,null);
		return LocSiteLiteVoAssembler.createLocSiteLiteVoCollectionFromLocSite(locations).sort();

	}

	public LocShortMappingsVoCollection listActiveHospitals()
	{
		List locations = listLocations(LocationType.HOSP,Boolean.TRUE,null,null,null);
		return  LocShortMappingsVoAssembler.createLocShortMappingsVoCollectionFromLocation(locations).sort();
	}

	public LocShortMappingsVoCollection listActiveWardsForHospital(LocationRefVo hospital)
	{
		List locations = listLocationsByParentLocation(LocationType.WARD,hospital,Boolean.TRUE,null,null,null);
		return  LocShortMappingsVoAssembler.createLocShortMappingsVoCollectionFromLocation(locations).sort();
	}
	
	public LocShortVoCollection listActiveWardsForHospital(LocationRefVo hospital, String name)
	{
		List locations = listLocationsByParentLocation(LocationType.WARD,hospital,Boolean.TRUE,null,null,name);
		return  LocShortVoAssembler.createLocShortVoCollectionFromLocation(locations).sort();
	}

	public LocationLiteVoCollection listActiveLocationsByName(String name)
	{
		List locations;
		if (name == null)
		{
			//		wdev-2730
			StringBuffer hql = new StringBuffer();
			hql.append(" from LocSite as ls");
			hql.append(" where");
			hql.append(" and ls.isActive =:active");
			hql.append(" and ls.isRIE is null");
			hql.append(" and ls.isVirtual =:virtual");
	
			locations = getDomainFactory().find(hql.toString(), new String[]{"active", "virtual"}, new Object[]{Boolean.TRUE, Boolean.FALSE});
		}
		else
		{
			locations = listLocations(null, Boolean.TRUE, null, null, name);
		}
		
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations).sort();
	}

	public LocationLiteVoCollection listActiveReferringHospitals()
	{
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation( listLocations(LocationType.HOSP, Boolean.TRUE, Boolean.TRUE, null, null)).sort();
	}

	public LocationLiteVoCollection listActiveTreatingHospitals()
	{
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation( listLocations(LocationType.HOSP, Boolean.TRUE, null, Boolean.TRUE, null)).sort();
	}

	public LocationLiteVoCollection listActiveLocSiteLite()
	{
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(getDomainFactory().find("from LocSite ls where ls.isActive = :isActive and ls.type != :SurgeryType and ls.isVirtual = :isVirtual", new String[]{"isActive","SurgeryType","isVirtual"}, new Object[]{Boolean.TRUE,getDomLookup(LocationType.SURGERY),Boolean.FALSE}));
	}

	public LocationLiteVoCollection listActiveLocSiteLiteByName(String nameFilter)
	{
		if (nameFilter == null || nameFilter.length() == 0)
		{
			return listActiveLocSiteLite();
		}
		String locFilter = nameFilter.toUpperCase() + "%";
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(getDomainFactory().find("from LocSite ls where ls.isActive = :isActive and ls.upperName like :nameFilter and ls.isVirtual = :isVirtual", new String[]{"isActive","nameFilter","isVirtual"}, new Object[]{Boolean.TRUE, locFilter,Boolean.FALSE}));
	}

	public ClinicVo getClinic(Integer clinicCode)
	{
		DomainFactory factory = getDomainFactory();
		
		return ClinicVoAssembler.create((Clinic) factory.getDomainObject(Clinic.class, clinicCode.intValue()));
	}

	public LocShortMappingsVo getLocation(Integer location)
	{
		DomainFactory factory = getDomainFactory();
		
		return LocShortMappingsVoAssembler.create((Location) factory.getDomainObject(Location.class, location.intValue()));

	}

	public LocShortVoCollection listActiveWardsForHospitalByName(LocationRefVo hospital, String name)
	{
		List locations = listLocationsByParentLocation(LocationType.WARD,hospital,Boolean.TRUE,null,null,name);
		return  LocShortVoAssembler.createLocShortVoCollectionFromLocation(locations).sort();
	}

	public LocShortVoCollection listActiveClinicsForHospitalByName(LocationRefVo hospital, String name)
	{
		List locations = listLocationsByParentLocation(LocationType.CLINIC,hospital,Boolean.TRUE,null,null,name);
		return  LocShortVoAssembler.createLocShortVoCollectionFromLocation(locations).sort();
	}

	public LocationLiteVoCollection listActiveWardsForHospitalByNameLite(LocationRefVo location, String name)
	{
		List locations = listLocationsByParentLocation(LocationType.WARD,location,Boolean.TRUE,null,null,name);
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations).sort();
	}

	public LocationLiteVoCollection listLocationByName(String locationName)
	{
		List locations = listLocationsByParentLocation(null,null,Boolean.TRUE,null,null,locationName);
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations).sort();
	}

	public LocationLiteVoCollection listActiveOutpatDeptsForHospitalByNameLite(LocationRefVo parentLoc, String nameFilter)
	{
		List locations = listLocationsByParentLocation(LocationType.OUTPATIENT_DEPT,parentLoc,Boolean.TRUE,null,null,nameFilter);
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations).sort();
	}

	public LocShortVoCollection listActiveOutpatDeptsForHospitalByName(LocationRefVo hospital, String nameFilter)
	{
		List locations = listLocationsByParentLocation(LocationType.OUTPATIENT_DEPT,hospital,Boolean.TRUE,null,null,nameFilter);
		return  LocShortVoAssembler.createLocShortVoCollectionFromLocation(locations).sort();
	}
	
	
	public LocationLiteVoCollection listActiveAandEForHospitalByNameLite(LocationRefVo hosp, String name)
	{
		List locations = listLocationsByParentLocation(LocationType.ANE,hosp,Boolean.TRUE,null,null,name);
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations).sort();	
	}

	public String checkExchequerCodeIsUnique(String taxonomyCode, ValueObjectRef refVo)
	{		
		String dupMessage = "";
		
		dupMessage = checkExchequerCodeIsUniqueInOrganisation(taxonomyCode, refVo);
		if (dupMessage != null)
		{
			return dupMessage;
		}
		
		dupMessage = checkExchequerCodeIsUniqueInLocSite(taxonomyCode, refVo);
		if (dupMessage != null)
		{
			return dupMessage;
		}
		
		dupMessage = checkExchequerCodeIsUniqueInLocation(taxonomyCode, refVo);
		if (dupMessage != null)
		{
			return dupMessage;
		}
		
		return null;
	}

	private String checkExchequerCodeIsUniqueInOrganisation(String taxonomyCode, ValueObjectRef refVo)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();

		DomainFactory factory = getDomainFactory();
		java.util.List list = null;
		String name = "";
		String strHql = "select t1_1.taxonomyCode, l1_1.id, o1_1.name from Organisation as o1_1 left join o1_1.codeMappings as t1_1 left join t1_1.taxonomyName as l1_1 where ";
			
		String andStr = " ";
		
		if (taxonomyCode != null)
		{
			condStr.append(andStr + "(t1_1.taxonomyCode = :code");
			markers.add("code");
			values.add(taxonomyCode);
			andStr = " and ";
			condStr.append(andStr + "l1_1.id = :id");
			markers.add("id");
			values.add(TaxonomyType.EXCH.getId());
			andStr = " and ";
		}
		if (refVo instanceof OrganisationRefVo  && refVo.getDomainId() != null)
		{
			condStr.append(andStr + "o1_1.id != :org");
			markers.add("org");
			values.add(refVo.getDomainId());

		}
		
		condStr.append(")");
		strHql += condStr.toString();

		list = factory.find(strHql, markers, values);

		if(list != null && list.size() > 0)
		{
			Object[] element = (Object[]) list.get(0);
			name = (String)element[2];
			String dupMessage = "Item named '" + name + "' already has a Exchequer mapping with code = " + taxonomyCode;
			return dupMessage;
		}	
		return null;
	}
	
	private String checkExchequerCodeIsUniqueInLocation(String taxonomyCode, ValueObjectRef refVo)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();

		DomainFactory factory = getDomainFactory();
		java.util.List list = null;
		String name = "";
		String strHql = "select t1_1.taxonomyCode, l1_1.id, o1_1.name from Location as o1_1 left join o1_1.codeMappings as t1_1 left join t1_1.taxonomyName as l1_1 where ";
			
		String andStr = " ";
		
	
		if (taxonomyCode != null)
		{
			condStr.append(andStr + "(t1_1.taxonomyCode = :code");
			markers.add("code");
			values.add(taxonomyCode);
			andStr = " and ";
			condStr.append(andStr + "l1_1.id = :id");
			markers.add("id");
			values.add(TaxonomyType.EXCH.getId());
			andStr = " and ";
		}
		if (refVo instanceof LocationRefVo  && refVo.getDomainId() != null)
		{
			condStr.append(andStr + "o1_1.id != :org");
			markers.add("org");
			values.add(refVo.getDomainId());

		}
		
		condStr.append(")");
		strHql += condStr.toString();

		list = factory.find(strHql, markers, values);

		if(list != null && list.size() > 0)
		{
			Object[] element = (Object[]) list.get(0);
			name = (String)element[2];
			String dupMessage = "Item named '" + name + "' already has a Exchequer mapping with code = " + taxonomyCode;
			return dupMessage;
		}	
		return null;
	}
	
	private String checkExchequerCodeIsUniqueInLocSite(String taxonomyCode, ValueObjectRef refVo)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();

		DomainFactory factory = getDomainFactory();
		java.util.List list = null;
		String name = "";
		String strHql = "select t1_1.taxonomyCode, l1_1.id, o1_1.name from LocSite as o1_1 left join o1_1.codeMappings as t1_1 left join t1_1.taxonomyName as l1_1 where ";
			
		String andStr = " ";
		
	
		if (taxonomyCode != null)
		{
			condStr.append(andStr + "(t1_1.taxonomyCode = :code");
			markers.add("code");
			values.add(taxonomyCode);
			andStr = " and ";
			condStr.append(andStr + "l1_1.id = :id");
			markers.add("id");
			values.add(TaxonomyType.EXCH.getId());
			andStr = " and ";
		}
		if (refVo instanceof LocationRefVo && refVo.getDomainId() != null)
		{
			condStr.append(andStr + "o1_1.id != :org");
			markers.add("org");
			values.add(refVo.getDomainId());

		}
		
		condStr.append(")");
		strHql += condStr.toString();

		list = factory.find(strHql, markers, values);

		if(list != null && list.size() > 0)
		{
			Object[] element = (Object[]) list.get(0);
			name = (String)element[2];
			String dupMessage = "Item named '" + name + "' already has a Exchequer mapping with code = " + taxonomyCode;
			return dupMessage;
		}	
		return null;
	}

	public String checkOrganisationNameisUnique(String orgName, OrganisationRefVo orgRefVo)
	{
		if (orgName == null)
			throw new CodingRuntimeException("Mandatory argument - Organisation Name");
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();
		java.util.List list = null;
		String strHql = "";
		DomainFactory factory = getDomainFactory();
		
		strHql = "from Organisation o where o.upperName = :name";
		markers.add("name");
		values.add(orgName.toUpperCase());
		
		String andStr = " and ";
		
		if (orgRefVo != null && orgRefVo.getID_OrganisationIsNotNull())
		{
			condStr.append(andStr + "o.id != :id");
			markers.add("id");
			values.add(orgRefVo.getID_Organisation());
		}
		
		strHql += condStr.toString();

		list = factory.find(strHql, markers, values);

		if(list != null && list.size() > 0)
		{
			String dupMessage = "An organisation with the name " + orgName + " already exists, please rename the entered organisation";
			return dupMessage;
		}
		
		return null;
	}

	public String checkLocationNameIsUnique(String locationName, Integer locationId)
	{
		if (locationName == null)
			throw new CodingRuntimeException("Mandatory argument - Location Name");
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();
		java.util.List list = null;
		String strHql = "";
		DomainFactory factory = getDomainFactory();
		
		strHql = "from Location o where o.upperName = :name";
		markers.add("name");
		values.add(locationName.toUpperCase());
		
		String andStr = " and ";
		
		if (locationId != null)
		{
			condStr.append(andStr + "o.id != :id");
			markers.add("id");
			values.add(locationId);
		}
		
		strHql += condStr.toString();

		list = factory.find(strHql, markers, values);

		if(list != null && list.size() > 0)
		{
			String dupMessage = "A Location with the name '" + locationName + "' already exists, please rename the entered Location";
			return dupMessage;
		}
		
		return null;
	}

	public String checkLocationSiteNameIsUnique(String locSiteName, Integer locSiteId)
	{
		if (locSiteName == null)
			throw new CodingRuntimeException("Mandatory argument - Location Site Name");
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();
		java.util.List list = null;
		String strHql = "";
		DomainFactory factory = getDomainFactory();
		
		strHql = "from LocSite o where o.upperName = :name";
		markers.add("name");
		values.add(locSiteName.toUpperCase());
		
		String andStr = " and ";
		
		if (locSiteId != null )
		{
			condStr.append(andStr + "o.id != :id");
			markers.add("id");
			values.add(locSiteId);
		}
		
		strHql += condStr.toString();

		list = factory.find(strHql, markers, values);

		if(list != null && list.size() > 0)
		{
			String dupMessage = "A Location Site with the name " + locSiteName + " already exists, please rename the entered Location Site";
			return dupMessage;
		}
		
		return null;
	}

	public LocShortMappingsVoCollection listActiveReferringHospitalsWithMappings()
	{
		return LocShortMappingsVoAssembler.createLocShortMappingsVoCollectionFromLocation( listLocations(LocationType.HOSP, Boolean.TRUE, Boolean.TRUE, null, null)).sort();
	}

	public LocationLiteVoCollection listActiveHospitalsLite()
	{
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(listLocations(LocationType.HOSP,Boolean.TRUE,null,null,null)).sort();
	}

	public LocationLiteVoCollection listActiveWardsForHospitalLite(LocationRefVo hospital)
	{
		return  LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(listLocationsByParentLocation(LocationType.WARD,hospital,Boolean.TRUE,null,null,null)).sort();
	}


	public OrganisationVoCollection listPCTs(String value, Boolean activeOnly) {
		DomainFactory factory = getDomainFactory();

		String hql = " from Organisation o ";
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		StringBuffer condStr = new StringBuffer();
		String andStr = " ";

		List orgs = null;

		condStr.append(andStr + " o.type.id = " + OrganisationType.NHS_PCT.getID());
		andStr = " and ";


		if (activeOnly != null && activeOnly.booleanValue())
		{
			condStr.append(andStr + " o.isActive = :isActive");
			markers.add("isActive");
			values.add(activeOnly);
			andStr = " and ";
		}
		
		
		if (null!=value && value.length() > 0)
		{
			condStr.append(andStr);
			condStr.append(" o.upperName like :OrgName");
			markers.add("OrgName");
			values.add(value.toUpperCase() + "%");
			andStr = " and ";

		}
		hql += " where ";
		hql +=  condStr.toString();
		orgs = factory.find(hql, markers, values);



		OrganisationVoCollection voCollOrgs = OrganisationVoAssembler.createOrganisationVoCollectionFromOrganisation(orgs);
		voCollOrgs.sort();
		return voCollOrgs;
	}

	public String getActiveHospitalCodeForClinic(ClinicRefVo clinicRefVo, TaxonomyType taxonomyType)
	{
		DomainFactory factory = getDomainFactory();
		Clinic clinic = (Clinic)factory.getDomainObject(clinicRefVo);
		if (clinic==null)
			return null;
		
		Location loc = clinic.getClinicLocation();

		while (loc!=null&&(loc.isIsActive()&&loc.getType()!=null&&loc.getType().equals(getDomLookup(OrganisationType.HOSPITAL))))
		{
			loc=loc.getParentLocation();
		}
		if(loc!=null)
			return loc.getExtCode(taxonomyType.getID());
		return null;
	}

	public LocationLiteVoCollection listLocationByOrganisation(OrganisationRefVo organisation, String name) 
	{
		if (name != null)
			name = name.replaceAll("[^a-zA-Z]", "");
		List<Location> locations = new ArrayList<Location>();
		buildLocations(organisation.getID_Organisation(), locations, name,false);
		
		LocationLiteVoCollection locs = LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations);
		return locs.sort(true);
	}
	
	private void buildLocations(Object node,List<Location> locations,final String name,Boolean includePathRad)
	{
		if (node == null)
			return;
		
		if(node instanceof Integer)
		{
			List<Integer> orgId = listOrganisationByOrganisation((Integer) node);
			for(int i=0; orgId!=null && i<orgId.size(); i++)
			{
				buildLocations(orgId.get(i), locations,name,includePathRad);
			}

			List<Location> locSiteList = listLocSiteByOrganisation((Integer) node, includePathRad);

			for(int j=0; locSiteList!=null && j<locSiteList.size(); j++)
			{
				buildLocations(locSiteList.get(j), locations,name,includePathRad);
			}
			
			return ;

		}

		if(node instanceof Location)
		{
			Location loc = (Location) node;
			boolean shouldAdd = true;
			if (name!=null && !loc.getName().toUpperCase().contains(name.toUpperCase()))
			{
				shouldAdd = false;
			}
			if (shouldAdd)
				 locations.add(loc);

			List<Location> locationList = listLocationByLocation(loc,includePathRad);

			for(int k = 0; locationList != null && k<locationList.size(); k++)
			{

				buildLocations(locationList.get(k), locations,name,includePathRad);
			}
		}
	}

	@SuppressWarnings("unchecked")
	private List<Location> listLocationByLocation(Location node,Boolean includePathRad) 
	{
		String hql = "";
		if(includePathRad != null && includePathRad)
		{
			hql = "select childLoc from Location as loc left join loc.locations as childLoc where (childLoc.isActive = 1 and childLoc.isVirtual <> 1 and childLoc.type is not null  and childLoc.type.id <> :surgery and loc.id = :id) ";
			return getDomainFactory().find(hql,new String[]{"id","surgery"}, new Object[]{node.getId(),LocationType.SURGERY.getID()});
		}
		else
		{
			hql = "select childLoc from Location as loc left join loc.locations as childLoc where (childLoc.isActive = 1 and childLoc.isVirtual <> 1 and childLoc.type is not null  and childLoc.type.id not in (:path,:rad,:surgery) and loc.id = :id) ";
			return getDomainFactory().find(hql,new String[]{"id","path","rad","surgery"}, new Object[]{node.getId(),LocationType.PATHOLOGYLABORATORY.getID(),LocationType.CLINICALIMAGINGDEPARTMENT.getID(),LocationType.SURGERY.getID()});
		}
	}

	@SuppressWarnings("unchecked")
	private List<Location> listLocSiteByOrganisation(Integer node,Boolean includePathRad)
	{
		String hql = "";
		if(includePathRad != null && includePathRad)
		{
			hql = "select locSite from Organisation as org left join org.locationSites as locSite where (org.id = :id and locSite.isActive = 1 and locSite.isVirtual <> 1)";
			return getDomainFactory().find(hql,"id",node);
		}
		else
		{
			hql = "select locSite from Organisation as org left join org.locationSites as locSite where (org.id = :id and locSite.isActive = 1 and locSite.isVirtual <> 1 and locSite.type is not null  and locSite.type.id not in (:path,:rad,:surgery)) ";
			return getDomainFactory().find(hql,new String[]{"id","path","rad","surgery"}, new Object[]{node,LocationType.PATHOLOGYLABORATORY.getID(),LocationType.CLINICALIMAGINGDEPARTMENT.getID(),LocationType.SURGERY.getID()});
		}
	}

	@SuppressWarnings("unchecked")
	private List<Integer> listOrganisationByOrganisation(Integer node) {
		String getOrgHql ="select org.id from Organisation as org where (org.parentOrganisation.id = :parentId  and org.isActive = 1 and org.type.id not in (:supp,:gpp,:nhs_pct) and org.type is not null)";
		return getDomainFactory().find(getOrgHql,new String[]{"parentId","supp","gpp","nhs_pct"},new Object[]{node,OrganisationType.SUPPLIER.getID(),OrganisationType.GPP.getID(),OrganisationType.NHS_PCT.getID()});
	}

	//WDEV-10065
	public LocationLiteVoCollection listLocationByOrganisationIncludingPathAndRadTypes(OrganisationRefVo org)
	{
		if (org == null)
			throw new CodingRuntimeException("org cannot be null in method listLocationByOrganisation");
		
		List<Location> locations = new ArrayList<Location>();
		
		buildLocations(org.getID_Organisation(), locations, null, true);
		
		LocationLiteVoCollection locs = LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations);
		return locs.sort(true);
	}

	/**
	* Gets the Active Hospital mapping for a particular location by walking up the Location tree until it hits a Hospital.
	* http://jira/browse/WDEV-11637
	*/

	public String getActiveHospitalCodeForLoc(LocShortMappingsVo loc,TaxonomyType taxonomyType) {
		DomainFactory factory = getDomainFactory();
		Location location = (Location)factory.getDomainObject(loc);
		if (location==null)
			return null;

		while (location!=null&&
				(location.isIsActive()&&location.getType()!=null&&!location.getType().equals(getDomLookup(LocationType.HOSP)))
				)
		{
			location=location.getParentLocation();
		}
		if(location!=null)
			return location.getExtCode(taxonomyType.getID());
		return null;
	}

	/*http://jira/browse/WDEV-11789
	 * (non-Javadoc)
	 * @see ims.admin.domain.OrganisationAndLocation#getPracticeNationalCodeForSurgery(ims.core.resource.place.vo.LocationRefVo)
	 * Returns the National code of the parctice of a surgery or null.
	 */
	public String getPracticeNationalCodeForSurgery(LocationRefVo surgery)
	{
		DomainFactory factory = getDomainFactory();
		if (surgery==null)
			return null;
		
		 LocSite loc=(LocSite)factory.getDomainObject(surgery);//(Organisation.class, id));
		 if (loc!=null&&
				 loc.getType()!=null&&
				 loc.getType().equals(getDomLookup(LocationType.SURGERY))&&
				 loc.getParentOrganisation()!=null)
		 {
			 return loc.getParentOrganisation().getMappingValueOfType(getDomLookup(TaxonomyType.NAT_LOC_CODE));
		 }
		 else 
		 {
			 return null;
		 }
		 
	}

	public LocationLiteVoCollection listActiveEDs() 
	{
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation( listLocations(LocationType.ANE, Boolean.TRUE, null, null, null));
	}
}
