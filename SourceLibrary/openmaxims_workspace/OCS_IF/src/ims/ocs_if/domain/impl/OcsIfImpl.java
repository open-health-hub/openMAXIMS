//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by John MacEnri using IMS Development Environment (version 1.45 build 2257.23328)
// Copyright (C) 1995-2006 IMS MAXIMS plc. All rights reserved.

package ims.ocs_if.domain.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.log4j.Logger;



import ims.admin.vo.DemographicFeedVo;
import ims.admin.vo.EDAttendanceFeedVo;
import ims.admin.vo.InPatientADTFeedVo;
import ims.admin.vo.domain.DemographicFeedVoAssembler;
import ims.admin.vo.domain.EDAttendanceFeedVoAssembler;
import ims.admin.vo.domain.InPatientADTFeedVoAssembler;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.ProviderSystem;
import ims.core.clinical.domain.objects.Service;
import ims.core.clinical.domain.objects.TaxonomyMap;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.vo.GeneralQuestionAnswerVo;
import ims.core.vo.GeneralQuestionAnswerVoCollection;
import ims.core.vo.IfPatientDocumentMessageVo;
import ims.core.vo.ServiceShortVo;
import ims.core.vo.domain.GeneralQuestionAnswerVoAssembler;
import ims.core.vo.domain.IfPatientDocumentMessageVoAssembler;
import ims.core.vo.domain.ServiceShortVoAssembler;
import ims.core.vo.lookups.QueueType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.lookups.LookupInstance;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.IPrintersProvider;
import ims.hl7adtout.domain.objects.DemographicsMessageQueue;
import ims.hl7adtout.domain.objects.EdAttendanceMessageQueue;
import ims.hl7adtout.domain.objects.InPatientADTMessageQueue;
import ims.hl7adtout.domain.objects.PatientDocumentMessageQueue;
import ims.ocrr.configuration.domain.objects.Investigation;
import ims.ocrr.configuration.vo.InvestigationRefVo;
import ims.core.hl7interface.domain.objects.Hl7OutboundRegister;
import ims.ocrr.orderingresults.domain.objects.CategoryQuestionAnswer;
import ims.ocrr.orderingresults.domain.objects.InvestigationQuestionAnswer;
import ims.ocrr.orderingresults.domain.objects.OcsOrderSession;
import ims.ocrr.orderingresults.domain.objects.OrderChangeResponseQueue;
import ims.ocrr.orderingresults.domain.objects.OrderInvestigation;
import ims.ocrr.orderingresults.domain.objects.OrderMessage;
import ims.ocrr.orderingresults.domain.objects.OrderSpecimen;
import ims.ocrr.orderingresults.domain.objects.OrderedInvestigationStatus;
import ims.ocrr.orderingresults.domain.objects.ServiceQuestionAnswer;
import ims.ocrr.orderingresults.vo.OcsOrderSessionRefVo;
import ims.ocrr.orderingresults.vo.OrderInvestigationRefVo;
import ims.ocrr.orderingresults.vo.OrderSpecimenRefVo;
import ims.ocrr.vo.ProviderSystemVo;
import ims.ocrr.vo.domain.ProviderSystemVoAssembler;
import ims.ocrr.vo.lookups.AuthorisationOrderStatus;
import ims.ocrr.vo.lookups.Category;
import ims.ocrr.vo.lookups.InvEventType;
import ims.ocrr.vo.lookups.OrderInvStatus;
import ims.ocs_if.domain.base.impl.BaseOcsIfImpl;
import ims.ocs_if.helper.IQueueHandler;
import ims.ocs_if.vo.Hl7OutboundRegVo;
import ims.ocs_if.vo.IfOrderInvCurrentStatusVo;
import ims.ocs_if.vo.IfOrderInvestigationVo;
import ims.ocs_if.vo.IfOrderMessageVo;
import ims.ocs_if.vo.IfOrderMessageVoCollection;
import ims.ocs_if.vo.IfOutOcsOrderVo;
import ims.ocs_if.vo.OrderChangeResponseVo;
import ims.ocs_if.vo.QueuedEventVo;
import ims.ocs_if.vo.domain.Hl7OutboundRegVoAssembler;
import ims.ocs_if.vo.domain.IfOrderInvCurrentStatusVoAssembler;
import ims.ocs_if.vo.domain.IfOrderInvestigationVoAssembler;
import ims.ocs_if.vo.domain.IfOrderMessageVoAssembler;
import ims.ocs_if.vo.domain.IfOutOcsOrderVoAssembler;
import ims.ocs_if.vo.domain.OrderChangeResponseVoAssembler;
import ims.vo.LookupInstVo;
import ims.vo.interfaces.IHL7OutboundMessageHandler;

public class OcsIfImpl extends BaseOcsIfImpl implements IQueueHandler
{
	private static final long serialVersionUID = 1L;
	private static final Logger			LOG		= Logger.getLogger(OcsIfImpl.class);


	public IfOutOcsOrderVo getOrder(ims.ocrr.orderingresults.vo.OcsOrderSessionRefVo orderRef)
	{
		DomainFactory factory = getDomainFactory();
		return IfOutOcsOrderVoAssembler.create((OcsOrderSession)factory.getDomainObject(OcsOrderSession.class, orderRef.getID_OcsOrderSession()));
	}

	public IfOrderMessageVo saveOrderMessage(ims.ocs_if.vo.IfOrderMessageVo ordMsg) throws StaleObjectException
	{
		if (ordMsg == null)
			throw new RuntimeException("Cannot save null Order Message");
//WDEV-10170 		if (!ordMsg.isValidated())
//WDEV-10170 			throw new CodingRuntimeException("Order Message has not been validated!");
		
		DomainFactory factory = getDomainFactory();
		OrderMessage domMsg = IfOrderMessageVoAssembler.extractOrderMessage(factory, ordMsg);
		factory.save(domMsg);
		return IfOrderMessageVoAssembler.create(domMsg);
	}

	public IfOrderMessageVoCollection saveOrderMessages(ims.ocs_if.vo.IfOrderMessageVoCollection orderMsgs) throws StaleObjectException
	{
		if (orderMsgs == null)
			throw new RuntimeException("Cannot save null Order Messages");
		DomainFactory factory = getDomainFactory();
		
		IfOrderMessageVoCollection returnColl = new IfOrderMessageVoCollection();
		
		for (int i=0; i<orderMsgs.size(); i++)
		{
			IfOrderMessageVo msg = orderMsgs.get(i);
//WDEV-10170 			if (!msg.isValidated())
//WDEV-10170 				throw new CodingRuntimeEction("Order Message instance " + i + " has not been validated!");
			
			// We should check if this order already exists - it may have previously,
			// but couldn't be saved due to errors
			OrderMessage domMsg = OrderMessage.getOrderMessageFromorder_msg_unq1(factory, msg.getPlacerOrdNum(), getDomLookup(msg.getOrderCategory()));
			if (domMsg == null)
			{
				domMsg = IfOrderMessageVoAssembler.extractOrderMessage(factory, msg);
				factory.save(domMsg);
			}
			else /*if (domMsg != null && domMsg.getHL7Message() == null)*/
			{
				domMsg.setHL7Message(msg.getHL7Message());
				factory.save(domMsg);
			}
			returnColl.add(IfOrderMessageVoAssembler.create(domMsg));
		}
		
		return returnColl;
	}

	public IfOrderInvestigationVo createInvestigationStatusRecord(OrderInvestigationRefVo investigation, IfOrderInvCurrentStatusVo statusRecordVo) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		DecimalFormat dftFormatter = new DecimalFormat("G00000000");
		
		OrderInvestigation inv = (OrderInvestigation) factory.getDomainObject(OrderInvestigation.class, investigation.getID_OrderInvestigation());
		OrderedInvestigationStatus stat = IfOrderInvCurrentStatusVoAssembler.extractOrderedInvestigationStatus(factory, statusRecordVo);
		inv.getOrdInvStatusHistory().add(stat);
		inv.setOrdInvCurrentStatus(stat);
		
		// wdev-2998 If the status is SENT
		// we want to mark the investigation as processed
		if (stat.getOrdInvStatus().getId() == OrderInvStatus.SENT.getId())
		{
			inv.setWasProcessed(true);
			
			if (inv.getSpecimen() != null&&!inv.getSpecimen().isEmpty())
				for (Object objSpecimen : inv.getSpecimen()) {
					OrderSpecimen specimen = (OrderSpecimen)objSpecimen;
					specimen.setWasProcessed(true);
					if(inv.getInvestigation()!=null
							&&inv.getInvestigation().getEventType()!=null
							&& InvEventType.TIME_SERIES.equals( inv.getInvestigation().getEventType()))
					{
						specimen.setPlacerOrdNum(dftFormatter.format(inv.getId()));
					}
				}
		}
		factory.save(inv);
		return IfOrderInvestigationVoAssembler.create(inv);
	}
	
	public ims.ocs_if.vo.Hl7OutboundRegVo registerOutbound(ims.ocs_if.vo.Hl7OutboundRegVo regVo) throws ims.domain.exceptions.DomainInterfaceException
	{
		if(!regVo.isValidated())
			throw new DomainInterfaceException("regVo Not Validated");

		DomainFactory factory = getDomainFactory();
		Hl7OutboundRegister existingReg = getExistingReg();
		if (existingReg != null)
		{
			if (!existingReg.getIpAddress().equals(regVo.getIpAddress()) || 
					!existingReg.getServletContext().equals(regVo.getServletContext()))
			{
				throw new DomainInterfaceException("An existing Outbound Thread with IP Address = " + 
						existingReg.getIpAddress() + " and Servlet location = " +  
						existingReg.getServletContext() + " is already registered.");
			}
			else
			{
				existingReg.setLastUpdated(regVo.getLastUpdated().getJavaDate());
				existingReg.setRegDateTime(regVo.getRegDateTime().getJavaDate());
			}
		}
		else
		{
			regVo.setID_Hl7OutboundRegister(null);
			existingReg = Hl7OutboundRegVoAssembler.extractHl7OutboundRegister(factory, regVo);
		}
		try
		{
			factory.save(existingReg);
		}
		catch (StaleObjectException e)
		{
			throw new DomainInterfaceException(e);
		}
			
		regVo.setID_Hl7OutboundRegister(existingReg.getId());
		return regVo;
	}

	public ims.ocs_if.vo.Hl7OutboundRegVo updateOutboundRegistration(ims.ocs_if.vo.Hl7OutboundRegVo regVo) throws ims.domain.exceptions.DomainInterfaceException
	{
		return registerOutbound(regVo);
	}

	public void deregisterOutbound(Hl7OutboundRegVo regVo) throws DomainInterfaceException
	{
		if(!regVo.isValidated())
			throw new DomainInterfaceException("regVo Not Validated");

		DomainFactory factory = getDomainFactory();
		Hl7OutboundRegister existingReg = getExistingReg();
		if (existingReg != null)
		{
			if (!existingReg.getIpAddress().equals(regVo.getIpAddress()) || 
					!existingReg.getServletContext().equals(regVo.getServletContext()))
			{
				throw new DomainInterfaceException("Another Outbound Thread with IP Address = " + 
						existingReg.getIpAddress() + " and Servlet location = " +  
						existingReg.getServletContext() + " is registered. Cannot Deregister.");
			}
			else
			{
				try
				{
					factory.delete(existingReg);
				}
				catch (ForeignKeyViolationException e)
				{
					throw new DomainInterfaceException(e);
				}
			}
		}		
	}

	public OcsOrderSessionRefVo getNextOrder()  
	{
		Integer orderId = getNextOrderId();
		if (orderId == null)
			return null;
		OcsOrderSessionRefVo vo = new OcsOrderSessionRefVo();
		vo.setID_OcsOrderSession(orderId);
		return vo;
	}

	public void updateNextOrder(OcsOrderSessionRefVo lastOrderVo) throws StaleObjectException 
	{
		if (lastOrderVo == null)
			return;
		DomainFactory factory = getDomainFactory();
		
		// wdev-2998
		// We should only update the was Processed value if all specimens
		// and investigations for the order have been dealt with
		// Note that this relies on wdev-3000, i.e. that the isAwaitingCollection value
		// is set to false when a specimen has been collected or cancelled
		String hql = " from OcsOrderSession o join o.specimens spc where spc.isAwaitingCollection is true and o.id = :orderId ";
		List pathLst = factory.find(hql, new String[]{"orderId"}, new Object[]{lastOrderVo.getID_OcsOrderSession()});
		if (pathLst != null && pathLst.size() > 0)
			return;  // There are still some outstanding specimens, so we do not mark the order as processed
			
		hql = " from OcsOrderSession o join o.investigations inv " + 
			" where inv.investigation.investigationIndex.category = :category " +
			" and (inv.wasProcessed is false or inv.wasProcessed is null) "  +
			" and (inv.ordInvCurrentStatus.ordInvStatus = :orderStat or inv.ordInvCurrentStatus.ordInvStatus = :authStat) "+
		    " and o.id = :orderId";
		List radLst = factory.find(hql, new String[]{"orderId", "category", "orderStat", "authStat"},
						new Object[]{lastOrderVo.getID_OcsOrderSession(), getDomLookup(Category.CLINICALIMAGING), getDomLookup(OrderInvStatus.ORDERED), getDomLookup(OrderInvStatus.AWAITING_AUTHORISATION)});
		if (radLst != null && radLst.size() > 0)
			return; // There are still some outstanding investigations, so we do not mark the order as processed
		
		OcsOrderSession domOrder = (OcsOrderSession) factory.getDomainObject(OcsOrderSession.class, lastOrderVo.getID_OcsOrderSession());
		domOrder.setWasProcessed(Boolean.TRUE);
		factory.save(domOrder);
	}
	

	private Hl7OutboundRegister getExistingReg() throws DomainInterfaceException
	{
		DomainFactory factory = getDomainFactory();
		List l = factory.find("from Hl7OutboundRegister");
		if (l.size() == 0) 
			return null;
		if (l.size() > 1)
			throw new DomainInterfaceException("More than one registration record for Outbound Thread found. This is not permitted. Please delete one.");
		
		else return (Hl7OutboundRegister)l.get(0);
	}
	
	/**
	 * getNextOrderId
	 * To get the next Pathology or Radiology Order to process
	 * we need to use a left join and include where sp is null -
	 * as for Radiology orders, there will not be a specimen record.
	 * @return Next Order to process
	 */
	private Integer getNextOrderId()
	{
		DomainFactory factory = getDomainFactory();
		Connection conn = factory.getJdbcConnection();
		
		// wdev-2998 wasProcessed added to investigation level too
		// so once a message has been processed for the investigation
		// in question, this will be set to true.  We will omit these from
		// the query
		String sql=null;
		//http://jira/browse/WDEV-12682 Changed frag from PukkaJ to ICAB so only do the link to patient in ICAB systems
		if(ConfigFlag.GEN.ICAB_ENABLED.getValue())
		{
			sql = "select distinct (id) from ocrr_ocsorder where id in (" +
			" select ORDERDETAI from OCRR_ORDERINVESTIGA oi, ocrr_ocsorder ord, OCRR_INVESTIGATION inv, OCRR_INVESTIGATIONI invidx, CORE_PATIENT patient " +
			" where oi.ORDERDETAI = ord.ID " +
			" and oi.INVESTIGAT = inv.ID " +
			" and ord.PATIENT = patient.ID " +
			" and patient.NAMEUPPERSURNA <> 'DUMMYICABSURNAME' " +
			" and oi.lkp_ordinvcurrordinvstat =? " +
			" and inv.INVESTIGAT = invidx.ID " +
			" and ord.WASPROCESS = 0 " +
			" and (ord.WASDISCARD is null or ord.WASDISCARD = 0) " +
			" and ord.lkp_authorisat=? " +
			" and (invidx.LKP_CATEGORY=? or (invidx.LKP_CATEGORY=? and inv.lkp_eventtype=?))" +
			" and (oi.WASPROCESS = 0 or oi.WASPROCESS is null) " +
			" union " +
			" select C_ORD from OCRR_ORDERSPECIMEN os, ocrr_ocsorder ord" +
			" where os.C_ORD = ord.ID " +
			" and ord.WASPROCESS = 0 " +
			" and (os.WASPROCESS is null or os.WASPROCESS = 0)" +
			" and (ord.WASDISCARD is null or ord.WASDISCARD = 0) " +
			" and (os.COLLDATETI is not null or os.ispatientc=1 or ord.sendnumber=1) " +
			" and ord.lkp_authorisat=? ) order by id ";
		}
		else
		{
		sql = "select distinct (id) from ocrr_ocsorder where id in (" +
			" select ORDERDETAI from OCRR_ORDERINVESTIGA oi, ocrr_ocsorder ord, OCRR_INVESTIGATION inv, OCRR_INVESTIGATIONI invidx " +
			" where oi.ORDERDETAI = ord.ID " +
			" and oi.INVESTIGAT = inv.ID " +
			" and oi.lkp_ordinvcurrordinvstat =? " +
			" and inv.INVESTIGAT = invidx.ID " +
			" and ord.WASPROCESS = 0 " +
			" and (ord.WASDISCARD is null or ord.WASDISCARD = 0) " +
			" and ord.lkp_authorisat=? " +
			" and (invidx.LKP_CATEGORY=? or (invidx.LKP_CATEGORY=? and inv.lkp_eventtype=?))" +
			" and (oi.WASPROCESS = 0 or oi.WASPROCESS is null) " +
			" union " +
			" select C_ORD from OCRR_ORDERSPECIMEN os, ocrr_ocsorder ord" +
			" where os.C_ORD = ord.ID " +
			" and ord.WASPROCESS = 0 " +
			" and (os.WASPROCESS is null or os.WASPROCESS = 0)" +
			" and (ord.WASDISCARD is null or ord.WASDISCARD = 0) " +
			" and (os.COLLDATETI is not null or os.ispatientc=1 or ord.sendnumber=1) " +
			" and ord.lkp_authorisat=? ) order by id ";
		}
		//List l = factory.find(" select ord from OcsOrder ord left join ord.specimens as sp where ord.wasProcessed = false and (ord.wasDiscarded = false or ord.wasDiscarded is null) and ord.authorisationOrderStatus.id = :authorised and ((sp.collDateTimePlacer is not null or sp.isPatientCollect = true) or sp is null ) order by ord.id", new String[]{"authorised"}, new Object[]{new Integer(AuthorisationOrderStatus.AUTHORISED.getId())}, 1);
		//List l = factory.find(" select ord from OcsOrder ord left join ord.specimens as sp where ord.wasProcessed = false and ord.authorisationOrderStatus = :authorised and ((sp.collDateTimePlacer is not null or sp.isPatientCollect = true) or sp is null ) order by ord.id", new String[]{"authorised"}, new Object[]{getDomLookup(AuthorisationOrderStatus.AUTHORISED)}, 1);		
//		if (l.size() == 0) 
//			return null;
//		
//		OcsOrder ord = (OcsOrder)l.get(0);
		//return ord.getId();
		
		try 
		{
			Integer ret = null;
			PreparedStatement ps = conn.prepareStatement(sql);
			ps.setInt(1, OrderInvStatus.ORDERED.getId());// AuthorisationOrderStatus.AUTHORISED.getId());
			ps.setInt(2, AuthorisationOrderStatus.AUTHORISED.getId());
			ps.setInt(3, Category.CLINICALIMAGING.getId());
			
			ps.setInt(4, Category.PATHOLOGY.getId());
			ps.setInt(5, InvEventType.TIME_SERIES.getId());
			
			ps.setInt(6, AuthorisationOrderStatus.AUTHORISED.getId());
			ResultSet rs = ps.executeQuery();
			if (rs.next())
			{
				ret = Integer.valueOf(rs.getInt(1));
			}
			rs.close();
			ps.close();
			conn.close();
			return ret;
		} 
		catch (SQLException e) 
		{
			//WDEV-7715  Don't throw an exception just log and return NULL
			//throw new DomainRuntimeException(e);
			LOG.warn("SQL Exception getting next order", e);
			return null;
		}		
	}


	public ProviderSystemVo getProviderSystem(String sendingApplication)
	{
		if (sendingApplication == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		List lst = factory.find(" from ProviderSystem ps where ps.hl7Application = '" + sendingApplication + "'");
		if (lst == null || lst.size() == 0)
			return null;
		
		return ProviderSystemVoAssembler.create((ProviderSystem) lst.get(0));
			
	}
	
	public GeneralQuestionAnswerVoCollection getPathologyQuestions(OrderSpecimenRefVo specVo, ims.ocrr.orderingresults.vo.OrderInvestigationRefVo investigation,Boolean includeShared)
	{
		if (specVo == null)
			throw new DomainRuntimeException("Specimen must be supplied in order to retrieve questions");

		DomainFactory factory = getDomainFactory();
		
		List returnedList = new ArrayList();

		OrderSpecimen domSpecimen = (OrderSpecimen) factory.getDomainObject(OrderSpecimen.class, specVo.getID_OrderSpecimen());
		
		OrderInvestigation domInvestigation = (OrderInvestigation) factory.getDomainObject(OrderInvestigation.class, investigation.getID_OrderInvestigation());
		// Category Questions
		String hql = " select o.clinicalInfo.categoryQuestionAnswers from OcsOrderSession o " +
		 	" join o.specimens spc where spc.id = :specimenId";
		
		List categoryList = factory.find(hql, new String[]{"specimenId"}, new Object[]{specVo.getID_OrderSpecimen()});

		// We now have the CategoryQuestionAnswerCollection, from here,
		// get Category, Service and Investigation questions?
		Iterator catIt = categoryList.iterator();
		while (catIt.hasNext())
		{
			CategoryQuestionAnswer domCat = (CategoryQuestionAnswer) catIt.next();
			
			// Category
			if (domCat.getCategory().getId() == Category.PATHOLOGY.getId()&&includeShared)
				returnedList.addAll(domCat.getCategoryQuestionAnswers());
			
			// Service Questions
			String serviceHql = " select svc from CategoryQuestionAnswer cat " +
					" join cat.serviceQuestionAnswers as svc " + 
					" where cat.id = :categoryId and svc.service.id = :serviceId";
			List svcLst = factory.find(serviceHql, new String[]{"categoryId", "serviceId"}, new Object[]{domCat.getId(), domSpecimen.getDiscipline().getId()});
			Iterator svcIt = svcLst.iterator();
			while (svcIt.hasNext())
			{
				ServiceQuestionAnswer svc = (ServiceQuestionAnswer) svcIt.next();
				if(includeShared)
				{
					returnedList.addAll(svc.getServiceQuestionAnswers());
				}
				List invList = svc.getInvestigationQuestionAnswers();
				Iterator invIt = invList.iterator();
				while (invIt.hasNext())
				{
					InvestigationQuestionAnswer inv = (InvestigationQuestionAnswer) invIt.next();
					Investigation domInv = inv.getInvestigation();
					if (domInvestigation == null || domInvestigation.getInvestigation().getId().equals(domInv.getId()))
							returnedList.addAll(inv.getInvestigationQuestionAnswers());
					
				}
			}
		}
		
		GeneralQuestionAnswerVoCollection returnColl = new GeneralQuestionAnswerVoCollection();
		GeneralQuestionAnswerVoCollection questionColl =  GeneralQuestionAnswerVoAssembler.createGeneralQuestionAnswerVoCollectionFromGeneralQuestionAnswer(returnedList);
		// wdev-3018 Remove all non-questions and non-answered questions
		for (int i=0; i<questionColl.size(); i++)
		{
			GeneralQuestionAnswerVo vo = questionColl.get(i);
			if (vo.getQuestion().getIsQuestionIsNotNull() && vo.getQuestion().getIsQuestion().booleanValue() == true)
				returnColl.add(vo);
				
		}
		return returnColl;
	}
	
	
	public GeneralQuestionAnswerVoCollection getRadiologyQuestions(OrderInvestigationRefVo invVo)
	{
		if (invVo == null)
			throw new DomainRuntimeException("Investigation must be supplied in order to retrieve questions");
		
		DomainFactory factory = getDomainFactory();
		
		List returnedList = new ArrayList();

		OrderInvestigation domInv = (OrderInvestigation) factory.getDomainObject(OrderInvestigation.class, invVo.getID_OrderInvestigation());
		
		// Category Questions
		String hql = " select o.clinicalInfo.categoryQuestionAnswers from OcsOrderSession o " +
		 	" join o.investigations inv where inv.id = :investigationId";
		
		List categoryList = factory.find(hql, new String[]{"investigationId"}, new Object[]{invVo.getID_OrderInvestigation()});

		// We now have the CategoryQuestionAnswerCollection, from here,
		// get Category, Service and Investigation questions?
		Iterator catIt = categoryList.iterator();
		while (catIt.hasNext())
		{
			CategoryQuestionAnswer domCat = (CategoryQuestionAnswer) catIt.next();
			
			// Category
			if (domCat.getCategory().getId() == Category.CLINICALIMAGING.getId())
				returnedList.addAll(domCat.getCategoryQuestionAnswers());
			
			// Service Questions
			String serviceHql = " select svc from CategoryQuestionAnswer cat " +
					" join cat.serviceQuestionAnswers as svc " + 
					" where cat.id = :categoryId and svc.service.id = :serviceId";
			List svcLst = factory.find(serviceHql, new String[]{"categoryId", "serviceId"}, new Object[]{domCat.getId(), domInv.getInvestigation().getProviderService().getLocationService().getService().getId()});
			Iterator svcIt = svcLst.iterator();
			while (svcIt.hasNext())
			{
				ServiceQuestionAnswer svc = (ServiceQuestionAnswer) svcIt.next();
				returnedList.addAll(svc.getServiceQuestionAnswers());
				
				List invList = svc.getInvestigationQuestionAnswers();
				Iterator invIt = invList.iterator();
				while (invIt.hasNext())
				{
					InvestigationQuestionAnswer inv = (InvestigationQuestionAnswer) invIt.next();
					if (inv.getInvestigation().getId().equals(domInv.getInvestigation().getId()))
						returnedList.addAll(inv.getInvestigationQuestionAnswers());
					
				}
			}
		}
		
		GeneralQuestionAnswerVoCollection returnColl = new GeneralQuestionAnswerVoCollection();
		GeneralQuestionAnswerVoCollection questionColl =  GeneralQuestionAnswerVoAssembler.createGeneralQuestionAnswerVoCollectionFromGeneralQuestionAnswer(returnedList);
		// wdev-3018 Remove all non-questions and non-answered questions
		for (int i=0; i<questionColl.size(); i++)
		{
			GeneralQuestionAnswerVo vo = questionColl.get(i);
			if (vo.getQuestion().getIsQuestionIsNotNull() && vo.getQuestion().getIsQuestion().booleanValue() == true)
				returnColl.add(vo);
				
		}
		return returnColl;

	}
	
	public ProviderSystemVo getProviderSystem(InvestigationRefVo invVo)
	{
		if (invVo == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		Investigation domInv = (Investigation)factory.getDomainObject(Investigation.class, invVo.getID_Investigation());
		return ProviderSystemVoAssembler.create(domInv.getProviderService().getProviderSystem());
	}

	public ServiceShortVo getService(InvestigationRefVo invVo)
	{
		if (invVo == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		Investigation domInv = (Investigation)factory.getDomainObject(Investigation.class, invVo.getID_Investigation());
		return ServiceShortVoAssembler.create(domInv.getProviderService().getLocationService().getService());
	}

	public String getServiceMapping(ServiceRefVo service, LookupInstVo taxType)
	{
		if (service == null || taxType == null)
			return null;

		DomainFactory factory = getDomainFactory();
		Service domSvc = (Service)factory.getDomainObject(Service.class, service.getID_Service());
		LookupInstance domTax = getDomLookup(taxType);
		
		for (int i = 0; i < domSvc.getTaxonomyMap().size(); i++)
		{
			TaxonomyMap map = (TaxonomyMap)domSvc.getTaxonomyMap().get(i);
			if (map.getTaxonomyName().equals(domTax))
				return map.getTaxonomyCode();
		}
		return null;
	}

	public void saveOrderAsDiscarded(OcsOrderSessionRefVo order) throws StaleObjectException 
	{
		DomainFactory factory = getDomainFactory();
		OcsOrderSession domOrder = (OcsOrderSession) factory.getDomainObject(OcsOrderSession.class, order.getBoId().intValue());
		domOrder.setWasDiscarded(Boolean.TRUE);
		factory.save(domOrder);
	}

// http://jira/browse/WDEV-11629
	public IHL7OutboundMessageHandler getEvent(QueuedEventVo event)
	{
		if (event!=null)
		{
			DomainFactory factory = getDomainFactory();
			if(event.getQueueTypeIsNotNull()&&event.getQueueType().equals(QueueType.ORDERCHANGERESPONSE))
			{
				return OrderChangeResponseVoAssembler.create((OrderChangeResponseQueue)factory.getDomainObject(OrderChangeResponseQueue.class, event.getID()));
			}
			else if(event.getQueueTypeIsNotNull()&&event.getQueueType().equals(QueueType.PATIENTDOCUMENT))
			{
				return IfPatientDocumentMessageVoAssembler.create((PatientDocumentMessageQueue)factory.getDomainObject(PatientDocumentMessageQueue.class, event.getID()));
			}
			else if(event.getQueueTypeIsNotNull()&&event.getQueueType().equals(QueueType.DEMOGRAPHICFEED))
			{
				return DemographicFeedVoAssembler.create((DemographicsMessageQueue)factory.getDomainObject(DemographicsMessageQueue.class, event.getID()));
			}
			else if(event.getQueueTypeIsNotNull()&&event.getQueueType().equals(QueueType.EDATTENDANCE))
			{
				return  EDAttendanceFeedVoAssembler.create((EdAttendanceMessageQueue)factory.getDomainObject(EdAttendanceMessageQueue.class, event.getID()));
			}
			else if(event.getQueueTypeIsNotNull()&&event.getQueueType().equals(QueueType.INPATIENTADT))
			{
				return  InPatientADTFeedVoAssembler.create((InPatientADTMessageQueue)factory.getDomainObject(InPatientADTMessageQueue.class, event.getID()));
			}

		}
		return null;
	}
	

	public QueuedEventVo getNextQueuedEvent()
	{
		QueuedEventVo event = null;
		try {
			DomainFactory factory = getDomainFactory();

			StringBuffer query = new StringBuffer();
			List <?> triggers = factory.find("select distinct l2_1.id from OutboundTriggers as o1_1 left join o1_1.queueType as l1_1 left join l1_1.instance as l2_1");
			
			//http://jira/browse/WDEV-13985 change conditions
			if(triggers!=null&&!triggers.isEmpty())
			{
				if (triggers.contains(QueueType.DEMOGRAPHICFEED.getID()))
				{
					query.append("select id,lkp_queuetype,sys_creation_datetime as DT from adto_demographicsmq where (WASPROCESS is null or WASPROCESS=0) and (WASDISCARD is null or WASDISCARD=0)");
				}
				if (triggers.contains(QueueType.ORDERCHANGERESPONSE.getID()))
				{
					if (query.length()!=0)
					{
						query.append(" union ");
					}
					query.append("select id,lkp_queuetype,sys_creation_datetime as DT from ocrr_orderchangeres where (WASPROCESS is null or WASPROCESS=0) and (WASDISCARD is null or WASDISCARD=0)");
				}
				if(triggers.contains(QueueType.PATIENTDOCUMENT.getID()))
				{
					if (query.length()!=0)
					{
						query.append(" union ");
					}
					query.append("select id,lkp_queuetype,sys_creation_datetime as DT from adto_patientdocumen where (WASPROCESS is null or WASPROCESS=0) and (WASDISCARD is null or WASDISCARD=0)");
				}	
				if(triggers.contains(QueueType.EDATTENDANCE.getID()))
				{
					if (query.length()!=0)
					{
						query.append(" union ");
					}
					query.append("select id,lkp_queuetype,sys_creation_datetime as DT from adto_edattendanceme where (WASPROCESS is null or WASPROCESS=0) and (WASDISCARD is null or WASDISCARD=0)");
				}
				if(triggers.contains(QueueType.INPATIENTADT.getID()))
				{
					if (query.length()!=0)
					{
						query.append(" union ");
					}
					query.append("select id,lkp_queuetype,sys_creation_datetime as DT from adto_inpatientadtme where (WASPROCESS is null or WASPROCESS=0) and (WASDISCARD is null or WASDISCARD=0)");
				}	

			}	
			if(ConfigFlag.HL7.EXTENDED_HL7_PROCESSING.getValue().equals("CARE_UK"))
			{
				if (query.length()!=0)
				{
					query.append(" union ");
				}
				if (ConfigFlag.GEN.ICAB_ENABLED.getValue())
					{
//					ExternalSystemEventTypes.NEWORDER.getId() -1518
					query.append("select ext.id,null,ext.sys_creation_datetime as DT from schl_externalsy as ext ");
					query.append("left join ocrr_orderinvestiga inv on ext.investigat=inv.id ");
					query.append("left join ocrr_ocsorder orde on inv.orderdetai=orde.id ");
					query.append("left join core_patient pat on orde.patient=pat.id ");
					query.append("where   pat.nameuppersurna<> 'DUMMYICABSURNAME' and pat.nameuppersurna is not null and "); 
					query.append("ext.WASPROCESS is null or ext.WASPROCESS=0 and ext.lkp_eventtype <>-1518");
				}
				else
				{
					query.append("select id,null,sys_creation_datetime as DT from schl_externalsy where (WASPROCESS is null or WASPROCESS=0) and lkp_eventtype <>-1518");
				}
			}
			
			//http://jira/browse/WDEV-13985 change order by
			query.append(" order by DT");	

			Connection conn = factory.getJdbcConnection();
			PreparedStatement ps = conn.prepareStatement(query.toString());
			ResultSet rs = ps.executeQuery();
			if (rs.next())
			{
				event = new QueuedEventVo();
				event.setID(rs.getInt(1));
				if(rs.getObject(2)!=null)
				{
					event.setQueueType((QueueType)getLookupService().getLookupInstance(QueueType.class, rs.getInt(2)));
				}
			}
			rs.close();
			ps.close();
			conn.close();
		}
		catch (SQLException e)
		{
			LOG.error("Exception ignored getting next event", e);
		}
		return event;
	}



	public IHL7OutboundMessageHandler saveMessage(IHL7OutboundMessageHandler iEvent) throws StaleObjectException
	{
		if (iEvent == null)
			throw new RuntimeException("Cannot save null Event");
		
		DomainFactory factory = getDomainFactory();

		if(iEvent instanceof OrderChangeResponseVo)
		{
			OrderChangeResponseVo event = (OrderChangeResponseVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			OrderChangeResponseQueue domEvent=OrderChangeResponseVoAssembler.extractOrderChangeResponseQueue(factory, event);
			factory.save(domEvent);
			return OrderChangeResponseVoAssembler.create(domEvent);
		}
		else if(iEvent instanceof IfPatientDocumentMessageVo)
		{
			IfPatientDocumentMessageVo event = (IfPatientDocumentMessageVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			PatientDocumentMessageQueue domEvent=IfPatientDocumentMessageVoAssembler.extractPatientDocumentMessageQueue(factory, event);
			factory.save(domEvent);
			return IfPatientDocumentMessageVoAssembler.create(domEvent);
		}
		else if(iEvent instanceof DemographicFeedVo)
		{
			DemographicFeedVo event = (DemographicFeedVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			DemographicsMessageQueue domEvent=DemographicFeedVoAssembler
				.extractDemographicsMessageQueue(factory, event);
			factory.save(domEvent);
			return DemographicFeedVoAssembler.create(domEvent);
		}
		else if(iEvent instanceof EDAttendanceFeedVo)
		{
			EDAttendanceFeedVo event = (EDAttendanceFeedVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			EdAttendanceMessageQueue  domEvent=EDAttendanceFeedVoAssembler
				.extractEdAttendanceMessageQueue(factory, event);
			factory.save(domEvent);
			return EDAttendanceFeedVoAssembler.create(domEvent);
		}
		else if(iEvent instanceof InPatientADTFeedVo)
		{
			InPatientADTFeedVo event = (InPatientADTFeedVo)iEvent;
			String[] errors = event.validate();
			if (errors != null)
				throw new RuntimeException("Validation errors - " + errors);
			if (!event.isValidated())
				throw new CodingRuntimeException("Event has not been validated!");
			InPatientADTMessageQueue  domEvent=InPatientADTFeedVoAssembler
				.extractInPatientADTMessageQueue(factory, event);
			factory.save(domEvent);
			return InPatientADTFeedVoAssembler.create(domEvent);
		}
		else 
		{
			throw new RuntimeException("Cannot determine event type for saving");
		}
	}

	public void processSpecimenWithoutInvestigations(OrderSpecimenRefVo specimen)
	{
		if(specimen==null)
			return;
		LOG.error("processSpecimenWithoutInvestigations"+specimen.getID_OrderSpecimen());

		DomainFactory factory = getDomainFactory();
		OrderSpecimen orderSpecimen =  (OrderSpecimen)factory.getDomainObject(specimen);
		if(orderSpecimen.getInvestigations()==null||orderSpecimen.getInvestigations().size()==0)
		{
			orderSpecimen.setWasProcessed(true);
			try
			{
				factory.save(orderSpecimen);
			}catch (StaleObjectException e)
			{
				LOG.error("StaleObjectException processSpecimenWithoutInvestigations "+specimen.getID_OrderSpecimen());
			}
			
		}
	}

	
}
