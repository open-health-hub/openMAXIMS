//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Marius Mihalec using IMS Development Environment (version 1.45 build 2438.24274)
// Copyright (C) 1995-2006 IMS MAXIMS plc. All rights reserved.

package ims.core.forms.charting;

import ims.configuration.gen.ConfigFlag;
import ims.core.vo.ChartAnalyteCommentsVo;
import ims.core.vo.ChartInvestigationCommentsVo;
import ims.core.vo.ChartValueCommentVo;
import ims.core.vo.ChartValueCommentVoCollection;
import ims.core.vo.enums.ChartingEvents;
import ims.core.vo.lookups.LineType;
import ims.framework.FormName;
import ims.framework.controls.DynamicGrid;
import ims.framework.controls.DynamicGridCell;
import ims.framework.controls.DynamicGridCellItem;
import ims.framework.controls.DynamicGridCellItemCollection;
import ims.framework.controls.DynamicGridColumn;
import ims.framework.controls.DynamicGridColumnCollection;
import ims.framework.controls.DynamicGridRow;
import ims.framework.controls.GraphingControl;
import ims.framework.enumerations.Alignment;
import ims.framework.enumerations.DialogResult;
import ims.framework.enumerations.DynamicCellType;
import ims.framework.enumerations.SortOrder;
import ims.framework.exceptions.PresentationLogicException;
import ims.framework.utils.Color;
import ims.framework.utils.DateTime;
import ims.framework.utils.graphing.GraphicLineStyle;
import ims.framework.utils.graphing.GraphingCustomOneValue;
import ims.framework.utils.graphing.GraphingGroup;
import ims.framework.utils.graphing.GraphingHighlight;
import ims.framework.utils.graphing.GraphingPoint;
import ims.ocrr.vo.lookups.SpecimenType;
import ims.vo.LookupInstVo;
import ims.vo.interfaces.IChartValue;
import ims.vo.interfaces.IChartValueAnalyte;
import ims.vo.interfaces.IChartValueComment;
import ims.vo.interfaces.IChartValueGroup;
import ims.vo.interfaces.IChartValueInvestigation;
import ims.vo.interfaces.IChartValueSet;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;

public class Logic extends BaseLogic
{		 
	public class InvestigationsComparator implements Comparator<IChartValueInvestigation>
	{
		public int compare(IChartValueInvestigation o1, IChartValueInvestigation o2)
		{
			if (o1.getIChartValueDisplayDate() != null && o2.getIChartValueDisplayDate() != null)
				return o1.getIChartValueDisplayDate().compareTo(o2.getIChartValueDisplayDate());
			
			if (o1.getIChartValueDisplayDate() != null)
				return 1;
			
			if (o2.getIChartValueDisplayDate() != null)
				return -1;
			
			return 0;
		}

	}

	public class AnalyteCommentsComparator implements Comparator<IChartValueAnalyte>
	{
		public int compare(IChartValueAnalyte arg0, IChartValueAnalyte arg1)
		{
			if (arg0.getIChartAnalyteDate() != null && arg1.getIChartAnalyteDate() != null)
				return arg0.getIChartAnalyteDate().compareTo(arg1.getIChartAnalyteDate());

			if (arg0.getIChartAnalyteDate() != null)
				return 1;
			
			if (arg1.getIChartAnalyteDate() != null)
				return -1;
			
			return 0;
		}

	}

	private static final long serialVersionUID = 1L;
	private HashMap<IChartValueGroup, GraphingGroup> graphingGroups;
	
	private static final int MAX_NO_GROUPS_SUPPORTED = 12;
	private static final int GRID_HEADER_HEIGHT = 100;
	private static final Integer COLUMN_IMAGE = new Integer(0);
	private static final Integer COLUMN_NAME = new Integer(1);
	private static final Integer COLUMN_UNITS = new Integer(2);
	private static final Integer COLUMN_REF_RANGE = new Integer(3);
	private static final int COLUMN_IMAGE_WIDTH = 25;
	private static final int COLUMN_NAME_WIDTH = 200;
	private static final int COLUMN_UNITS_WIDTH = 70;
	private static final int COLUMN_REF_RANGE_WIDTH = 100;
	private static final int COLUMN_VALUE_WIDTH = 110;
	private static final Color CELL_ABNORMAL_TEXTCOLOR = Color.Red;
	private static final Color CELL_ABNORMAL_BACKCOLOR = Color.Cornsilk;
	private static final String RECEIVED_DATE_STRING = "(R)";// 	WDEV-16395
	private static final String COLLECTED_DATE_STRING = "(C)";// 	WDEV-16395
	
	private static final int CHARS_TO_TRIM_ST_RESULTS = 8;
	
	private static final Integer	VIEW_GRAPHICAL		= Integer.valueOf(0);
	private static final Integer	VIEW_TABULAR		= Integer.valueOf(1);	
	
	private static final Integer	ENABLE_CLOSE		= Integer.valueOf(1);
	
	
	//--------------------------------------------------------------------------------------------------------------------------------------------
	// Auxiliary Classes - Column Identifiers for dynamically created columns (value & comments columns)
	//--------------------------------------------------------------------------------------------------------------------------------------------
	
	/**
	 * WDEV-12627
	 * Class used for value columns identifiers - which are created dynamically
	 * @author Josan George Cristian
	 */
 	private class ColumnIdentifierValue implements Comparable<ColumnIdentifierValue>//WDEV-12627, WDEV-12628
	{
		private DateTime dateTime;
		private boolean timeSupplied;
		private ArrayList<Integer> groupIndex;
		private LookupInstVo labSpecimen;
		private SpecimenType orderSpecimen;
		private boolean isReceivedDateTime;

		public ColumnIdentifierValue(DateTime dateTime, Boolean timeSupplied, Integer analyte, LookupInstVo labSpecimen, SpecimenType orderSpecimen, Boolean isReceivedDate)
		{
			this.dateTime = dateTime;
			
			this.timeSupplied = Boolean.TRUE.equals(timeSupplied);
			
			if(this.groupIndex == null)
			{
				this.groupIndex = new ArrayList<Integer>();
			}
			
			this.groupIndex.add(analyte);

			this.labSpecimen = labSpecimen;
			this.orderSpecimen = orderSpecimen;
			this.isReceivedDateTime = Boolean.TRUE.equals(isReceivedDate);
		}

		public String toString()
		{
			StringBuilder displayString = new StringBuilder();
			
			if (timeSupplied == true)
				displayString.append(dateTime.toString());
			else
				displayString.append(dateTime.getDate().toString());
			
			displayString.append(this.isReceivedDateTime == true ? RECEIVED_DATE_STRING : COLLECTED_DATE_STRING);// 	WDEV-16395
			
			if (labSpecimen != null)
				displayString.append("\n").append(this.labSpecimen.getText());
			else if (orderSpecimen != null)
				displayString.append("\n").append(this.orderSpecimen.getText());
			
			return displayString.toString();
		}
		

		public DateTime getDate()
		{
			return this.dateTime;
		}
		
		
		public LookupInstVo getLabSpecimen()
		{
			return this.labSpecimen;
		}
		
		public SpecimenType getOrderSpecimen()
		{
			return this.orderSpecimen;
		}
		
		public boolean needsMerging(DateTime date, boolean timeSupplied, LookupInstVo labSpecimen, SpecimenType orderSpecimen, Integer analyte)
		{
			if (this.dateTime.equals(date) && this.timeSupplied == timeSupplied)
			{
				if (this.labSpecimen != null && labSpecimen != null && this.labSpecimen.getID() == labSpecimen.getID())
					return !this.groupIndex.contains(analyte);
					
				if (this.labSpecimen == null && labSpecimen == null && this.orderSpecimen != null && orderSpecimen != null && this.orderSpecimen.getID() == orderSpecimen.getID())
					return !this.groupIndex.contains(analyte);
				
				if (this.labSpecimen == null && labSpecimen == null && this.orderSpecimen == null && orderSpecimen == null)
					return !this.groupIndex.contains(analyte);
				
				return false;
			}
			
			return false;
		}

		public int compareTo(ColumnIdentifierValue o)
		{
			return this.dateTime.compareTo(o.dateTime);
		}
		
		public void merge(DateTime date, Integer analyte)
		{
			this.groupIndex.add(analyte);
		}

	}

	public class ColumnIdentifierValueComparator implements	Comparator<ColumnIdentifierValue>//WDEV-12627, WDEV-12628
	{
		int order = 1;
		
		public ColumnIdentifierValueComparator()
		{
			
		}
		public ColumnIdentifierValueComparator(SortOrder order)
		{
			if(SortOrder.DESCENDING.equals(order))
			{
				this.order = -1;
			}
		}
		public int compare(ColumnIdentifierValue arg0,	ColumnIdentifierValue arg1)
		{
			return order * arg0.compareTo(arg1);
		}
	}
	
	protected void onFormOpen() throws PresentationLogicException 
	{
		form.getLocalContext().setDateOrder(SortOrder.DESCENDING);	//	WDEV-12614
		
		initializeGrid();
		switchToGraphicalView();
	}
	protected void onFormDialogClosed(FormName formName, DialogResult result) throws PresentationLogicException 
	{
		if(formName.equals(form.getForms().Core.ChartingGroupSelection) && result.equals(DialogResult.OK))
			refresh();
	}


	public ChartingEvents getCustomEvent()
	{
		return form.getLocalContext().getCustomEvent();
	}
	
	public void clearCustomEvent()
	{
		form.getLocalContext().setCustomEvent(null);
	}

	protected void onDyngrdCellValueChanged(DynamicGridCell cell)
	{
		DynamicGridCellItemCollection items = cell.getItems();
		
		if (items != null && items.size() > 0)
		{
			for (int i = 0; i < items.size(); i++)
			{
				DynamicGridCellItem item = items.get(i);
				
				if (ENABLE_CLOSE.equals(item.getIdentifier()))
				{
					if (item.isChecked())
						form.getLocalContext().setCustomEvent(ChartingEvents.ENABLE_CLOSE);
					else
						form.getLocalContext().setCustomEvent(ChartingEvents.DISABLE_CLOSE);
					
					form.fireCustomControlValueChanged();
				}
			}
		}
	}

	
	public void initialize(Boolean usedInDialog)
	{
		form.getLocalContext().setUsedInDialog(Boolean.TRUE.equals(usedInDialog));
	}

	/**
	* Sets the value
	*/
	public void setValue(IChartValueSet value)
	{
		if(!validate(value))
			return;
		
		sortAfterGroups(value);	//	WDEV-12548
		
		populate(value);
		
		
		if (Boolean.TRUE.equals(ConfigFlag.UI.DISPLAY_INVESTIGATION_COMMENTS_ON_CUMULATE_RESULTS.getValue()))
		{
			if (VIEW_TABULAR.equals(form.getLocalContext().getViewingStyle()))
			{
				//WDEV-15801 - starts here
				IChartValueAnalyte[] analytesComments = getAnalytesComments(value);
				IChartValueInvestigation[] investigationComments = getInvestigationComments(value);

				if ((analytesComments != null && analytesComments.length > 0) || (investigationComments != null && investigationComments.length > 0))
				{
					// Add two empty rows
					form.dyngrd().getRows().newRow();
					form.dyngrd().getRows().newRow();
					
					populateAnalytesComments(analytesComments);
	
					populateInvestigationComments(investigationComments);
				}
				//WDEV-15801 - ends here

				// Add check box for enabling the "Close" button
				if (Boolean.TRUE.equals(form.getLocalContext().getUsedInDialog()))
				{
					createCloseCombobox();
				}
			}

			form.getLocalContext().setCustomEvent(ChartingEvents.DISABLE_CLOSE);

			form.fireCustomControlValueChanged();
		}
	}
	

	private void createCloseCombobox()
	{
		// Add two empty rows
		form.dyngrd().getRows().newRow();

		DynamicGridRow row = form.dyngrd().getRows().newRow();
		row.setReadOnly(false);
		row.setSelectable(false);
		
		DynamicGridCell enableCloseCell = row.getCells().newCell(form.dyngrd().getColumns().getByIdentifier(COLUMN_NAME), DynamicCellType.MULTISELECT);
		enableCloseCell.setWidth(100);
		
		enableCloseCell.setAutoPostBack(true);
		enableCloseCell.setReadOnly(false);
		
		DynamicGridCellItem item = enableCloseCell.getItems().newItem("Enable Close", "Enable Close");
		item.setIdentifier(ENABLE_CLOSE);
	}
	
	private void populateAnalytesComments(IChartValueAnalyte[] analyteComments)
	{
		if (analyteComments == null || analyteComments.length == 0)
			return;
		
		// Iterate analytes and add comments
		for (int i = 0; i < analyteComments.length; i++)
		{
			addAnalyteComments(analyteComments[i]);
		}
	}

	private void populateInvestigationComments(IChartValueInvestigation[] investigationComments)
	{
		if (investigationComments == null || investigationComments.length == 0)
			return;
		
		// Iterate investigations and add comments
		for (int i = 0; i < investigationComments.length; i++)
		{
			addInvestigationComments(investigationComments[i]);
		}
	}
	
	private void addAnalyteComments(IChartValueAnalyte analytesComments)
	{
		if (analytesComments == null || analytesComments.getIChartAnalyteComments() == null || analytesComments.getIChartAnalyteComments().length == 0)
			return;

		DynamicGridRow commentsRow = form.dyngrd().getRows().newRow();
		
		DynamicGridCell commentCell = commentsRow.getCells().newCell(form.dyngrd().getColumns().getByIdentifier(COLUMN_NAME), DynamicCellType.HTMLVIEW);
		commentCell.setWidth(700);
		
		StringBuilder comments = new StringBuilder();
		
		
		comments.append("<b>").append(analytesComments.getIChartAnalyteDate() != null ? analytesComments.getIChartAnalyteDate() : "<Unknown date>");
		comments.append(" - ").append(analytesComments.getIChartAnalyteDisplayFlag()).append(" - ").append(analytesComments.getIChartAnalyteSpecimenName());
		comments.append("</b><br>");
		
		comments.append("<b>Analyte:</b> ").append(analytesComments.getIChartAnalyteName()).append("<br>");
		
		for (int i = 0; i < analytesComments.getIChartAnalyteComments().length; i++)
		{
			IChartValueComment analyteComment = analytesComments.getIChartAnalyteComments()[i];
			
			if (analyteComment != null)
			{
				if (analyteComment.getIChartValueCommentText() != null)
				{
					comments.append("<br>").append(analyteComment.getIChartValueCommentText().replaceAll("\n", "<br>")).append("<br>");
				}
				else
				{
					comments.append("<br>");
				}
			}
		}
		
		comments.append("<br><br>");
		
		commentCell.setValue(comments.toString());
		commentCell.setReadOnly(true);
	}

	private void addInvestigationComments(IChartValueInvestigation investigation)
	{
		if (investigation == null || investigation.getIChartValueComments() == null || investigation.getIChartValueComments().length == 0)
			return;
		
		DynamicGridRow commentRow = form.dyngrd().getRows().newRow();

		DynamicGridCell commentCell = commentRow.getCells().newCell(form.dyngrd().getColumns().getByIdentifier(COLUMN_NAME), DynamicCellType.HTMLVIEW);
		commentCell.setWidth(700);

		StringBuilder comments = new StringBuilder();
		
		comments.append("<b>").append(investigation.getIChartValueInvestigationName()).append("</b> ").append("Comments:").append("<br>");
		comments.append("<b>Lab Order No:</b> ");
		
		if (investigation.getIChartValueInvestigationLabOrderNo() != null)
			comments.append(investigation.getIChartValueInvestigationLabOrderNo());
		else
			comments.append("Unknown Lab Order No.");
		
		comments.append(" - ");
		
		if (investigation.getIChartValueDisplayDate() != null)
			comments.append(investigation.getIChartValueDisplayDate());
		else
			comments.append("Unknown Date");

		if (investigation.getIChartValueDisplayFlag() != null)
			comments.append(" ").append(investigation.getIChartValueDisplayFlag());

		comments.append("<br>");
		

		for (int i = 0; i < investigation.getIChartValueComments().length; i++)
		{
			IChartValueComment investigationComment = investigation.getIChartValueComments()[i];
			
			if (investigationComment != null)
			{
				if (investigationComment.getIChartValueCommentText() != null)
				{
					comments.append("<br>").append(investigationComment.getIChartValueCommentText().replaceAll("\n", "<br>")); //WDEV-16697
				}
				else
				{
					comments.append("<br>");
				}
				
				comments.append("<br>");
			}
		}
		
		comments.append("<br><br>");
		commentCell.setValue(comments.toString());
		commentCell.setReadOnly(true);
	}

	private IChartValueInvestigation[] getInvestigationComments(IChartValueSet value)
	{
		ArrayList<IChartValueInvestigation> investigations = new ArrayList<IChartValueInvestigation>();
		
		IChartValueGroup[] groups = value.getIChartValueSetGroups();
		if (groups != null && groups.length > 0)
		{
			for (int i = 0; i < groups.length; i++)
			{
				IChartValue[] analytes = groups[i].getIChartValueGroupValues();
				if (analytes != null && analytes.length > 0)
				{
					for (int j = 0; j < analytes.length; j++)
					{
						IChartValueInvestigation investigation = analytes[j].getIChartValueInvestigation();
						
						if (investigation != null && investigation.getIChartValueComments() != null && investigation.getIChartValueComments().length > 0)
						{
							// Check if investigation is already added (have to do this mannualy as equals method fails for interfaces)
							if (!isAdded(investigations, investigation))
							{
								investigations.add((ChartInvestigationCommentsVo)investigation);
							}
						}
					}
				}
			}
		}
		
		Collections.sort(investigations, new InvestigationsComparator());

		return investigations.toArray(new IChartValueInvestigation[investigations.size()]);
	}
	
	private IChartValueAnalyte[] getAnalytesComments(IChartValueSet set)
	{
		ArrayList<IChartValueAnalyte> analytesWithComments = new ArrayList<IChartValueAnalyte>();
		
		if (set == null)
			return analytesWithComments.toArray(new IChartValueAnalyte[analytesWithComments.size()]);
		
		IChartValueGroup[] groups = set.getIChartValueSetGroups();
		if (groups != null && groups.length > 0)
		{
    		for (int i = 0; i < groups.length; i++)
    		{
    			IChartValue[] analytes = groups[i].getIChartValueGroupValues();
    			if (analytes != null && analytes.length > 0)
    			{
    				for (int j = 0; j < analytes.length; j++)
    				{
    					IChartValue analyte = analytes[j];
    					
    					if (analyte != null && analyte.getIChartValueComments() != null && analyte.getIChartValueComments().length > 0)
    					{
    						ChartAnalyteCommentsVo analyteWithComments = new ChartAnalyteCommentsVo();
    						
    						analyteWithComments.setInvestigationName(analyte.getIChartValueInvestigationName());
    						analyteWithComments.setSpecimenName(analyte.getIChartValueSpecimenType());
    						analyteWithComments.setAnalyte(groups[i].getIChartValueGroupName());
    						analyteWithComments.setDate(analyte.getIChartValueDateTime());
    						analyteWithComments.setDisplayFlag(analyte.getIChartValueDisplayFlag());
    						
    						if (analyte.getIChartValueComments() != null && analyte.getIChartValueComments().length > 0)
    						{
    							analyteWithComments.setComments(new ChartValueCommentVoCollection());
    							
    							for (int x = 0; x < analyte.getIChartValueComments().length; x++)
    							{
    								if (analyte.getIChartValueComments()[x] instanceof ChartValueCommentVo)
    								{
    									analyteWithComments.getComments().add((ChartValueCommentVo) analyte.getIChartValueComments()[x]);
    								}
    							}
    						}
    						else
    						{
    							analyteWithComments.setComments(null);
    						}
    						
    						analytesWithComments.add(analyteWithComments);
    					}
    				}
    			}
    		}
		}
		
		Collections.sort(analytesWithComments, new AnalyteCommentsComparator());
		
		
		return analytesWithComments.toArray(new IChartValueAnalyte[analytesWithComments.size()]);
	}

	
	
	private boolean isAdded(ArrayList<IChartValueInvestigation> investigations, IChartValueInvestigation investigation)
	{
		if (investigations == null)
			return true;
		
		for (IChartValueInvestigation invInCollection : investigations)
		{
			if (invInCollection.getIChartValueInvestigationID() == null || investigation.getIChartValueInvestigationID() == null)
				return false;
			
			if (invInCollection.getIChartValueInvestigationID().equals(investigation.getIChartValueInvestigationID()))
			{
				if(Boolean.TRUE.equals(investigation.getIChartValueInvestigationIsDFT()))
				{
					if(invInCollection.getIChartValuePathologyResultId() != null && invInCollection.getIChartValuePathologyResultId().equals(investigation.getIChartValuePathologyResultId()))
					{
						return true;
					}
				}
				else
				{
					return true;
				}
			}
		}

		return false;
	}
	
	//WDEV-12548
	private void sortAfterGroups(IChartValueSet values) 
	{
		if(values == null || values.getIChartValueSetGroups() == null)
			return;
		
		int size = values.getIChartValueSetGroups().length;
		IChartValueGroup[] group = values.getIChartValueSetGroups();
		
		for(int x = 0; x < size; x++)
		{
			for(int y = size - 1; y > x; y--)
			{
				if(group[y-1] != null && group[y-1].getIChartValueGroupSortOrder() != null && group[y]!= null && group[y].getIChartValueGroupSortOrder() != null)
				{
					if(group[y-1].getIChartValueGroupSortOrder().compareTo(group[y].getIChartValueGroupSortOrder()) > 0)
					{
						IChartValueGroup temp = group[y-1];
						group[y-1] = group[y];
						group[y] = temp;		
					}
				}
			}
		}
		
		values.setIChartValueSetGroups(group);
	}
	
	private void initializeGrid()
	{
		getGrid().setHeaderHeight(GRID_HEADER_HEIGHT);
	}
	private boolean validate(IChartValueSet value) 
	{
		if(value == null)
		{
			engine.showErrors("Data Error", new String[] { "Invalid data set" });
			return false;
		}
		
		ArrayList<String> errors = new ArrayList<String>();

		if(form.getLocalContext().getViewingStyleIsNotNull() && form.getLocalContext().getViewingStyle().equals(VIEW_GRAPHICAL))
		{
			// Below Band Percent
			if(value.getIChartValueSetBelowBandPercent() == null)
				errors.add("Chart below band percent is unspecified.");
			else if(value.getIChartValueSetBelowBandPercent().floatValue() < 0 || value.getIChartValueSetBelowBandPercent().floatValue() > 100)
				errors.add("Chart below band percent should be between 0 and 100, current value is " + value.getIChartValueSetBelowBandPercent() + ".");
		
			// Above Band Percent
			if(value.getIChartValueSetAboveBandPercent() == null)
				errors.add("Chart above band percent is unspecified.");
			else if(value.getIChartValueSetAboveBandPercent().floatValue() < 0 || value.getIChartValueSetAboveBandPercent().floatValue() > 100)
				errors.add("Chart above band percent should be between 0 and 100, current value is " + value.getIChartValueSetAboveBandPercent() + ".");
			
			if(value.getIChartValueSetBelowBandPercent() != null && value.getIChartValueSetAboveBandPercent() != null && (value.getIChartValueSetBelowBandPercent().floatValue() + value.getIChartValueSetAboveBandPercent().floatValue()) > 100)
				errors.add("Chart above + below band percent should be less than 100.");
		}
		
		//Groups
		validate(errors, value.getIChartValueSetGroups());
		
		if(errors.size() > 0)
		{
			String[] result = new String[errors.size()];
			for(int x = 0; x < errors.size(); x++)
			{
				result[x] = errors.get(x);
			}
			
			engine.showErrors("Data Error", result);
			return false;
		}
		return true;
	}
	private void validate(ArrayList<String> errors, IChartValueGroup[] values) 
	{
		if(values == null)
			return;
		
		for(int x = 0; x < values.length; x++)
		{
			validate(errors, values[x]);
		}
	}
	private void validate(ArrayList<String>errors, IChartValueGroup value) 
	{
		if(value == null)
		{
			errors.add("Chart group is unspecified.");
			return;
		}
		
		String name = value.getIChartValueGroupName() == null ? "?" : value.getIChartValueGroupName();
		
		// Color
		if(value.getIChartValueGroupColor() == null)
		{
			errors.add("Chart color for the group '" + name + "' is unspecified.");
		}
		
		if(form.getLocalContext().getViewingStyleIsNotNull() && form.getLocalContext().getViewingStyle().equals(VIEW_GRAPHICAL))
		{
			// Min Factor
			if(value.getIChartValueGroupMinFactor() == null)
			{
				errors.add("Chart min factor for the group '" + name + "' is unspecified.");
			}
			else if(value.getIChartValueGroupMinFactor().intValue() < 1)
			{
				errors.add("Chart min factor for the group '" + name + "' should be greater than 1.");
			}
			
			// Max Factor
			if(value.getIChartValueGroupMaxFactor() == null)
			{
				errors.add("Chart max factor for the group '" + name + "' is unspecified.");
			}
			else if(value.getIChartValueGroupMaxFactor().intValue() < 1)
			{
				errors.add("Chart max factor for the group '" + name + "' should be greater than 1.");
			}
		}	

		// Image
		if(value.getIChartValueGroupImage() == null)
		{
			errors.add("Chart image for the group '" + name + "' is unspecified.");
		}
		
		// Line type
		if(value.getIChartValueGroupLineType() == null)
		{
			errors.add("Chart line type for the group '" + name + "' is unspecified.");
		}

		if(form.getLocalContext().getViewingStyleIsNotNull() && form.getLocalContext().getViewingStyle().equals(VIEW_GRAPHICAL))
		{
			// Min Value
			if(value.getIChartValueGroupMinValue() == null)
			{
				errors.add("Chart min value for the group '" + name + "' is unspecified.");
			}
			
			// Max Value
			if(value.getIChartValueGroupMaxValue() == null)
			{
				errors.add("Chart max value for the group '" + name + "' is unspecified.");
			}
			
			if(value.getIChartValueGroupMinValue() != null 
					&& value.getIChartValueGroupMaxValue() != null
					&& value.getIChartValueGroupMinValue().floatValue() >= value.getIChartValueGroupMaxValue().floatValue())
			{
				errors.add("Chart min value for the group '" + name + "' is greater or equal than the max value.");
			}
		}

		// Name
		if(value.getIChartValueGroupName() == null)
		{
			errors.add("Chart group name is unspecified.");
		}
		
		// Values
		validate(errors, value, value.getIChartValueGroupValues());
	}
	private void validate(ArrayList<String> errors, IChartValueGroup group, IChartValue[] values) 
	{
		if(values == null)
			return;
		
		for(int x = 0; x < values.length; x++)
		{
			validate(errors, group, values[x]);
		}
	}
	private void validate(ArrayList<String> errors, IChartValueGroup group, IChartValue value) 
	{
		String groupName = group.getIChartValueGroupName() == null ? "?" : group.getIChartValueGroupName();
		
		if (value == null)
		{
			errors.add("A chart value data in the group '" + groupName + "' is unspecified.");
			return;
		}
		
		// Value
		if (value.getIChartValueValue() == null && value.getIChartValue() == null)
		{
			errors.add("A chart value in the group '" + groupName + "' is unspecified.");
		}
		
		// Date Time
		if(value.getIChartValueDateTime() == null)
		{
			errors.add("A chart date value in the group '" + groupName + "' is unspecified.");
		}
		
		// Is Abnormal
		if(value.getIChartValueIsAbnormal() == null)
		{
			errors.add("A chart abnormal flag in the group '" + groupName + "' is unspecified.");
		}
	}	
	public void switchToGraphicalView()
	{
		getGraphing().setVisible(true);
		getGrid().setVisible(false);
		
		form.getLocalContext().setViewingStyle(VIEW_GRAPHICAL);
		form.fireCustomControlValueChanged();
	}
	public void switchToTabularView()
	{
		getGraphing().setVisible(false);
		getGrid().setVisible(true);
		
		form.getLocalContext().setViewingStyle(VIEW_TABULAR);
		form.fireCustomControlValueChanged();
	}
	boolean isGraphicalView()
	{
		return getGraphing().isVisible();
	}
	boolean isTabularView()
	{
		return getGrid().isVisible();
	}
	GraphingControl getGraphing()
	{
		return form.graphing();
	}
	DynamicGrid getGrid()
	{
		return form.dyngrd();
	}
	void clear()
	{		
		getGraphing().clear();
		getGrid().clear();			
	}
	void resetGroupFilter()
	{
		form.getGlobalContext().Core.setChartDatasetSelection(new ims.vo.interfaces.IChartValueGroup[0]);
		selectGroups();
	}
	void refresh()
	{
		populate(form.getLocalContext().getChartData(), false);
	}
	void populate(ims.vo.interfaces.IChartValueSet set)
	{
		populate(set, true);
	}
	void populate(ims.vo.interfaces.IChartValueSet set, boolean shouldResetFilter)
	{
		form.getLocalContext().setChartData(set);
		clear();
		if(set == null)
			return;
				
		if(shouldResetFilter) 
		{
			if(set.getIChartValueSetGroups().length > MAX_NO_GROUPS_SUPPORTED)			
			{
				if(form.getLocalContext().getViewingStyleIsNotNull() && form.getLocalContext().getViewingStyle().equals(VIEW_GRAPHICAL))
				{
					resetGroupFilter();
					return;
				}
			}
			else
			{
				form.getGlobalContext().Core.setChartDatasetSelection(set.getIChartValueSetGroups());
			}
		}	
		
		if(set.getIChartValueSetTitle() != null)
			getGraphing().setTitle(set.getIChartValueSetTitle());
		if(set.getIChartValueSetSubTitle() != null)
			getGraphing().setSubTitle(set.getIChartValueSetSubTitle());
		
		float minNormal = set.getIChartValueSetBelowBandPercent().floatValue();
		float maxNormal = 100 - set.getIChartValueSetAboveBandPercent().floatValue();
		
		// no longer used - MM @ 13/03/2007
		// int minFactor = set.getIChartValueSetMinFactor().intValue();
		// int maxFactor = set.getIChartValueSetMaxFactor().intValue();
		
		getGraphing().addHighlightedY(new GraphingHighlight(0, 1));
		getGraphing().addHighlightedY(new GraphingHighlight(minNormal, (float)1.5));
		getGraphing().addHighlightedY(new GraphingHighlight(maxNormal, (float)1.5));
		getGraphing().addHighlightedY(new GraphingHighlight(100, 1));
		
		getGraphing().addLabelY(minNormal, "Ref Range Min");
		getGraphing().addLabelY(maxNormal, "Ref Range Max");
		getGraphing().addLabelY(-3, "Chart Lower Limit");			// WDEV-12655 - Slight adjustment to label to centre it to chart
		getGraphing().addLabelY(106, "Chart Upper Limit");			// WDEV-12655 - Slight adjustment to label to centre it to chart
		
		Color normalBandColor = set.getIChartValueSetNormalBandColor();
		getGraphing().addColorBandY(minNormal, maxNormal, normalBandColor == null ? Color.FloralWhite : normalBandColor);
		
		configureGrid();		
		populateGroups(set);
	}
	private void configureGrid() 
	{
		getGrid().setSelectable(false);
		DynamicGridColumn imageColumn = getGrid().getColumns().newColumn("", COLUMN_IMAGE);
		imageColumn.setWidth(COLUMN_IMAGE_WIDTH);
		imageColumn.setAlignment(Alignment.CENTER);
		DynamicGridColumn nameColumn = getGrid().getColumns().newColumn("Analyte Name", COLUMN_NAME);// 	WDEV-16395
		nameColumn.setWidth(COLUMN_NAME_WIDTH);
		nameColumn.setDynamicWidthSupported(true);
		DynamicGridColumn unitsColumn = getGrid().getColumns().newColumn("Units", COLUMN_UNITS);
		unitsColumn.setWidth(COLUMN_UNITS_WIDTH);
		if(Boolean.TRUE.equals(ConfigFlag.UI.CUMULATIVE_RESULTS_DISPLAY_REF_RANGE_COLUMN.getValue()))    //wdev-13893
		{
			DynamicGridColumn refRangeColumn = getGrid().getColumns().newColumn("Ref. Range", COLUMN_REF_RANGE);
			refRangeColumn.setWidth(COLUMN_REF_RANGE_WIDTH);
		}
	}
	private void populateGroups(ims.vo.interfaces.IChartValueSet set) 
	{
		if(set == null || set.getIChartValueSetGroups() == null)
			return;
		
		graphingGroups = new HashMap<IChartValueGroup, GraphingGroup>();		
		
		createResultsColumns(set);//WDEV-12627, WDEV-12628
		
		for(int x = 0; x < set.getIChartValueSetGroups().length; x++)
		{
			IChartValueGroup group = set.getIChartValueSetGroups()[x];
			
			GraphingGroup graphingGroup = new GraphingGroup(group.getIChartValueGroupName(), group.getIChartValueGroupColor(), getLineType(group.getIChartValueGroupLineType()), group.getIChartValueGroupImage(), getLegendTooltip(group));
			graphingGroups.put(group, graphingGroup);
			
			if(group != null)
			{
				// WDEV-12627 - Pass group index value
				populateGroup(set, group, x);
			}
		}
				
	}
	
	//WDEV-12627, WDEV-12628
	private void createResultsColumns(IChartValueSet set) 
	{
		if(set == null)
			return;
	
		ArrayList<ColumnIdentifierValue> columns = new ArrayList<Logic.ColumnIdentifierValue>();
		
		for(int x = 0; x < set.getIChartValueSetGroups().length; x++)
		{
			IChartValueGroup group = set.getIChartValueSetGroups()[x];
			
			IChartValue[] groupValues = group.getIChartValueGroupValues();
			
			for(int y =0 ; y<groupValues.length; y++)
			{
				updateColumns(columns, x, groupValues[y]);
			}
		}
		
		Collections.sort(columns, new ColumnIdentifierValueComparator(form.getLocalContext().getDateOrder()));
		
		for (ColumnIdentifierValue columnIdentifier : columns)
		{
			String columnLabel = columnIdentifier.toString();
			
			DynamicGridColumn column = form.dyngrd().getColumns().newColumn(columnLabel, columnIdentifier);
			column.setHeaderAlignment(Alignment.CENTER);
			column.setWidth(COLUMN_VALUE_WIDTH);
			
			DynamicGridColumn commentColumn = form.dyngrd().getColumns().newColumn("");
			commentColumn.setWidth(22);
			commentColumn.setCanGrow(false);
		}
		
		
	}
	
	//WDEV-12627, WDEV-12628
	private void updateColumns(ArrayList<ColumnIdentifierValue> columns, int analyteIndex, IChartValue chartValue) 
	{
		if (columns != null)
		{
			for (ColumnIdentifierValue column : columns)
			{
				if (column.needsMerging(chartValue.getIChartValueDateTime(), chartValue.getIChartValueTimeSupplied(), chartValue.getIChartValueLabSpecimen(), chartValue.getIChartValueOrderSpecimen(), analyteIndex))
				{
					column.merge(chartValue.getIChartValueDateTime(), analyteIndex);
					return;
				}
			}

			columns.add(new ColumnIdentifierValue(chartValue.getIChartValueDateTime(), chartValue.getIChartValueTimeSupplied(), analyteIndex, chartValue.getIChartValueLabSpecimen(), chartValue.getIChartValueOrderSpecimen(), chartValue.getIChartValueIsReceivedDateTime()));
		}
	}
	
	private String getLegendTooltip(IChartValueGroup group) 
	{
		if(group == null)
			return "";
		
		StringBuffer result = new StringBuffer();
		
		result.append("<b>");
		result.append(group.getIChartValueGroupName());
		result.append("</b>");
		result.append("<br>");
		result.append("<br>");
		result.append("<b>Ref. Range:</b> ");
		result.append(group.getIChartValueGroupRefRange());
		result.append("<br>");
		result.append("<b>Unit of Measure:</b>: ");
		result.append(group.getIChartValueGroupUnits());
		result.append("<br>");
		result.append("<b>Chart Lower Limit :</b>: ");

		//WDEV-12547 - these values only need to be populated if the view is graphical
		if(form.getLocalContext().getViewingStyleIsNotNull() && form.getLocalContext().getViewingStyle().equals(VIEW_GRAPHICAL))
		{
			if (group.getIChartValueGroupMinValue() != null && group.getIChartValueGroupMinFactor() != null && group.getIChartValueGroupMinFactor().floatValue() != 0)
			{
				result.append(group.getIChartValueGroupMinValue().floatValue() / group.getIChartValueGroupMinFactor().floatValue());
			}
			else
			{
				result.append("Value can not be calculated at this time");
			}
		}

		result.append("<br>");
		result.append("<b>Chart Upper Limit :</b>: ");
		
		//WDEV-12547 - these values only need to be populated if the view is graphical
		if(form.getLocalContext().getViewingStyleIsNotNull() && form.getLocalContext().getViewingStyle().equals(VIEW_GRAPHICAL))
		{
			if (group.getIChartValueGroupMaxValue() != null && group.getIChartValueGroupMaxFactor() != null)
			{
				result.append(group.getIChartValueGroupMaxValue().floatValue() * group.getIChartValueGroupMaxFactor().floatValue());
			}
			else
			{
				result.append("Value can not be calculated at this time");
			}
		}
		
		return result.toString();
	}
	
	/**
	 * WDEV-12627
	 * Added group index parameter - will be needed when creating value columns
	 */
	private void populateGroup(IChartValueSet set, IChartValueGroup group, int groupIndex) 
	{
		if(group == null)
			return;
		
		DynamicGridRow groupRow = getGrid().getRows().newRow();
		groupRow.setIdentifier(group);
		
		StringBuffer tooltip = new StringBuffer();// 	WDEV-16395
		
		if(group.getIChartValueGroupImage() != null)
		{
			DynamicGridCell imageCell = groupRow.getCells().newCell(getGrid().getColumns().getByIdentifier(COLUMN_IMAGE), DynamicCellType.IMAGE);
			imageCell.setValue(group.getIChartValueGroupImage());
			imageCell.setReadOnly(true);
		}
		if(group.getIChartValueGroupName() != null)
		{
			DynamicGridCell nameCell = groupRow.getCells().newCell(getGrid().getColumns().getByIdentifier(COLUMN_NAME), DynamicCellType.STRING);
			nameCell.setValue(group.getIChartValueGroupName());
			nameCell.setReadOnly(true);
			
			tooltip.append("<b>Analyte Name:</b> " + group.getIChartValueGroupName());// 	WDEV-16395
		}
		if(group.getIChartValueGroupUnits() != null)
		{
			DynamicGridCell unitsCell = groupRow.getCells().newCell(getGrid().getColumns().getByIdentifier(COLUMN_UNITS), DynamicCellType.STRING);
			unitsCell.setValue(group.getIChartValueGroupUnits());
			unitsCell.setReadOnly(true);
		}		
		if(group.getIChartValueGroupRefRange() != null && Boolean.TRUE.equals(ConfigFlag.UI.CUMULATIVE_RESULTS_DISPLAY_REF_RANGE_COLUMN.getValue()))  //wdev-13893
		{
			DynamicGridCell refRangeCell = groupRow.getCells().newCell(getGrid().getColumns().getByIdentifier(COLUMN_REF_RANGE), DynamicCellType.STRING);
			refRangeCell.setValue(group.getIChartValueGroupRefRange());
			refRangeCell.setReadOnly(true);
		}
		
		IChartValue[] values = group.getIChartValueGroupValues();//WDEV-12627, WDEV-12628
		
		for(int x = 0; x < values.length; x++)
		{
			IChartValue value = values[x];
			
			if(value != null)
			{
				// WDEV-12627 - Pass value index and group index - will be needed when creating value column & comments column
				populateValue(set, group, value, x, groupIndex, tooltip);	// 	WDEV-16395			
			}
		}
	}	
	private String buildValueTooltip(IChartValueGroup group, IChartValue value)
	{
		if(group == null || value == null)
			return "";
		
		boolean isAbnormal = value.getIChartValueIsAbnormal().booleanValue();
		
		StringBuffer result = new StringBuffer(); 
		
		result.append("<b>" + group.getIChartValueGroupName() + "</b>");
		result.append("<br><br>");
		result.append("<b>Date:</b> " + value.getIChartValueDateTime() + (Boolean.TRUE.equals(value.getIChartValueIsReceivedDateTime()) ? RECEIVED_DATE_STRING : COLLECTED_DATE_STRING) + " - " + value.getIChartValueDisplayFlag());// 	WDEV-16395
		result.append("<br>");
		result.append("<b>" + (isAbnormal ? "Abnormal" : "") + " Value:</b> " + value.getIChartValueValue() + (value.getIChartValueUnitOfMeasure() == null ? "" : " " + value.getIChartValueUnitOfMeasure()));

		result.append("<br><b>Units:</b> ").append(value.getIChartValueUnitOfMeasure() != null ? value.getIChartValueUnitOfMeasure() : "-");
		result.append("<br><b>Ref. Range:</b> ").append(value.getIChartValueRefRange() != null ? value.getIChartValueRefRange() : "-");
		
		return result.toString();
	}
	
	/**
	 * WDEV-12627
	 * Function used to populate values & comments to grid
	 * It will add the columns as it needs it for values and comments. It will attempt to 
	 * @param tooltip 
	 */
	private void populateValue(IChartValueSet set, IChartValueGroup group, IChartValue value, int valueIndex, int groupIndex, StringBuffer tooltip)// 	WDEV-16395 
	{
		if(group == null || value == null)
			return;
		
		boolean isAbnormal = value.getIChartValueIsAbnormal() != null && value.getIChartValueIsAbnormal().booleanValue();
		
		//WDEV-12547
		if(form.getLocalContext().getViewingStyleIsNotNull() && form.getLocalContext().getViewingStyle().equals(VIEW_GRAPHICAL))
		{
			if(isSelected(group))
			{
				if (value.getIChartValueValue() != null)
				{
					getGraphing().addPoint(new GraphingCustomOneValue(graphingGroups.get(group), value.getIChartValueDateTime(), normalizeValue(set, group, value), value, buildValueTooltip(group, value)));
				}
			}
		}
		
		DynamicGridRow row = getGroupRow(group);

		// Find a column based on the identifier created (the equals method in ColumnIdentifierValue class is overwritten with custom code)
		// If no column exists then a new one is created
		DynamicGridColumn valueColumn = getValueColumn(value.getIChartValueDateTime(), groupIndex, value.getIChartValueLabSpecimen(), value.getIChartValueOrderSpecimen());//WDEV-12627, WDEV-12628
		
		DynamicGridCell cell = row.getCells().newCell(valueColumn, DynamicCellType.STRING);
		StringBuilder valueTooltip = new StringBuilder();
		if (value.getIChartValueValue() != null)
		{
			cell.setValue(value.getIChartValueValue().toString());
			valueTooltip.append(value.getIChartValueValue().toString()).append("<br>");
		}
		else
		{
			cell.setValue(value.getIChartValue().substring(0, Math.min(value.getIChartValue().length(), CHARS_TO_TRIM_ST_RESULTS)));
			valueTooltip.append(value.getIChartValue()).append("<br>");
		}
		
		cell.setReadOnly(true);

		// Find a column based on the identifier created (the equals method in ColumnIdentifierComments class is overwritten with custom code)
		DynamicGridColumn commentColumn = getCommentColumn(valueColumn);//WDEV-12627, WDEV-12628
			
		if ((value.getIChartValueComments() != null && value.getIChartValueComments().length > 0)
				|| Boolean.TRUE.equals(ConfigFlag.UI.DISPLAY_INVESTIGATION_COMMENTS_ON_CUMULATE_RESULTS.getValue()) && (value.getIChartValueInvestigationComments() != null && value.getIChartValueInvestigationComments().length > 0)
				|| Boolean.TRUE.equals(ConfigFlag.UI.DISPLAY_INVESTIGATION_COMMENTS_ON_CUMULATE_RESULTS.getValue()) && (value.getIChartValueSpecimenComments() != null && value.getIChartValueSpecimenComments().length > 0))
		{
			DynamicGridCell commentCell = row.getCells().newCell(commentColumn, DynamicCellType.BUTTON);			
			commentCell.setIdentifier(value);
			commentCell.setReadOnly(true);
		}
		
		if(isAbnormal)
		{
			DynamicGridCell nameCell = row.getCells().get(getGrid().getColumns().getByIdentifier(COLUMN_NAME));
			nameCell.setTextColor(CELL_ABNORMAL_TEXTCOLOR);
			nameCell.setBackColor(CELL_ABNORMAL_BACKCOLOR);
			cell.setTextColor(CELL_ABNORMAL_TEXTCOLOR);
			cell.setBackColor(CELL_ABNORMAL_BACKCOLOR);			
		}
		
		cell.setIdentifier(value);

		valueTooltip.append(tooltip.toString());
		valueTooltip.append("<br><b>Units:</b> ").append(value.getIChartValueUnitOfMeasure() != null ? value.getIChartValueUnitOfMeasure() : "-");
		valueTooltip.append("<br><b>Ref. Range:</b> ").append(value.getIChartValueRefRange() != null ? value.getIChartValueRefRange() : "-");
		cell.setTooltip(valueTooltip.toString());
	}
	
	//WDEV-12627, WDEV-12628
	private DynamicGridColumn getCommentColumn(DynamicGridColumn valueColumn) 
	{
		DynamicGridColumnCollection columns = form.dyngrd().getColumns();
		
		for (int i = 0; i < columns.size() - 1; i++)
		{
			if (columns.get(i).equals(valueColumn))
				return columns.get(i + 1);
		}
		
		return null;
	}
	
	//WDEV-12627, WDEV-12628
	private DynamicGridColumn getValueColumn(DateTime valueDateTime, int groupIndex, LookupInstVo labSpecimenType, SpecimenType orderSpecimenType) 
	{
		for(int i = 0; i < form.dyngrd().getColumns().size(); i++)
		{
			DynamicGridColumn column = form.dyngrd().getColumns().get(i);
			
			if(column.getIdentifier() instanceof ColumnIdentifierValue)
			{
				ColumnIdentifierValue columnIndentifier = (ColumnIdentifierValue) column.getIdentifier();
				
				boolean labSpecimenMatch = columnIndentifier.getLabSpecimen() != null && labSpecimenType != null && columnIndentifier.getLabSpecimen().equals(labSpecimenType);
				boolean orderSpecimenMatch = columnIndentifier.getLabSpecimen() == null && labSpecimenType == null && columnIndentifier.getOrderSpecimen() != null && orderSpecimenType != null && columnIndentifier.getOrderSpecimen().equals(orderSpecimenType);
				boolean noOrderOrLabSpecimen = columnIndentifier.getLabSpecimen() == null && columnIndentifier.getOrderSpecimen() == null && labSpecimenType == null && orderSpecimenType == null;
				
				if (columnIndentifier.getDate().equals(valueDateTime) && (labSpecimenMatch || orderSpecimenMatch || noOrderOrLabSpecimen))
				{
					DynamicGridRow row = form.dyngrd().getRows().get(groupIndex);
					DynamicGridCell cell = row.getCells().get(column);
					
					if(cell == null || cell.getValue() == null)
						return column;
				}
			}
		}
		
		return null;
	}
	
	boolean isSelected(IChartValueGroup group) 
	{
		for(int x = 0; x < form.getGlobalContext().Core.getChartDatasetSelection().length; x++)
		{
			if(group.equals(form.getGlobalContext().Core.getChartDatasetSelection()[x]))
				return true;
		}
		
		return false;
	}
	private Float normalizeValue(IChartValueSet set, IChartValueGroup group, IChartValue value)
	{
		//WDEV-12547 - not applicable to tabular view
		if(form.getLocalContext().getViewingStyleIsNotNull() && form.getLocalContext().getViewingStyle().equals(VIEW_TABULAR))
			return null;
		
		float currentValue = value.getIChartValueValue().floatValue();
		float minValue = group.getIChartValueGroupMinValue().floatValue();
		float maxValue = group.getIChartValueGroupMaxValue().floatValue();
		
		if(currentValue > maxValue)
			return normalizeAboveValue(set, group, value);
		else if(currentValue < minValue)
			return normalizeBelowValue(set, group, value);
		
		return normalizeNormalValue(set, group, value);
	}
	private Float normalizeAboveValue(IChartValueSet set, IChartValueGroup group, IChartValue value)
	{
		//WDEV-12547 - not applicable to tabular view
		if(form.getLocalContext().getViewingStyleIsNotNull() && form.getLocalContext().getViewingStyle().equals(VIEW_TABULAR))
			return null;
		
		float currentValue = value.getIChartValueValue().floatValue();
		//int factor = set.getIChartValueSetMaxFactor().intValue();
		int factor = group.getIChartValueGroupMaxFactor().intValue();
		float minPercent = 100 - set.getIChartValueSetAboveBandPercent().floatValue();
		float maxPercent = 100;		
		float minValue = group.getIChartValueGroupMaxValue().floatValue();
		float maxValue = minValue * factor;
		
		float valuePercent = (((currentValue - minValue) * (maxPercent - minPercent)) / (maxValue - minValue)) + minPercent;
		
		if(valuePercent > 100)
			valuePercent = 100;
		
		return new Float(valuePercent);
	}	
	private Float normalizeBelowValue(IChartValueSet set, IChartValueGroup group, IChartValue value)
	{		
		//WDEV-12547 - not applicable to tabular view
		if(form.getLocalContext().getViewingStyleIsNotNull() && form.getLocalContext().getViewingStyle().equals(VIEW_TABULAR))
			return null;
		
		float currentValue = value.getIChartValueValue().floatValue();
		//int factor = set.getIChartValueSetMinFactor().intValue();
		int factor = group.getIChartValueGroupMinFactor().intValue();
		float minPercent = 0;
		float maxPercent = set.getIChartValueSetBelowBandPercent().floatValue();		
		float maxValue = group.getIChartValueGroupMinValue().floatValue();
		float minValue = maxValue / (factor == 0 ? 1 : factor);
		
		float valuePercent = (((currentValue - minValue) * (maxPercent - minPercent)) / (maxValue - minValue)) + minPercent;
		
		if(valuePercent < 0)
			valuePercent = 0;
		
		return new Float(valuePercent);
	}	
	private Float normalizeNormalValue(IChartValueSet set, IChartValueGroup group, IChartValue value)
	{
		float currentValue = value.getIChartValueValue().floatValue();
		float minPercent = set.getIChartValueSetBelowBandPercent().floatValue();
		float maxPercent = 100 - set.getIChartValueSetAboveBandPercent().floatValue();
		float minValue = group.getIChartValueGroupMinValue().floatValue();
		float maxValue = group.getIChartValueGroupMaxValue().floatValue();
		
		float valuePercent = (((currentValue - minValue) * (maxPercent - minPercent)) / (maxValue - minValue)) + minPercent;		
		return new Float(valuePercent);
	}	
	private DynamicGridRow getGroupRow(IChartValueGroup group)
	{
		for(int x = 0; x < getGrid().getRows().size(); x++)
		{
			if(group.equals(getGrid().getRows().get(x).getIdentifier()))
				return getGrid().getRows().get(x);
		}
		
		return null;
	}
	
	private GraphicLineStyle getLineType(LineType value) 
	{
		if(value == null)
			return GraphicLineStyle.SOLID;
		
		if(value.equals(LineType.DASH))
			return GraphicLineStyle.DASH;
		else if(value.equals(LineType.DASHDOT))
			return GraphicLineStyle.DASHDOT;
		else if(value.equals(LineType.DOT))
			return GraphicLineStyle.DOT;
		else if(value.equals(LineType.LONGDASH))
			return GraphicLineStyle.LONGDASH;
		else if(value.equals(LineType.LONGDASHDOT))
			return GraphicLineStyle.LONGDASHDOT;
		else if(value.equals(LineType.LONGDASHDOTDOT))
			return GraphicLineStyle.LONGDASHDOTDOT;
		else if(value.equals(LineType.SOLID))
			return GraphicLineStyle.SOLID;
		
		return GraphicLineStyle.SOLID;
	}
	public Boolean canSelectGroups() 
	{	
		if(form.getLocalContext().getChartData() == null || form.getLocalContext().getChartData().getIChartValueSetGroups() == null)
			return Boolean.FALSE;		
		
		return Boolean.TRUE;
	}
	public void selectGroups() 
	{
		if(!canSelectGroups().booleanValue())
			return;
		
		form.getGlobalContext().Core.setChartAvailableDatasets(getAvailableDataSets());		
		form.getGlobalContext().Core.setChartMaxGroupSelection(Integer.valueOf(MAX_NO_GROUPS_SUPPORTED));
		//wdev-13867
		if(form.getGlobalContext().OCRR.getSelectGroupsInViewGraphicIsNotNull() && Boolean.TRUE.equals(form.getGlobalContext().OCRR.getSelectGroupsInViewGraphic()))
		{
			if(form.getGlobalContext().Core.getChartDatasetSelection() == null)
				form.getGlobalContext().Core.setChartDatasetSelection(new ims.vo.interfaces.IChartValueGroup[0]);
			
			form.getGlobalContext().OCRR.setSelectGroupsInViewGraphic(null);
		}
		//Groups
		ArrayList<String> errors = new ArrayList<String>();
		validate(errors, getAvailableDataSets());
		
		if(errors.size() > 0)
		{
			String[] result = new String[errors.size()];
			for(int x = 0; x < errors.size(); x++)
			{
				result[x] = errors.get(x);
			}
			
			engine.showErrors("Data Error", result);
			return;
		}
		//------------------------
		engine.open(form.getForms().Core.ChartingGroupSelection);		
	}
	IChartValueGroup[] getAvailableDataSets() 
	{
		return form.getLocalContext().getChartData().getIChartValueSetGroups();
	}
	@Override
	protected void onGraphingPointClicked(GraphingPoint point) 
	{
		IChartValue value = (IChartValue)point.getTag();
		if(value != null)
		{		
			displayComments(point.getTitle(), value);
		}
	}
	private void displayComments(String title, IChartValue value) 
	{
		String commentString = concatComments(buildComments(value, title));
		if(commentString == null || commentString.length() == 0)
		{
			commentString = "No comments available";
		}
		form.getGlobalContext().Core.setCommentDialogString(commentString);
		form.getGlobalContext().Core.setCommentDialogReadOnly(true);
		form.getGlobalContext().Core.setCommentDialogTitle(title + " Comments");		
		engine.open(form.getForms().Core.CommentDialog);
	}

	private String concatComments(String[] comments) 
	{
		if(comments == null)
			return "";
		String result = "";
		for(int x = 0; x < comments.length; x++)
		{
			if(comments[x] != null)
			{
				if(result.length() > 0)
					result += "\n\n";
				result += comments[x];
			}
		}
		return result;
	}
	private String[] buildComments(IChartValue value, String analyteName) 
	{
		if (value == null)
			return new String[0];
		
		ArrayList<String> comments = new ArrayList<String>();
		
		if (value.getIChartValueComments() != null)
		{
			for (int i = 0; i < value.getIChartValueComments().length; i++)
			{
				IChartValueComment chartValueComment = value.getIChartValueComments()[i];
				
				if (chartValueComment != null)
				{
					StringBuilder comment = new StringBuilder();
					
					comment.append(value.getIChartValueDateTime() != null ? value.getIChartValueDateTime() : "<Unknown date>");
					comment.append(" - ").append(value.getIChartValueDisplayFlag()).append(" - ").append(value.getIChartValueSpecimenType()).append("\n");
					
					if (analyteName != null)
					{
						comment.append("Analyte: ").append(analyteName).append("\n");
					}
					
					comment.append("\n");

					comment.append(chartValueComment.getIChartValueCommentText() != null ? chartValueComment.getIChartValueCommentText() : "Unknown");
					
					comments.add(comment.toString());
				}
			}
		}
		
		if (Boolean.TRUE.equals(ConfigFlag.UI.DISPLAY_INVESTIGATION_COMMENTS_ON_CUMULATE_RESULTS.getValue()))
		{
			if (value.getIChartValueInvestigationComments() != null && value.getIChartValueInvestigationComments().length > 0)
			{
				if (value.getIChartValueInvestigationName() != null)
				{
					comments.add("");
					comments.add(value.getIChartValueInvestigationName() + " Comments:");

					StringBuilder labOrderDateAndFlag = new StringBuilder();

					labOrderDateAndFlag.append(value.getIChartValueLabOrder() != null ? "Lab Order No: " + value.getIChartValueLabOrder() : "Unknown Lab Order No.").append(" - ");
					labOrderDateAndFlag.append(value.getIChartValueDisplayDate() != null ? value.getIChartValueDisplayDate().toString() : "Unknown Date").append(" ");
					labOrderDateAndFlag.append(value.getIChartValueDisplayFlag());


					comments.add(labOrderDateAndFlag.toString());
				}

				for (int i = 0; i < value.getIChartValueInvestigationComments().length; i++)
				{
					IChartValueComment investigationComment = value.getIChartValueInvestigationComments()[i];

					if (investigationComment != null)
					{
						StringBuilder comment = new StringBuilder();

						comment.append(investigationComment.getIChartValueCommentText() != null ? investigationComment.getIChartValueCommentText() : "Unknown");

						comments.add(comment.toString());
					}
				}
			}
		}

		return comments.toArray(new String[comments.size()]);
	}
	@Override
	protected void onDyngrdCellButtonClicked(DynamicGridCell cell) 
	{
		if(cell != null && cell.getIdentifier() != null)
		{
			ims.vo.interfaces.IChartValue comments = (ims.vo.interfaces.IChartValue) cell.getIdentifier();
			DynamicGridCell nameCell = cell.getRow().getCells().get(form.dyngrd().getColumns().getByIdentifier(COLUMN_NAME));
			displayComments(nameCell.getValue().toString(), comments);
		}
	}
	//WDEV-11992
	public void readOnlyDynGrid(Boolean enable)
	{
		form.dyngrd().setReadOnly(enable);
	}
	
	//WDEV-12614
	public void setOrder(SortOrder order) 
	{
		form.getLocalContext().setDateOrder(order);	
	}
}
