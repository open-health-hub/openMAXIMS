//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.66 build 3261.22124)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.core.domain.impl;

import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.vo.ContractConfigShortVo;
import ims.RefMan.vo.PatientElectiveListBedAdmissionVo;
import ims.RefMan.vo.PatientElectiveListBedAdmissionVoCollection;
import ims.RefMan.vo.PatientElectiveListBedInfoVoCollection;
import ims.RefMan.vo.PatientElectiveListRefVo;
import ims.RefMan.vo.domain.ContractConfigShortVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListBedAdmissionVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListBedInfoVoAssembler;
import ims.clinical.vo.lookups.VTEAsessmentStatus;
import ims.configuration.InitConfig;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.domain.objects.CareContextStatusHistory;
import ims.core.admin.domain.objects.CareSpell;
import ims.core.admin.domain.objects.EpisodeOfCare;
import ims.core.admin.domain.objects.Referral;
import ims.core.admin.pas.domain.objects.AdmissionDetail;
import ims.core.admin.pas.domain.objects.BedSpaceState;
import ims.core.admin.pas.domain.objects.HomeLeave;
import ims.core.admin.pas.domain.objects.InpatientEpisode;
import ims.core.admin.pas.domain.objects.PendingElectiveAdmission;
import ims.core.admin.pas.domain.objects.PendingEmergencyAdmission;
import ims.core.admin.pas.vo.BedSpaceStateRefVo;
import ims.core.admin.pas.vo.InpatientEpisodeRefVo;
import ims.core.admin.pas.vo.PASEventRefVo;
import ims.core.admin.vo.ReferralRefVo;
import ims.core.clinical.domain.objects.TaxonomyMap;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.configuration.domain.objects.AppUser;
import ims.core.configuration.domain.objects.ContractConfig;
import ims.core.configuration.vo.AppUserRefVo;
import ims.core.domain.BedAdmissionComponent;
import ims.core.domain.Demographics;
import ims.core.domain.PatientSearch;
import ims.core.domain.WardView;
import ims.core.helper.DTOHelper;
import ims.core.helper.IPathwayPatientEventHelper;
import ims.core.patient.domain.objects.PatientId;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.Hcp;
import ims.core.resource.people.domain.objects.Medic;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.resource.place.domain.objects.CCGPCTPCCodes;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.AdmissionDetailVo;
import ims.core.vo.BedSpaceStateLiteVo;
import ims.core.vo.CareSpellVo;
import ims.core.vo.CatsReferralEmergencyAdmissionVo;
import ims.core.vo.ConsultantStayVo;
import ims.core.vo.EpisodeOfCareWithPrimaryDiagnosisVo;
import ims.core.vo.EpisodeOfCareWithPrimaryDiagnosisVoCollection;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.HomeLeaveVo;
import ims.core.vo.InpatientEpisodeLiteVo;
import ims.core.vo.InpatientEpisodeLiteVoCollection;
import ims.core.vo.MedicVo;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.Patient;
import ims.core.vo.PatientFilter;
import ims.core.vo.PatientShort;
import ims.core.vo.PatientShortCollection;
import ims.core.vo.PatientWithGPForCCGVo;
import ims.core.vo.PendingElectiveAdmissionAdmitVo;
import ims.core.vo.PendingElectiveAdmissionAdmitVoCollection;
import ims.core.vo.PendingEmergencyAdmissionAdmitVo;
import ims.core.vo.PendingEmergencyAdmissionAdmitVoCollection;
import ims.core.vo.ServiceLiteVoCollection;
import ims.core.vo.WardStayVo;
import ims.core.vo.domain.AdmissionDetailVoAssembler;
import ims.core.vo.domain.BedSpaceStateLiteVoAssembler;
import ims.core.vo.domain.CareSpellVoAssembler;
import ims.core.vo.domain.CatsReferralEmergencyAdmissionVoAssembler;
import ims.core.vo.domain.ConsultantStayVoAssembler;
import ims.core.vo.domain.EpisodeOfCareWithPrimaryDiagnosisVoAssembler;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.InpatientEpisodeLiteVoAssembler;
import ims.core.vo.domain.MedicVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffMappingsLiteVoAssembler;
import ims.core.vo.domain.PatientIdAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.domain.PatientWithGPForCCGVoAssembler;
import ims.core.vo.domain.PendingElectiveAdmissionAdmitVoAssembler;
import ims.core.vo.domain.PendingEmergencyAdmissionAdmitVoAssembler;
import ims.core.vo.domain.ServiceLiteVoAssembler;
import ims.core.vo.domain.WardStayVoAssembler;
import ims.core.vo.enums.AdmissionType;
import ims.core.vo.lookups.CareContextStatus;
import ims.core.vo.lookups.CareSpelltoEpisodeRelationship;
import ims.core.vo.lookups.ContextType;
import ims.core.vo.lookups.ElectiveAdmissionStatus;
import ims.core.vo.lookups.EmergencyAdmissionStatus;
import ims.core.vo.lookups.MethodOfAdmission;
import ims.core.vo.lookups.PASSpecialty;
import ims.core.vo.lookups.PASSpecialtyCollection;
import ims.core.vo.lookups.PatIdType;
import ims.core.vo.lookups.ReferralType;
import ims.core.vo.lookups.Sex;
import ims.core.vo.lookups.Specialty;
import ims.core.vo.lookups.SpecialtyCollection;
import ims.core.vo.lookups.TCIType;
import ims.core.vo.lookups.TaxonomyType;
import ims.core.vo.lookups.TransferStatus;
import ims.core.vo.lookups.WaitingListStatus;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DTODomainInterfaceException;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.lookups.LookupMapping;
import ims.dto.DTODomainImplementation;
import ims.dto.Result;
import ims.dto.client.Conspc;
import ims.dto.client.Conspc.ConspcRecord;
import ims.dto.client.Homeleave;
import ims.dto.client.Homeleave.HomeleaveRecord;
import ims.dto.client.Inpat;
import ims.dto.client.Inpat.InpatRecord;
import ims.emergency.vo.lookups.ElectiveListReason;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.DateTimeFormat;
import ims.framework.utils.TimeFormat;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.domain.objects.PathwayRTTStatus;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.PatientJourneyVo;
import ims.pathways.vo.PatientPathwayJourneyRefVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.vo.LookupMappingVo;
import ims.vo.LookupMappingVoCollection;
import ims.vo.interfaces.IMos;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;



public class BedAdmissionComponentImpl extends DTODomainImplementation implements BedAdmissionComponent
{
	private static final long serialVersionUID = 1L;
	private static final int START_OF_FIRST_DEFINITIVE_TREATMENT = 30;
	private static final int SUBSEQUENT_ACTIVITY = 20;

	public boolean dtoOnly()
	{
		return InitConfig.getConfigType().equals("DTO");
	}

	public Class getLookupServiceClass()
	{
		return ims.domain.lookups.impl.LookupServiceImpl.class;
	}
	/**
	* listPendingElectiveAdmission
	*/
	public ims.core.vo.PendingElectiveAdmissionAdmitVoCollection listPendingElectiveAdmission(LocationRefVo voLocation)
	{
		if(voLocation == null)
			throw new CodingRuntimeException("voLocation is null in method listPendingElectiveAdmission");
		
		DomainFactory factory = getDomainFactory();
		List pendingElectives = factory.find("from PendingElectiveAdmission pea where (pea.tCIDate = :today or pea.tCIDate = :yesterday) and pea.allocatedWard.id = :idWard and pea.electiveAdmissionStatus = :status  and pea.tCIType = :tciType ", new String[]{"today","yesterday", "idWard","status","tciType"}, new Object[]{new Date().getDate(),new Date().addDay(-1).getDate(), voLocation.getID_Location(), getDomLookup(ElectiveAdmissionStatus.TCI), getDomLookup(TCIType.BOOKED)});
			return PendingElectiveAdmissionAdmitVoAssembler.createPendingElectiveAdmissionAdmitVoCollectionFromPendingElectiveAdmission(pendingElectives);
	}


	public PatientElectiveListBedAdmissionVo saveTCIAdmissionAndUpdateList(PatientElectiveListBedAdmissionVo electiveAdmission, BedSpaceStateLiteVo bedSpaceState, WardStayVo wardStay, ConsultantStayVo consultant, PatientElectiveListBedAdmissionVoCollection patientElectiveListToCancel) throws StaleObjectException, DomainInterfaceException
	{
		if (electiveAdmission == null)
			throw new CodingRuntimeException("Elective Admission is mandatory for saving");
		if (!electiveAdmission.isValidated())
			throw new CodingRuntimeException("Elective Admission has not been validated in method saveAdmission");
		
		// Determine if the patient was admitted on PAS - this should not be the case for this type of save
		boolean isAdmitedOnPAS = electiveAdmission.getTCIDetails() != null && electiveAdmission.getTCIDetails().getAdmissionDetail() != null && electiveAdmission.getTCIDetails().getAdmissionDetail().getID_AdmissionDetail() != null;
			
		@SuppressWarnings("rawtypes")
		HashMap domMap = new HashMap();
		PatientElectiveList domElectiveAdmission = PatientElectiveListBedAdmissionVoAssembler.extractPatientElectiveList(getDomainFactory(), electiveAdmission, domMap);

		if (patientElectiveListToCancel != null)
		{
			for (PatientElectiveListBedAdmissionVo patientElectiveListToBeCancelled : patientElectiveListToCancel)
			{
				PatientElectiveList domPatientElectiveListToCancel = PatientElectiveListBedAdmissionVoAssembler.extractPatientElectiveList(getDomainFactory(), patientElectiveListToBeCancelled, domMap);
				getDomainFactory().save(domPatientElectiveListToCancel);
			}
		}
		
		domElectiveAdmission.getTCIDetails().getAdmissionDetail().setAdmittingUser((AppUser) getDomainFactory().getDomainObject((AppUserRefVo) getLoggedInUser()));
		getDomainFactory().save(domElectiveAdmission);

		CatsReferral domCats = domElectiveAdmission.getReferral();
		
		//WDEV-18316  WDEV-18617 - only stop clock if EL is non-diagnostic
		if (Boolean.TRUE.equals(ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue()) && Boolean.TRUE.equals(domCats.isRTTClockImpact()))
		{
			// WDEV-18686 - Instead of just stopping the clock and setting the status, we set status, and look for the relevant admission
			// event dependant on whether this is a Treatment or Diagnostic Admission
			Boolean isDiagnostic=false;
			PathwayRTTStatus rttStatus=null; // WDEV-18617 - create 20 for diagnostic on admission, so pass this to create method
			if ( domElectiveAdmission.getElectiveListReason() != null && domElectiveAdmission.getElectiveListReason().getId() == ElectiveListReason.DIAGNOSTIC.getId())
			{
				rttStatus = createPathwayRTTStatus(domCats, true);
				isDiagnostic=true;
			}
			else
			{
				rttStatus = createPathwayRTTStatus(domCats, false);
			}
			
			domCats.setCurrentRTTStatus(rttStatus);

			Class<?> implClass;
			try 
			{
				implClass = Class.forName("ims.pathways.domain.impl.HL7PathwayIfImpl");
				IPathwayPatientEventHelper pathwayImp = (IPathwayPatientEventHelper) getDomainImpl(implClass);

			
				// Find the event that needs to be instantiated - PAS mapping of type CONS is required for Consultant Upgrade
				ims.pathways.vo.EventVo pthwEvent=null;
				try
				{
					if (isDiagnostic)
						pthwEvent = pathwayImp.getEventByTaxonomyMap(TaxonomyType.PAS, "ADD");
					else
						pthwEvent = pathwayImp.getEventByTaxonomyMap(TaxonomyType.PAS, "ADT");
				}
				catch (DomainInterfaceException e) 
				{
					super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, "Event was not found for Admission code = " + (isDiagnostic ? "ADD" : "ADT"));
				}
				
				if (pthwEvent != null)
				{
					PatientEventVo patientEvent = new PatientEventVo();
					patientEvent.setEvent(pthwEvent);
					if (electiveAdmission.getTCIDetailsIsNotNull() && electiveAdmission.getTCIDetails().getTCIDateIsNotNull())
						patientEvent.setEventDateTime(new DateTime(electiveAdmission.getTCIDetails().getTCIDate()));
					else
						patientEvent.setEventDateTime(new DateTime());	
					patientEvent.setPatient(PatientListVoAssembler.create(domCats.getPatient()));
					patientEvent.setEventStatus(EventStatus.ACTIVE);
					patientEvent.setJourney(PatientJourneyVoAssembler.create(domCats.getJourney()));
					patientEvent.setDescription("Admission Event created from Bed Admission Component");
					pathwayImp.instantiatePatientEvent(patientEvent);
				}
				else // No Event found - proceed as previous
				{
					if (electiveAdmission.getPathwayClock() != null)
					{
						if (electiveAdmission.getTCIDetailsIsNotNull() && electiveAdmission.getTCIDetails().getTCIDateIsNotNull())
							electiveAdmission.getPathwayClock().setStopDate(electiveAdmission.getTCIDetails().getTCIDate());
						else
							electiveAdmission.getPathwayClock().setStopDate(new Date());
					}
					
					RTTStatusEventMapVo rttMap = getRTTStatusEventMap(rttStatus.getRTTStatus());
	
					if (rttMap != null && rttMap.getEvent() != null)
					{
						PatientEventVo patEvent = new PatientEventVo();
						patEvent.setPatient(PatientListVoAssembler.create(domCats.getPatient()));
						patEvent.setEvent(rttMap.getEvent());
						patEvent.setEventDateTime(new DateTime());
						patEvent.setEventStatus(EventStatus.ACTIVE);
						patEvent.setJourney(PatientJourneyVoAssembler.create(domCats.getJourney()));
						pathwayImp.instantiatePatientEvent(patEvent);
					}
				}
			}
			catch (ClassNotFoundException e1) 
			{
				e1.printStackTrace();
				super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, "ClassNotFoundException - " + e1.getMessage());
			}
		}
		
		// Pas event was created, Patient has had it's ward updated
		
		// Create InpatientEpisode
		InpatientEpisode inpatEpisode = null;
//		if (!isAdmitedOnPAS)
//		{
//			// Check for an existing inpatient episode - stop admission process if one exists
//			String query = "SELECT COUNT(inpat.id) FROM InpatientEpisode AS inpat LEFT JOIN inpat.pasEvent AS pasEv LEFT JOIN pasEv.patient AS pat WHERE pat.id = :PAT_ID";
//			long count = getDomainFactory().countWithHQL(query, new String[] {"PAT_ID"}, new Object[] {electiveAdmission.getPatient().getID_Patient()});
//			
//			if (count > 0) throw new DomainInterfaceException("Patient is already admitted");
//			
//			inpatEpisode = new InpatientEpisode();
//		}
//		else
//		{
//			List<?> episodes = getDomainFactory().find("from InpatientEpisode inpatEpis left join fetch inpatEpis.bed as bedspace  where inpatEpis.pasEvent.id = '" + domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent().getId() + "' and bedspace is null" );
//			if(episodes != null && episodes.size() == 1)
//				inpatEpisode = (InpatientEpisode) episodes.get(0);
//		}
		
		if (inpatEpisode == null)
			inpatEpisode = new InpatientEpisode();
			
		inpatEpisode.setPasEvent(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent());
		
		inpatEpisode.getPasEvent().setAttendingHCP(domElectiveAdmission.getConsultant());
		
		inpatEpisode.setAdmissionDateTime(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getAdmissionDateTime());
		inpatEpisode.setEstDischargeDate(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getEstDischargeDate());
		inpatEpisode.setWardType(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getWardType());
		
		if (wardStay != null)
			inpatEpisode.getWardStays().add(WardStayVoAssembler.extractWardStay(getDomainFactory(), wardStay, domMap));
		if (consultant != null)
			inpatEpisode.getConsultantStays().add(ConsultantStayVoAssembler.extractConsultantStay(getDomainFactory(), consultant, domMap));
		
		BedSpaceState doBedSpaceState = BedSpaceStateLiteVoAssembler.extractBedSpaceState(getDomainFactory(), bedSpaceState, domMap);	
		if(doBedSpaceState != null)
		{
			doBedSpaceState.setInpatientEpisode(inpatEpisode);	
			inpatEpisode.setBed(doBedSpaceState);
			inpatEpisode.setBedNo(doBedSpaceState.getBedSpace().getBedNumber());
		}

		if (wardStay != null && wardStay.getWardIsNotNull() && ConfigFlag.UI.VTE_RISK_ASSESSMENT_FUNCTIONALITY.getValue() == true)
		{
			Location doloc = getLocation(wardStay.getWard().getID_Location(), getDomainFactory());
			if (doloc != null && !Boolean.TRUE.equals(doloc.isVTEAsessmentNotRequired()))
			{
				inpatEpisode.setVTEAssessmentStatus(getDomLookup(VTEAsessmentStatus.REQUIRED));
			}
		}
		
		
		//WDEV-12991
		inpatEpisode.setReasonForAdmission(electiveAdmission.getTCIDetails().getAdmissionDetail().getReasonForAdmission());
		
		getDomainFactory().save(inpatEpisode);

		
		
//		if(!isAdmitedOnPAS)
//		{
//			//4) only admit to pas if record is new 
//			Inpat inpatRec = (Inpat)getDTOInstance(Inpat.class);
//			inpatRec.DataCollection.add();
//
//			copyAdmissionToDto(inpatRec, domElectiveAdmission.getTCIDetails().getAdmissionDetail(), null, null);
//			Result res = inpatRec.executeAction("ADMIT");
//			
//			if (res != null && res.getId() < 0 )
//			{
//				if (res.getId() == -5)
//					throw new DomainInterfaceException("Error occurred Admitting Patient to PAS " + res.getMessage());
//				else 
//					throw new DTODomainInterfaceException(res.getId(), "Error occurred Admitting Patient to PAS " + res.getMessage());	
//			}
//			else
//			{
//				if (inpatRec.getLastResultData() == null) {
//					throw new DTODomainInterfaceException(res.getId(), "Error occurred Admitting Patient to PAS : no result data from PAS");
//				}
//					
//				//WDEV-9663
//				domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent().setPasEventId("I_" +  inpatRec.getLastResultData().getValue("DSPN"));
//				domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent().setPasEpisodeId(inpatRec.getLastResultData().getValue("DSPN"));  // WDEV-12588
//				getDomainFactory().save(domElectiveAdmission.getTCIDetails().getAdmissionDetail());
//			}
//		}
		
		//5) a) Create CareSpell,CareContext and EpisodeOfCare 	or b) Use Selected Episode
		// Not needed - PatientElectiveList has a CATS Referral mandatory which in turn has CareContext mandatory
		// createOrSaveCareSpell(getDomainFactory(), domElectiveAdmission.getTCIDetails().getAdmissionDetail());
		
		return PatientElectiveListBedAdmissionVoAssembler.create(domElectiveAdmission);
	}

	
	public AdmissionDetailVo saveEmergencyAdmissionInElectiveCase(AdmissionDetailVo admission, CareSpellVo careSpell, CatsReferralEmergencyAdmissionVo catsReferral, BedSpaceStateLiteVo bedSpaceState, WardStayVo wardStay, ConsultantStayVo consultant) throws DomainInterfaceException, StaleObjectException
	{
		if (admission == null)
			throw new CodingRuntimeException("Admission Details parameter is mandatory.");
		
		if (careSpell == null)
			throw new CodingRuntimeException("Care Spell parameter is mandatory.");
		
		if (catsReferral == null)
			throw new CodingRuntimeException("Cats Referral parameter is mandatory.");
		
		
		PatientPathwayJourneyRefVo journey = createPatientJourney(catsReferral, admission);
		catsReferral.setJourney(journey);
		
		@SuppressWarnings("rawtypes")
		HashMap domMap = new HashMap();
		AdmissionDetail domAdmissionDetail = AdmissionDetailVoAssembler.extractAdmissionDetail(getDomainFactory(), admission, domMap);
		CareSpell domCareSpell = CareSpellVoAssembler.extractCareSpell(getDomainFactory(), careSpell, domMap);
		CatsReferral domCatsReferral = CatsReferralEmergencyAdmissionVoAssembler.extractCatsReferral(getDomainFactory(), catsReferral, domMap);
		domCatsReferral.getCareContext().setPasEvent(domAdmissionDetail.getPasEvent());
		
		getDomainFactory().save(domAdmissionDetail);
		getDomainFactory().save(domCareSpell);
		getDomainFactory().save(domCatsReferral);

		InpatientEpisode inpatEpisode = new InpatientEpisode();
		inpatEpisode.setPasEvent(domAdmissionDetail.getPasEvent());
		inpatEpisode.getPasEvent().setConsultant(domAdmissionDetail.getConsultant());
		inpatEpisode.setAdmissionDateTime(domAdmissionDetail.getAdmissionDateTime());
		inpatEpisode.setEstDischargeDate(null);
		inpatEpisode.setWardType(domAdmissionDetail.getWardType());
		
		if (wardStay != null)
			inpatEpisode.getWardStays().add(WardStayVoAssembler.extractWardStay(getDomainFactory(), wardStay, domMap));
		if (consultant != null)
			inpatEpisode.getConsultantStays().add(ConsultantStayVoAssembler.extractConsultantStay(getDomainFactory(), consultant, domMap));
		
		BedSpaceState doBedSpaceState = BedSpaceStateLiteVoAssembler.extractBedSpaceState(getDomainFactory(), bedSpaceState, domMap);	
		if(doBedSpaceState != null)
		{
			doBedSpaceState.setInpatientEpisode(inpatEpisode);	
			inpatEpisode.setBed(doBedSpaceState);
			inpatEpisode.setBedNo(doBedSpaceState.getBedSpace().getBedNumber());
		}

		if (wardStay != null && wardStay.getWardIsNotNull() && ConfigFlag.UI.VTE_RISK_ASSESSMENT_FUNCTIONALITY.getValue() == true)
		{
			Location doloc = getLocation(wardStay.getWard().getID_Location(), getDomainFactory());
			if (doloc != null && !Boolean.TRUE.equals(doloc.isVTEAsessmentNotRequired()))
			{
				inpatEpisode.setVTEAssessmentStatus(getDomLookup(VTEAsessmentStatus.REQUIRED));
			}
		}
		
		getDomainFactory().save(inpatEpisode);

		return null;
	}

	
	private PatientJourneyVo createPatientJourney(CatsReferralEmergencyAdmissionVo referral, AdmissionDetailVo admission)
	{
		// Only create the patient journey if the flag specified to do this.
		if (!ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue())
			return null;
		
		// If a patientjourney already exists for the referral, then don't create a new one
		PatientJourneyVo journey = new PatientJourneyVo();
		journey.setPatient(referral.getPatient());
		
		try 
		{
			Class<?> implClass = Class.forName("ims.pathways.domain.impl.HL7PathwayIfImpl");
			ims.core.helper.IPathwayPatientEventHelper pathwayImp = (ims.core.helper.IPathwayPatientEventHelper) getDomainImpl(implClass);

			// Create the holding referral first
			Referral domReferral = new Referral();
			domReferral.setAuthoringDateTime(new java.util.Date());			
			domReferral.setClockId("MAXIMS_1");
			domReferral.setReferralType(getDomainFactory().getLookupInstance(ReferralType.INTERNAL.getId()));
			domReferral.setExtReferralKey("IMS_" + new java.util.Date().getTime());
			domReferral.setPatient((ims.core.patient.domain.objects.Patient) getDomainFactory().getDomainObject(ims.core.patient.domain.objects.Patient.class, referral.getPatient().getID_Patient()));
			
			getDomainFactory().save(domReferral);
						
			journey.setReferral(new ReferralRefVo(domReferral.getId(), domReferral.getVersion()));
			
			journey.setStartDate(new Date());
			journey.setExtReferralKey(domReferral.getExtReferralKey());
			journey.setTargetEndDate(referral.getReferralDetails().getEnd18WW());
						
			// Services specialty - if not set then use Emergency
			journey = pathwayImp.createPatientJourney(journey, null, admission.getSpecialty(), null,null);
			

			return journey;
		} 
		catch (ClassNotFoundException exception)
		{
			// Log the exception in application log
			createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Cast exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
			return null;
		}
		catch (DomainInterfaceException e) 
		{
			super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Domain Interface Exception occurred creating patient journey - " + e.getMessage());
			return null;
		} 
		catch (StaleObjectException e) 
		{
			super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Stale Object Exception occurred creating patient journey - " + e.getMessage());
			return null;
		}
	}

	private RTTStatusEventMapVo getRTTStatusEventMap(RTTStatusPoint rttStatusPoint)
	{
		if(rttStatusPoint == null)
			return null;
		
		String query = "select rttMap from RTTStatusEventMap as rttMap left join rttMap.currentRTTStatus as rtt where rtt.id = :RTTStatusPoint and rttMap.event is not null and rttMap.active = 1";
		List<?> listRTTMap = getDomainFactory().find(query, new String[] {"RTTStatusPoint"}, new Object[] {rttStatusPoint.getId()});
		
		if(listRTTMap != null && listRTTMap.size() > 0 && listRTTMap.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) listRTTMap.get(0));
		}
		
		return null;
	}

	private PathwayRTTStatus createPathwayRTTStatus(CatsReferral domCats, boolean isDiagnostic) // WDEV-18617
	{
		if(!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return null;
		
		if(domCats == null)
			return null;
		
		RTTStatusPoint rttStatusPoint =null;
		if (isDiagnostic)
			rttStatusPoint= getRTTStatusPoint(SUBSEQUENT_ACTIVITY);
		else
			rttStatusPoint= getRTTStatusPoint(START_OF_FIRST_DEFINITIVE_TREATMENT);
		
		Object mos = getMosUser();
		MemberOfStaff doMos = null;
		
		if(mos instanceof MemberOfStaffLiteVo)
		{
			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
		}
		
		PathwayRTTStatus pathwayRTTStatus = new PathwayRTTStatus();
		pathwayRTTStatus.setRTTStatus(rttStatusPoint);
		pathwayRTTStatus.setStatusBy(doMos);
		pathwayRTTStatus.setStatusDateTime(new java.util.Date());
		
		if(domCats.getJourney() != null && domCats.getJourney().getCurrentClock() != null)
    	{
			domCats.getJourney().getCurrentClock().setCurrentRTTStatus(pathwayRTTStatus);
    			
    		if(domCats.getJourney().getCurrentClock().getRTTStatusHistory() == null)
    			domCats.getJourney().getCurrentClock().setRTTStatusHistory(new java.util.ArrayList());
    			
    		domCats.getJourney().getCurrentClock().getRTTStatusHistory().add(pathwayRTTStatus);
    	}
		
		return pathwayRTTStatus;
	}

	private RTTStatusPoint getRTTStatusPoint(int nationalCode)
	{
		String query = "select rtt from RTTStatusPoint as rtt where rtt.nationalCode = :NationalCode";
		
		List<?> rttList = getDomainFactory().find(query, new String[] {"NationalCode"}, new Object[] {nationalCode});
		
		if(rttList != null && rttList.size() > 0 && rttList.get(0) instanceof RTTStatusPoint)
		{
			return (RTTStatusPoint) rttList.get(0);
		}
		
		return null;
	}

	/**
	* saveAdmission - save AdmissionDetail record linked to PasEvent(new) and saveInpatientEpisode
	*
	* 1) save admissiondetail
	* 2) save Inpatient Episode
	* 3) update PendingElectiveAdmission or PendingEmergencyAdmission 
	* 4) make DTO call to inpat - action admit only if not already on PAS(waiting area patient)
	* 5) a)Create CareSpell,CareContext and EpisodeOfCare or b)Use selected Episode
	*/
	public void saveAdmissionAndUpdateList(AdmissionDetailVo admissionDetail, BedSpaceStateLiteVo voBedSpaceStateLite, WardStayVo wardStay, ConsultantStayVo voConsStay, PendingElectiveAdmissionAdmitVo voBookedElective, PendingEmergencyAdmissionAdmitVo voEmergency, PendingElectiveAdmissionAdmitVo voPlannedElective, AdmissionType admitType) throws DomainInterfaceException, StaleObjectException	
	{
		if(admissionDetail == null)
			throw new CodingRuntimeException("admissionDetail is mandatory in method saveAdmission");
		if(!admissionDetail.isValidated())
			throw new CodingRuntimeException("admissionDetail has not been validated in method saveAdmission");
			
		DomainFactory factory = getDomainFactory();
		AdmissionDetail doAdmissionDetail = AdmissionDetailVoAssembler.extractAdmissionDetail(factory, admissionDetail);
		
		//already on PAS ie pas Admission previously worked and AdmissionDetail record instantiated (Waiting Area patient)
		boolean isAdmittedOnPAS = false;
		if(doAdmissionDetail.getId() != null)
			isAdmittedOnPAS  = true;

		PendingElectiveAdmissionAdmitVo voElective = null;
		boolean isMaternity = false;
		if(admitType != null)
		{
			if(admitType.equals(AdmissionType.BOOKED))
				voElective  = voBookedElective;
			else if(admitType.equals(AdmissionType.PLANNED))
				voElective = voPlannedElective;
			
			if(voElective.getIsMaternityIsNotNull())
				isMaternity = voElective.getIsMaternity();
		}
		
		doAdmissionDetail.getPasEvent().setConsultant(doAdmissionDetail.getConsultant());
		doAdmissionDetail.getPasEvent().setSpecialty(doAdmissionDetail.getSpecialty());
		doAdmissionDetail.getPasEvent().setPASSpecialty(doAdmissionDetail.getPasEvent() != null ? doAdmissionDetail.getPasEvent().getPASSpecialty() : null);
		doAdmissionDetail.getPasEvent().setLocation(doAdmissionDetail.getWard());
		
		//WDEV-8403
		if(doAdmissionDetail.getPasEvent().getPatient() != null)
			doAdmissionDetail.getPasEvent().getPatient().setWard(doAdmissionDetail.getWard());
		
		//WDEV-10421		
		if(getLoggedInUser() != null)
			doAdmissionDetail.setAdmittingUser((AppUser) getDomainFactory().getDomainObject((AppUserRefVo) getLoggedInUser()));
		
		
		//WDEV-10964 - needed as patient replicate sorts the identifiers and tries to update the collection causing sql errors
		doAdmissionDetail.getPasEvent().getPatient().getIdentifiers().clear();
		List lst = PatientIdAssembler.extractPatientIdList(factory, admissionDetail.getPasEvent().getPatient().getIdentifiers());
		doAdmissionDetail.getPasEvent().getPatient().setIdentifiers(lst);
		
		//1)	
		factory.save(doAdmissionDetail);
		
		// Get CatsReferral if one exists
		if (doAdmissionDetail.getPasEvent() != null && doAdmissionDetail.getPasEvent().getId() != null)
		{
			CatsReferral catsReferral =	(CatsReferral) factory.findFirst("SELECT cats FROM CatsReferral AS cats LEFT JOIN cats.careContext AS context LEFT JOIN context.pasEvent AS pas WHERE pas.id = :PASID AND (cats.isRIE = 0 or cats.isRIE is null)", "PASID", doAdmissionDetail.getPasEvent().getId());
			if (catsReferral != null)
			{
				catsReferral.getAdmissions().add(doAdmissionDetail);
				factory.save(catsReferral);
			}
		}
		
		//2)
		InpatientEpisode doInpatEpis = null;
		if(!isAdmittedOnPAS)
			doInpatEpis = new InpatientEpisode();
		else
		{
			//get existing InpatientEpisode from DB (WDEV-7676)
			List episodes = factory.find("from InpatientEpisode inpatEpis left join fetch inpatEpis.bed as bedspace  where inpatEpis.pasEvent.id = '" + doAdmissionDetail.getPasEvent().getId() + "' and bedspace is null" );
			if(episodes != null && episodes.size() == 1)
				doInpatEpis = (InpatientEpisode) episodes.get(0);
		}
		
		if(doInpatEpis == null)
			throw new DomainInterfaceException("Data Error occurred in Admission - no inpatient episode");
			
		doInpatEpis.setPasEvent(doAdmissionDetail.getPasEvent());
		doInpatEpis.setAdmissionDateTime(doAdmissionDetail.getAdmissionDateTime());
		doInpatEpis.setEstDischargeDate(doAdmissionDetail.getEstDischargeDate());
		doInpatEpis.setWardType(doAdmissionDetail.getWardType());
		doInpatEpis.setIsMaternityInpatient(isMaternity);
		
		if(wardStay != null)
			doInpatEpis.getWardStays().add(WardStayVoAssembler.extractWardStay(factory, wardStay));
		if(voConsStay != null)
			doInpatEpis.getConsultantStays().add(ConsultantStayVoAssembler.extractConsultantStay(factory, voConsStay));
		
		BedSpaceState doBedSpaceState = BedSpaceStateLiteVoAssembler.extractBedSpaceState(factory, voBedSpaceStateLite);	
		if(doBedSpaceState != null)
		{
			doBedSpaceState.setInpatientEpisode(doInpatEpis);	
			doInpatEpis.setBed(doBedSpaceState);
		}
		//wdev-14784
		if( wardStay != null && wardStay.getWardIsNotNull() && ConfigFlag.UI.VTE_RISK_ASSESSMENT_FUNCTIONALITY.getValue() == true) //wdev-15602
		{
			Location doloc = getLocation(wardStay.getWard().getID_Location(), factory);
			if(	doloc != null && !Boolean.TRUE.equals(doloc.isVTEAsessmentNotRequired()))
			{
				doInpatEpis.setVTEAssessmentStatus(getDomLookup(VTEAsessmentStatus.REQUIRED));
			}
		}
		//WDEV-12991
		doInpatEpis.setReasonForAdmission(doAdmissionDetail.getReasonForAdmission());
		
		factory.save(doInpatEpis);
		
		if(doBedSpaceState != null)
			doAdmissionDetail.setBed(doBedSpaceState.getBedSpace());
		
		//WDEV-10593 - only set this once
		if(doAdmissionDetail.getAdmissionTransactionDateTime() == null)
			doAdmissionDetail.setAdmissionTransactionDateTime(new DateTime().getJavaDate());
		
		factory.save(doAdmissionDetail);
		
		//3)
		if(voElective != null && voElective.getID_PendingElectiveAdmissionIsNotNull())
		{
			PendingElectiveAdmission doPending = (PendingElectiveAdmission) factory.getDomainObject(voElective);
			if(doPending != null)
			{
				doPending.setElectiveAdmissionStatus(getDomLookup(ElectiveAdmissionStatus.ADMITTED));
				factory.save(doPending);
			}
		}
		else if(voEmergency != null)
		{
			PendingEmergencyAdmission doPending = (PendingEmergencyAdmission) factory.getDomainObject(voEmergency);
			if(doPending != null)
			{
				doPending.setAdmissionStatus(getDomLookup(EmergencyAdmissionStatus.ADMITTED));
				factory.save(doPending);
			}
		}
		else if(voPlannedElective != null)
		{
			PendingElectiveAdmission doPending = (PendingElectiveAdmission) factory.getDomainObject(voPlannedElective);
			if(doPending != null)
			{
				doPending.setElectiveAdmissionStatus(getDomLookup(ElectiveAdmissionStatus.ADMITTED));
				factory.save(doPending);
			}
		}
		
		if(!isAdmittedOnPAS
				&& Boolean.FALSE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
		{
			//4) only admit to pas if record is new 
			Inpat inpatRec = (Inpat)getDTOInstance(Inpat.class);
			inpatRec.DataCollection.add();

			copyAdmissionToDto(inpatRec, doAdmissionDetail, voElective, admitType);
			Result res = inpatRec.executeAction("ADMIT");
			
			if (res != null && res.getId() < 0 )
			{
				if (res.getId() == -5)
					throw new DomainInterfaceException("Error occurred Admitting Patient to PAS " + res.getMessage());
				else 
					throw new DTODomainInterfaceException(res.getId(), "Error occurred Admitting Patient to PAS " + res.getMessage());	
			}
			else
			{
				if (inpatRec.getLastResultData() == null) {
					throw new DTODomainInterfaceException(res.getId(), "Error occurred Admitting Patient to PAS : no result data from PAS");
				}
					
				//WDEV-9663
				doAdmissionDetail.getPasEvent().setPasEventId("I_" +  inpatRec.getLastResultData().getValue("DSPN"));
				doAdmissionDetail.getPasEvent().setPasEpisodeId(inpatRec.getLastResultData().getValue("DSPN"));  // WDEV-12588
				factory.save(doAdmissionDetail);
			}
		}
		
		//5) a) Create CareSpell,CareContext and EpisodeOfCare 	or b) Use Selected Episode
		createOrSaveCareSpell(factory, doAdmissionDetail);
	}
	//wdev-14784
	private Location getLocation(Integer loc, DomainFactory factory)
	{
		if( loc == null)
			return null;
		
		Location doLocation = (Location) getDomainFactory().getDomainObject(Location.class,loc);
		return doLocation;
		
	}
	
	//method now optionally uses an existing episode and carespell or will create new as previously
	private void createOrSaveCareSpell(DomainFactory factory, AdmissionDetail doAdmissionDetail) throws StaleObjectException
	{
		//WDEV-13001 //5) b) Use Selected Episode
		EpisodeOfCare doEpisode = new EpisodeOfCare();
		CareSpell doCareSpell = new CareSpell();
		if(ConfigFlag.DOM.ADT_LINK_ADMISSION_TO_EPISODE.getValue())
		{
			if(doAdmissionDetail.getAdmissionEpisode() != null)
				doEpisode = doAdmissionDetail.getAdmissionEpisode();
			
			if(doEpisode.getCareSpell() != null)
				doCareSpell = doEpisode.getCareSpell();
		}
		
		doCareSpell.setPatient(doAdmissionDetail.getPasEvent().getPatient());
		
		//WDEV-13001
		if(!ConfigFlag.DOM.ADT_LINK_ADMISSION_TO_EPISODE.getValue())
		{	
			doCareSpell.setStartDate(doAdmissionDetail.getAdmissionDateTime());

			doEpisode.setCareSpell(doCareSpell);
			
			//wdev-14309
			doEpisode.setResponsibleHCP(doAdmissionDetail.getConsultant());
			
			doEpisode.setRelationship(getDomLookup(CareSpelltoEpisodeRelationship.PRIMARY));
			doEpisode.setSpecialty(doAdmissionDetail.getPasEvent().getSpecialty());
			doEpisode.setStartDate( doAdmissionDetail.getAdmissionDateTime());
			//wdev-14309
		}
		
		//WDEV-13001
		if(!ConfigFlag.DOM.ADT_LINK_ADMISSION_TO_EPISODE.getValue())
			doCareSpell.getEpisodes().add(doEpisode);
		
		CareContext doCareContext = new CareContext();
		doCareContext.setEpisodeOfCare(doEpisode);
		doCareContext.setContext(getDomLookup(ContextType.INPATIENT));
		doCareContext.setStartDateTime(doAdmissionDetail.getAdmissionDateTime());
		doCareContext.setPasEvent(doAdmissionDetail.getPasEvent());
		doCareContext.setResponsibleHCP(doEpisode.getResponsibleHCP());
		doCareContext.setEstimatedDischargeDate(doAdmissionDetail.getEstDischargeDate()); //WDEV-11438
		
		doCareContext.setCurrentStatus(new CareContextStatusHistory());
		doCareContext.getCurrentStatus().setStatus(getDomLookup(CareContextStatus.OPEN));
		doCareContext.getCurrentStatus().setStatusDateTime(new java.util.Date());
		
		doEpisode.getCareContexts().add(doCareContext);
		factory.save(doCareSpell);
	}

	public String checkForPatientAlreadyAdmited(PatientRefVo  voPatient)
	{
		if (voPatient == null || voPatient.getID_Patient() == null)
			throw new CodingRuntimeException("voPatient is null or id not provided in method checkForPatientAlreadyAdmited");
			
		InpatientEpisode doInpatEpis = null;
		DomainFactory factory = getDomainFactory();

		List episodes = factory.find("from InpatientEpisode inpatEpis left join fetch inpatEpis.pasEvent as pe where pe.patient.id = '" + voPatient.getID_Patient() + "'" );
		if(episodes != null && episodes.size() == 1) 
		{			
			doInpatEpis = (InpatientEpisode) episodes.get(0);		
			String patientName = doInpatEpis.getPasEvent() != null ? doInpatEpis.getPasEvent().getPatient().getName() != null ? doInpatEpis.getPasEvent().getPatient().getName().toString() : "" : "";

			//wdev-13924
			DateTime dtAdmission = null; 
			if (doInpatEpis.getAdmissionDateTime() != null)
				dtAdmission = new DateTime(doInpatEpis.getAdmissionDateTime());

			return "Patient " +  patientName + " was already admitted on " + (dtAdmission != null ? dtAdmission.toString(DateTimeFormat.STANDARD) : "");
		}

		return null;
	}
	
	private void copyAdmissionToDto(Inpat inpatRec, AdmissionDetail doAdmissionDetail, PendingElectiveAdmissionAdmitVo voElective, AdmissionType admitType) 
	{		
		InpatRecord rec = inpatRec.DataCollection.get(0);
	 	
		inpatRec.EditFilter.excludeAll();
		inpatRec.EditFilter.IncludePkey = true;
		inpatRec.EditFilter.IncludeHospnum = true;
		inpatRec.EditFilter.IncludeHcpcode = true;
		inpatRec.EditFilter.IncludeSpcd = true;
		inpatRec.EditFilter.IncludeRescode = true;
		inpatRec.EditFilter.IncludeMors = true;
		inpatRec.EditFilter.IncludeAddt = true;
		inpatRec.EditFilter.IncludeAdtm = true;
		inpatRec.EditFilter.IncludeReas = true;
		inpatRec.EditFilter.IncludeEddt = true;
		inpatRec.EditFilter.IncludeAdmt = true;
		inpatRec.EditFilter.IncludeAdsc = true;
		inpatRec.EditFilter.IncludeCflup = true;
		inpatRec.EditFilter.IncludeChap = true;
		inpatRec.EditFilter.IncludeAmen = true;
		inpatRec.EditFilter.IncludeConf = true;
		inpatRec.EditFilter.IncludeWebadt = true;
		inpatRec.EditFilter.IncludeBtyp = true; //WDEV-10965
		inpatRec.EditFilter.IncludeRfcd = true; //WDEV-12587
		
		//WDEV-12957
		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO"))
		{
			inpatRec.EditFilter.IncludeStay = true;
			inpatRec.EditFilter.IncludeCflcomm = true;
			inpatRec.EditFilter.IncludeCfl = true;
		}

		//remove from BookedList
		if(admitType != null)
		{
			if(doAdmissionDetail.getMethodOfAdmission().equals(getDomLookup(MethodOfAdmission.BOOKED)) && admitType.equals(AdmissionType.BOOKED))
				rec.Plbk = "B";
			else if(doAdmissionDetail.getMethodOfAdmission().equals(getDomLookup(MethodOfAdmission.PLANNED)) && admitType.equals(AdmissionType.PLANNED))
				rec.Plbk = "P";

			inpatRec.EditFilter.IncludeBookremv = true;
			inpatRec.EditFilter.IncludePlbk = true;
			inpatRec.EditFilter.IncludeBookdate = true;
			inpatRec.EditFilter.IncludeBooktime = true;
				
			rec.Bookremv = "Y";
				
			if(voElective != null)
			{
				if(voElective.getTCIDateIsNotNull())
					rec.Bookdate = DTOHelper.convertToDtoDate(voElective.getTCIDate().getDate());
				if(voElective.getTCITimeIsNotNull())
					rec.Booktime = voElective.getTCITime().toString(TimeFormat.FLAT4);
			}
		}

		rec.Pkey = getPatientIdValue(doAdmissionDetail, PatIdType.PKEY);
		rec.Hospnum = getPatientIdValue(doAdmissionDetail, PatIdType.HOSPNUM);
		rec.Hcpcode = getPasMapping(doAdmissionDetail.getConsultant());
		
		rec.Spcd = DTOHelper.getPasMapping(doAdmissionDetail.getSpecialty());

		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO")
			&& doAdmissionDetail.getPasEvent() != null
			&& doAdmissionDetail.getPasEvent().getPASSpecialty() != null)
			rec.Spcd = DTOHelper.getPasMapping(doAdmissionDetail.getPasEvent().getPASSpecialty());
			
		rec.Rescode = doAdmissionDetail.getWard() != null ? doAdmissionDetail.getWard().getExtCode(TaxonomyType.PAS.getID()) : null;
		rec.Mors = DTOHelper.getPasMapping(doAdmissionDetail.getWardType());
		
		//WDEV-10965 - interim solution
		if(rec.Mors != null)
		{
			if(rec.Mors.equals("M"))
			{
				if(doAdmissionDetail.getPasEvent().getPatient().getSex() != null)
				{
					if(doAdmissionDetail.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.MALE)))
						rec.Btyp = "M";
					else if(doAdmissionDetail.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.FEMALE)))
						rec.Btyp = "F";
					else
						//defaulting Male for unknown sex
						rec.Btyp = "M";
				}
				else
					//defaulting Male for unknown sex
					rec.Btyp = "M";	
			}
			else if(rec.Mors.equals("S"))
				rec.Btyp = "S";
		}
		
		rec.Addt = DTOHelper.convertToDtoDate(doAdmissionDetail.getAdmissionDateTime());
		rec.Adtm = DTOHelper.convertToDtoTime(doAdmissionDetail.getAdmissionDateTime());
		rec.Reas = doAdmissionDetail.getReasonForAdmission() != null && doAdmissionDetail.getReasonForAdmission().length() > 32 ? doAdmissionDetail.getReasonForAdmission().substring(0, 32) : doAdmissionDetail.getReasonForAdmission(); //Hearts restriction of 32 chars
		rec.Admt = DTOHelper.getPasMapping(doAdmissionDetail.getMethodOfAdmission());
		rec.Adsc = DTOHelper.getPasMapping(doAdmissionDetail.getSourceOfAdmission());
		rec.Cflup = doAdmissionDetail.isUpdateCFL() != null && doAdmissionDetail.isUpdateCFL() ? "Y" : "N";
		
		//WDEV-12957
		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO"))
		{
			rec.Cfl = rec.Rescode;
			rec.Cflcomm = doAdmissionDetail.getCaseFolderComments();
			if(doAdmissionDetail.getAdmissionDateTime() != null && doAdmissionDetail.getEstDischargeDate() != null)
				rec.Stay =  String.valueOf(Date.daysBetween( new Date(doAdmissionDetail.getAdmissionDateTime()), new Date(doAdmissionDetail.getEstDischargeDate())));
		}
		
		rec.Chap = doAdmissionDetail.isIsChaplainRequired() ? "Y" : "N";
		if(doAdmissionDetail.getEstDischargeDate() != null)
			rec.Eddt = DTOHelper.convertToDtoDate(doAdmissionDetail.getEstDischargeDate());
		
		//WDEV-8012
		if(doAdmissionDetail.getPasEvent() != null && doAdmissionDetail.getPasEvent().getSourceOfReferral() != null)
			rec.Rfcd = DTOHelper.getPasMapping(doAdmissionDetail.getPasEvent().getSourceOfReferral());
		
		rec.Amen = "N";
		rec.Conf = "N";
		
		//WDEV-7827
		rec.Webadt = "Y";
		
		//wdev-12661
		if(doAdmissionDetail.getPatientStatus() != null)
		{
			inpatRec.EditFilter.IncludeStat = true; //WDEV-12661
			rec.Stat = DTOHelper.getPasMapping(doAdmissionDetail.getPatientStatus());
		}		
		//WDEV-12587
		if(doAdmissionDetail.getReferringConsultant() != null)
		{
			inpatRec.EditFilter.IncludeRefr = true; //WDEV-12587

			rec.Refr = getPasMapping(doAdmissionDetail.getReferringConsultant());
		}
	}

	private void copyHomeLeaveToDto(Homeleave homeLeaveRec, AdmissionDetail doAdmissionDetail, HomeLeaveVo voHomeLeave) 
	{		
		HomeleaveRecord hlRec = homeLeaveRec.DataCollection.get(0);
	 	
		hlRec.Pkey = getPatientIdValue(doAdmissionDetail, PatIdType.PKEY);
		hlRec.Hospnum = getPatientIdValue(doAdmissionDetail, PatIdType.HOSPNUM);

		hlRec.Leavedt = voHomeLeave.getDateOnHomeLeaveIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getDateOnHomeLeave().getDate()) : "";
		hlRec.Leavetm =  voHomeLeave.getTimeOnHomeLeaveIsNotNull() ? voHomeLeave.getTimeOnHomeLeave().toString(TimeFormat.FLAT4) : "";

		hlRec.Exdt = voHomeLeave.getExpectedDateOfReturnIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getExpectedDateOfReturn().getDate()) : "";
		hlRec.Extm = voHomeLeave.getExpectedTimeOfReturnIsNotNull() ? voHomeLeave.getExpectedTimeOfReturn().toString(TimeFormat.FLAT4) : "";

		hlRec.Rescode = doAdmissionDetail.getWard() != null ? doAdmissionDetail.getWard().getExtCode(TaxonomyType.PAS.getID()) : null;
		hlRec.Mors = DTOHelper.getPasMapping(doAdmissionDetail.getWardType());
		if(hlRec.Mors.equals("M"))
		{
			if(doAdmissionDetail.getPasEvent().getPatient().getSex() != null)
			{
				if(doAdmissionDetail.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.MALE)))
					hlRec.Btyp = "M";
				else if(doAdmissionDetail.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.FEMALE)))
					hlRec.Btyp = "F";
				else
					//defaulting Male for unknown sex
					hlRec.Btyp = "M";
			}
			else
				//defaulting Male for unknown sex
				hlRec.Btyp = "M";	
		}
		else if(hlRec.Mors.equals("S"))
			hlRec.Btyp = "S";

		hlRec.Returndt = voHomeLeave.getDateReturnedFromHomeLeaveIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getDateReturnedFromHomeLeave().getDate()) : "";
		hlRec.Returntm = voHomeLeave.getTimeReturnedFromHomeLeaveIsNotNull() ? voHomeLeave.getTimeReturnedFromHomeLeave().toString(TimeFormat.FLAT4) : "";
		
//		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO"))
//			hlRec.Cflup = rec.Rescode;
		
		if (voHomeLeave.getID_HomeLeaveIsNotNull())
			hlRec.Hlfl = "N"; //"N" on an update
		else
			hlRec.Hlfl = "Y"; //"Y" on an insert
		hlRec.Webadt = "Y";				
	}

	private String getPasMapping(Medic consultant) 
	{
		if(consultant == null || consultant.getMos() == null || consultant.getMos().getCodeMappings() == null || consultant.getMos().getCodeMappings().size() == 0)
			return null;
		
		Iterator it = consultant.getMos().getCodeMappings().iterator();
		while(it.hasNext())
		{
			TaxonomyMap map = (TaxonomyMap) it.next();
			if(map.getTaxonomyName().equals(getDomLookup(TaxonomyType.PAS)))
				return map.getTaxonomyCode();
		}
		
		return null;
	}

	private String getPatientIdValue(AdmissionDetail doAdmissionDetail, PatIdType type) 
	{
		if(doAdmissionDetail == null)
			return null;
		
		if(doAdmissionDetail.getPasEvent() != null && doAdmissionDetail.getPasEvent().getPatient() != null && doAdmissionDetail.getPasEvent().getPatient().getIdentifiers() != null)
		{
			Iterator it = doAdmissionDetail.getPasEvent().getPatient().getIdentifiers().iterator();
			while(it.hasNext())
			{
				PatientId patId = (PatientId) it.next();
				if(patId.getType().equals( getDomLookup(type)))
					return patId.getValue();
			}
		}
		
		return null;
	}

	public PendingEmergencyAdmissionAdmitVoCollection listEmergencyAdmission(LocationRefVo voLocation) 
	{
		if(voLocation == null)
			throw new CodingRuntimeException("voLocation is null in method listEmergencyAdmission");
		
		DomainFactory factory = getDomainFactory();
		List pendingEmergencies = factory.find("from PendingEmergencyAdmission pea where pea.allocatedWard.id = :idWard and ( pea.admissionStatus = :discharged or  pea.admissionStatus = :dta )", new String[]{"idWard", "discharged", "dta"}, new Object[]{voLocation.getID_Location(), getDomLookup(EmergencyAdmissionStatus.DISCHARGED), getDomLookup(EmergencyAdmissionStatus.DTA)});
		return PendingEmergencyAdmissionAdmitVoAssembler.createPendingEmergencyAdmissionAdmitVoCollectionFromPendingEmergencyAdmission(pendingEmergencies);
	}

	public PendingElectiveAdmissionAdmitVoCollection listPlannedElectiveAdmission(Date dateFrom, Date dateTo, LocationRefVo ward)
	{
		if(dateFrom == null)
			throw new CodingRuntimeException("dateFrom is mandatory in method listPlannedElectiveAdmission");	
		if(dateTo == null)
			throw new CodingRuntimeException("dateTo is mandatory in method listPlannedElectiveAdmission");
		if(ward == null)
			throw new CodingRuntimeException("ward is null in method listPlannedElectiveAdmission");
		
		DomainFactory factory = getDomainFactory();
		List pendingElectives = factory.find("from PendingElectiveAdmission pea where pea.tCIDate >= :dateFrom and pea.tCIDate <= :dateTo and pea.allocatedWard.id = :idWard and pea.electiveAdmissionStatus = :status and pea.tCIType = :tciType ", new String[]{"dateFrom","dateTo","idWard","status", "tciType"}, new Object[]{dateFrom.getDate(), dateTo.getDate(), ward.getID_Location(), getDomLookup(ElectiveAdmissionStatus.TCI), getDomLookup(TCIType.PLANNED)});
		return PendingElectiveAdmissionAdmitVoAssembler.createPendingElectiveAdmissionAdmitVoCollectionFromPendingElectiveAdmission(pendingElectives);
	}

	public PatientShortCollection searchPatients(PatientFilter filter) throws DomainInterfaceException
	{
		if (filter == null)
			throw new CodingRuntimeException("filter cannot be null in method searchPatients");
			
		PatientSearch impl = (PatientSearch) getDomainImpl(PatientSearchImpl.class);
		return impl.searchPatients(filter);
	}

	public InpatientEpisodeLiteVoCollection listWaitingAreaPatientsByWard(LocationRefVo ward)
	{
		WardView impl = (WardView) getDomainImpl(WardViewImpl.class);
		return impl.listWaitingAreaPatientsByWard(ward);
	}

	public AdmissionDetailVo getAdmissionDetailByPasEvent(PASEventRefVo pasEvent)
	{
		if (pasEvent == null || pasEvent.getID_PASEvent() == null)
			throw new CodingRuntimeException("pasEvent is null or id not provided in method getAdmissionDetailByPasEvent");
		
		List lstAdmissions = getDomainFactory().find("from AdmissionDetail admDet where admDet.pasEvent.id = " + pasEvent.getID_PASEvent());
		if(lstAdmissions != null && lstAdmissions.size() == 1)
			return AdmissionDetailVoAssembler.create((AdmissionDetail) lstAdmissions.get(0));
		
		return null;
	}
	
	public void allocateBed(BedSpaceStateLiteVo bedSpace, InpatientEpisodeLiteVo inpatientEpisode, AdmissionDetailVo admissionDetail, HomeLeaveVo voHomeLeave) throws StaleObjectException, DomainInterfaceException 
	{
		if (inpatientEpisode == null)
			throw new CodingRuntimeException("inpatientEpisode is null in method allocateBed");
		if (bedSpace == null)
			throw new CodingRuntimeException("bedSpace is null in method allocateBed");
		if (admissionDetail == null)
			throw new CodingRuntimeException("admissionDetail is null in method allocateBed");
	
		BedSpaceState doBedSpaceState = BedSpaceStateLiteVoAssembler.extractBedSpaceState(getDomainFactory(), bedSpace);	
		InpatientEpisode doInpatEpis = InpatientEpisodeLiteVoAssembler.extractInpatientEpisode(getDomainFactory(), inpatientEpisode);
		AdmissionDetail doAdmissionDetail = AdmissionDetailVoAssembler.extractAdmissionDetail(getDomainFactory(), admissionDetail);
		
		if(doBedSpaceState != null)
		{
			doBedSpaceState.setInpatientEpisode(doInpatEpis);	
			doInpatEpis.setBed(doBedSpaceState);
		}
		
		if(voHomeLeave != null)
		{
			for(int i = 0 ; doInpatEpis.getHomeLeaves().size() > 0 && i < doInpatEpis.getHomeLeaves().size() ; i++)
			{
				 HomeLeave doHL = (HomeLeave)doInpatEpis.getHomeLeaves().get(i);
				 if (doHL != null
					&& doHL.getDateReturnedFromHomeLeave() == null)
				 {
					 doHL.setDateReturnedFromHomeLeave(voHomeLeave.getDateReturnedFromHomeLeaveIsNotNull() ? voHomeLeave.getDateReturnedFromHomeLeave().getDate() : null);
					 doHL.setTimeReturnedFromHomeLeave(voHomeLeave.getTimeReturnedFromHomeLeaveIsNotNull() ? voHomeLeave.getTimeReturnedFromHomeLeave().toString() : null);
					 
					 doInpatEpis.getHomeLeaves().set(i, doHL);
				 }
			}
			doInpatEpis.setIsOnHomeLeave(false);
			doInpatEpis.setDateOnHomeLeave(null);
			doInpatEpis.setTimeOnHomeLeave(null);
			doInpatEpis.setExpectedDateOfReturn(null);
			doInpatEpis.setExpectedTimeOfReturn(null);
			doInpatEpis.setVacatedBedNumber(null);
			
			//UPDATE PAS THAT NO LONGER ON HOME LEAVE 
			if (Boolean.FALSE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			{
				Homeleave hlRec = (Homeleave)getDTOInstance(Homeleave.class);
				hlRec.DataCollection.add();

				copyHomeLeaveToDto(hlRec, doAdmissionDetail, voHomeLeave);
				
				Result res = hlRec.update();
				if (res != null && res.getId() < 0 )
				{
					if (res.getId() == -5)
						throw new DomainInterfaceException("Error occurred saving Home Leave record to PAS " + res.getMessage());
					else 
						throw new DTODomainInterfaceException(res.getId(), "Error occurred saving Home Leave record to PAS " + res.getMessage());	
				}
			}
		}
		
		getDomainFactory().save(doInpatEpis);
		
		if(doBedSpaceState != null)
			doAdmissionDetail.setBed(doBedSpaceState.getBedSpace());
		
		getDomainFactory().save(doAdmissionDetail);
	}

	/**
	 * HEARTS Service Call to Conspc
	 */
	public SpecialtyCollection listSpecialtiesFromConSpc(String consultantMapping) throws DomainInterfaceException
	{
		if (consultantMapping == null || consultantMapping.equals(""))
			throw new CodingRuntimeException("consultantMapping cannot be null in method listSpecialtiesFromConSpc");
		
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;
		
		String extSystem = ConfigFlag.DOM.DEMOGRAPHICS_EXT_SYSTEM.getValue();

		SpecialtyCollection specColl = new SpecialtyCollection();

		Conspc conspc = (Conspc) getDTOInstance(Conspc.class);
		conspc.Filter.clear();
		conspc.Filter.Cons = consultantMapping;
		conspc.list();

		ConspcRecord rec;
		String recordMappings = "";
		int count = conspc.DataCollection.count();
		for (int i = 0; i < count; i++)
		{
			rec = conspc.DataCollection.get(i);
			recordMappings += "'" + rec.Spcd + "'";
			recordMappings += ((count - (i+1)) > 0 ? "," : "");			
		}

		if(count > 0)
		{
			List specs = getDomainFactory().find("from LookupInstance lkp join lkp.mappings as map where type = " + Specialty.TYPE_ID + " and map.extSystem = 'PAS' and map.extCode in (" + recordMappings + ")");
			specColl = constructSpecialtyLookupCollection(specs);
		}
		
		return specColl;
	}

	public PASSpecialtyCollection listCCOSpecialtiesFromConSpc(String consultantMapping) throws DomainInterfaceException
	{
		if (consultantMapping == null || consultantMapping.equals(""))
			throw new CodingRuntimeException("consultantMapping cannot be null in method listCCOSpecialtiesFromConSpc");
		
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;

		String extSystem = ConfigFlag.DOM.DEMOGRAPHICS_EXT_SYSTEM.getValue();

		PASSpecialtyCollection specColl = new PASSpecialtyCollection();

		Conspc conspc = (Conspc) getDTOInstance(Conspc.class);
		conspc.Filter.clear();
		conspc.Filter.Cons = consultantMapping;
		conspc.list();

		ConspcRecord rec;
		String recordMappings = "";
		int count = conspc.DataCollection.count();
		for (int i = 0; i < count; i++)
		{
			rec = conspc.DataCollection.get(i);
			recordMappings += "'" + rec.Spcd + "'";
			recordMappings += ((count - (i+1)) > 0 ? "," : "");			
		}

		if(count > 0)
		{
			List specs = getDomainFactory().find("from LookupInstance lkp join lkp.mappings as map where type = " + PASSpecialty.TYPE_ID + " and map.extSystem = 'PAS' and map.extCode in (" + recordMappings + ")");
			specColl = constructCCOSpecialtyLookupCollection(specs);
		}
		return specColl;
	}

	private SpecialtyCollection constructSpecialtyLookupCollection(List specs)
	{
		if (specs == null)
			throw new CodingRuntimeException("specs cannot be null in method constructSpecialtyLookupCollection");
		
		SpecialtyCollection collSpec = new SpecialtyCollection();
		for(java.util.Iterator iterator = specs.iterator(); iterator.hasNext(); ) 
		{
			ims.framework.utils.ImagePath img = null;
			ims.framework.utils.Color color = null;
		
			ims.domain.lookups.LookupInstance instance = 
				(ims.domain.lookups.LookupInstance) iterator.next();
			if (instance.getImage() != null) 
			{
				img = new ims.framework.utils.ImagePath(instance.getImage().getImageId(), instance.getImage().getImagePath());
			}
			else 
			{
				img = null;
			}
			color = instance.getColor();
			if (color != null) 
				color.getValue();
			
			
			Specialty voInstance = new Specialty(instance.getId(),instance.getText(), instance.isActive(), null, img, color);
			Specialty parentVoInstance = voInstance;
			ims.domain.lookups.LookupInstance parent = instance.getParent();
			while (parent != null)
			{
				if (parent.getImage() != null) 
				{
					img = new ims.framework.utils.ImagePath(parent.getImage().getImageId(), parent.getImage().getImagePath());
				}
				else 
				{
					img = null;
				}
				color = parent.getColor();
				if (color != null) 
					color.getValue();
			
				parentVoInstance.setParent(new Specialty(parent.getId(),parent.getText(), parent.isActive(), null, img, color));
				parentVoInstance = parentVoInstance.getParent();
				parent = parent.getParent();
			}
			LookupMappingVoCollection voMapColl = new LookupMappingVoCollection();
			for(java.util.Iterator iteratorMap = instance.getMappings().iterator(); iteratorMap.hasNext(); ) 
			{
				LookupMapping instanceMap = (LookupMapping) iteratorMap.next();
				
				voMapColl.add(new LookupMappingVo(instanceMap.getExtSystem(), instanceMap.getExtCode()));
			}
			
			voInstance.setMappings(voMapColl);

			collSpec.add(voInstance);
		}
		
		return collSpec;
	}

	private PASSpecialtyCollection constructCCOSpecialtyLookupCollection(List specs)
	{
		if (specs == null)
			throw new CodingRuntimeException("specs cannot be null in method constructCCOSpecialtyLookupCollection");
		
		PASSpecialtyCollection collSpec = new PASSpecialtyCollection();
		for(java.util.Iterator iterator = specs.iterator(); iterator.hasNext(); ) 
		{
			ims.framework.utils.ImagePath img = null;
			ims.framework.utils.Color color = null;
		
			ims.domain.lookups.LookupInstance instance = 
				(ims.domain.lookups.LookupInstance) iterator.next();
			if (instance.getImage() != null) 
			{
				img = new ims.framework.utils.ImagePath(instance.getImage().getImageId(), instance.getImage().getImagePath());
			}
			else 
			{
				img = null;
			}
			color = instance.getColor();
			if (color != null) 
				color.getValue();
			
			
			PASSpecialty voInstance = new PASSpecialty(instance.getId(),instance.getText(), instance.isActive(), null, img, color);
			PASSpecialty parentVoInstance = voInstance;
			ims.domain.lookups.LookupInstance parent = instance.getParent();
			while (parent != null)
			{
				if (parent.getImage() != null) 
				{
					img = new ims.framework.utils.ImagePath(parent.getImage().getImageId(), parent.getImage().getImagePath());
				}
				else 
				{
					img = null;
				}
				color = parent.getColor();
				if (color != null) 
					color.getValue();
			
				parentVoInstance.setParent(new PASSpecialty(parent.getId(),parent.getText(), parent.isActive(), null, img, color));
				parentVoInstance = parentVoInstance.getParent();
				parent = parent.getParent();
			}			
			
			LookupMappingVoCollection voMapColl = new LookupMappingVoCollection();
			for(java.util.Iterator iteratorMap = instance.getMappings().iterator(); iteratorMap.hasNext(); ) 
			{
				LookupMapping instanceMap = (LookupMapping) iteratorMap.next();
				
				voMapColl.add(new LookupMappingVo(instanceMap.getExtSystem(), instanceMap.getExtCode()));
			}
			
			voInstance.setMappings(voMapColl);
			collSpec.add(voInstance);
		}
		
		return collSpec;
	}

	public String getPasMappingFromConsultant(IMos mos)
	{
		//WDEV-9946 undo of changes
		if (mos == null || mos.getIMosId() == null)
			throw new CodingRuntimeException("mos is null or id not provided in method getPasMappingFromConsultant");
		
		//WDEV-9946 undo of changes
		MemberOfStaff doMos = (MemberOfStaff) getDomainFactory().getDomainObject(MemberOfStaff.class, mos.getIMosId());
		return MemberOfStaffMappingsLiteVoAssembler.create(doMos).getPasCode();
	}

	//WDEV-10908 for replicating if needed
	public Patient getPatient(PatientShort patient) throws StaleObjectException, DomainInterfaceException
	{
		Demographics demographicsImpl = (Demographics) getDomainImpl(DemographicsImpl.class);
		
		Patient pat = null;
		try
		{
			pat = demographicsImpl.getPatient(patient);
		}
		catch (DomainRuntimeException e)
		{
			throw new DomainInterfaceException(e.getMessage());
		}

		return pat;
	}

	//get all open active episodes and then get the primary diagnosis associated with each
	public EpisodeOfCareWithPrimaryDiagnosisVoCollection listOpenEpisodesForPatient(PatientRefVo patient)
	{
		if (patient == null || patient.getID_Patient() == null)
			throw new CodingRuntimeException("patient is null or id not provided in method listOpenEpisodesForPatient");
		
		EpisodeOfCareWithPrimaryDiagnosisVoCollection  voCollEpisodes = null;
		
		String hql = "from EpisodeOfCare as epis left join fetch epis.responsibleHCP as hcp left join fetch hcp.mos as mos left join fetch epis.careSpell as cs where epis.endDate is null and cs.patient.id = " + patient.getID_Patient();
		List episodes = getDomainFactory().find(hql);
		if(episodes != null)
		{
			voCollEpisodes = EpisodeOfCareWithPrimaryDiagnosisVoAssembler.createEpisodeOfCareWithPrimaryDiagnosisVoCollectionFromEpisodeOfCare(episodes);
			for(EpisodeOfCareWithPrimaryDiagnosisVo voEpis : voCollEpisodes)
			{
	
				//get the primary diagnosis if it exists
				String primaryHql = "select distinct primary.diagnosisDescription from CsPrimaryDiagnosis as csp left join csp.diagnosis as primary where (csp.episodeOfCare.id = :episId and csp.isActive = :status)";
				List diagnosisNames = getDomainFactory().find(primaryHql, new String[]{"episId", "status"}, new Object[]{ voEpis.getID_EpisodeOfCare(), Boolean.TRUE});
				if(diagnosisNames != null && diagnosisNames.size() > 0)
				{
					String strDisplay = "";
					int i=0;
					Iterator it = diagnosisNames.iterator();
					while(it.hasNext())
					{
						if(i > 0)
							strDisplay += ",";	
						
						strDisplay += (String)it.next();
						i++;
					}
					
					if(strDisplay.equals(""))
						strDisplay = "unknown";
						
					voEpis.setPrimaryDiagnosisName(" - " + strDisplay + " - ");
				}
				else
					voEpis.setPrimaryDiagnosisName(" - unknown - ");
			}
		}
		
		return voCollEpisodes;
	}

	public Specialty getSpecialtyMappingFromPASSpecialty(String szMapping) 
	{
		if (szMapping == "")
			return null;

		List specs = getDomainFactory().find("from LookupInstance lkp join lkp.mappings as map where type = " + Specialty.TYPE_ID + " and map.extSystem = 'PAS' and map.extCode = '" + szMapping + "'");
		SpecialtyCollection specColl = constructSpecialtyLookupCollection(specs);
		return specColl.size() > 0 ? specColl.get(0) : null;
	}

	public PASSpecialty getPASSpecialtyMappingFromSpecialty(String szMapping) 
	{
		if (szMapping == "")
			return null;
		
		List specs = getDomainFactory().find("from LookupInstance lkp join lkp.mappings as map where type = " + PASSpecialty.TYPE_ID + " and map.extSystem = 'PAS' and map.extCode = '" + szMapping + "'");
		PASSpecialtyCollection specColl = constructCCOSpecialtyLookupCollection(specs);
		return specColl.size() > 0 ? specColl.get(0) : null;
	}

	public Specialty getCCOSpecialtyMappingFromPASSpecialty(PASSpecialty pasSpecialty) 
	{
		if (pasSpecialty == null)
			return null;
		
		String szMapping = null;
		for (int i = 0 ; pasSpecialty.getMappings() != null && i < pasSpecialty.getMappings().size() ; i++)
		{
			if (pasSpecialty.getMappings().get(i).getExtSystem().equals("PAS"))
				szMapping = pasSpecialty.getMappings().get(i).getExtCode();
		}
		if (szMapping != null)
			return getSpecialtyMappingFromPASSpecialty(szMapping);
		else
			return null;
	}

	public InpatientEpisodeLiteVoCollection listHomeLeavesByWard(LocationRefVo ward) 
	{
		if(ward == null || ward.getID_Location() == null)
			throw new CodingRuntimeException("ward is null or id not provide in method listInpatientEpisodeByWard");
		
		String hql = getHomeLeavesQuery(false);//	WDEV-14563
		
		List<?> inpatEpis = getDomainFactory().find(hql, new String[]{"idWard", "bTRUE","idWard2", "status"}, new Object[]{ward.getID_Location(), Boolean.TRUE, ward.getID_Location(),getDomLookup(TransferStatus.PENDING) });
		return InpatientEpisodeLiteVoAssembler.createInpatientEpisodeLiteVoCollectionFromInpatientEpisode(inpatEpis);
	}

	//	WDEV-14563
	public Boolean hasHomeLeavesByWard(LocationRefVo ward) 
	{
		if(ward == null || ward.getID_Location() == null)
			throw new CodingRuntimeException("ward is null or id not provide in method listInpatientEpisodeByWard");
		
		String hql = getHomeLeavesQuery(true);
		
		List<?> inpatEpis = getDomainFactory().find(hql, new String[]{"idWard", "bTRUE","idWard2", "status"}, new Object[]{ward.getID_Location(), Boolean.TRUE, ward.getID_Location(),getDomLookup(TransferStatus.PENDING) });
		
		if(inpatEpis != null && inpatEpis.size() > 0)
		{
			if(((Long) inpatEpis.get(0)) > 0)
				return true;
		}
		
		return false;
	}

	//	WDEV-14563
	private String getHomeLeavesQuery(boolean count) 
	{
		String hql = "from InpatientEpisode inpat where (inpat.pasEvent.location.id = :idWard and inpat.isOnHomeLeave = :bTRUE" +
			" and inpat.pasEvent.patient not in ( select pend.inpatientEpisode.pasEvent.patient from PendingTransfers pend where pend.inpatientEpisode.pasEvent.location.id = :idWard2 and pend.currentStatus = :status ))";
		
		if(count)
		{
			return "select count(inpat.id) " + hql;
		}
		
		return hql + " order by inpat.pasEvent.patient.name.upperSurname asc,inpat.pasEvent.patient.name.upperForename asc";
	}

	//WDEV-16062
	public InpatientEpisodeLiteVo getInpatientEpisode(InpatientEpisodeRefVo inpatientRef)
	{
		if(inpatientRef == null)
		{
			throw new CodingRuntimeException("Cannot get InpatientEpisode on null Id.");
		}
		
		return InpatientEpisodeLiteVoAssembler.create((InpatientEpisode) getDomainFactory().getDomainObject(InpatientEpisode.class, inpatientRef.getID_InpatientEpisode()));
	}

	public BedSpaceStateLiteVo getBedSpaceState(BedSpaceStateRefVo bedRef)
	{
		if(bedRef == null || bedRef.getID_BedSpaceState() == null)
			throw new CodingRuntimeException("Cannot get BedSpaceState on null Id.");
		
		return BedSpaceStateLiteVoAssembler.create(	(BedSpaceState)	getDomainFactory().getDomainObject(BedSpaceState.class, bedRef.getID_BedSpaceState()));
	}


	public PatientElectiveListBedInfoVoCollection listPatientElective(LocationRefVo ward, Date fromDate, Date toDate)
	{
		StringBuilder query = new StringBuilder();
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		query.append("SELECT pel FROM PatientElectiveList AS pel ");
		query.append("LEFT JOIN pel.electiveListStatus AS els LEFT JOIN els.electiveListStatus AS elStatus ");
		query.append("LEFT JOIN pel.tCIDetails AS tci LEFT JOIN tci.tCIWard AS ward ");
		query.append("LEFT JOIN pel.patient AS patient ");
		
		query.append("WHERE ward.id = :WARD AND elStatus.id = :TCI_GIVEN AND tci.isActive = 1 AND tci.currentOutcome is null ");
		paramNames.add("WARD");
		paramValues.add(ward.getID_Location());
		paramNames.add("TCI_GIVEN");
		paramValues.add(WaitingListStatus.TCI_GIVEN.getId());
		
		if (fromDate != null)
		{
			query.append(" AND tci.tCIDate >= :FROM_DATE");
			paramNames.add("FROM_DATE");
			paramValues.add(fromDate.getDate());
		}
		
		if (toDate != null)
		{
			query.append(" AND tci.tCIDate <= :TO_DATE");
			paramNames.add("TO_DATE");
			paramValues.add(toDate.getDate());
		}
		
		query.append(" ORDER BY patient.name.surname, patient.name.forename");

		return PatientElectiveListBedInfoVoAssembler.createPatientElectiveListBedInfoVoCollectionFromPatientElectiveList(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}


	public PatientElectiveListBedAdmissionVo getPatientElectiveAdmission(PatientElectiveListRefVo patientElectiveList)
	{
		if (patientElectiveList == null || patientElectiveList.getID_PatientElectiveList() == null)
			return null;
		
		return PatientElectiveListBedAdmissionVoAssembler.create((PatientElectiveList) getDomainFactory().getDomainObject(PatientElectiveList.class, patientElectiveList.getID_PatientElectiveList()));
	}

	public PatientShort getPatientShort(PatientRefVo patient)
	{
		if (patient == null || patient.getID_Patient() == null)
			return null;
		
		return PatientShortAssembler.create((ims.core.patient.domain.objects.Patient) getDomainFactory().getDomainObject(ims.core.patient.domain.objects.Patient.class, patient.getID_Patient()));
	}


	public MedicVo getMedic(HcpRefVo hcp)
	{
		if (hcp == null || hcp.getID_Hcp() == null)
			return null;
		
		String query = "SELECT medic FROM Medic AS medic WHERE medic.id = :ID";

		return MedicVoAssembler.create((Medic) getDomainFactory().findFirst(query, "ID", hcp.getID_Hcp()));
	}

	public Boolean hasPatientElectiveListToCancel(PatientRefVo patient, PatientElectiveListRefVo electiveElist, ServiceRefVo service)
	{
		if (patient == null || patient.getID_Patient() == null)
			return Boolean.FALSE;
		
		if (service == null || service.getID_Service() == null)
			return Boolean.FALSE;
		
		StringBuilder query = new StringBuilder("SELECT COUNT(pel.id) FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service LEFT JOIN pel.patient AS patient LEFT JOIN pel.tCIDetails AS tci");
		query.append(" WHERE pel.id <> :PEL_ID AND patient.id = :PAT_ID AND service.id = :SERVICE_ID AND tci.isActive = 0");
		
		ArrayList<String> paramNames = new ArrayList<String>();							ArrayList<Object> paramValues = new ArrayList<Object>();
		paramNames.add("PEL_ID");														paramValues.add(electiveElist.getID_PatientElectiveList());
		paramNames.add("PAT_ID");														paramValues.add(patient.getID_Patient());
		paramNames.add("SERVICE_ID");													paramValues.add(service.getID_Service());
		
		long count = getDomainFactory().countWithHQL(query.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray(new Object[paramValues.size()]));
		
		if (count > 0)
			return Boolean.TRUE;
		
		return Boolean.FALSE;
	}

	public PatientElectiveListBedAdmissionVoCollection getPatientElectiveListToCancel(PatientRefVo patient, PatientElectiveListRefVo electiveElist, ServiceRefVo service)
	{
		if (patient == null || patient.getID_Patient() == null)
			return null;
		
		if (service == null || service.getID_Service() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service LEFT JOIN pel.patient AS patient LEFT JOIN pel.tCIDetails AS tci");
		query.append(" WHERE pel.id <> :PEL_ID AND patient.id = :PAT_ID AND service.id = :SERVICE_ID AND tci.isActive = 0");
		
		ArrayList<String> paramNames = new ArrayList<String>();							ArrayList<Object> paramValues = new ArrayList<Object>();
		paramNames.add("PEL_ID");														paramValues.add(electiveElist.getID_PatientElectiveList());
		paramNames.add("PAT_ID");														paramValues.add(patient.getID_Patient());
		paramNames.add("SERVICE_ID");													paramValues.add(service.getID_Service());
		
		return PatientElectiveListBedAdmissionVoAssembler.createPatientElectiveListBedAdmissionVoCollectionFromPatientElectiveList(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}


	public Boolean isPatientAnInpatient(PatientRefVo patient)
	{
		if (patient == null || patient.getID_Patient() == null)
			throw new CodingRuntimeException("Can not check if patient is an inpatient for invalid record.");
		
		String query = "SELECT COUNT (ipEp.id) FROM InpatientEpisode AS ipEp LEFT JOIN ipEp.pasEvent AS pas LEFT JOIN pas.patient AS pat WHERE pat.id = :PAT_ID";
		
		long count = getDomainFactory().countWithHQL(query, new String[] {"PAT_ID"}, new Object[] {patient.getID_Patient()});
		
		if (count > 0)
			return Boolean.TRUE;
		
		return Boolean.FALSE;
	}

	
	public HcpLiteVo getHcpFromIMos(ims.vo.interfaces.IMos iMos)
	{
		if (iMos == null || iMos.getIMosHcpId() == null)
			return null;
		
		return HcpLiteVoAssembler.create((Hcp) getDomainFactory().getDomainObject(Hcp.class, iMos.getIMosHcpId()));
	}


	public PatientWithGPForCCGVo getPatientForCCG(PatientRefVo patient)
	{
		if (patient == null || patient.getID_Patient() == null)
			return null;
		
		return PatientWithGPForCCGVoAssembler.create((ims.core.patient.domain.objects.Patient) getDomainFactory().getDomainObject(ims.core.patient.domain.objects.Patient.class, patient.getID_Patient()));
	}


	public ContractConfigShortVo getContractByCCG(String codeCCG)
	{
		if (codeCCG == null || codeCCG.length() == 0)
			return null;
		
		String query = "SELECT contract FROM ContractConfig AS contract LEFT JOIN contract.cCGsForContract AS ccgContract WHERE ccgContract.cCGCode = :CCG_CONTRACT AND ccgContract.isActive = 1";
		
		return ContractConfigShortVoAssembler.create((ContractConfig) getDomainFactory().findFirst(query, "CCG_CONTRACT", codeCCG));
	}

	
	public String getCodeCCGFromPostalCode(String postCode)
	{
		if (postCode == null || postCode.length() == 0)
			return null;
		
		String query = "SELECT ccg FROM CCGPCTPCCodes AS ccg WHERE ccg.postcode = :POST_CODE";
		CCGPCTPCCodes ccgCode = (CCGPCTPCCodes) getDomainFactory().findFirst(query, "POST_CODE", postCode);
		
		if (ccgCode != null)
			return ccgCode.getCCGCode();
		
		return null;
	}


	public ServiceLiteVoCollection getServicesBySpecialty(Specialty specialty)
	{
		if (specialty == null)
			return null;
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		String query = "SELECT serv FROM Service AS serv LEFT JOIN serv.specialty AS serviceSpecialty WHERE serviceSpecialty.id = :SPECIALTY_ID AND serv.isActive = 1";
		paramNames.add("SPECIALTY_ID");
		paramValues.add(specialty.getID());
		
		return ServiceLiteVoAssembler.createServiceLiteVoCollectionFromService(getDomainFactory().find(query, paramNames, paramValues));
	}
}
