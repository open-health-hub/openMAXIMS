//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by George Cristian Josan using IMS Development Environment (version 1.65 build 3195.25608)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.core.domain.impl;

import ims.core.admin.domain.objects.HrgConfig;
import ims.core.domain.base.impl.BaseHRGConfigurationImpl;
import ims.core.vo.HrgConfigVo;
import ims.core.vo.NonUniqueTaxonomyMapVo;
import ims.core.vo.domain.HrgConfigLiteVoAssembler;
import ims.core.vo.domain.HrgConfigVoAssembler;
import ims.core.vo.lookups.TaxonomyType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;

import java.util.ArrayList;
import java.util.List;

public class HRGConfigurationImpl extends BaseHRGConfigurationImpl
{

	private static final long serialVersionUID = 1L;

	/**
	 * List all the HRG Configuration in the system
	 */
	public ims.core.vo.HrgConfigLiteVoCollection listHRGConfiguration()
	{
		// Build the query
		String query = "from HrgConfig as hrg";

		DomainFactory factory = getDomainFactory();

		return HrgConfigLiteVoAssembler.createHrgConfigLiteVoCollectionFromHrgConfig(factory.find(query));
	}

	/**
	 * Get the detailed HRG Configuration VO
	 */
	public ims.core.vo.HrgConfigVo getHRGConfiguration(ims.core.admin.vo.HrgConfigRefVo configuration)
	{
		if (configuration == null)
			return null;

		DomainFactory factory = getDomainFactory();

		return HrgConfigVoAssembler.create((HrgConfig) factory.getDomainObject(HrgConfig.class, configuration.getID_HrgConfig()));
	}

	/**
	 * Saves an HRG Configuration
	 */
	public ims.core.vo.HrgConfigVo saveHRGConfiguration(ims.core.vo.HrgConfigVo configuration) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException
	{
		// Test for a validated VO provided
		if (configuration == null)
			throw new DomainInterfaceException("Can not save an empty HRG Configuration.");

		if (!configuration.isValidated())
			throw new DomainInterfaceException("Invalid HRG Configuration. Can not save");

		try
		{
			// Save the VO data in the database
			DomainFactory factory = getDomainFactory();
			String hrgCode = areMappingsPairInUse(configuration, factory);
			if (hrgCode != null)
			{
				throw new UniqueKeyViolationException(hrgCode+" HRG Configuration contains a duplicate ICD10/OPCS4 mapping. No duplicates allowed.");
			}

			// Check for unique HRG Code (as RIE records are not to be
			// considered, the check has to be done manually)
			String query = new String();
			if (configuration.getID_HrgConfigIsNotNull())
				query = "from HrgConfig as hrg where hRGCode = '" + configuration.getHRGCode() + "' and hrg.id <> " + configuration.getID_HrgConfig().toString() + " and hrg.isRIE is null";
			else
				query = "from HrgConfig as hrg where hRGCode = '" + configuration.getHRGCode() + "' and hrg.isRIE is null";

			List results = factory.find(query);
			if (results != null && results.size() > 0)
				throw new UniqueKeyViolationException("Another HRG Configuration with the same HRG Code already exists in the system");

			HrgConfig hrgConfiguration = HrgConfigVoAssembler.extractHrgConfig(factory, configuration);
			factory.save(hrgConfiguration);
			return HrgConfigVoAssembler.create(hrgConfiguration);
		}
		catch (UnqViolationUncheckedException e)
		{
			throw new UniqueKeyViolationException("The taxonomy mappings of the HRG Configuration are already in use");
		}
	}

	private String areMappingsPairInUse(HrgConfigVo configuration, DomainFactory df)
	{
		if (configuration == null || !configuration.getMappingsIsNotNull())
			return null;
		ArrayList<String> opcsValue = new ArrayList<String>();
		ArrayList<String> icdValue = new ArrayList<String>();

		for (int i = 0; i < configuration.getMappings().size(); i++)
		{
			NonUniqueTaxonomyMapVo tmVo = configuration.getMappings().get(i);
			if (TaxonomyType.OPCS4.equals(tmVo.getTaxonomyName()))
			{
				opcsValue.add(tmVo.getTaxonomyCode());

			}
			else
			{
				if (TaxonomyType.ICD10.equals(tmVo.getTaxonomyName()))
				{
					icdValue.add(tmVo.getTaxonomyCode());
				}
			}
		}

		if (opcsValue.size() == 0 || icdValue.size() == 0)
			return null;

		String select = "select distinct hrgC.hRGCode from HrgConfig as hrgC " + 
		"left join hrgC.mappings as mapp left join mapp.taxonomyName as tnm where " + 
		"(hrgC.id in (select distinct subhrgC.id from HrgConfig as subhrgC " +
		"left join subhrgC.mappings as submapp left join submapp.taxonomyName as subtnm where " + 
		"(submapp.taxonomyCode in (" + getStringForHql(opcsValue) + ") and subtnm.id = " + TaxonomyType.OPCS4.getID() +
		(configuration.getID_HrgConfigIsNotNull() ? (" and subhrgC.id<>" + configuration.getID_HrgConfig()) : "") + 
		" )) and mapp.taxonomyCode in (" + getStringForHql(icdValue) + ") and tnm.id = " + TaxonomyType.ICD10.getID() +
		(configuration.getID_HrgConfigIsNotNull() ? (" and hrgC.id<>" + configuration.getID_HrgConfig()) : "") + " )";
		
		List<?> codes = df.find(select);
		if (codes == null || codes.size() == 0)
			return null;
		
		return (String) codes.get(0);
	}
	
	private String getStringForHql(ArrayList<String> list)
	{
		StringBuilder result = new StringBuilder();
		for (int i = 0 ; i < list.size() ; i++)
		{
			result.append("'");
			result.append(list.get(i));
			result.append("'");
			if (i < list.size()-1)
			{
				result.append(", ");
			}
		}
		return result.toString();
	}
}
