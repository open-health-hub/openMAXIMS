//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Marius Mihalec using IMS Development Environment (version 1.35 build 2102.13596)
// Copyright (C) 1995-2005 IMS MAXIMS plc. All rights reserved.

package ims.ocrr.domain.impl;

import ims.admin.domain.HcpAdmin;
import ims.admin.domain.MosAdmin;
import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.HcpAdminImpl;
import ims.admin.domain.impl.MosAdminImpl;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.OrderInvAppt;
import ims.RefMan.vo.CatsReferralListVo;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.OrderInvWithStatusApptVo;
import ims.RefMan.vo.domain.CatsReferralListVoAssembler;
import ims.RefMan.vo.domain.OrderInvWithStatusApptVoAssembler;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.clinical.domain.ClinicalNotesList;
import ims.clinical.domain.impl.ClinicalNotesListImpl;
import ims.clinical.domain.objects.SummaryClinicalInformation;
import ims.clinical.vo.SummaryClinicalInformationVo;
import ims.clinical.vo.domain.SummaryClinicalInformationVoAssembler;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.pas.domain.objects.InpatientEpisode;
import ims.core.admin.pas.domain.objects.OutpatientAttendance;
import ims.core.admin.pas.domain.objects.PASEvent;
import ims.core.admin.pas.vo.PASEventRefVo;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.Gp;
import ims.core.resource.people.domain.objects.Hcp;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.domain.objects.Clinic;
import ims.core.resource.place.domain.objects.LocSite;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.ClinicRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.ClinicLiteVo;
import ims.core.vo.ClinicLiteVoCollection;
import ims.core.vo.ClinicalNotesFilterVo;
import ims.core.vo.ClinicalNotesLiteVoCollection;
import ims.core.vo.GeneralQuestionAnswerVoCollection;
import ims.core.vo.GpLiteVo;
import ims.core.vo.GpShortVoCollection;
import ims.core.vo.HcpCollection;
import ims.core.vo.HcpFilter;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.LocShortMappingsVoCollection;
import ims.core.vo.LocShortVoCollection;
import ims.core.vo.LocSiteLiteVo;
import ims.core.vo.LocSiteShortVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVoCollection;
import ims.core.vo.MemberOfStaffShortVo;
import ims.core.vo.MemberOfStaffShortVoCollection;
import ims.core.vo.PasEventShortVo;
import ims.core.vo.PersonName;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.ClinicLiteVoAssembler;
import ims.core.vo.domain.GeneralQuestionAnswerVoAssembler;
import ims.core.vo.domain.GpLiteVoAssembler;
import ims.core.vo.domain.GpShortVoAssembler;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.LocSiteShortVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.PasEventShortVoAssembler;
import ims.core.vo.lookups.ClinicalNoteType;
import ims.core.vo.lookups.GPStatus;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.PollStatus;
import ims.domain.DomainFactory;
import ims.domain.DomainObject;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.impl.DomainImpl;
import ims.domain.lookups.LookupInstance;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.ILocation;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;
import ims.ocrr.configuration.domain.objects.Container;
import ims.ocrr.configuration.domain.objects.DFTCollectionTypesConfig;
import ims.ocrr.configuration.domain.objects.Investigation;
import ims.ocrr.configuration.domain.objects.InvestigationIndex;
import ims.ocrr.configuration.domain.objects.Specimen;
import ims.ocrr.configuration.vo.InvestigationIndexRefVo;
import ims.ocrr.configuration.vo.InvestigationRefVo;
import ims.ocrr.domain.CategoryQuestions;
import ims.ocrr.domain.DFTCollectionTypeConfigurations;
import ims.ocrr.domain.ServiceQuestions;
import ims.ocrr.domain.SpecimenCollectionConfig;
import ims.ocrr.helper.IOCRRSchedulingHelper;
import ims.ocrr.orderingresults.domain.objects.OcsOrderSession;
import ims.ocrr.orderingresults.domain.objects.OrderInvestigation;
import ims.ocrr.orderingresults.domain.objects.OrderSpecimen;
import ims.ocrr.orderingresults.domain.objects.OrderedInvestigationStatus;
import ims.ocrr.orderingresults.domain.objects.SpecimenWorkListItem;
import ims.ocrr.orderingresults.vo.OcsOrderSessionRefVo;
import ims.ocrr.orderingresults.vo.OrderInvestigationRefVo;
import ims.ocrr.orderingresults.vo.OrderInvestigationRefVoCollection;
import ims.ocrr.vo.CategoryQuestionShortVoCollection;
import ims.ocrr.vo.DFTCollectionTypesConfigVo;
import ims.ocrr.vo.InvestigationHelpTextVo;
import ims.ocrr.vo.InvestigationQuestionAnswerVoCollection;
import ims.ocrr.vo.InvestigationUnderSpecimenVo;
import ims.ocrr.vo.MyOrderInpatEpisVo;
import ims.ocrr.vo.MyOrderOutpatAttendVo;
import ims.ocrr.vo.MyOrderOutpatAttendVoCollection;
import ims.ocrr.vo.OcsOrderVo;
import ims.ocrr.vo.OrderInvestigationBookingWithStatusVo;
import ims.ocrr.vo.OrderInvestigationForStatusChangeVo;
import ims.ocrr.vo.OrderInvestigationLiteVo;
import ims.ocrr.vo.OrderInvestigationVo;
import ims.ocrr.vo.OrderSpecimenVo;
import ims.ocrr.vo.OrderSpecimenVoCollection;
import ims.ocrr.vo.PathInvDetailsVo;
import ims.ocrr.vo.PathSpecimenContainerVo;
import ims.ocrr.vo.PathSpecimenContainerVoCollection;
import ims.ocrr.vo.PhlebotomyRoundShortVoCollection;
import ims.ocrr.vo.ServiceQuestionShortVoCollection;
import ims.ocrr.vo.SpecimenCollectionListConfigDetailsVoCollection;
import ims.ocrr.vo.SpecimenWorkListItemVo;
import ims.ocrr.vo.SpecimenWorkListItemVoCollection;
import ims.ocrr.vo.domain.DFTCollectionTypesConfigVoAssembler;
import ims.ocrr.vo.domain.InvestigationHelpTextVoAssembler;
import ims.ocrr.vo.domain.InvestigationQuestionAnswerVoAssembler;
import ims.ocrr.vo.domain.InvestigationQuestionsSelectOrderVoAssembler;
import ims.ocrr.vo.domain.InvestigationUnderSpecimenVoAssembler;
import ims.ocrr.vo.domain.MyOrderInpatEpisVoAssembler;
import ims.ocrr.vo.domain.MyOrderOutpatAttendVoAssembler;
import ims.ocrr.vo.domain.OcsOrderVoAssembler;
import ims.ocrr.vo.domain.OrderInvestigationBookingWithStatusVoAssembler;
import ims.ocrr.vo.domain.OrderInvestigationForStatusChangeVoAssembler;
import ims.ocrr.vo.domain.OrderInvestigationLiteVoAssembler;
import ims.ocrr.vo.domain.PathInvDetailsVoAssembler;
import ims.ocrr.vo.domain.PathSpecimenContainerVoAssembler;
import ims.ocrr.vo.domain.PhlebotomyRoundShortVoAssembler;
import ims.ocrr.vo.domain.SpecimenWorkListItemVoAssembler;
import ims.ocrr.vo.enums.ORDERSTATE;
import ims.ocrr.vo.lookups.AuthorisationOrderStatus;
import ims.ocrr.vo.lookups.Category;
import ims.ocrr.vo.lookups.InvEventType;
import ims.ocrr.vo.lookups.LookupHelper;
import ims.ocrr.vo.lookups.OcsDisplayFlag;
import ims.ocrr.vo.lookups.OrderCategory;
import ims.ocrr.vo.lookups.OrderInvStatus;
import ims.ocrr.vo.lookups.OrderPriority;
import ims.ocrr.vo.lookups.OrderPriorityCollection;
import ims.ocrr.vo.lookups.SpecimenCollectionMethod;
import ims.ocrr.vo.lookups.SpecimenCollectionTime;
import ims.ocs_if.helper.GHGWinPathNumbers;
import ims.scheduling.domain.OCSExternalEvents;
import ims.scheduling.domain.SessionAdmin;
import ims.scheduling.domain.impl.OCSExternalEventsImpl;
import ims.scheduling.domain.impl.SessionAdminImpl;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.vo.ValueObject;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.log4j.Logger;

import com.sun.org.apache.bcel.internal.generic.NEW;

public class MyOrderImpl extends DomainImpl implements ims.ocrr.domain.MyOrder, ims.domain.impl.Transactional
{
	private static final long	serialVersionUID	= 1L;
	private static final Logger		LOG		= Logger.getLogger(MyOrderImpl.class);

	/**
	 * Returns a list of questions
	 */
	public ims.ocrr.vo.InvestigationQuestionsSelectOrderVo getQuestions(ims.ocrr.vo.MyOrderComponentVo component)
	{
		return InvestigationQuestionsSelectOrderVoAssembler.create((Investigation) getDomainFactory().getDomainObject(Investigation.class, component.getID().intValue()));
	}

	public HcpCollection listHcp(String text)
	{
		if (text == null || text.length() == 0)
			throw new DomainRuntimeException("Filter not supplied");

		HcpFilter filter = new HcpFilter();
		filter.setQueryName(new PersonName());
		filter.getQueryName().setSurname(text);

		HcpAdmin impl = (HcpAdmin) getDomainImpl(HcpAdminImpl.class);
		return impl.listHCPs(filter);
	}

	public MemberOfStaffShortVoCollection listMos(String text)
	{
		if (text == null || text.length() == 0)
			throw new DomainRuntimeException("Filter not supplied");

		MemberOfStaffShortVo filter = new MemberOfStaffShortVo();
		filter.setName(new PersonName());
		filter.getName().setSurname(text);
		filter.setIsActive(true);

		MosAdmin impl = (MosAdmin) getDomainImpl(MosAdminImpl.class);
		return impl.listMembersOfStaffWithPrimaryLocations(filter);
	}

	public OcsOrderVo saveOcsOrder(OcsOrderVo ocsOrder, SpecimenWorkListItemVoCollection voCollWorkListItem, ORDERSTATE state, CatsReferralRefVo referral, Booking_AppointmentRefVo appt) throws StaleObjectException
	{
		if (ocsOrder == null)
			throw new DomainRuntimeException("Cannot save null value for OcsOrderVo");
		
		if (!ocsOrder.isValidated())
			throw new DomainRuntimeException("OcsOrderVo has not been validated");

		DomainFactory factory = getDomainFactory();
		HashMap objMap = new HashMap();

		OcsOrderSession doCurrentOcsOrder = null;
		if(ocsOrder.getID_OcsOrderSessionIsNotNull())
		{
			doCurrentOcsOrder = (OcsOrderSession) factory.getDomainObject(OcsOrderSession.class, ocsOrder.getID_OcsOrderSession().intValue());
			//updating the order
			if(state == ORDERSTATE.AUTHORISING && doCurrentOcsOrder.getId() != null)
			{
				Iterator it2 = doCurrentOcsOrder.getSpecimens().iterator();
				String idsValues = "";
				while (it2.hasNext())
				{
					OrderSpecimen doSpecimen = (OrderSpecimen) it2.next();
					if(idsValues.length() > 0)
						idsValues += ",";

					idsValues += doSpecimen.getId();
				}

				if(idsValues != null && !idsValues.equals(""))
				{
					try
					{
						factory.delete("from SpecimenWorkListItem item where item.specimen.id in ( " + idsValues + " ) ");
					}
					catch (ForeignKeyViolationException e)
					{
						throw new CodingRuntimeException ("delete of SpecimenWorkListItem failed - Foreign Key Violation in updateOcsOrder");
					}
				}
			}
		}

		// Remove OrderSpecimen for DTF investigations
		// This is hack to get it to work. The entire MyOrder form needs to be 
		clearOrderSpecimensFromOrderInvestigationsDFT(ocsOrder, state);

		// For the Specimen Worklist items
		processSpecimenWorklistItems(ocsOrder, voCollWorkListItem);
		

		OcsOrderSession doOcsOrder = OcsOrderVoAssembler.extractOcsOrderSession(factory, ocsOrder, objMap);

		setDefaults(doOcsOrder, state);
		//update the order
		factory.save(doOcsOrder);
		//WDEV-7493
		Set<?> s =doOcsOrder.getSpecimens();
		for (Object object : s)
		{
			OrderSpecimen os = (OrderSpecimen)object;
			if(ConfigFlag.DOM.USE_GHG_SPECIMEN_NUMBERING.getValue())
			{
				String placerNumber = new GHGWinPathNumbers().getOCSNumber(os.getId());
				os.setPlacerOrdNum(placerNumber);
			}
			else
			{
				DecimalFormat myFormatter = new DecimalFormat("000000000");  // Required for placer order number
				os.setPlacerOrdNum(myFormatter.format(os.getId()));
			}
		}
		
		Set<?> investigations = doOcsOrder.getInvestigations();
		for (Object object : investigations)
		{
			OrderInvestigation investigation = (OrderInvestigation) object;
			
			if (Category.PATHOLOGY.equals(LookupHelper.getCategoryInstance(getLookupService(), investigation.getInvestigation().getInvestigationIndex().getCategory().getId())))
			{
				if (InvEventType.SINGLE_EVENT.equals(LookupHelper.getInvEventTypeInstance(getLookupService(), investigation.getInvestigation().getEventType().getId())) && investigation.getSpecimen() != null)
				{
					List<?> specimens = investigation.getSpecimen();

					if (specimens.size() > 0)
					{
						investigation.setPlacerOrdNum(((OrderSpecimen)specimens.get(0)).getPlacerOrdNum());
					}
				}
				else
				{
					DecimalFormat timeSeriesFormatter = new DecimalFormat("G00000000");
					investigation.setPlacerOrdNum(timeSeriesFormatter.format(investigation.getId()));
				}
			}
			else
			{
				DecimalFormat nonPathologyFormatter = new DecimalFormat("000000000");
				investigation.setPlacerOrdNum(nonPathologyFormatter.format(investigation.getId()));
			}
		}
		
		factory.save(doOcsOrder);
		//end WDEV-7493 see change below as well
		
		
		if (voCollWorkListItem != null && voCollWorkListItem.size() > 0)
			voCollWorkListItem = saveWorkListItems(factory, voCollWorkListItem, objMap, state);

		CatsReferral doReferral = null;
		if(referral != null)
			doReferral = (CatsReferral) factory.getDomainObject(referral);
		
		//WDEV-6787
		//get each OrderInvestigation record and create and save a new OrderInvAppt record for the appt
		//add the newly created OrdInvAppt records to the CatReferral and save and (send message - at end of method)
		Map extEvents = null;
		if(appt != null)
		{
			extEvents = new HashMap();
			Booking_Appointment doAppt = (Booking_Appointment)factory.getDomainObject(appt);
			Iterator it = doOcsOrder.getInvestigations().iterator();
			while(it.hasNext())
			{
			 	OrderInvestigation doOrderInv = (OrderInvestigation) it.next();
			 	
			 	if (!(doOrderInv.getOrdInvCurrentStatus() != null && getDomLookup(OrderInvStatus.CANCEL_REQUEST).equals(doOrderInv.getOrdInvCurrentStatus().getOrdInvStatus())))
			 	{			 	
			 		//dont link invs to appts that can't be scheduled
			 		if(!canInvBeScheduled(doOrderInv))
			 			continue;

			 		OrderInvAppt doOrdInvAppt = new OrderInvAppt();

			 		//WDEV-6967
			 		OrderedInvestigationStatus status = new OrderedInvestigationStatus();
			 		status.setOrdInvStatus(getDomLookup(OrderInvStatus.ORDERED));
			 		status.setChangeDateTime(new java.util.Date());	
			 		status.setProcessedDateTime(new java.util.Date());
			 		status.setChangeUser(getHcpLiteUser() != null ? ((HcpLiteVo) getHcpLiteUser()).getIMosName() : null);
			 		doOrderInv.setOrdInvCurrentStatus(status);
			 		doOrderInv.getOrdInvStatusHistory().add(status);

			 		doOrdInvAppt.setOrderInvestigation(doOrderInv);
			 		doOrdInvAppt.setAppointment(doAppt);
			 		if(doAppt != null)
			 			doOrderInv.setAppointmentDate(doAppt.getAppointmentDate());

			 		doOrdInvAppt.setStatus(getDomLookup(PollStatus.CANCELNOTPROCESSED));
			 		if(doReferral != null)
			 			doReferral.getOrderInvAppts().add(doOrdInvAppt);

			 		if (doOrdInvAppt.getAppointment() != null && doOrdInvAppt.getOrderInvestigation() != null)
			 		{
			 			extEvents.put(new OrderInvestigationRefVo(doOrdInvAppt.getOrderInvestigation().getId(), doOrdInvAppt.getOrderInvestigation().getVersion()), new Booking_AppointmentRefVo(doOrdInvAppt.getAppointment().getId(), doOrdInvAppt.getAppointment().getVersion()));
			 		}
			 	}
			}
		}

		//update the CatsReferal WDEV-5560
		if(doReferral != null)
		{
			doReferral.getInvestigationOrders().add(doOcsOrder);
			
			//WDEV-5727 - setHasInvestigations
			doReferral.setHasInvestigations(true);
			
			factory.save(doReferral);
		}
		
		//WDEV-6787 - send message after save as message end was causing data problems - generateNewOrderEvent method did some get calls
		if(extEvents != null)
		{
			OCSExternalEvents impl = (OCSExternalEvents) getDomainImpl(OCSExternalEventsImpl.class);
			Iterator it = extEvents.entrySet().iterator();
			while(it.hasNext())
			{
				Map.Entry entry = (Entry) it.next();
				impl.generateNewOrderEvent((Booking_AppointmentRefVo )entry.getValue(), (OrderInvestigationRefVo)entry.getKey());
			}
		}
		
		return OcsOrderVoAssembler.create(doOcsOrder);
	}


	/**
	 *	Remove OrderSpecimens from OrderInvestigation created in error for DFT 
	 * @param state 
	 */
	private void clearOrderSpecimensFromOrderInvestigationsDFT(OcsOrderVo ocsOrder, ORDERSTATE state)
	{
		OrderSpecimenVoCollection specimens = new OrderSpecimenVoCollection();
		OrderInvestigationRefVoCollection investigationsDFT = new OrderInvestigationRefVoCollection();
		
		for (OrderInvestigationVo investigation : ocsOrder.getInvestigations())
		{
			if (InvEventType.TIME_SERIES.equals(investigation.getInvestigation().getEventType()))
			{
				investigation.setSpecimen(null);
				investigationsDFT.add(investigation);
				
				// Do not change the status of Cancelled or Cancel Requests orders
				if (investigation.getOrdInvCurrentStatus() == null
						|| (!OrderInvStatus.CANCEL_REQUEST.equals(investigation.getOrdInvCurrentStatus().getOrdInvStatus())
								&& !OrderInvStatus.CANCELLED.equals(investigation.getOrdInvCurrentStatus().getOrdInvStatus())))
				{
					// Set status as requested
					if (ORDERSTATE.AUTHORISING.equals(state))
					{
						investigation.getOrdInvCurrentStatus().setOrdInvStatus(OrderInvStatus.ORDERED);
						investigation.setDisplayFlag(OcsDisplayFlag.REQUESTED);
					}
					else
					{
						investigation.getOrdInvCurrentStatus().setOrdInvStatus(OrderInvStatus.AWAITING_AUTHORISATION);
						investigation.setDisplayFlag(OcsDisplayFlag.REQUESTED);
					}
				}
			}
		}
		
		for (OrderSpecimenVo specimen : ocsOrder.getSpecimens())
		{
			OrderInvestigationRefVoCollection investigationNonDFT = getNonDFTInvestigation(specimen, investigationsDFT);
			
			if (investigationNonDFT != null && investigationNonDFT.size() > 0)
			{
				specimen.setInvestigations(investigationNonDFT);
				specimens.add(specimen);
			}
		}
		
		ocsOrder.setSpecimens(specimens);
	}


	/**
	 * For SpecimenWorklist items created for DFT investigation remove the OrderSpecimen entry
	 */
	private void processSpecimenWorklistItems(OcsOrderVo order, SpecimenWorkListItemVoCollection specimenWorklistItems)
	{
		if (specimenWorklistItems != null)
		{
    		for (SpecimenWorkListItemVo specimen : specimenWorklistItems)
    		{
    			if (specimen.getDFTOrderInvestigation() != null)
    				specimen.setSpecimen(null);
    		}
		}
	}

	
	
	private OrderInvestigationRefVoCollection getNonDFTInvestigation(OrderSpecimenVo specimen, OrderInvestigationRefVoCollection investigationsDFT)
	{
		OrderInvestigationRefVoCollection nonDFTInvestigations = new OrderInvestigationRefVoCollection();
		
		if (specimen.getInvestigations() != null)
		{
			for (OrderInvestigationRefVo investigation : specimen.getInvestigations())
			{
				if (investigationsDFT == null || !investigationsDFT.contains(investigation))
					nonDFTInvestigations.add(investigation);
			}
		}

		return nonDFTInvestigations;
	}

	private boolean canInvBeScheduled(OrderInvestigation doOrderInv)
	{
		if(doOrderInv.getInvestigation() != null && doOrderInv.getInvestigation().getProviderService() != null && doOrderInv.getInvestigation().getProviderService().getLocationService() != null && doOrderInv.getInvestigation().getProviderService().getLocationService().getService() != null && doOrderInv.getInvestigation().getProviderService().getLocationService().getService().isCanBeScheduled() != null)
			return doOrderInv.getInvestigation().getProviderService().getLocationService().getService().isCanBeScheduled();
		
		return false;
	}

	private void setDefaults(OcsOrderSession doOcsOrder, ORDERSTATE state)
	{
		if (doOcsOrder == null || state == null)
			throw new CodingRuntimeException("Coding Error - Order or state is null");

		if(state.equals(ORDERSTATE.CANCELLED))
			doOcsOrder.setAuthorisationOrderStatus( getDomLookup(AuthorisationOrderStatus.CANCELLED));
		else if(state.equals(ORDERSTATE.REQUESTING_AUTHORISATION))
			doOcsOrder.setAuthorisationOrderStatus( getDomLookup(AuthorisationOrderStatus.AWAITING_AUTHORISATION));
		else if(state.equals(ORDERSTATE.AUTHORISING))
			doOcsOrder.setAuthorisationOrderStatus( getDomLookup(AuthorisationOrderStatus.AUTHORISED));

		//defaults
		Iterator it = doOcsOrder.getInvestigations().iterator();
		while (it.hasNext())
		{
			OrderInvestigation doOrderInv = (OrderInvestigation) it.next();
		
			if (OrderInvStatus.CANCEL_REQUEST.getID() != doOrderInv.getOrdInvCurrentStatus().getOrdInvStatus().getId()) //WDEV-16998
			{
				doOrderInv.getOrdInvStatusHistory().add(doOrderInv.getOrdInvCurrentStatus());
				doOrderInv.setDisplayTimeSupplied(Boolean.FALSE);

				// WDEV-3602
				doOrderInv.setResponsibleClinician(doOcsOrder.getResponsibleClinician());
				doOrderInv.setResponsibleGp(doOcsOrder.getResponsibleGp());
				doOrderInv.setPatientClinic(doOcsOrder.getPatientClinic());
				doOrderInv.setPatientLocation(doOcsOrder.getPatientLocation());
				
				// WDEV-18165 set ParentLocation dependent on current location
				if (doOrderInv.getPatientLocation() != null)
					doOrderInv.setParentLocation(doOrderInv.getPatientLocation().getParentLocation());
				else if (doOrderInv.getPatientClinic() != null)
					doOrderInv.setParentLocation(doOrderInv.getPatientClinic().getClinicLocation());
				
				// If the OrderInvestigation locations are not set, then its outpatient department
				// so get the parent location from there.
				if (doOrderInv.getParentLocation() == null && doOcsOrder.getOutpatientDept() != null)
					doOrderInv.setParentLocation(doOcsOrder.getOutpatientDept().getParentLocation());
			}
		}
//		doOcsOrder.getSpecimens()
		//WDEV-7493 
		for (Object iterable_element : doOcsOrder.getSpecimens())
		{
			OrderSpecimen spec = (OrderSpecimen) iterable_element;
			String token = "Do not use:" + (Double.valueOf(Math.random()*10000).toString().substring(0,4));
			spec.setPlacerOrdNum(token);
		}
		//End WDEV-7493
	}

	public InvestigationUnderSpecimenVo getInvestigationUnderSpecimen(Integer idInvestigation)
	{
		if (idInvestigation == null)
			throw new DomainRuntimeException("No id provided for getInvestigationUnderSpecimen");

		DomainFactory factory = getDomainFactory();
		return InvestigationUnderSpecimenVoAssembler.create((Investigation) factory.getDomainObject(Investigation.class, idInvestigation));
	}

	public SpecimenCollectionListConfigDetailsVoCollection listSpecimenCollectionDetails(SpecimenCollectionMethod type, Date date)
	{
		SpecimenCollectionConfig impl = (SpecimenCollectionConfig) getDomainImpl(SpecimenCollectionConfigImpl.class);
		return impl.listSpecimenCollectionDetails(type, date);
	}

	public ClinicalNotesLiteVoCollection listClinicalNotesByCareContextAndNoteType(CareContextRefVo careContext, ClinicalNoteType noteType)
	{
		ClinicalNotesList impl = (ClinicalNotesList) getDomainImpl(ClinicalNotesListImpl.class);
		ClinicalNotesFilterVo voFilter = new ClinicalNotesFilterVo();

		voFilter.setNoteType(noteType);
		voFilter.setCareContext(careContext);

		return impl.listClinicalNoteLite(voFilter);
	}

	public LocationLiteVoCollection listActiveLocationsByName(String name)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveLocationsByName(name);
	}

	public PathSpecimenContainerVoCollection getAdultOrPaediatricContainerforProfileInvestigation(InvestigationIndexRefVo invIndex, Boolean isUsePaediatricContainer)
	{
		if (invIndex == null)
			throw new CodingRuntimeException("No id supplied for get - method getSpecimenDetailsforProfileInvestigation()");

		DomainFactory factory = getDomainFactory();
		InvestigationIndex doInvIndex = (InvestigationIndex) factory.getDomainObject(InvestigationIndex.class, invIndex.getID_InvestigationIndex());

		Investigation doInvestigation = null;
		if (doInvIndex.getInvestigations().iterator().hasNext())
			doInvestigation = (Investigation) doInvIndex.getInvestigations().iterator().next();

		if (doInvestigation != null)
		{
			// TODO - This needs to be updated when coding for complex investigation
			Specimen specimen = (Specimen) doInvestigation.getPathInvDetails().getSpecimens().get(0);
			
			if (isUsePaediatricContainer.booleanValue())
			{
				return PathSpecimenContainerVoAssembler.createPathSpecimenContainerVoCollectionFromPathSpecimenContainer(specimen.getPaediatricContainers());
//				Container paediatricContainer = (Container) specimen.getPaediatricContainers();
//				return PathSpecimenContainerVoAssembler.create(paediatricContainer.getSpecContainer());
			}
			else
			{
				return PathSpecimenContainerVoAssembler.createPathSpecimenContainerVoCollectionFromPathSpecimenContainer(specimen.getPaediatricContainers());
//				Container adultContainer = (Container) specimen.getPaediatricContainers().get(0);
//				return PathSpecimenContainerVoAssembler.create(adultContainer.getSpecContainer());
			}
		}

		return null;
	}

	public PathInvDetailsVo getPathInvDetailsForInvestigation(Integer idInvestigation)
	{
		DomainFactory factory = getDomainFactory();

		List invDetails = factory.find("select inv.pathInvDetails from Investigation inv where inv.id = :idInv", new String[]{"idInv"}, new Object[]{idInvestigation});
		if (invDetails != null && invDetails.size() > 0)
			return PathInvDetailsVoAssembler.createPathInvDetailsVoCollectionFromPathInvDetails(invDetails).get(0);

		return null;
	}

	private SpecimenWorkListItemVoCollection saveWorkListItems(DomainFactory factory, SpecimenWorkListItemVoCollection workListitems, HashMap objMap, ORDERSTATE state) throws StaleObjectException
	{
		if (workListitems == null)
			throw new CodingRuntimeException("No workListitems to save - method saveWorkListItems()");

		List items = SpecimenWorkListItemVoAssembler.extractSpecimenWorkListItemList(factory, workListitems, null, objMap);
		Iterator it = items.iterator();

		while (it.hasNext())
		{
			SpecimenWorkListItem item = (SpecimenWorkListItem) it.next();
			if(state.equals(ORDERSTATE.REQUESTING_AUTHORISATION))
				item.setCollectionStatus(getDomLookup(ims.ocrr.vo.lookups.SpecimenCollectionStatus.AWAITING_AUTHORISATION));

			factory.save(item);
		}

		workListitems = SpecimenWorkListItemVoAssembler.createSpecimenWorkListItemVoCollectionFromSpecimenWorkListItem(items);
		return workListitems;
	}

	public GpShortVoCollection listGPsBySurname(String text)
	{
		if(text == null)
    		throw new CodingRuntimeException("text is mandatory in method listGPsBySurname");

		text = text.replaceAll("%", "");

		String hql = "from Gp gp where gp.name.upperSurname like :surname and gp.status = :activeStatus order by gp.name.upperSurname";
		return GpShortVoAssembler.createGpShortVoCollectionFromGp(getDomainFactory().find(hql, new String[] {"surname", "activeStatus"}, new Object[] {text.toUpperCase() + "%", getDomLookup(GPStatus.ACTIVE)}));
	}

	public PhlebotomyRoundShortVoCollection listClosedRounds(Date date, SpecimenCollectionTime round, LocationRefVo ward)
	{
		if (date == null || round == null || ward == null)
			return null;

		DomainFactory factory = getDomainFactory();

		String hql = "select pRound from PhlebotomyRound" + " as pRound left join pRound.wards as ward where pRound.date = :date and pRound.roundToCollect = :round and ward.id = :wardId";

		List items = factory.find(hql, new String[]{"date", "round", "wardId"}, new Object[]{date.getDate(), getDomLookup(round), ward.getID_Location()});
		if (items != null && items.size() > 0)
			return PhlebotomyRoundShortVoAssembler.createPhlebotomyRoundShortVoCollectionFromPhlebotomyRound(items);

		return null;
	}

	public HcpLiteVoCollection listResponsibleMedicsByName(String strMedicName) 
	{
		HcpFilter filter = new HcpFilter();
		PersonName name = new PersonName();
		name.setSurname(strMedicName);
		filter.setQueryName(name);
		
		HcpAdmin impl = (HcpAdmin) getDomainImpl(HcpAdminImpl.class);
		HcpLiteVoCollection voCollHcp = impl.listResponsibleMedics(filter); //WDEV-11656
		return voCollHcp;
	}
	public HcpLiteVoCollection listHcpLiteByName(String hcpName)
	{
		if (hcpName == null || hcpName.length() == 0)
			return null;
		
		String query = "SELECT hcp FROM Hcp AS hcp LEFT JOIN hcp.mos AS mos WHERE hcp.isActive = 1 AND hcp.isHCPaResponsibleHCP = 1 AND mos.name.upperSurname LIKE :HCP_NAME";
		
		return HcpLiteVoAssembler.createHcpLiteVoCollectionFromHcp(getDomainFactory().find(query, "HCP_NAME", hcpName.toUpperCase() + "%")).sort();
	}

	public LocShortMappingsVoCollection listActiveHospitals()
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveHospitals();
	}

	public ServiceQuestionShortVoCollection listActiveServiceQuestions(Integer serviceId)
	{
		ServiceQuestions impl = (ServiceQuestions) getDomainImpl(ServiceQuestionsImpl.class);

		ServiceRefVo voServiceRef = new ServiceRefVo();
		voServiceRef.setID_Service(serviceId);

		return impl.listServiceQuestions(voServiceRef);

	}

	public CategoryQuestionShortVoCollection listActiveCategoryQuestions(Category category)
	{
		CategoryQuestions impl = (CategoryQuestions) getDomainImpl(CategoryQuestionsImpl.class);
		return impl.listCategoryQuestions(category);
	}

	public ILocation getParentHospital(ValueObject wardOrClinicOrOutpatientDepartment)
	{
		if(wardOrClinicOrOutpatientDepartment == null)
			throw new CodingRuntimeException("wardOrClinic parameter is null in method getParentHospital");

		DomainFactory factory = getDomainFactory();

		if(wardOrClinicOrOutpatientDepartment instanceof LocationLiteVo)
		{
			LocationLiteVo voLocLite = (LocationLiteVo) wardOrClinicOrOutpatientDepartment;
			Location doLocation = (Location) factory.getDomainObject(Location.class, voLocLite.getID());
			return getHospital(doLocation);
		}
		else if (wardOrClinicOrOutpatientDepartment instanceof LocSiteLiteVo)
		{
			LocSiteLiteVo voLocStieLite = (LocSiteLiteVo) wardOrClinicOrOutpatientDepartment;
			Location doLocation = (Location) factory.getDomainObject(Location.class, voLocStieLite.getID_Location());
			return getHospital(doLocation);
		}
		else if(wardOrClinicOrOutpatientDepartment instanceof ClinicLiteVo)
		{
			ClinicLiteVo voClinLite = (ClinicLiteVo) wardOrClinicOrOutpatientDepartment;
			Clinic doClinic = (Clinic) factory.getDomainObject(Clinic.class, voClinLite.getID_Clinic());
			Location doLocation = doClinic.getClinicLocation();
			return LocationLiteVoAssembler.create(doLocation);
		}

		return null;
	}

	private LocSiteShortVo getHospital(Location doLocation)
	{
		if(doLocation instanceof LocSite && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
			return LocSiteShortVoAssembler.create((LocSite) doLocation);

		while(doLocation.getParentLocation() != null)
		{
			doLocation = doLocation.getParentLocation();
			if(doLocation instanceof LocSite && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
				return LocSiteShortVoAssembler.create((LocSite) doLocation);
		}

		return null;
	}

	public LocationLiteVoCollection listWardsForHospitalByNameLite(LocationRefVo location, String name)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		
		//WDEV-6721 - if user enters more than 1 '%' - search was failing
		String[] arr = null;
		if(name.contains("%"))
		{
			arr = name.split("%");
			if(arr.length > 0)
				name = arr[0] + "%";
			else
				name = "%";
		}
		
		return impl.listActiveWardsForHospitalByNameLite(location, name);
	}

	public ClinicLiteVoCollection listClinicsForHospitalByNameLite(LocationRefVo location, String name)
	{
		DomainFactory factory = getDomainFactory();
		List clinics = factory.find("from Clinic clin where clin.clinicLocation.id = :idLocation and upper(clin.clinicName) like :clinName and clin.isActive = 1 order by clin.clinicName", new String[]{"idLocation", "clinName"}, new Object[]{location.getID_Location(), "%" + name.toUpperCase() + "%"});
		return ClinicLiteVoAssembler.createClinicLiteVoCollectionFromClinic(clinics);
	}

	public LocationLiteVoCollection listOutpatDeptsForHospitalByName(LocationRefVo hospital, String nameFilter)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveOutpatDeptsForHospitalByNameLite(hospital, nameFilter);
	}

	public LocShortVoCollection listWardsForHospitalByNameShort(LocationRefVo hospital, String name)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveWardsForHospitalByName(hospital, name);
	}

	public OcsOrderVo getOcsOrder(OcsOrderSessionRefVo ocsOrder)
	{
		if(ocsOrder == null || ocsOrder.getID_OcsOrderSession() == null)
			return null;

		OcsOrderSession doOcsOrder = (OcsOrderSession) getDomainFactory().getDomainObject(ocsOrder);
		return OcsOrderVoAssembler.create(doOcsOrder);
	}

	public MemberOfStaffLiteVoCollection listActiveMosByName(String name)
	{
		if(name == null)
			throw new CodingRuntimeException("name parameter is null in method listActiveMosByName");

		HcpAdmin impl = (HcpAdmin) getDomainImpl(HcpAdminImpl.class);

		//WDEV-8204
		HcpLiteVoCollection hcps = impl.listHcpLiteByName(name, 400); //WDEV-11656
		if (hcps == null || hcps.size()==0)
			return null;
		MemberOfStaffLiteVoCollection result = new MemberOfStaffLiteVoCollection();
		for (int i=0 ; i<hcps.size() ; i++)
		{
			result.add(hcps.get(i).getMos());
		}
		return result;
		//return MemberOfStaffLiteVoAssembler.createMemberOfStaffLiteVoCollectionFromMemberOfStaff(members).sort();
	}

	public Boolean getProfileLevelPhlebMayCollect(Integer parentInvestigationId)
	{
		DomainFactory factory = getDomainFactory();

		List invDetails = factory.find("select inv.investigationIndex.phlebMayCollect from Investigation inv where inv.id = :idInv", new String[]{"idInv"}, new Object[]{parentInvestigationId});
		if (invDetails != null && invDetails.size() > 0)
			return (Boolean)invDetails.get(0);

		return null;
	}

	public LocShortVoCollection listOutpatDeptsForHospitalByNameShort(LocationRefVo hospital, String nameFilter)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveOutpatDeptsForHospitalByName(hospital, nameFilter);
	}

	public MyOrderInpatEpisVo getInpatientEpisode(PatientRefVo patient, PASEventRefVo pasEvent)
	{
		if (patient == null)
			throw new CodingRuntimeException("patient parameter is null method getInpatientEpisode");

		DomainFactory factory = getDomainFactory();
		String hql = "";
		List inps = null;
		if(pasEvent != null)
		{
			hql = "from InpatientEpisode as inp where inp.pasEvent.patient.id = :idPatient and inp.pasEvent.location is not null and inp.pasEvent.id = :idPasEvent";
			inps = factory.find(hql, new String[]{"idPatient", "idPasEvent"}, new Object[]{patient.getID_Patient(), pasEvent.getID_PASEvent()});
		}
		else
		{
			hql = "from InpatientEpisode as inp where inp.pasEvent.patient.id = :idPatient and inp.pasEvent.location is not null";
			inps = factory.find(hql, new String[]{"idPatient"}, new Object[]{patient.getID_Patient()});
		}

		if (inps != null && inps.size() > 0)
			return MyOrderInpatEpisVoAssembler.create((InpatientEpisode) inps.get(0));
		/* WDEV-16954 for merged patients you can have more than one inpatient records
		else if (inps != null && inps.size() > 1)
			throw new DomainRuntimeException("More than 1 current inpatient record found for patient with id = " + patient.getID_Patient());
			*/

		return null;
	}

	public MyOrderOutpatAttendVo getOutPatientAttendance(PatientRefVo patient, PASEventRefVo pasEvent)
	{
		if (patient == null)
			throw new CodingRuntimeException("patient parameter is null method getOutPatientAttendance");

		DomainFactory factory = getDomainFactory();

		// WDEV-16607
		MyOrderOutpatAttendVo todayAppointment = findTodayAppointment(patient, pasEvent);
		if (todayAppointment != null)
			return todayAppointment;

		
		String hql = "";
		List outps = null;
		if(pasEvent != null)
		{
			hql = "from OutpatientAttendance as outp " +
				" where outp.pasEvent.patient.id = :idPatient " +
				" and outp.pasEvent.id = :idPasEvent " +
				" and outp.clinic is not null " +
				" and outp.appointmentStatus.id != :cancelledStatus";
			outps = factory.find(hql, new String[]{"idPatient", "idPasEvent", "cancelledStatus"}, new Object[]{patient.getID_Patient(), pasEvent.getID_PASEvent(), new Integer(Status_Reason.CANCELLED.getId())});
		}
		else
		{
			hql = "from OutpatientAttendance as outp " +
			" where outp.pasEvent.patient.id = :idPatient " +
			" and outp.clinic is not null " +
			" and outp.appointmentStatus.id != :cancelledStatus" +
			" and outp.appointmentDateTime >= :todayMinus7Days order by outp.appointmentDateTime";
			outps = factory.find(hql, new String[]{"idPatient", "todayMinus7Days", "cancelledStatus"}, new Object[]{patient.getID_Patient(), new Date().addDay(-7).getDate(), new Integer(Status_Reason.CANCELLED.getId())});
		}

		if(outps != null && outps.size() > 0)
			return MyOrderOutpatAttendVoAssembler.create((OutpatientAttendance) outps.get(0));

		return null;
	}

	// WDEV-16607
	private MyOrderOutpatAttendVo findTodayAppointment(PatientRefVo patient, PASEventRefVo pasEvent)
	{
		if (patient == null)
			return null;
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		StringBuilder todayQuery = new StringBuilder("FROM OutpatientAttendance AS outp ");
		
		todayQuery.append("WHERE outp.pasEvent.patient.id = :PATIENT_ID ");
		paramNames.add("PATIENT_ID");
		paramValues.add(patient.getID_Patient());
		
		if (pasEvent != null)
		{
			todayQuery.append("AND outp.pasEvent.id = :PAS_EVENT_ID ");
			paramNames.add("PAS_EVENT_ID");
			paramValues.add(pasEvent.getID_PASEvent());
		}
		
		todayQuery.append("AND outp.clinic is not null AND outp.appointmentStatus.id != :CANCELLED_STATUS and outp.appointmentDateTime BETWEEN :TODAY AND :TODAY_MIDNIGHT");
		
		paramNames.add("CANCELLED_STATUS");
		paramValues.add(Status_Reason.CANCELLED.getID());
		
		paramNames.add("TODAY");
		paramValues.add(new DateTime(new Date(), new Time(0, 0, 0)).getJavaDate());
		
		paramNames.add("TODAY_MIDNIGHT");
		paramValues.add(new DateTime(new Date(), new Time(23, 59, 59)).getJavaDate());

		MyOrderOutpatAttendVoCollection outpatientAttendances = MyOrderOutpatAttendVoAssembler.createMyOrderOutpatAttendVoCollectionFromOutpatientAttendance(getDomainFactory().find(todayQuery.toString(), paramNames, paramValues));
		
		if (outpatientAttendances != null && outpatientAttendances.size() > 0)
			return outpatientAttendances.get(0);
		
		return null;
	}

	public LocationLiteVoCollection listActiveLocationForService(ServiceRefVo service)
	{
		if(service == null)
			throw new CodingRuntimeException("service param is null in method : listActiveLocationForService");

		DomainFactory factory = getDomainFactory();
		List locs = factory.find("select locService.location from LocationService as locService left join locService.location as loc where locService.service.id = :serviceId and locService.isActive = true and loc.isVirtual = false and loc.isActive = true",new String[]{"serviceId"},new Object[]{service.getID_Service()});
		if(locs != null && locs.size() > 0)
			return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locs);

		return null;
	}

	public LocationLiteVoCollection listAandEForHospitalByNameLite(LocationRefVo hosp, String name)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveAandEForHospitalByNameLite(hosp, name);
	}

	public LocationLiteVoCollection listUserEnteredLocationsForHospitalByNameLite(LocationRefVo hosp, String name)
	{
		if(hosp == null || hosp.getID_Location() == null)
			throw new CodingRuntimeException("Hospital parameter value not supplied for method :listUserEnteredLocationsForHospitalNyNameLite");

		DomainFactory factory = getDomainFactory();
		List locs = factory.find("from Location loc where loc.parentLocation.id = :hospId and loc.upperName like :name and loc.type.id >= 0 and loc.isActive = true and loc.isVirtual = false", new String[]{"hospId", "name"}, new Object[] {hosp.getID_Location(), name.toUpperCase() + "%"});
		if(locs != null && locs.size() > 0)
			return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locs);

		return null;
	}

	public void updateCatsReferralAdditionalInvStatus(CatsReferralRefVo catsReferral) throws StaleObjectException
	{
		IOCRRSchedulingHelper impl;
		try {
			impl = (IOCRRSchedulingHelper) getDomainImpl(Class.forName("ims.ocrr.helper.OCRRSchedulingHelper"));
			impl.updateCatsReferralAdditionalInvStatus(catsReferral);			
		} catch (ClassNotFoundException e) {
			LOG.error("Attempting to Load CARE_UK code in non care uk context", e);
		}
	}

	public GpLiteVo getReferrerGP(CatsReferralRefVo catsRef)
	{
		if (catsRef == null || catsRef.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsRef is null or id not provided in method getReferrerGP");
				
		String hql = "select refDetail.gPName from CatsReferral as cats left join cats.referralDetails as refDetail where cats.id = '" + catsRef.getID_CatsReferral() + "'";
		
		List gps = getDomainFactory().find(hql);
		if(gps.size() > 0)
		{
			return GpLiteVoAssembler.create((Gp)gps.get(0));	
		}
		 
		return null;	
	}

	//WDEV-9913 - get the latest record
	public HcpLiteVo getInitiallySeenByHcpFromConsultationClinicalNotesByReferral(CatsReferralRefVo referral)
	{
		if (referral == null || referral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("referral is null or id not provided in method getInitiallySeenByHcpFromConsultationClinicalNotesByReferral");
				
		String hql = "select cons.initiallySeenBy.authoringHcp from ConsultationClinicalNotes as cons left join cons.catsReferral as referral where referral.id = " + referral.getID_CatsReferral() + " order by cons.systemInformation.creationDateTime desc ";
		List hcpList =  getDomainFactory().find(hql);
		if(hcpList != null && hcpList.size() >= 1)
		{
			Hcp doHcp = (Hcp)hcpList.get(0);
			if(doHcp != null)
				return HcpLiteVoAssembler.create(doHcp);
		}
			
		return null;
	}

	//WDEV-11915
	public LocationLiteVoCollection listActiveOutpatientDepartment(LocationRefVo hospital) 
	{
		if(hospital == null || !hospital.getID_LocationIsNotNull())
			throw new CodingRuntimeException("Can not list Outpatient Departments on null Hospital Id.");
		
		OrganisationAndLocation orgLoc = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return orgLoc.listActiveOutpatDeptsForHospitalByNameLite(hospital, null);
	}

	//WDEV-11915
	public LocationLiteVo getOutpatientDepartmentByClinic(ClinicRefVo clinic) 
	{
		if(clinic == null || !clinic.getID_ClinicIsNotNull())
			throw new CodingRuntimeException("Can not get Outpatient Department on null Clinic Id.");
		
		DomainFactory factory = getDomainFactory();
		
		String query = "select c.outpatientDept from Clinic as c where c.id = :ClinicId";
		List<?> department = factory.find(query, new String[] {"ClinicId"}, new Object[] {clinic.getID_Clinic()});
		
		if(department != null && department.size() == 1)
		{
			return LocationLiteVoAssembler.create((Location) department.get(0));
		}
		
		return null;
	}

	//WDEV-11938
	public InvestigationHelpTextVo getInvestigationHelpText(Integer investigation) 
	{
		if(investigation == null)
			return null;
		
		return InvestigationHelpTextVoAssembler.create((Investigation) getDomainFactory().getDomainObject(Investigation.class, investigation));
	}

	//wdev-12864
	public CatsReferralListVo getCatsReferralListVo(CatsReferralRefVo catsRefVo) 
	{
		
		return CatsReferralListVoAssembler.create((CatsReferral)getDomainFactory().getDomainObject(CatsReferral.class, catsRefVo.getID_CatsReferral()));
	}

	/**
	 * WDEV-13890
	 * Function used to retrieve inpatient episode
	 */
	public MyOrderInpatEpisVo getInpatientEpisodeForPatient(PatientRefVo patient)
	{
		if (patient == null || !patient.getID_PatientIsNotNull())
			return null;
		
		String query = "select ie from InpatientEpisode as ie left join ie.pasEvent as pe left join pe.patient as p where p.id = :PatId and ie.isRIE is null";
		
		return MyOrderInpatEpisVoAssembler.create((InpatientEpisode) getDomainFactory().findFirst(query, "PatId", patient.getID_Patient()));
	}

	/**
	 *	WDEV-13890
	 *	Function used to retrieve the default emergency department (if there is only one it will retrieve it, else it will not)
	 */
	public LocationLiteVoCollection getDefaultEmergencyDepartment(LocationRefVo hospital)
	{
		if (hospital == null)
			return null;
		
		Location parentLocation = (Location) getDomainFactory().getDomainObject(Location.class, hospital.getID_Location());
		
		return getDefaultEmergencyDepartment(parentLocation, null);
	}


	/**
	 * WDEV-13890
	 * Function used to retrieve the default emergency department (if there is only one, if more than one or none exist - null is returned)
	 * It will recursively iterate through tree and search the emergency department
	 * If it founds more than one, then it will return null;
	 */
	private LocationLiteVoCollection getDefaultEmergencyDepartment(Location parentLocation, LocationLiteVoCollection emergencyDepartments)
	{
		if (emergencyDepartments == null)
			emergencyDepartments = new LocationLiteVoCollection();
		
		if (emergencyDepartments.size() > 1)
			return null;
		
		
		Iterator<?> iterator = parentLocation.getLocations().iterator();
		
		while (iterator.hasNext())
		{
			Location location = (Location) iterator.next();
			
			if (getDomLookup(LocationType.ANE).equals(location.getType()) && Boolean.TRUE.equals(location.isIsActive()) && Boolean.FALSE.equals(location.isIsVirtual())
					&& location.getIsRIE() == null)
			{
				emergencyDepartments.add(LocationLiteVoAssembler.create(location));
			}
			
			getDefaultEmergencyDepartment(location, emergencyDepartments);
		}
		
		return emergencyDepartments;
	}


	/**
	 * WDEV-13999
	 * Function used to determine if a patient has arrived for a referral 
	 */
	public Boolean hasArrived(CatsReferralRefVo referral)
	{
		if (referral == null || !referral.getID_CatsReferralIsNotNull())
			return Boolean.FALSE;
		

		StringBuilder query = new StringBuilder();
		query.append("SELECT COUNT(appointments.id) FROM  CatsReferral AS referral LEFT JOIN referral.appointments AS appointments LEFT JOIN appointments.apptStatus AS status");
		query.append(" WHERE referral.id = :REF_ID AND (status.id = :SEEN OR status.id = :ARRIVED)");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("REF_ID");		paramValues.add(referral.getID_CatsReferral());
		paramNames.add("SEEN");			paramValues.add(Status_Reason.SEEN.getID());
		paramNames.add("ARRIVED");		paramValues.add(Status_Reason.ARRIVAL.getID());
		
		List<?> result = getDomainFactory().find(query.toString(), paramNames, paramValues);
		
		Long count = (Long) result.iterator().next();
		
		if (count.longValue() > 0)
			return Boolean.TRUE;
			
		return Boolean.FALSE;
	}

	/**
	 * WDEV-13999
	 * Function used to retrieve the Lead Consultant for a referral speciality
	 */
	public HcpLiteVo getLeadConsultantForReferral(CatsReferralRefVo referral)
	{
		if (referral == null || !referral.getID_CatsReferralIsNotNull())
			return null;
		
		StringBuilder query = new StringBuilder();
		
		query.append("SELECT hcp FROM CatsReferral AS referral LEFT JOIN referral.referralDetails AS details LEFT JOIN details.service AS service, ");
		query.append(" SpecialtyLeadConsultant AS spec LEFT JOIN spec.leadConsultant AS hcp WHERE ");
		query.append(" spec.specialty.id = service.specialty.id AND referral.id = :REF_ID");
		
		return HcpLiteVoAssembler.create((Hcp) getDomainFactory().findFirst(query.toString(), "REF_ID", referral.getID_CatsReferral()));
	}

	/**
	 * Function used to retrieve the HCP corresponding to a member of staff
	 */
	public HcpLiteVo getHCPbyMoS(MemberOfStaffRefVo memberOfStaff)
	{
		if (memberOfStaff == null || !memberOfStaff.getID_MemberOfStaffIsNotNull())
			return null;
		
		StringBuilder query = new StringBuilder();
		
		query.append("select hcp from MemberOfStaff as mos left join mos.hcp as hcp");
		query.append(" where mos.id = :MOS_ID");
		
		return HcpLiteVoAssembler.create((Hcp) getDomainFactory().findFirst(query.toString(), "MOS_ID", memberOfStaff.getID_MemberOfStaff()));
	}


	/**
	 * Function used to retrieve the questions and answers for an investigation
	 */
	public InvestigationQuestionAnswerVoCollection getInvestigationQuestionsAnswers(InvestigationRefVo investigation, OcsOrderSessionRefVo orderDetails)
	{
		if (investigation == null || orderDetails == null)
			return null;
		
		StringBuilder query = new StringBuilder();
		
		query.append("SELECT questions FROM OcsOrderSession AS ocsorder LEFT JOIN ocsorder.clinicalInfo AS clinInfo LEFT JOIN clinInfo.categoryQuestionAnswers AS category ");
		query.append(" LEFT JOIN category.serviceQuestionAnswers AS serviceQA LEFT JOIN serviceQA.investigationQuestionAnswers AS questions ");
		query.append(" LEFT JOIN questions.investigation AS investigation");
		query.append(" WHERE ocsorder.id = :ID_ORDERDETAILS AND investigation.id = :ID_INVESTIGATION");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("ID_ORDERDETAILS");		paramValues.add(orderDetails.getID_OcsOrderSession());
		paramNames.add("ID_INVESTIGATION");		paramValues.add(investigation.getID_Investigation());

		return InvestigationQuestionAnswerVoAssembler.createInvestigationQuestionAnswerVoCollectionFromInvestigationQuestionAnswer(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	/**
	 * Function used to retrieve the OrderInvestigationAppointment for the investigation
	 */
	public OrderInvWithStatusApptVo getOrderInvestigationAppointment(OrderInvestigationRefVo investigation)
	{
		if (investigation == null || !investigation.getID_OrderInvestigationIsNotNull())
			return null;
		
		StringBuilder query = new StringBuilder();
		query.append("SELECT orderInv FROM OrderInvAppt AS orderInv LEFT JOIN orderInv.orderInvestigation AS investigation ");
		query.append(" WHERE investigation.id = :ID_INV");
		
		return OrderInvWithStatusApptVoAssembler.create((OrderInvAppt) getDomainFactory().findFirst(query.toString(), "ID_INV", investigation.getID_OrderInvestigation()));
	}

	/**
	 * Function used to retrieve the OrderInvestigation Booking VO
	 */
	public OrderInvestigationBookingWithStatusVo getOrderInvestigationBooking(OrderInvestigationRefVo investigation)
	{
		if (investigation == null || !investigation.getID_OrderInvestigationIsNotNull())
			return null;

		return OrderInvestigationBookingWithStatusVoAssembler.create((OrderInvestigation) getDomainFactory().getDomainObject(OrderInvestigation.class, investigation.getID_OrderInvestigation()));
	}

	/**
	 * Function used to update OrderInvestigationAppointment (with new Investigation - amended one)
	 */
	public void updateOrderInvestigationAppointment(OrderInvWithStatusApptVo orderInvestigationAppointment, OrderInvestigationLiteVo investigationToAmend) throws StaleObjectException
	{
		if (orderInvestigationAppointment == null)
			throw new CodingRuntimeException("Can not save null OderInvestigationAppointemnt");
		
		if (orderInvestigationAppointment.isValidated() == false)
			throw new CodingRuntimeException("Can not save not validated OrderInvestigationAppointment");
		
		if (investigationToAmend == null)
			throw new CodingRuntimeException("Can not save null OrderInvestigation");
		
		// Get domain object to save
		OrderInvAppt domOrderInvestigationAppointment = OrderInvWithStatusApptVoAssembler.extractOrderInvAppt(getDomainFactory(), orderInvestigationAppointment);
		OrderInvestigation domOrderInvestigation = OrderInvestigationLiteVoAssembler.extractOrderInvestigation(getDomainFactory(), investigationToAmend);
		
		getDomainFactory().save(domOrderInvestigationAppointment);
		getDomainFactory().save(domOrderInvestigation);
		
		OCSExternalEvents impl = (OCSExternalEvents) getDomainImpl(OCSExternalEventsImpl.class);
		impl.generateOrderUpdateEvent(new Booking_AppointmentRefVo(domOrderInvestigationAppointment.getAppointment().getId(), domOrderInvestigationAppointment.getAppointment().getVersion()), new OrderInvestigationRefVo(domOrderInvestigationAppointment.getOrderInvestigation().getId(), domOrderInvestigationAppointment.getOrderInvestigation().getVersion()));
		
		return;
	}

	/**
	 *	Function used to cancel an appointment
	 */
	public Booking_AppointmentVo cancelAppointment(Booking_AppointmentVo appointment, ActionRequestType requestType, String requestSource) throws StaleObjectException
	{
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		
		return impl.cancelAppt(appointment, requestType, requestSource);
	}

	public void updateCatsReferralCancelStatus(CatsReferralRefVo referral) throws StaleObjectException
	{
		if(referral == null || referral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsReferral is null or id not provided in method updateCatsReferralAdditionalInvStatus");
		
		DomainFactory factory = getDomainFactory();
		
		CatsReferral doCatsReferral = (CatsReferral) factory.getDomainObject(referral);
		
		doCatsReferral.setHasCancelledApptsForReview(true);
		factory.save(doCatsReferral);
	}

	/**
	 * Function used to retrieve Questions & Answers for the service of the amended investigation
	 */
	public GeneralQuestionAnswerVoCollection getServiceQuestionsAnswers(OcsOrderSessionRefVo orderDetails, ServiceRefVo service)
	{
		if (orderDetails == null || service == null)
			return null;
		
		StringBuilder query = new StringBuilder();
		
		query.append("SELECT questions ");
		query.append(" FROM OcsOrderSession AS ocsOrder LEFT JOIN ocsOrder.clinicalInfo AS clinInfo LEFT JOIN clinInfo.categoryQuestionAnswers AS categoryQA ");
		query.append(" LEFT JOIN categoryQA.serviceQuestionAnswers AS serviceQA LEFT JOIN serviceQA.service AS service LEFT JOIN serviceQA.serviceQuestionAnswers AS questions");
		query.append(" WHERE ocsOrder.id = :ID_ORDER AND service.id = :ID_SERVICE");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("ID_ORDER");			paramValues.add(orderDetails.getID_OcsOrderSession());
		paramNames.add("ID_SERVICE");		paramValues.add(service.getID_Service());

		return GeneralQuestionAnswerVoAssembler.createGeneralQuestionAnswerVoCollectionFromGeneralQuestionAnswer(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	/**
	 * Function used to retrieve Question & Answers for the category for amended investigation
	 */
	public GeneralQuestionAnswerVoCollection getCategoryQuestionsAnswers(OcsOrderSessionRefVo orderDetails, Category category)
	{
		if (orderDetails == null || category == null)
			return null;
		
		StringBuilder query = new StringBuilder();
		
		query.append("SELECT questions ");
		query.append(" FROM OcsOrderSession AS ocsOrder LEFT JOIN ocsOrder.clinicalInfo AS clinInfo LEFT JOIN clinInfo.categoryQuestionAnswers AS categoryQA ");
		query.append(" LEFT JOIN categoryQA.categoryQuestionAnswers AS questions LEFT JOIN categoryQA.category AS category ");
		query.append(" WHERE ocsOrder.id = :ID_ORDER AND category.id = :ID_CATEGORY ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("ID_ORDER");			paramValues.add(orderDetails.getID_OcsOrderSession());
		paramNames.add("ID_CATEGORY");		paramValues.add(category.getID());

		return GeneralQuestionAnswerVoAssembler.createGeneralQuestionAnswerVoCollectionFromGeneralQuestionAnswer(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	public OrderInvestigationForStatusChangeVo getOrderInvestigation(OrderInvestigationRefVo investigation)
	{
		if (investigation == null)
			throw new CodingRuntimeException("Error - Investigation to amend must not be null");
		
		return OrderInvestigationForStatusChangeVoAssembler.create((OrderInvestigation) getDomainFactory().getDomainObject(OrderInvestigation.class, investigation.getID_OrderInvestigation()));
	}

	public OrderInvestigationLiteVo updateInvestigationStatus(OrderInvestigationForStatusChangeVo investigation) throws StaleObjectException
	{
		if (investigation == null)
			throw new CodingRuntimeException("Error - Can not update the status for a null investigation");
		
		OrderInvestigation domInvestigation = OrderInvestigationForStatusChangeVoAssembler.extractOrderInvestigation(getDomainFactory(), investigation);
		
		getDomainFactory().save(domInvestigation);
		
		return OrderInvestigationLiteVoAssembler.create(domInvestigation);
	}

	public SummaryClinicalInformationVo getLatestSummaryClinicalInformation(PatientRefVo patient)
	{
		if (patient == null || patient.getID_Patient() == null)
			return null;
		
		String query = "SELECT summary FROM SummaryClinicalInformation AS summary LEFT JOIN summary.patient AS patient WHERE summary.isRIE is null AND patient.id = :ID_PATIENT ORDER BY summary.systemInformation.creationDateTime DESC";
		
		return SummaryClinicalInformationVoAssembler.create((SummaryClinicalInformation) getDomainFactory().findFirst(query, "ID_PATIENT", patient.getID_Patient()));
	}

	//WDEV-15899
	public LocSiteShortVo getTypeOfLocSite(LocationRefVo locRef)
	{
		if (locRef == null)
			throw new CodingRuntimeException("Location not provided");

		DomainFactory factory = getDomainFactory();
		LocSite doLocation = (LocSite) factory.getDomainObject(LocSite.class, locRef.getID_Location());
		return LocSiteShortVoAssembler.create(doLocation);
	}

	//WDEV-15899
	public HcpLiteVoCollection listResponsibleEdClinicians(String hcpName)
	{
		if (hcpName == null || hcpName.length() == 0)
			return null;
		
		String query = "SELECT hcp FROM Hcp AS hcp LEFT JOIN hcp.mos AS mos WHERE hcp.isActive = 1 AND hcp.isAResponsibleEDClinician = 1 AND mos.name.upperSurname LIKE :HCP_NAME";
		
		return HcpLiteVoAssembler.createHcpLiteVoCollectionFromHcp(getDomainFactory().find(query, "HCP_NAME", hcpName.toUpperCase() + "%")).sort();
	}

	public CareContextShortVo getCareContextByPasEvent(PASEventRefVo pasEvent)
	{
		if (pasEvent == null || pasEvent.getID_PASEvent() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT context FROM CareContext AS context LEFT JOIN context.pasEvent AS pas WHERE pas.id = :PAS_EVENT_ID");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("PAS_EVENT_ID");
		paramValues.add(pasEvent.getID_PASEvent());
		
		return CareContextShortVoAssembler.create((CareContext) getDomainFactory().findFirst(query.toString(), paramNames, paramValues));
	}

	public DFTCollectionTypesConfigVo getDFTCollectionTypes()
	{
		String query = " from DFTCollectionTypesConfig as dftConfig where (dftConfig.isRIE is null )";
	
		return DFTCollectionTypesConfigVoAssembler.create((DFTCollectionTypesConfig) getDomainFactory().findFirst(query));
	}

	public OrderPriorityCollection listOrderPriority(Boolean requiresPathologyMappings, Boolean requiresRadiologyMappings, Boolean requiresClinicalMappings)
	{
		OrderPriorityCollection results = new OrderPriorityCollection();
		OrderPriorityCollection resultsPathology = new OrderPriorityCollection();
		OrderPriorityCollection resultsRadiology = new OrderPriorityCollection();
		OrderPriorityCollection resultsClinical = new OrderPriorityCollection();
		
		
		String radiologySystem = "Radiology System";
		String pathologySystem = "Pathology System";
		String clinicalMapping = "Clinical Mapping";
		
		StringBuilder query = new StringBuilder("SELECT orderPriority.id FROM LookupInstance AS orderPriority LEFT JOIN orderPriority.type AS lookupType LEFT JOIN orderPriority.mappings AS mappings");
		query.append(" WHERE lookupType.id = :ORDER_PRIORITY_TYPE AND orderPriority.active = 1");
		
		if (Boolean.TRUE.equals(requiresPathologyMappings))
		{
			StringBuilder queryPathology = new StringBuilder(query.toString());
			queryPathology.append(" AND mappings.extSystem = :PATHOLOGY_SYSTEM ORDER BY orderPriority.id");
			
			List<?> pathologyPriorities = getDomainFactory().find(queryPathology.toString(), new String[] {"ORDER_PRIORITY_TYPE", "PATHOLOGY_SYSTEM"}, new Object[] {OrderPriority.TYPE_ID, pathologySystem});
			
			for (int i = 0; i < pathologyPriorities.size(); i++)
				resultsPathology.add(LookupHelper.getOrderPriorityInstance(getLookupService(), (Integer) pathologyPriorities.get(i)));
			
			if (Boolean.FALSE.equals(requiresRadiologyMappings) && Boolean.FALSE.equals(requiresClinicalMappings))
				return resultsPathology;
		}
		
		if (Boolean.TRUE.equals(requiresRadiologyMappings))
		{
			StringBuilder queryRadiology = new StringBuilder(query.toString());
			queryRadiology.append(" AND mappings.extSystem = :RADIOLOGY_SYSTEM ORDER BY orderPriority.id");
			
			List<?> radiologyPriorities = getDomainFactory().find(queryRadiology.toString(), new String[] {"ORDER_PRIORITY_TYPE", "RADIOLOGY_SYSTEM"}, new Object[] {OrderPriority.TYPE_ID, radiologySystem});
			
			for (int i = 0; i < radiologyPriorities.size(); i++)
				resultsRadiology.add(LookupHelper.getOrderPriorityInstance(getLookupService(), (Integer) radiologyPriorities.get(i)));
			
			if (Boolean.FALSE.equals(requiresPathologyMappings) && Boolean.FALSE.equals(requiresClinicalMappings))
				return resultsRadiology;
		}
		
		if (Boolean.TRUE.equals(requiresClinicalMappings))
		{
			StringBuilder queryClinical = new StringBuilder(query.toString());
			queryClinical.append(" AND mappings.extSystem = :CLINICAL_SYSTEM ORDER BY orderPriority.id");
			
			List<?> clinicalPriorities = getDomainFactory().find(queryClinical.toString(), new String[] {"ORDER_PRIORITY_TYPE", "CLINICAL_SYSTEM"}, new Object[] {OrderPriority.TYPE_ID, clinicalMapping});
			
			for (int i = 0; i < clinicalPriorities.size(); i++)
				resultsClinical.add(LookupHelper.getOrderPriorityInstance(getLookupService(), (Integer) clinicalPriorities.get(i)));
			
			if (Boolean.FALSE.equals(requiresPathologyMappings) && Boolean.FALSE.equals(requiresRadiologyMappings))
				return resultsClinical;
		}
		

		if (Boolean.TRUE.equals(requiresPathologyMappings))
		{
			for (int i = 0; i < resultsPathology.size(); i++)
			{
				OrderPriority orderPriority = resultsPathology.get(i);
				
				if ((Boolean.FALSE.equals(requiresRadiologyMappings) || resultsRadiology.contains(orderPriority)) && (Boolean.FALSE.equals(requiresClinicalMappings) || resultsClinical.contains(orderPriority)))
					results.add(orderPriority);
			}
		}
		else
		{
			for (int i = 0; i < resultsRadiology.size(); i++)
			{
				OrderPriority orderPriority = resultsRadiology.get(i);
				
				if (Boolean.TRUE.equals(requiresClinicalMappings) || resultsClinical.contains(orderPriority))
					results.add(orderPriority);
			}
		}
				
		return results;
	}

	
	public PasEventShortVo getLatestPasEvent(PatientRefVo patient)
	{
		if (patient == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT pasEv FROM PASEvent AS pasEv LEFT JOIN pasEv.patient AS pat WHERE ");
		query.append(" pat.id = :PATIENT_ID ORDER BY pasEv.systemInformation.creationDateTime DESC");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("PATIENT_ID");
		paramValues.add(patient.getID_Patient());
		
		return PasEventShortVoAssembler.create((PASEvent) getDomainFactory().findFirst(query.toString(), paramNames, paramValues));
	}

	//wdev-17823
	public OrderCategory getOrderCategoryByMap() 
	{
		DomainFactory factory = getDomainFactory(); 
		StringBuffer hql = new StringBuffer();
		hql.append("select lookInst from Lookup as look left join look.instances as lookInst left join lookInst.mappings as mappings where (look.id = 1161035 and mappings.extSystem = 'MAXIMS' and mappings.extCode like 'ALIAS_DEFAULT' and lookInst.active = 1)");
		List<?> list = factory.find(hql.toString());

		if (list!=null && list.size()>0)
		{
			LookupInstance doLookInst=(LookupInstance)list.get(0);
			ims.ocrr.vo.lookups.OrderCategory voLookup = new ims.ocrr.vo.lookups.OrderCategory(doLookInst.getId(),doLookInst.getText(),doLookInst.isActive(),null,doLookInst.getImage(),doLookInst.getColor()); 
		 	return voLookup;
		}
		return null;	
	}
}
