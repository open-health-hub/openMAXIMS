//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Rory Fitzpatrick using IMS Development Environment (version 1.70 build 3467.22451)
// Copyright (C) 1995-2009 IMS MAXIMS. All rights reserved.

package ims.clinical.domain.impl;

import ims.admin.vo.AppointmentTrackingstatusColourConfigVo;
import ims.admin.vo.domain.AppointmentTrackingstatusColourConfigVoAssembler;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.vo.CatsReferralListVo;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.PatientElectiveListForDNAAppointmentsVo;
import ims.RefMan.vo.TCIForPatientElectiveListAppointmentDNAVo;
import ims.RefMan.vo.domain.CatsReferralBreachDatesVoAssembler;
import ims.RefMan.vo.domain.CatsReferralListVoAssembler;
import ims.RefMan.vo.domain.CatsReferralVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListForDNAAppointmentsVoAssembler;
import ims.RefMan.vo.domain.TCIForPatientElectiveListAppointmentDNAVoAssembler;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.clinical.domain.base.impl.BaseClinicListWithICPActionsImpl;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.AppointmentTrackingstatusColourConfig;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.pas.domain.objects.InpatientEpisode;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.IPandOPSearchCriteriaVo;
import ims.core.vo.InpatientEpisodeLiteVo;
import ims.core.vo.LocMostVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.InpatientEpisodeLiteVoAssembler;
import ims.core.vo.domain.LocMostVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.ServiceCategory;
import ims.domain.DomainFactory;
import ims.domain.DomainObject;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.icp.vo.OutpatientEpisodeWithICPInfoVo;
import ims.icp.vo.OutpatientEpisodeWithICPInfoVoCollection;
import ims.icp.vo.domain.OutpatientEpisodeWithICPInfoVoAssembler;
import ims.icp.vo.domain.PatientICPLiteVoAssembler;
import ims.icps.instantiation.domain.objects.PatientICP;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.domain.HL7PathwayIf;
import ims.pathways.domain.objects.PathwayClock;
import ims.pathways.domain.objects.PathwayRTTStatus;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.scheduling.domain.objects.Appt_Tracking_Status_History;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.helper.CABRequests;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.SessionShortVoCollection;
import ims.scheduling.vo.SessionSlotVo;
import ims.scheduling.vo.domain.Appt_Tracking_Status_HistoryVoAssembler;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.SessionShortVoAssembler;
import ims.scheduling.vo.lookups.OutcomeAction;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.vo.LookupInstVo;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

public class ClinicListwithICPActionsImpl extends BaseClinicListWithICPActionsImpl
{

	private static final long serialVersionUID = 1L;
	private static final int PATIENT_DNA_NAT_CODE = 33;

	/**
	 * Get PatientShort
	 */
	public ims.core.vo.PatientShort getPatientShort(ims.core.patient.vo.PatientRefVo voPatientRef)
	{
		DomainFactory factory = getDomainFactory();
		ims.core.patient.domain.objects.Patient patBo = (ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, voPatientRef.getID_Patient().intValue());
		return PatientShortAssembler.create(patBo);
	}

	public LocationLiteVoCollection getActiveHospitals(MemberOfStaffRefVo mos)
	{
		if (mos == null || !mos.getID_MemberOfStaffIsNotNull())
			return null;

		StringBuilder query = new StringBuilder();
		query.append("select location from MemberOfStaff as mos left join mos.locations as hcpLocation left join hcpLocation.location as location ");
		query.append(" where location.type = :LocType and location.isActive = :isActive and location.isVirtual = :isVirtual and mos.id = :mosID");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("LocType");
		paramValues.add(getDomLookup(LocationType.HOSP));

		paramNames.add("isActive");
		paramValues.add(Boolean.TRUE);

		paramNames.add("isVirtual");
		paramValues.add(Boolean.FALSE);

		paramNames.add("mosID");
		paramValues.add(mos.getID_MemberOfStaff());

		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	/**
	 * Select all booking appointments records that match the search criteria and associate them the ICP Information if it exists,
	 * associate latest Appt_Tracking_Status_History record if it exists, and associate AppointmentTrackingstatusColourConfig
	 * record corresponding to Appt_Tracking_Status_History record associated if it exists
	 */
	@SuppressWarnings("rawtypes")
	public OutpatientEpisodeWithICPInfoVoCollection listOPEpisodes(IPandOPSearchCriteriaVo searchCriteria)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		// WDEV-12909
		// Get the AppointmentTrackingStatusConfig records from data base (the actual number should be less than 10, about 6)
		List appointmentTrackingStatusConfig = getDomainFactory().find(" from AppointmentTrackingstatusColourConfig");

		StringBuffer query = new StringBuffer();

		query.append("SELECT icp, appts, apptTrackStatus");
		query.append(", referral");
		query.append(" FROM PatientICP AS icp RIGHT JOIN icp.appointments AS appts LEFT JOIN appts.apptTrackingStatusHistory AS apptTrackStatus LEFT JOIN icp.careContext AS icpContext");
		query.append(", CatsReferral AS referral LEFT JOIN referral.appointments AS refAppt");
		
		//WDEV-18439
		if (searchCriteria.getApptOutcome() != null || searchCriteria.getAppointmentAction() != null || Boolean.TRUE.equals(searchCriteria.getComplete()))
		{
			query.append(" LEFT JOIN appts.outcome AS apptOutcome LEFT JOIN appts.outcomeActions AS outcomeAct LEFT JOIN outcomeAct.appointmentAction AS apptAction LEFT JOIN outcomeAct.outcomeOfAction AS outcomeAction");
			
			//WDEV-18664
			if (searchCriteria.getApptDateFrom() != null || searchCriteria.getApptDateTo()!= null)
			{
				query.append(" LEFT JOIN outcomeAct.futureAppointmentDetails AS futureApptDetails") ;
			}
		}
		
		query.append(" WHERE ");
		query.append(" refAppt.id = appts.id AND ");
		query.append(" (apptTrackStatus.id is null or ");
		query.append(" apptTrackStatus.id = (select max(th.id) from Booking_Appointment as ba join ba.apptTrackingStatusHistory as th where ba.id = appts.id))");

		if (searchCriteria.getClinicIsNotNull())
		{
			query.append(" and appts.session.id = :clinic");
			markers.add("clinic");
			values.add(searchCriteria.getClinic().getID_Sch_Session());
		}
		else
		{
			query.append(" and ( appts.session.schLocation.id = :idHosp or appts.session.schLocation.parentLocation.id = :idHosp)");
			markers.add("idHosp");
			values.add(searchCriteria.getHospital().getID_Location());

			if (searchCriteria.getDate() != null)
			{
				query.append(" and appts.session.sessionDate = :sessionDate");
				markers.add("sessionDate");
				values.add(searchCriteria.getDate().getDate());
			}

			query.append(" and appts.session.isActive = :isActive");
			markers.add("isActive");
			values.add(Boolean.TRUE);

			query.append(" and appts.session.isTheatreSession = :falseTheatre");
			markers.add("falseTheatre");
			values.add(Boolean.FALSE);
		}
		
		if (searchCriteria.getApptOutcome() != null)
		{
			query.append(" and apptOutcome.id = :apptOutcomeID");
			markers.add("apptOutcomeID");
			values.add(searchCriteria.getApptOutcome().getID());
		}

		if (searchCriteria.getAppointmentAction() != null)
		{
			query.append(" and apptAction.id = :appointmentActionID");
			markers.add("appointmentActionID");
			values.add(searchCriteria.getAppointmentAction().getID());
		}

		if (Boolean.TRUE.equals(searchCriteria.getComplete()))
		{
			query.append(" and outcomeAction.id = :completedOutcomeId");
			markers.add("completedOutcomeId");
			values.add(OutcomeAction.DONE_NOW.getID());
		}

		//WDEV-18664
		if (searchCriteria.getApptDateFrom() != null)
		{
			query.append(" and  futureApptDetails.futureApptByDate >= :fromDate");
			markers.add("fromDate");
			values.add(searchCriteria.getApptDateFrom().getDate());
			
		}
		
		if (searchCriteria.getApptDateTo() != null)
		{
			query.append(" and  futureApptDetails.futureApptByDate <= :toDate");
			markers.add("toDate");
			values.add(searchCriteria.getApptDateTo().getDate());
		}
		
		query.append(" and appts.apptStatus.id != :CAN_ID ");//WDEV-12965
		
		markers.add("CAN_ID");
		values.add(Status_Reason.CANCELLED.getID());
		
		java.util.List list = getDomainFactory().find(query.toString(), markers, values, 500);
		Iterator it = list.iterator();
		OutpatientEpisodeWithICPInfoVoCollection voColl = new OutpatientEpisodeWithICPInfoVoCollection();

		while (it.hasNext())
		{
			Object[] lstItem = (Object[]) it.next();
			
			Booking_Appointment doOP = (Booking_Appointment) lstItem[1];
			
			// Populate database mapped fields
			OutpatientEpisodeWithICPInfoVo voOPEpis = OutpatientEpisodeWithICPInfoVoAssembler.create(doOP);
			
			// Set ICP Information
			if (lstItem[0] instanceof PatientICP)
			{
				PatientICP domPatientICP = (PatientICP) lstItem[0];
				
				voOPEpis.setICPInfo(PatientICPLiteVoAssembler.create(domPatientICP));
			}
			
			// Set Appointment Tracking Status field from appointment
			if (lstItem[2] instanceof Appt_Tracking_Status_History)
			{
				Appt_Tracking_Status_History domApptTrackingHistory = (Appt_Tracking_Status_History) lstItem[2];
				
				voOPEpis.setCurrentApptTrakingStatus(Appt_Tracking_Status_HistoryVoAssembler.create(domApptTrackingHistory));
				
				// Set Appointment Tracking Status Colour Configuration record
				if (appointmentTrackingStatusConfig != null)
				{
					for (int i = 0; i < appointmentTrackingStatusConfig.size(); i++)
					{
						if (appointmentTrackingStatusConfig.get(i) instanceof AppointmentTrackingstatusColourConfig)
						{
							AppointmentTrackingstatusColourConfig domColourConfig = (AppointmentTrackingstatusColourConfig) appointmentTrackingStatusConfig.get(i);
							
							if (domColourConfig.getTrackingStatus().getId() == domApptTrackingHistory.getTrackingStatus().getId())
							{
								voOPEpis.setAppointmentTrackingStatus(AppointmentTrackingstatusColourConfigVoAssembler.create(domColourConfig));
							}
						}
					}
				}
			}
			
			// WDEV-15944 - Get the CatsReferral for this appointment
			if (lstItem[3] instanceof CatsReferral)
			{
				voOPEpis.setReferral(CatsReferralBreachDatesVoAssembler.create((CatsReferral) lstItem[3]));
			}
			
			voColl.add(voOPEpis);
		}
		
		return voColl;
	}

	public SessionShortVoCollection listClinics(Integer hospital, Date date) 
	{
		DomainFactory factory = getDomainFactory();
		String query = " from Sch_Session session where (session.schLocation.id = :idHosp or session.schLocation.parentLocation.id = :idHosp) and session.isTheatreSession = :falseTheatre and session.sessionDate = :sessionDate and session.isActive = :isActive";
		return SessionShortVoAssembler.createSessionShortVoCollectionFromSch_Session(factory.find(query, new String[]{"idHosp", "falseTheatre", "sessionDate", "isActive"}, new Object[]{hospital, Boolean.FALSE, date.getDate(), Boolean.TRUE})).sort();
	}

	public LocMostVo getLocation(LocationRefVo voLocRef) 
	{
		DomainFactory factory = getDomainFactory();
		return LocMostVoAssembler.create((Location) factory.getDomainObject(Location.class, voLocRef.getID_Location()));
	}

	public Booking_AppointmentVo saveOPEpisode(Booking_AppointmentVo voOP) throws DomainInterfaceException, StaleObjectException 
	{
		if(voOP == null)
			throw new DomainRuntimeException("Invalid Booking to save");
		if(!voOP.isValidated())
			throw new DomainRuntimeException("Record not validated before save");
		
		
		DomainFactory factory = getDomainFactory();
		Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, voOP);		
		factory.save(doAppt);
		
		//WDEV-9657 DNA for ICAB appts - no dna hl7 messages in uksh
		if(ConfigFlag.GEN.ICAB_ENABLED.getValue())
		{
			if(doAppt.getApptStatus() != null && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.DNA)))
			{
				if(doAppt.isIsCABBooking() != null && doAppt.isIsCABBooking().booleanValue())
					CABRequests.sendRequestandUpdateReferences(factory, getDomLookup(ActionRequestType.NOTIFY_DNA), doAppt, "Appt DNA Requested from ClinicListWithIcpActions");	
			}
		}
		
		return Booking_AppointmentVoAssembler.create(doAppt);
	}

	public Booking_AppointmentVo getOpEpisode(Booking_AppointmentRefVo voBookingRef) 
	{
		return Booking_AppointmentVoAssembler.create((Booking_Appointment)getDomainFactory().getDomainObject(Booking_Appointment.class, voBookingRef.getID_Booking_Appointment()));
	}

	public Boolean isNotACurrentInpatient(PatientRefVo voPatRef) 
	{
		String hql = "from InpatientEpisode ip where ip.pasEvent in (select event.id from PASEvent as event where event.patient.id = :patID)";
		DomainFactory factory= getDomainFactory();
		List l = factory.find(hql, new String[] {"patID"}, new Object[] {voPatRef.getID_Patient()});		
		if (l != null && l.size() > 0)
		{
			return false;
		}
		return true;
	}

	public CatsReferralRefVo getCatsReferralRef(Integer bookApptID) 
	{
		DomainFactory factory = getDomainFactory();
		List cats = factory.find(" select catsref from CatsReferral as catsref left join catsref.appointments as appt where appt.id = :apptID",	new String[]{"apptID"},	new Object[]{bookApptID});
		if (cats != null && cats.size() > 0)
			return CatsReferralVoAssembler.create((CatsReferral)cats.get(0));
		return null;
	}

	public Booking_AppointmentVo saveOPEpisode(Booking_AppointmentVo voOP, CatsReferralListVo voCatsReferral, SessionSlotVo dnaSessionSlot, PatientElectiveListForDNAAppointmentsVo electiveList, Boolean isFirstAppointmentActivity) throws DomainInterfaceException, StaleObjectException
	{
		if(voOP == null)
			throw new DomainRuntimeException("Invalid Booking to save");
		if(!voOP.isValidated())
			throw new DomainRuntimeException("Booking Record not validated before save");
		if(voCatsReferral == null)
			throw new DomainRuntimeException("Invalid Referral to save");
		if(!voCatsReferral.isValidated())
			throw new DomainRuntimeException("Referral Record not validated before save");
		
		//WDEV-9091
		if(dnaSessionSlot != null && !dnaSessionSlot.isValidated())
			throw new CodingRuntimeException("Session Slot is not validated.");
		
		DomainFactory factory = getDomainFactory();
		
		Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, voOP);		
		
		factory.save(doAppt);
		
		
		//WDEV-9657 DNA for ICAB appts - no dna hl7 messages in uksh
		if(ConfigFlag.GEN.ICAB_ENABLED.getValue())
		{
			if(doAppt.getApptStatus() != null && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.DNA)))
			{
				if(doAppt.isIsCABBooking() != null && doAppt.isIsCABBooking().booleanValue())
					CABRequests.sendRequestandUpdateReferences(factory, getDomLookup(ActionRequestType.NOTIFY_DNA), doAppt, "Appt DNA Requested from ClinicListWithIcpActions");	
			}
		}
		
		//WDEV-18524 
		CatsReferral doCats = updateCatsReferral(factory, voCatsReferral, doAppt, isFirstAppointmentActivity);

		try
		{
			factory.save(doCats);
		}
		catch(StaleObjectException e)// workaround to not get stale when mark an appt as dna because of WDEV-17644 
		{
			doCats = updateCatsReferral(factory, voCatsReferral, doAppt, isFirstAppointmentActivity);
			factory.save(doCats);
		}
		
		////WDEV-18524
		if (doCats != null && isFirstAppointmentActivity && Boolean.TRUE.equals(doCats.isRTTClockImpact()) && doCats.getJourney() != null && doCats.getJourney().getCurrentClock() != null)
		{	
			instantiatePatientEvent(doCats);
		}
		
		if (electiveList != null)
		{
			@SuppressWarnings("rawtypes")
			HashMap domMap = new HashMap(); 
			TCIForPatientElectiveListAppointmentDNAVo currentTCI = electiveList.getTCIDetails();
			TCIForPatientElectiveList domTCIToSave = TCIForPatientElectiveListAppointmentDNAVoAssembler.extractTCIForPatientElectiveList(factory, currentTCI, domMap);
			electiveList.setTCIDetails(null);
			PatientElectiveList domPatientElectiveList = PatientElectiveListForDNAAppointmentsVoAssembler.extractPatientElectiveList(factory, electiveList, domMap);
			
			factory.save(domPatientElectiveList);
			factory.save(domTCIToSave);
		}
		
		
		//WDEV-9091 - starts here
		//if(dnaSessionSlot != null)
		//{			
		//	Session_Slot doSessionSlot = SessionSlotVoAssembler.extractSession_Slot(factory, dnaSessionSlot);
		//	factory.save(doSessionSlot);
		//}
		//WDEV-9091 - ends here
		
		return Booking_AppointmentVoAssembler.create(doAppt);
	}
	
	private CatsReferral updateCatsReferral(DomainFactory factory, CatsReferralListVo voCatsReferral, Booking_Appointment doAppt, Boolean isFirstAppointmentActivity)
	{
		//WDEV-18524 
		CatsReferral doCats = (CatsReferral) factory.getDomainObject(CatsReferral.class, voCatsReferral.getID_CatsReferral());
		//CatsReferralListVoAssembler.extractCatsReferral(factory, voCatsReferral);
		doCats.setHasDNAApptsForReview(voCatsReferral.getHasDNAApptsForReview());
		
		//WDEV-17987 added the code below so the form will do the same thing on "Arrived" and "Undo Arrival" as RefMan.ClinicList
		if(doAppt.getApptStatus().equals(getDomLookup(Status_Reason.ARRIVAL)))
		{
			if(doAppt.getSession() != null &&  doAppt.getSession().getService() != null &&  doAppt.getSession().getService().getServiceCategory() != null)
			{
				if(doAppt.getSession().getService().getServiceCategory().equals( getDomLookup(ServiceCategory.CLINICAL)))
				{
					doCats.setLastApptArrivedDate(new Date().getDate());
				}
			}			
		}
		//WDEV-17987 when Undo Arrival, if there are no other Arrived or Seen appointments for the Referral, clear last appointment arrived date so the context menus are updated correctly
		else if(doAppt.getApptStatus().equals(getDomLookup(Status_Reason.BOOKED)))
		{
			if(doAppt.getSession() != null &&  doAppt.getSession().getService() != null &&  doAppt.getSession().getService().getServiceCategory() != null)
			{
				if(doAppt.getSession().getService().getServiceCategory().equals( getDomLookup(ServiceCategory.CLINICAL)) && canClearLastPatArrivedDate(doCats))
				{
					doCats.setLastApptArrivedDate(null);
				}
			} 
		}
		
		
		//WDEV-18325 //WDEV-18524
		PathwayRTTStatus rttSTatusDO = null;
				
		if (isFirstAppointmentActivity && Boolean.TRUE.equals(doCats.isRTTClockImpact()))
		{
			PatientPathwayJourney journeyDO = doCats.getJourney();

			int dnaNatCode = PATIENT_DNA_NAT_CODE;

			rttSTatusDO = createPatientRTTStatus(dnaNatCode);
			
			if  (journeyDO != null)
			{
				if (journeyDO.getCurrentClock() != null)
				{
					PathwayClock ptwClockDO = journeyDO.getCurrentClock();

					ptwClockDO.setCurrentRTTStatus(rttSTatusDO);

					List<PathwayRTTStatus> ptwClockHistory = ptwClockDO.getRTTStatusHistory();

					if (ptwClockHistory == null)
					{
						ptwClockHistory = new java.util.ArrayList();
					}
					
					ptwClockHistory.add(rttSTatusDO);	
				}
			}
			
			doCats.setCurrentRTTStatus(rttSTatusDO);
		}
		
		return doCats;
	}
	
	private PathwayRTTStatus createPatientRTTStatus(int nationalCode) //WDEV-18325
	{
		PathwayRTTStatus rttSTatusDO = new PathwayRTTStatus();
		
		RTTStatusPoint rttStatusPoint = getRTTStatusPointFromConfig(nationalCode);
		
		rttSTatusDO.setRTTStatus(rttStatusPoint);
		
		Object mos = getMosUser();
		MemberOfStaff doMos = null;
		
		if(mos instanceof MemberOfStaffLiteVo)
		{
			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
		}
		
		rttSTatusDO.setStatusBy(doMos);
		rttSTatusDO.setStatusDateTime(new java.util.Date());
		
		rttSTatusDO.setSetting("O");
		
		return rttSTatusDO;
	}

	private void  instantiatePatientEvent(CatsReferral doCats) throws StaleObjectException, DomainInterfaceException //WDEV-18325
	{
		if (!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return;
		
		if(doCats == null || doCats.getJourney() == null || doCats.getJourney().getCurrentClock() == null)
			return;
		
		RTTStatusEventMapVo rttEventMap = null;

		if (doCats.getJourney().getCurrentClock().getCurrentRTTStatus() != null)
		{
			rttEventMap = getRTTStatusEventMap(doCats.getJourney().getCurrentClock().getCurrentRTTStatus().getRTTStatus());
		}
		if (rttEventMap == null || rttEventMap.getEvent() == null)
			return;
		
		PatientEventVo patEvent = new PatientEventVo();
		patEvent.setPatient((PatientRefVo)PatientListVoAssembler.create(doCats.getPatient()));
		patEvent.setEvent(rttEventMap.getEvent());
		patEvent.setEventDateTime(new DateTime());
		patEvent.setEventStatus(EventStatus.ACTIVE);
		patEvent.setJourney(PatientJourneyVoAssembler.create(doCats.getJourney()));
		
		HL7PathwayIf impl = (HL7PathwayIf) getDomainImpl(ims.pathways.domain.impl.HL7PathwayIfImpl.class);
		
		impl.instantiatePatientEvent(patEvent);
	}
		
	private RTTStatusPoint getRTTStatusPointFromConfig(int nationalCode) //WDEV-18325
	{	
		String hql = "from RTTStatusPoint as rttpoint where rttpoint.nationalCode = :natCode";
		DomainFactory fact = getDomainFactory();
		
		List<?> results = fact.find(hql, new String[]{"natCode"}, new Object[] {nationalCode});
		if (results != null && results.size() != 0 && results.get(0) instanceof RTTStatusPoint)
		{	
			return (RTTStatusPoint) results.get(0);
						
		}
		return null;
	}

	private RTTStatusEventMapVo getRTTStatusEventMap(RTTStatusPoint rttStatusPoint) //WDEV-18325 
	{
		if (rttStatusPoint == null || rttStatusPoint.getId() == null)	
			return null;

		String hql = "select event from RTTStatusEventMap as event left join event.currentRTTStatus as rttstat where event.active = 1 and rttstat.nationalCode = :natCode";

		DomainFactory factory = getDomainFactory();

		List<?> events = factory.find(hql, new String[]{"natCode"}, new Object[] {rttStatusPoint.getNationalCode()});

		if (events != null && events.size() != 0 && events.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) events.get(0));
		}
		return null;		
	}

	//WDEV-17987
	private boolean canClearLastPatArrivedDate(CatsReferral doCats)
	{
		if (doCats.getAppointments() == null)
			return true;

		Iterator<?> it1 = doCats.getAppointments().iterator();

		while (it1.hasNext())
		{
			Booking_Appointment doItem = (Booking_Appointment) it1.next();

			if (doItem.getApptStatus() != null && (doItem.getApptStatus().equals(getDomLookup(Status_Reason.ARRIVAL)) || doItem.getApptStatus().equals(getDomLookup(Status_Reason.SEEN))))
			{
				return false;
			}
		}

		return true;
	}

	public CatsReferralListVo getCatsReferral(Booking_AppointmentRefVo voBookRefVo) 
	{
		DomainFactory factory = getDomainFactory();
		List cats = factory.find(" select catsref from CatsReferral as catsref left join catsref.appointments as appt where appt.id = :apptID",	new String[]{"apptID"},	new Object[]{voBookRefVo.getID_Booking_Appointment()});
		if (cats != null && cats.size() > 0)
			return CatsReferralListVoAssembler.create((CatsReferral)cats.get(0));
		return null;
	}

	public CareContextShortVo getCareContext(CareContextRefVo careContextRef)
	{
		if (careContextRef == null)
			return null;
		DomainObject domainObject = getDomainFactory().getDomainObject(CareContext.class, careContextRef.getID_CareContext());
		if (domainObject instanceof CareContext)
			return CareContextShortVoAssembler.create((CareContext) domainObject);
		return null;
	}

	public Booking_AppointmentVo getBookingAppt(Booking_AppointmentRefVo bookingApptRefVo) 
	{
		DomainFactory factory = getDomainFactory();
		Booking_Appointment apptBo = (Booking_Appointment) factory.getDomainObject(Booking_Appointment.class, bookingApptRefVo.getID_Booking_Appointment());
		return Booking_AppointmentVoAssembler.create(apptBo);
	}

	public Boolean isInpatientCareContext(PatientRefVo patientRef, CareContextRefVo careContextRef)
	{
		if (patientRef == null || !patientRef.getID_PatientIsNotNull())
			throw new CodingRuntimeException("Logical Error - Patient expected");
		
		if (careContextRef == null || !careContextRef.getID_CareContextIsNotNull())
			throw new CodingRuntimeException("Logical Error - Care Context expected");
		
		String hql = "from InpatientEpisode as ip where (ip.pasEvent.id in (select cc.pasEvent.id from CareContext as cc where cc.id = :refID))";
		ArrayList<String> paramNames = new ArrayList<String>();
		paramNames.add("refID");
		
		ArrayList<Object> paramValues = new ArrayList<Object>();
		paramValues.add(careContextRef.getID_CareContext());
		
		InpatientEpisodeLiteVo inpatientEpisode = InpatientEpisodeLiteVoAssembler.create((InpatientEpisode) getDomainFactory().findFirst(hql, paramNames, paramValues));
		
		if (inpatientEpisode == null)
			return Boolean.FALSE;
		
		return Boolean.TRUE;
	}

	//WDEV-11665 - starts here
	public Booking_AppointmentVo saveBookingAppointment(Booking_AppointmentVo appointment) throws DomainInterfaceException,	StaleObjectException, UniqueKeyViolationException 
	{
		if(appointment == null)
			throw new DomainRuntimeException("Invalid Booking to save");
		if(!appointment.isValidated())
			throw new DomainRuntimeException("Record not validated before save");
		
		
		DomainFactory factory = getDomainFactory();
		Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, appointment);		
		factory.save(doAppt);
		
		return Booking_AppointmentVoAssembler.create(doAppt);
	}
	
	public AppointmentTrackingstatusColourConfigVo getTrackingColorConfig(LookupInstVo trackingStatus) 
	{
		if(trackingStatus == null)
			throw new CodingRuntimeException("Can not get AppointmentTrackingColorConfigVo for null LookupInstVo.");
		
		DomainFactory factory = getDomainFactory();
		
		return AppointmentTrackingstatusColourConfigVoAssembler.create((AppointmentTrackingstatusColourConfig) factory.findFirst("from AppointmentTrackingstatusColourConfig as atsc where atsc.trackingStatus.id = :statusLookup and atsc.isRIE is null", new String[] {"statusLookup"}, new Object[] {trackingStatus.getID()}));
	}
	//WDEV-11665 - ends here


	public PatientElectiveListForDNAAppointmentsVo getPatientElectiveList(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null)
			return null;
		
		String query = "SELECT electivList FROM PatientElectiveList AS electivList LEFT JOIN electivList.tCIDetails AS tci LEFT JOIN tci.appointment AS appt WHERE appt.id = :APPT_ID ";
		
		return PatientElectiveListForDNAAppointmentsVoAssembler.create((PatientElectiveList) getDomainFactory().findFirst(query, "APPT_ID", appointment.getID_Booking_Appointment()));
	}

	public Boolean hasTCI(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null)
			return Boolean.FALSE;

		String query = "SELECT COUNT (tci.id) FROM TCIForPatientElectiveList AS tci LEFT JOIN tci.appointment AS appt WHERE appt.id = :APPT_ID and tci.isRIE is null";
		
		long count = getDomainFactory().countWithHQL(query, new String[] {"APPT_ID"}, new Object[] {appointment.getID_Booking_Appointment()});
		
		if (count > 0)
			return Boolean.TRUE;
		
		return Boolean.FALSE;
	}
}
