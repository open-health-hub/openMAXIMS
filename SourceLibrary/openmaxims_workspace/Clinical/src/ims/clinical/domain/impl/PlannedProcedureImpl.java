//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Alexie Ursache using IMS Development Environment (version 1.44 build 2245.22719)
// Copyright (C) 1995-2006 IMS MAXIMS plc. All rights reserved.

package ims.clinical.domain.impl;
 
import java.util.ArrayList;
import java.util.List;

import ims.admin.domain.HcpAdmin;
import ims.admin.domain.impl.HcpAdminImpl;
import ims.admin.helper.Keywords;
import ims.clinical.configuration.domain.objects.ProcedureHotlistItem;
import ims.clinical.domain.ClinicalDiAssociations;
import ims.clinical.domain.base.impl.BaseProceduresImpl;
import ims.clinical.vo.ClinicalDIAssociationVoCollection;
import ims.clinical.vo.IntraOperativeCareRecordVo;
import ims.clinical.vo.PatientProcedureChecklistVoCollection;
import ims.clinical.vo.domain.IntraOperativeCareRecordVoAssembler;
import ims.clinical.vo.domain.PatientProcedureChecklistVoAssembler;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.admin.vo.CareSpellRefVo;
import ims.core.admin.vo.ClinicalContactRefVo;
import ims.core.admin.vo.EpisodeOfCareRefVo;
import ims.core.clinical.domain.objects.IntraOperativeCareRecord;
import ims.core.clinical.domain.objects.PatientProcedure;
import ims.core.clinical.vo.IntraOperativeCareRecordRefVo;
import ims.core.clinical.vo.PatientProcedureRefVo;
import ims.clinical.domain.PastMedicalHistory;
import ims.clinical.domain.impl.PastMedicalHistoryImpl;
import ims.core.patient.vo.PatientRefVo;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.PatientPastMedicalHistoryVo;
import ims.core.vo.PatientProcedureShortListVoCollection;
import ims.core.vo.PatientProcedureShortVoCollection;
import ims.core.vo.PatientProcedureVo;
import ims.core.vo.PatientShort;
import ims.core.vo.ProcedureLiteVo;
import ims.core.vo.ProcedureLiteVoCollection;
import ims.core.vo.domain.PatientProcedureShortListVoAssembler;
import ims.core.vo.domain.PatientProcedureShortVoAssembler;
import ims.core.vo.domain.PatientProcedureVoAssembler;
import ims.core.vo.domain.ProcedureLiteVoAssembler;
import ims.core.vo.lookups.PatientProcedureStatus;
import ims.core.vo.lookups.Specialty;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.framework.exceptions.CodingRuntimeException;

public class PlannedProcedureImpl extends BaseProceduresImpl
{
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/**
	* listProcedureByClinalContact
	*/
	public ims.core.vo.PatientProcedureShortVoCollection listProcedureByClinalContact(ims.core.admin.vo.ClinicalContactRefVo clinicalContactRefVo)
	{
		List list = listProcedures(clinicalContactRefVo, null);
		return PatientProcedureShortVoAssembler.createPatientProcedureShortVoCollectionFromPatientProcedure(list);
	}

	/**
	* listProcedureByPatient
	*/
	public ims.core.vo.PatientProcedureShortVoCollection listProcedureByPatient(ims.core.patient.vo.PatientRefVo patientRefVo)
	{
		List list = listProcedures(null, patientRefVo);
		return PatientProcedureShortVoAssembler.createPatientProcedureShortVoCollectionFromPatientProcedure(list);
	}
	public PatientProcedureShortVoCollection listProcedureByPatientAndStatus(PatientRefVo patientRefVo, PatientProcedureStatus status)
	{
		List list = listProcedures(null, patientRefVo, status);
		return PatientProcedureShortVoAssembler.createPatientProcedureShortVoCollectionFromPatientProcedure(list); 
	}

	/**
	* listProcedure by clinical contact
	*/
	public ims.core.vo.PatientProcedureShortListVoCollection listProcedure(ims.core.admin.vo.ClinicalContactRefVo clinicalContactRefVo)
	{
		List list = listProcedures(clinicalContactRefVo, null);
		return PatientProcedureShortListVoAssembler.createPatientProcedureShortListVoCollectionFromPatientProcedure(list);
	}
	
	private List listProcedures(ims.core.admin.vo.ClinicalContactRefVo clinicalContactRefVo, ims.core.patient.vo.PatientRefVo patientRefVo)
	{
		return listProcedures(clinicalContactRefVo, patientRefVo, null);
	}
	private List listProcedures(ims.core.admin.vo.ClinicalContactRefVo clinicalContactRefVo, ims.core.patient.vo.PatientRefVo patientRefVo, PatientProcedureStatus status)
	{
		StringBuffer hql  		    = new StringBuffer(" from PatientProcedure pp ");
		java.util.ArrayList values  = new java.util.ArrayList();
		java.util.ArrayList markers = new java.util.ArrayList();
		boolean whereClause = true;
		
		if(clinicalContactRefVo != null)
		{
			hql.append(whereClause?" where ":" and ");
			hql.append(" pp.clinicalContact.id = :clinContactId ");
			markers.add("clinContactId");
			values.add(clinicalContactRefVo.getID_ClinicalContact());
			whereClause = false;
		}
		
		if(patientRefVo != null)
		{
			hql.append(whereClause?" where ":" and ");
			hql.append(" pp.careContext.episodeOfCare.careSpell.patient.id = :patId");
			markers.add("patId");
			values.add(patientRefVo.getID_Patient());
			whereClause = false;
		}
		
		if(status != null)
		{
			hql.append(whereClause?" where ":" and ");
			hql.append(" pp.procedureStatus = :procStatus");
			markers.add("procStatus");
			values.add(getDomLookup(status));
			whereClause = false;
		}
	
		DomainFactory factory = getDomainFactory();
		return factory.find(hql.toString(), markers, values);
	}

	public PatientProcedureVo getProcedure(PatientProcedureRefVo patientProcedureRefVo)
	{
		if( patientProcedureRefVo == null)
			throw new DomainRuntimeException("PatientProcedure cannot be null.");
		
		if( patientProcedureRefVo.getID_PatientProcedure() == null)
			throw new DomainRuntimeException("PatientProcedure ID cannot be null.");
		
		DomainFactory factory = getDomainFactory();
		PatientProcedure doPatProcedure = (PatientProcedure) factory.getDomainObject(PatientProcedure.class, patientProcedureRefVo.getID_PatientProcedure());
		return PatientProcedureVoAssembler.create(doPatProcedure);
	}
	
	public PatientProcedureVo savePlannedProcedure(PatientProcedureVo voPatientProcedure, PatientShort patientShortVo) throws StaleObjectException, UniqueKeyViolationException 
	{
		if(voPatientProcedure == null)
			throw new RuntimeException("Cannot save null PatientProcedureVo");
		if(voPatientProcedure.isValidated() == false)
			throw new RuntimeException("PatientProcedureVo is not validated");
		
		DomainFactory factory = getDomainFactory();

		//Check the procedure to be saved
		if(voPatientProcedure.getProcedureIsNotNull() && voPatientProcedure.getProcedure().getID_Procedure() == null)
		{
			voPatientProcedure.setProcedure(saveProcedure(voPatientProcedure.getProcedure()));
		}
		PatientProcedure doPatientProcedure = PatientProcedureVoAssembler.extractPatientProcedure(factory, voPatientProcedure);
		
		factory.save(doPatientProcedure);
		
		voPatientProcedure = PatientProcedureVoAssembler.create(doPatientProcedure);//Create here to avoid possible StaleObj in PMH save
		
		if (voPatientProcedure.getIsPMHIsNotNull() && voPatientProcedure.getIsPMH().booleanValue()) //||(voPatientProcedure.getIsMajorDiagnosisIsNotNull() && voPatientProcedure.getIsMajorDiagnosis().booleanValue()))	
		{	//Save a PMH Procedure record.
			PatientPastMedicalHistoryVo voPMH = new PatientPastMedicalHistoryVo();

			PastMedicalHistory implPMH = (PastMedicalHistory) getDomainImpl(PastMedicalHistoryImpl.class);
			voPMH = implPMH.getPastMedicalHistory(patientShortVo);
		
			if (voPMH == null)
				voPMH = new PatientPastMedicalHistoryVo();
			
			PatientProcedureShortVoCollection voProcColl = voPMH.getProcedure();
			if (voProcColl == null)
				voProcColl = new PatientProcedureShortVoCollection();
			
			voProcColl.add(voPatientProcedure);
			voPMH.setProcedure(voProcColl);
			voPMH.setPatient(patientShortVo);
			String[] arrErrors = voPMH.validate();
			if( arrErrors != null)
			{
				throw new DomainRuntimeException("Error saving Past Medical History");
			}
				
			try 
			{
				implPMH.savePMH(voPMH);
			} 
			catch (StaleObjectException e) 
			{
				e.printStackTrace();
			} 
			catch (UniqueKeyViolationException e) 
			{
				e.printStackTrace();
			}
			
		}
		return voPatientProcedure;

	}

	private ProcedureLiteVo saveProcedure(ProcedureLiteVo voProcedure) throws StaleObjectException, UniqueKeyViolationException
	{
		return null;//TODO replace
		/*
		 * 
		 * ProcedureList intf = (ProcedureList)getDomainImpl(ProcedureListImpl.class);
		return intf.saveProcedureLite(voProcedure);
		 */
	}

	public HcpLiteVoCollection listHcpLiteByName(String hcpName)
	{
		HcpAdmin impl = (HcpAdmin) getDomainImpl(HcpAdminImpl.class);
		return impl.listHcpLiteByName(hcpName);

	}

	public PatientProcedureShortListVoCollection listProceduresByCareContext(CareContextRefVo careContextRefVo) 
	{
		if(careContextRefVo == null)
			throw new DomainRuntimeException("Invalid Care Context Ref");
		
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer("from PatientProcedure p ");
		hql.append(" where p.careContext.id = " + careContextRefVo.getID_CareContext());
		return PatientProcedureShortListVoAssembler.createPatientProcedureShortListVoCollectionFromPatientProcedure(factory.find(hql.toString()));
	}

	public PatientProcedureShortVoCollection listProceduresByEpisodeOfCare(EpisodeOfCareRefVo episodeOfCareRefVo) 
	{
		return listProcedureByEpisodeOfCare(episodeOfCareRefVo, null);
	}

	private PatientProcedureShortVoCollection listProcedureByEpisodeOfCare(EpisodeOfCareRefVo episodeOfCareRefVo, PatientProcedureStatus status)
	{
		if(episodeOfCareRefVo == null)
			throw new DomainRuntimeException("Invalid Episode Context Ref");
		
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer("from PatientProcedure p ");
		hql.append(" where p.careContext.episodeOfCare.id = " + episodeOfCareRefVo.getID_EpisodeOfCare());
		if(status != null)
			hql.append(" and p.procedureStatus.id = " + status.getId());
		return PatientProcedureShortVoAssembler.createPatientProcedureShortVoCollectionFromPatientProcedure(factory.find(hql.toString()));
	}

	public PatientProcedureShortVoCollection listProceduresByCareSpell(CareSpellRefVo careSpellRefVo) 
	{
		return listProcedureByCareSpell(careSpellRefVo, null);
	}

	private PatientProcedureShortVoCollection listProcedureByCareSpell(CareSpellRefVo careSpellRefVo, PatientProcedureStatus status)
	{
		if(careSpellRefVo == null)
			throw new DomainRuntimeException("Invalid Care Spell Context Ref");
		
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer("from PatientProcedure p ");
		hql.append(" where p.careContext.episodeOfCare.careSpell.id = " + careSpellRefVo.getID_CareSpell());
		if(status != null)
			hql.append(" and p.procedureStatus.id = " + status.getId());
		return PatientProcedureShortVoAssembler.createPatientProcedureShortVoCollectionFromPatientProcedure(factory.find(hql.toString()));
	}

	public PatientProcedureShortVoCollection listProceduresByCareContextPatientSummary(CareContextRefVo careContextRefVo) 
	{
		return listProcedureByCareContext(careContextRefVo, null);
	}

	private PatientProcedureShortVoCollection listProcedureByCareContext(CareContextRefVo careContextRefVo, PatientProcedureStatus status)
	{
		if(careContextRefVo == null)
			throw new DomainRuntimeException("Invalid Care Context Context Ref");
		
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer("from PatientProcedure p ");
		hql.append(" where p.careContext.id = " + careContextRefVo.getID_CareContext());
		if(status != null)
			hql.append(" and p.procedureStatus.id = " + status.getId());
		return PatientProcedureShortVoAssembler.createPatientProcedureShortVoCollectionFromPatientProcedure(factory.find(hql.toString()));
	}

	public PatientProcedureShortListVoCollection listProceduresByEpisodeOfCareShortList(EpisodeOfCareRefVo episodeOfCareRefVo) 
	{
		if(episodeOfCareRefVo == null)
			throw new DomainRuntimeException("Invalid Care Context Ref");
		
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer("from PatientProcedure p ");
		hql.append(" where p.careContext.episodeOfCare.id = " + episodeOfCareRefVo.getID_EpisodeOfCare());
		return PatientProcedureShortListVoAssembler.createPatientProcedureShortListVoCollectionFromPatientProcedure(factory.find(hql.toString()));
	}

	public ProcedureLiteVoCollection listHotlistProcedureShort(String procedureName, Specialty specialty) throws DomainInterfaceException 
	{
		if(procedureName == null)
			throw new DomainRuntimeException("Invalid Search criteria. Clinical Problem name filter must be supplied.");
		
		if(specialty == null)
			throw new DomainRuntimeException("Invalid Search criteria. Specialty must be supplied.");

		DomainFactory factory = getDomainFactory();

		StringBuffer hql = new StringBuffer("  select distinct item from ProcedureHotlistItem item join item.procedure as proc join proc.keywords as kw "); 
		ArrayList names = new ArrayList();
		ArrayList values = new ArrayList();

		hql.append(" where proc.isActive = :isActive");
		names.add("isActive");
		values.add(Boolean.TRUE);	

		hql.append(" and item.hotlist.specialty = :spec");
		names.add("spec");
		values.add(getDomLookup(specialty));			
	
		List hits = Keywords.searchByKeywords(factory, procedureName, hql.toString(), names, values);		
		
		List ret = new ArrayList();		
		for (int i = 0; i < hits.size(); i++)
		{
			ret.add(((ProcedureHotlistItem)hits.get(i)).getProcedure());
		}
		
		return ProcedureLiteVoAssembler.createProcedureLiteVoCollectionFromProcedure(ret);
	}

	public PatientProcedureShortVoCollection listProcedureByClinicalContactAndStatus(ClinicalContactRefVo clinicalContactRefVo, PatientProcedureStatus status)
	{
		List list = listProcedures(clinicalContactRefVo, null, status);
		return PatientProcedureShortVoAssembler.createPatientProcedureShortVoCollectionFromPatientProcedure(list);
	}

	public PatientProcedureShortVoCollection listProceduresByCareContextPatientSummaryAndStatus(CareContextRefVo careContextRefVo, PatientProcedureStatus status)
	{
		return listProcedureByCareContext(careContextRefVo, status);		
	}

	public PatientProcedureShortVoCollection listProceduresByEpisodeOfCareAndStatus(EpisodeOfCareRefVo episodeOfCareRefVo, PatientProcedureStatus status)
	{
		return listProcedureByEpisodeOfCare(episodeOfCareRefVo, status);
	}

	public PatientProcedureShortVoCollection listProceduresByCareSpellAndStatus(CareSpellRefVo careSpellRefVo, PatientProcedureStatus status)
	{
		return listProcedureByCareSpell(careSpellRefVo, status);
	}

	public ClinicalDIAssociationVoCollection saveClinicalDiAssociation(ClinicalDIAssociationVoCollection list) throws StaleObjectException
	{
		ClinicalDiAssociations clinicalDiAssocImpl = (ClinicalDiAssociations) getDomainImpl(ClinicalDiAssociationsImpl.class);
		return clinicalDiAssocImpl.saveClinicalDiAssociation(list);
	}

	public Boolean checkIfClinicalCDIAssociationsExist(PatientProcedureRefVo voPatientProcedure) 
	{
		//WDEV-1482
		ClinicalDiAssociations clinicalDiAssocImpl = (ClinicalDiAssociations) getDomainImpl(ClinicalDiAssociationsImpl.class);
		ClinicalDIAssociationVoCollection voColl = clinicalDiAssocImpl.listClinicalDiAssociation(voPatientProcedure);
		if (voColl.size() > 0)
			return Boolean.TRUE;
		else
			return Boolean.FALSE;
	}

	public PatientProcedureShortListVoCollection listProcedureShortListVoByPatient(PatientRefVo patient)
	{
		List list = listProcedures(null, patient, null);
		return PatientProcedureShortListVoAssembler.createPatientProcedureShortListVoCollectionFromPatientProcedure(list);
	}

	public Boolean checkForProcedureChecklist(ClinicalContactRefVo refClinicalContact) {
		if(refClinicalContact == null)
			throw new DomainRuntimeException("Invalid Search criteria. ClinicalContact must be supplied.");

		DomainFactory factory = getDomainFactory();
		
		StringBuffer hql = new StringBuffer("from PatientProcedureChecklist p ");
		hql.append(" where (p.clinicalContact.id = " + refClinicalContact.getID_ClinicalContact() + ")");
		PatientProcedureChecklistVoCollection collPatientProcedureChecklist = PatientProcedureChecklistVoAssembler.createPatientProcedureChecklistVoCollectionFromPatientProcedureChecklist((factory.find(hql.toString())));
	
		if(collPatientProcedureChecklist.size()==0)
			return Boolean.FALSE;
		
		return Boolean.TRUE;
	}

	public IntraOperativeCareRecordVo getIntraOperativeCareRecord(
			IntraOperativeCareRecordRefVo refVo) {
		if (refVo == null || !refVo.getID_IntraOperativeCareRecordIsNotNull()){
			throw new CodingRuntimeException("IntraOperativeCareRecord ref is null or ref.id is null");
		}
		
		return IntraOperativeCareRecordVoAssembler.create((IntraOperativeCareRecord)getDomainFactory().getDomainObject(IntraOperativeCareRecord.class,refVo.getID_IntraOperativeCareRecord()));
	}

}
