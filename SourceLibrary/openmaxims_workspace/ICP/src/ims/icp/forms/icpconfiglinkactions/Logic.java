//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by George Cristian Josan using IMS Development Environment (version 1.71 build 3832.22959)
// Copyright (C) 1995-2010 IMS MAXIMS. All rights reserved.

package ims.icp.forms.icpconfiglinkactions;

import java.util.Comparator;

import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.framework.controls.TreeNode;
import ims.framework.enumerations.DialogResult;
import ims.framework.enumerations.FormMode;
import ims.framework.exceptions.PresentationLogicException;
import ims.framework.utils.Color;
import ims.icp.vo.ICPActionLiteVo;
import ims.icp.vo.ICPActionLiteVoCollection;
import ims.icp.vo.ICPConfigurationDisplayVo;
import ims.icp.vo.ICPPhaseDisplayVo;
import ims.icp.vo.ICPPhaseDisplayVoCollection;
import ims.icp.vo.ICPStageDisplayVo;
import ims.icp.vo.ICPStageDisplayVoCollection;
import ims.icps.configuration.vo.ICPActionRefVo;
import ims.icps.configuration.vo.ICPActionRefVoCollection;
import ims.icps.configuration.vo.ICPRefVo;

public class Logic extends BaseLogic
{
	private static final long serialVersionUID = 1L;

	// ------------------------------------------------------------------------------------------------------------------------------------------------------
	// Region - Event Handlers
	// ------------------------------------------------------------------------------------------------------------------------------------------------------

	/**
	 * Handler for OnFormOpen event
	 * Initializes the form and populates with default data
	 */
	protected void onFormOpen(Object[] args) throws ims.framework.exceptions.PresentationLogicException
	{
		// Initialize local context with arguments value
		if (args.length >= 3)
		{
			if (args[0] instanceof ICPRefVo)
				form.getLocalContext().setICP(domain.getDisplayICP((ICPRefVo) args[0]));
			
			if (args[1] instanceof ICPActionRefVo)
				form.getLocalContext().setSelectedICPAction((ICPActionRefVo) args[1]);
			
			if (FormMode.VIEW.equals(args[2]))
				form.getLocalContext().setReadOnly(Boolean.TRUE);
			else
				form.getLocalContext().setReadOnly(Boolean.FALSE);
		}
		else
			throw new PresentationLogicException("Dialog was not properly initialized");
		
		// Initialize the form
		initialize();
		
		// Populate the screen with initial data
		open();
	}

	@Override
	protected void onFormModeChanged()
	{
		updateControlsState();
	}

	@Override
	protected void onImbClearFilterClick() throws PresentationLogicException
	{
		form.txtFilter().setValue(null);
		
		populateICPTree(form.getLocalContext().getICP(), null);
	}

	@Override
	protected void onImbFilterClick() throws PresentationLogicException
	{
		populateICPTree(form.getLocalContext().getICP(), form.txtFilter().getValue());
	}

	@Override
	protected void onBtnCancelClick() throws ims.framework.exceptions.PresentationLogicException
	{
		// Populate the collection of ICP Action
		updateLinkedActionsCollection();

		// Close the dialog
		engine.close(DialogResult.OK);
	}
	
	private void updateLinkedActionsCollection()
	{
		// Check the linked actions collection
		if (!form.getGlobalContext().ICP.getLinkedActionsIsNotNull())
			form.getGlobalContext().ICP.setLinkedActions(new ICPActionRefVoCollection());
		
		// Clear linked actions collection
		form.getGlobalContext().ICP.getLinkedActions().clear();
		
		for (int i = 0; i < form.treICP().getNodes().size(); i++)
		{
			TreeNode node = form.treICP().getNodes().get(i);

			addNodeToLinkedActions(node, form.getGlobalContext().ICP.getLinkedActions());
		}
	}

	private void addNodeToLinkedActions(TreeNode node, ICPActionRefVoCollection linkedActions)
	{
		if (linkedActions == null)
			return;
		
		if (node == null)
			return;
		
		if (node.getValue() instanceof ICPActionRefVo && node.isChecked())
			linkedActions.add((ICPActionRefVo) node.getValue());
		
		for (int i = 0; i < node.getNodes().size(); i++)
		{
			TreeNode treeNode = node.getNodes().get(i);
			
			addNodeToLinkedActions(treeNode, linkedActions);
		}
	}

	public void open() throws ims.framework.exceptions.PresentationLogicException
	{
		// Clear screen
		clearInstanceControls();
		
		// Populate the ICP tree (select the actions associated with the action)
		populateICPTree(form.getLocalContext().getICP(), null);
		
		// Set form mode to VIEW
		form.setMode(form.getLocalContext().getReadOnly() ? FormMode.VIEW : FormMode.EDIT);
	}
	
	private void populateICPTree(ICPConfigurationDisplayVo displayICP, String filterValue)
	{
		// Clear tree
		form.treICP().clear();
		
		// If the ICP is null terminate the function
		if (displayICP == null)
			return;
		
		// Create root node for the ICP (not selectable)
		TreeNode rootNode = form.treICP().getNodes().add(displayICP, displayICP.getName());
		rootNode.setCheckBoxVisible(false);

		// Set node images
		rootNode.setCollapsedImage(form.getImages().ICP.ICP);
		rootNode.setExpandedImage(form.getImages().ICP.ICP);
		rootNode.setSelectedImage(form.getImages().ICP.ICP);
		
		// Add ICP Stages
		populateICPStages(rootNode, displayICP.getStages(), filterValue);
		
		// Expand the node
		rootNode.setExpanded(true);
	}

	private void populateICPStages(TreeNode rootNode, ICPStageDisplayVoCollection stages, String filterValue)
	{
		// Terminate function if stage collection is null
		if (stages == null)
			return;
		
		// Sort stages
		stages.sort(new StageComparator());
		
		for (int i = 0; i < stages.size(); i++)
		{
			ICPStageDisplayVo stage = stages.get(i);
			
			if (stage == null)
				continue;
			
			// Add stage to root node
			TreeNode stageNode = rootNode.getNodes().add(stage, stage.getName());
			stageNode.setCheckBoxVisible(false);
			stageNode.setTextColor(PreActiveActiveInactiveStatus.INACTIVE.equals(stage.getStatus()) ? Color.Gray : Color.Black);
			
			// Set node images
			stageNode.setCollapsedImage(form.getImages().ICP.Stage);
			stageNode.setExpandedImage(form.getImages().ICP.Stage);
			stageNode.setSelectedImage(form.getImages().ICP.Stage);
			
			// Add ICP Phases
			populateICPPhases(stageNode, stage.getPhases(), filterValue);
			
			// Check to see if the node has child, else remove it
			if (filterValue == null || stageNode.getNodes().size() > 0)
			{			
    			// Expand the node
    			stageNode.setExpanded(true);
			}
			else
			{
				rootNode.getNodes().remove(stageNode);
			}
		}
	}

	private void populateICPPhases(TreeNode stageNode, ICPPhaseDisplayVoCollection phases, String filterValue)
	{
		// Terminate function if phase collection is null
		if (phases == null)
			return;
		
		// Sort phases
		phases.sort(new PhaseComparator());
		
		for (int i = 0; i < phases.size(); i++)
		{
			ICPPhaseDisplayVo phase = phases.get(i);
			
			if (phases == null)
				continue;
			
			// Add phase to stage node
			TreeNode phaseNode = stageNode.getNodes().add(phase, phase.getName());
			phaseNode.setCheckBoxVisible(false);
			phaseNode.setTextColor(PreActiveActiveInactiveStatus.INACTIVE.equals(phase.getStatus()) ? Color.Gray : Color.Black);
			
			// Set node images
			phaseNode.setCollapsedImage(form.getImages().ICP.Phase);
			phaseNode.setExpandedImage(form.getImages().ICP.Phase);
			phaseNode.setSelectedImage(form.getImages().ICP.Phase);
			
			// Add ICP Actions
			populateICPActions(phaseNode, phase.getActions(), filterValue);
			
			// Check to see if the node has child, else remove it
			if (filterValue == null || phaseNode.getNodes().size() > 0)
			{
				// Expand the node
				phaseNode.setExpanded(true);
			}
			else
			{
				stageNode.getNodes().remove(phaseNode);
			}
		}
		
	}

	private void populateICPActions(TreeNode phaseNode, ICPActionLiteVoCollection actions, String filterValue)
	{
		// Terminate function if action collection is  null
		if (actions == null)
			return;
		
		// Sort actions
		actions.sort(new ActionComparator());
		
		for (int i = 0; i < actions.size(); i++)
		{
			ICPActionLiteVo action = actions.get(i);
			
			if (action == null)
				continue;
			
			if (filterValue != null && action.getNameIsNotNull() && !action.getName().toUpperCase().contains(filterValue.toUpperCase()))
				continue;
			
			// Add action to phase node
			TreeNode actionNode = phaseNode.getNodes().add(action, action.getName());
			actionNode.setCheckBoxVisible(!PreActiveActiveInactiveStatus.INACTIVE.equals(action.getStatus()) && !action.equals(form.getLocalContext().getSelectedICPAction()));
			actionNode.setTextColor(PreActiveActiveInactiveStatus.INACTIVE.equals(action.getStatus()) ? Color.Gray : Color.Black);
			
			if (form.getGlobalContext().ICP.getLinkedActionsIsNotNull() && form.getGlobalContext().ICP.getLinkedActions().contains(action))
				actionNode.setChecked(true);
			
			// Set node images
			actionNode.setCollapsedImage(form.getImages().ICP.Action);
			actionNode.setExpandedImage(form.getImages().ICP.Action);
			actionNode.setSelectedImage(form.getImages().ICP.Action);
		}
	}

	public void clearInstanceControls()
	{
		// Clear tree
		form.treICP().clear();
	}
	public void newInstance() throws ims.framework.exceptions.PresentationLogicException
	{
		// TODO: Add you code here.
	}
	public boolean save() throws ims.framework.exceptions.PresentationLogicException
	{
		// TODO: Add you code here.
		return false;
	}
	public void updateControlsState()
	{
		// TODO: Add you code here.
	}
	public void updateInstance()
	{
		// TODO: Add you code here.
	}


	/**
	 * Private class for sorting ICP Stages after sequence
	 * @author gjosan
	 *
	 */
	private class StageComparator implements Comparator<ICPStageDisplayVo>
	{

		public int compare(ICPStageDisplayVo stageOne, ICPStageDisplayVo stageTwo)
		{
			if (stageOne.getSequenceIsNotNull())
				return stageOne.getSequence().compareTo(stageTwo.getSequence());
			
			if (stageTwo.getSequenceIsNotNull())
				return stageTwo.getSequence().compareTo(stageOne.getSequence());
			
			return 0;
		}
		
	}
	
	private class PhaseComparator implements Comparator<ICPPhaseDisplayVo>
	{

		public int compare(ICPPhaseDisplayVo phaseOne, ICPPhaseDisplayVo phaseTwo)
		{
			if (phaseOne.getSequenceIsNotNull())
				return phaseOne.getSequence().compareTo(phaseTwo.getSequence());
			
			if (phaseTwo.getSequenceIsNotNull())
				return phaseTwo.getSequence().compareTo(phaseOne.getSequence());
	
			return 0;
		}
		
	}
	
	private class ActionComparator implements Comparator<ICPActionLiteVo>
	{

		public int compare(ICPActionLiteVo arg0, ICPActionLiteVo arg1)
		{
			if (arg0.getSequenceIsNotNull())
				return arg0.getSequence().compareTo(arg1.getSequence());
			
			if (arg1.getSequenceIsNotNull())
				return arg1.getSequence().compareTo(arg0.getSequence());

			return 0;
		}
		
	}

}
