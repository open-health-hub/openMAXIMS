//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by George Cristian Josan using IMS Development Environment (version 1.71 build 3714.19498)
// Copyright (C) 1995-2010 IMS MAXIMS. All rights reserved.

package ims.icp.domain.impl;

import ims.clinical.configuration.vo.ClinicalProblemRefVo;
import ims.clinical.vo.ClinicalProblemShortVoCollection;
import ims.clinical.vo.domain.ClinicalProblemShortVoAssembler;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.vo.DiagLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVoCollection;
import ims.core.vo.ProcedureLiteVoCollection;
import ims.core.vo.domain.DiagLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.ProcedureLiteVoAssembler;
import ims.core.vo.lookups.ICPCategoryType;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.core.vo.lookups.Specialty;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.framework.utils.Date;
import ims.icp.domain.base.impl.BaseICPConfigImpl;
import ims.icp.vo.ICPActionCloneVo;
import ims.icp.vo.ICPActionCloneVoCollection;
import ims.icp.vo.ICPActionLiteVo;
import ims.icp.vo.ICPActionLiteVoCollection;
import ims.icp.vo.ICPActionShortVo;
import ims.icp.vo.ICPConfigurationDisplayVo;
import ims.icp.vo.ICPFullVo;
import ims.icp.vo.ICPLiteVoCollection;
import ims.icp.vo.ICPPhaseCloneVo;
import ims.icp.vo.ICPPhaseCloneVoCollection;
import ims.icp.vo.ICPPhaseFullVo;
import ims.icp.vo.ICPPhaseLiteVo;
import ims.icp.vo.ICPPhaseLiteVoCollection;
import ims.icp.vo.ICPPhaseShortVo;
import ims.icp.vo.ICPPhaseVo;
import ims.icp.vo.ICPShortVo;
import ims.icp.vo.ICPStageCloneVo;
import ims.icp.vo.ICPStageFullVo;
import ims.icp.vo.ICPStageLiteVo;
import ims.icp.vo.ICPStageLiteVoCollection;
import ims.icp.vo.ICPStageShortVo;
import ims.icp.vo.ICPStageVo;
import ims.icp.vo.ICPVo;
import ims.icp.vo.domain.ICPActionCloneVoAssembler;
import ims.icp.vo.domain.ICPActionLiteVoAssembler;
import ims.icp.vo.domain.ICPActionShortVoAssembler;
import ims.icp.vo.domain.ICPConfigurationDisplayVoAssembler;
import ims.icp.vo.domain.ICPFullVoAssembler;
import ims.icp.vo.domain.ICPLiteVoAssembler;
import ims.icp.vo.domain.ICPPhaseCloneVoAssembler;
import ims.icp.vo.domain.ICPPhaseFullVoAssembler;
import ims.icp.vo.domain.ICPPhaseLiteVoAssembler;
import ims.icp.vo.domain.ICPPhaseShortVoAssembler;
import ims.icp.vo.domain.ICPPhaseVoAssembler;
import ims.icp.vo.domain.ICPShortVoAssembler;
import ims.icp.vo.domain.ICPStageCloneVoAssembler;
import ims.icp.vo.domain.ICPStageFullVoAssembler;
import ims.icp.vo.domain.ICPStageLiteVoAssembler;
import ims.icp.vo.domain.ICPStageShortVoAssembler;
import ims.icp.vo.domain.ICPStageVoAssembler;
import ims.icp.vo.domain.ICPVoAssembler;
import ims.icps.configuration.domain.objects.ICP;
import ims.icps.configuration.domain.objects.ICPAction;
import ims.icps.configuration.domain.objects.ICPPhase;
import ims.icps.configuration.domain.objects.ICPStage;
import ims.icps.configuration.vo.ICPActionRefVo;
import ims.icps.configuration.vo.ICPPhaseRefVo;
import ims.icps.configuration.vo.ICPRefVo;
import ims.icps.configuration.vo.ICPStageRefVo;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ICPConfigImpl extends BaseICPConfigImpl
{

	private static final long serialVersionUID = 1L;

	// --------------------------------------------------------------------------------------------------------------------------------------------------
	// Functions used for retrieving data for populating the tree
	// --------------------------------------------------------------------------------------------------------------------------------------------------

	/**
	 * Find ICPs based on criteria
	 */
	public ICPLiteVoCollection listICP(String name, PreActiveActiveInactiveStatus status, ICPCategoryType category, Specialty specialty, MemberOfStaffRefVo contactPerson, Date creationDate)
	{
		// String Builder for query
		StringBuilder hqlQuery = new StringBuilder();
		hqlQuery.append("from ICP as icp");

		// Array list for parameters
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		// Build conditions strings
		ArrayList<String> conditions = new ArrayList<String>();

		if (name != null && name.length() > 0)
		{
			conditions.add("UPPER(icp.name) like :NAME");

			paramNames.add("NAME");
			paramValues.add("%" + name.toUpperCase() + "%");
		}

		if (status != null)
		{
			conditions.add("icp.status.id = :STATUS_ID");

			paramNames.add("STATUS_ID");
			paramValues.add(status.getID());
		}

		if (category != null)
		{
			conditions.add("icp.category.id = :CATEGORY_ID");

			paramNames.add("CATEGORY_ID");
			paramValues.add(category.getID());
		}

		if (specialty != null)
		{
			conditions.add("icp.specialty.id = :SPECIALTY_ID");

			paramNames.add("SPECIALTY_ID");
			paramValues.add(specialty.getID());
		}

		if (contactPerson != null)
		{
			conditions.add("icp.contactPerson.id = :MOS_ID");

			paramNames.add("MOS_ID");
			paramValues.add(contactPerson.getID_MemberOfStaff());
		}

		if (creationDate != null)
		{
			conditions.add("icp.creationDate = :DATE");

			paramNames.add("DATE");
			paramValues.add(creationDate.getDate());
		}

		// Add conditions if necessary
		if (conditions != null && conditions.size() > 0)
		{
			hqlQuery.append(" where ");

			hqlQuery.append(conditions.get(0));

			for (int i = 1; i < conditions.size(); i++)
			{
				hqlQuery.append(" and ");
				hqlQuery.append(conditions.get(i));
			}
		}

		hqlQuery.append(" order by UPPER(icp.name) asc");

		return ICPLiteVoAssembler.createICPLiteVoCollectionFromICP(getDomainFactory().find(hqlQuery.toString(), paramNames, paramValues));
	}

	public ICPStageLiteVoCollection listStages(ICPRefVo icp)
	{
		if (icp == null || !icp.getID_ICPIsNotNull())
			return null;

		// Domain factory - tool for HQL query
		DomainFactory factory = getDomainFactory();

		// Get ICP domain object
		ICP domainICP = (ICP) factory.getDomainObject(ICP.class, icp.getID_ICP());

		// Get the ICP stages
		return ICPStageLiteVoAssembler.createICPStageLiteVoCollectionFromICPStage(domainICP.getStages());
	}

	public ICPPhaseLiteVoCollection listPhases(ICPStageRefVo icpStage)
	{
		if (icpStage == null || !icpStage.getID_ICPStageIsNotNull())
			return null;

		// Domain factory - tool for HQL query
		DomainFactory factory = getDomainFactory();

		// Get ICP Stage domain object
		ICPStage domainICPStage = (ICPStage) factory.getDomainObject(ICPStage.class, icpStage.getID_ICPStage());

		// Get the ICP phases
		return ICPPhaseLiteVoAssembler.createICPPhaseLiteVoCollectionFromICPPhase(domainICPStage.getPhases());
	}

	public ICPActionLiteVoCollection listActions(ICPPhaseRefVo phase)
	{
		if (phase == null || !phase.getID_ICPPhaseIsNotNull())
			return null;

		// Domain factory - tool for HQL query
		DomainFactory factory = getDomainFactory();

		// Get ICP Phase domain object
		ICPPhase domainICPPhase = (ICPPhase) factory.getDomainObject(ICPPhase.class, phase.getID_ICPPhase());

		// Get the ICP actions
		return ICPActionLiteVoAssembler.createICPActionLiteVoCollectionFromICPAction(domainICPPhase.getActions());
	}

	public ICPConfigurationDisplayVo getDisplayICP(ICPRefVo icp)
	{
		if (icp == null || !icp.getID_ICPIsNotNull())
			return null;

		return ICPConfigurationDisplayVoAssembler.create((ICP) getDomainFactory().getDomainObject(ICP.class, icp.getID_ICP()));
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------
	// Functions used for retrieving data for populating the instance controls
	// --------------------------------------------------------------------------------------------------------------------------------------------------
	/**
	 * Function used to retrieve the Short VO for selected item (ICP, ICPStage,
	 * ICPPhase or ICPAction)
	 */
	public Object getItem(Object item)
	{
		if (item instanceof ICPRefVo)
			return getICP((ICPRefVo) item);

		if (item instanceof ICPStageRefVo)
			return getICPStage((ICPStageRefVo) item);

		if (item instanceof ICPPhaseRefVo)
			return getICPPhase((ICPPhaseRefVo) item);

		if (item instanceof ICPActionRefVo)
			return getICPAction((ICPActionRefVo) item);

		return null;
	}

	/**
	 * Function used to retrieve the Short VO for given ICP
	 */
	public ICPVo getICP(ICPRefVo refICP)
	{
		if (refICP == null || !refICP.getID_ICPIsNotNull())
			return null;

		return ICPVoAssembler.create((ICP) getDomainFactory().getDomainObject(ICP.class, refICP.getID_ICP()));
	}

	public ICPFullVo getFullICP(ICPRefVo refICP)
	{
		return ICPFullVoAssembler.create((ICP) getDomainFactory().getDomainObject(ICP.class, refICP.getID_ICP()));
	}

	/**
	 * Function used to retrieve the Short VO for given ICP Stage
	 */
	public ICPStageVo getICPStage(ICPStageRefVo icpStageRef)
	{
		if (icpStageRef == null || !icpStageRef.getID_ICPStageIsNotNull())
			return null;

		return ICPStageVoAssembler.create((ICPStage) getDomainFactory().getDomainObject(ICPStage.class, icpStageRef.getID_ICPStage()));
	}


	/**
	 * WDEV-13773
	 * Function used to get the full ICP Stage
	 */
	public ICPStageFullVo getICPStageFull(ICPStageRefVo stage)
	{
		long start = System.nanoTime();
		
		if (stage == null || !stage.getID_ICPStageIsNotNull())
			return null;

		StringBuilder query = new StringBuilder();
		
		query.append("SELECT stage, phase, action FROM ICPStage AS stage LEFT JOIN stage.phases AS phase LEFT JOIN phase.actions AS action WHERE stage.id = :STAGE_ID");
		
		List<?> queryResults = getDomainFactory().find(query.toString(), "STAGE_ID", stage.getID_ICPStage());
		
		if (queryResults == null)
			return null;
		
		Iterator<?> iterator = queryResults.iterator();
		
		ICPStageCloneVo		stageResult		= null;
		ICPPhaseCloneVo		phaseResult		= null;
		ICPActionCloneVo	actionResult	= null;
		
		while (iterator.hasNext())
		{
			Object[] queryResultIteration = (Object[]) iterator.next();
			
			if (stageResult == null && queryResultIteration[0] instanceof ICPStage)
			{
				stageResult = ICPStageCloneVoAssembler.create((ICPStage) queryResultIteration[0]);
				
				stageResult.setPhases(new ICPPhaseCloneVoCollection());
			}
			
			if (queryResultIteration[1] instanceof ICPPhase)
			{
				if (phaseResult == null || phaseResult.getID_ICPPhase() != ((ICPPhase) queryResultIteration[1]).getId())
				{
					phaseResult = ICPPhaseCloneVoAssembler.create((ICPPhase) queryResultIteration[1]);
					
					phaseResult.setActions(new ICPActionCloneVoCollection());
					
					if (stageResult != null && stageResult.getPhasesIsNotNull())
					{
						stageResult.getPhases().add(phaseResult);
					}
				}
			}
			
			if (queryResultIteration[2] instanceof ICPAction)
			{
				if (actionResult == null || actionResult.getID_ICPAction() != ((ICPAction) queryResultIteration[2]).getId())
				{
					actionResult = ICPActionCloneVoAssembler.create((ICPAction) queryResultIteration[2]);
					
					if (phaseResult != null && phaseResult.getActionsIsNotNull())
					{
						phaseResult.getActions().add(actionResult);
					}
				}
			}
		}

		ICPStageFullVo stageToReturn = stageResult.getCloneStageFullVo();

		long end = System.nanoTime();
		
		System.out.println("Elapsed time:" + (end - start) + " nanoseconds");
		
		return stageToReturn;
	}

	/**
	 * Function used to retrieve the Short VO for given ICP Phase
	 */
	public ICPPhaseVo getICPPhase(ICPPhaseRefVo icpPhaseRef)
	{
		if (icpPhaseRef == null || !icpPhaseRef.getID_ICPPhaseIsNotNull())
			return null;

		return ICPPhaseVoAssembler.create((ICPPhase) getDomainFactory().getDomainObject(ICPPhase.class, icpPhaseRef.getID_ICPPhase()));
	}

	/**
	 * WDEV-13773
	 * Function used to get the full ICP Phase
	 */
	public ICPPhaseFullVo getICPPhaseFull(ICPPhaseRefVo phase)
	{
		if (phase == null || !phase.getID_ICPPhaseIsNotNull())
			return null;

		
		StringBuilder query = new StringBuilder();
		
		query.append("SELECT phase, action FROM ICPPhase AS phase LEFT JOIN phase.actions AS action WHERE phase.id = :PHASE_ID");
		
		List<?> queryResults = getDomainFactory().find(query.toString(), "PHASE_ID", phase.getID_ICPPhase());
		
		if (queryResults == null)
			return null;
		
		Iterator<?> iterator = queryResults.iterator();
		
		ICPPhaseCloneVo		phaseResult		= null;
		ICPActionCloneVo	actionResult	= null;
		
		while (iterator.hasNext())
		{
			Object[] queryResultIteration = (Object[]) iterator.next();
			
			if (phaseResult == null && queryResultIteration[0] instanceof ICPPhase)
			{
				phaseResult = ICPPhaseCloneVoAssembler.create((ICPPhase) queryResultIteration[0]);
				
				phaseResult.setActions(new ICPActionCloneVoCollection());
			}
			
			if (queryResultIteration[1] instanceof ICPAction)
			{
				if (actionResult == null || actionResult.getID_ICPAction() != ((ICPAction) queryResultIteration[1]).getId())
				{
					actionResult = ICPActionCloneVoAssembler.create((ICPAction) queryResultIteration[1]);
					
					if (phaseResult != null && phaseResult.getActionsIsNotNull())
					{
						phaseResult.getActions().add(actionResult);
					}
				}
			}
		}
		
		return phaseResult.getClonePhaseFullVo();
	}

	/**
	 * Function used to retrieve the Short VO for given ICP Action
	 */
	public ICPActionShortVo getICPAction(ICPActionRefVo icpActionRef)
	{
		if (icpActionRef == null || !icpActionRef.getID_ICPActionIsNotNull())
			return null;

		return ICPActionShortVoAssembler.create((ICPAction) getDomainFactory().getDomainObject(ICPAction.class, icpActionRef.getID_ICPAction()));
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------
	// Functions used for saving items
	// --------------------------------------------------------------------------------------------------------------------------------------------------

	/**
	 * Function used to generally save an item to database It will call specific
	 * functions to save based on the type of item provided
	 */
	public Object save(Object item) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		if (item instanceof ICPVo)
			return saveICP((ICPVo) item);
		
		if (item instanceof ICPFullVo)
			return saveFullICP((ICPFullVo) item);

		if (item instanceof ICPStageVo)
			return saveICPStage((ICPStageVo) item);

		if (item instanceof ICPPhaseVo)
			return saveICPPhase((ICPPhaseVo) item);

		if (item instanceof ICPActionShortVo)
			return saveICPAction((ICPActionShortVo) item);

		return null;
	}

	/**
	 * Function used to save provided ICP to database
	 */
	public ICPVo saveICP(ICPVo icp) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		// Check for parameter
		if (icp == null)
			throw new DomainRuntimeException("Logical error - Can not save null ICP");

		// Check VO for validation
		if (!icp.isValidated())
			throw new DomainRuntimeException("Logical error - ICP Vo must be validated before save");
		
		if (PreActiveActiveInactiveStatus.ACTIVE.equals(icp.getStatus()) && existsICPwithProblem(icp, icp.getProblem()))
		{
			throw new DomainInterfaceException("Another active ICP configuration exists for selected problem");
		}

		// Get domain factory
		DomainFactory factory = getDomainFactory();

		// Extract ICP domain object
		ICP domainICP = ICPVoAssembler.extractICP(factory, icp);

		// Save domain object
		factory.save(domainICP);

		// Return saved domain object
		return ICPVoAssembler.create(domainICP);
	}

	/**
	 * Function used to save a clone for the ICP
	 */
	public ICPVo saveFullICP(ICPFullVo fullICP) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		// Check for parameters
		if (fullICP == null)
			throw new DomainRuntimeException("Logical error - Can not save null ICP");
		
		// Check VO for validation
		if (!fullICP.isValidated())
			throw new DomainRuntimeException("Logical error - ICP VO must be validated before save");
		
		if (PreActiveActiveInactiveStatus.ACTIVE.equals(fullICP.getStatus()) && existsICPwithProblem(fullICP, fullICP.getProblem()))
		{
			throw new DomainInterfaceException("Another active ICP configuration exists for selected problem");
		}
		
		// Get domain factory
		DomainFactory factory = getDomainFactory();
		
		// Extract ICP domain object
		ICP domainICP = ICPFullVoAssembler.extractICP(factory, fullICP);
		
		// Save domain object
		factory.save(domainICP);
		
		// Return saved domain object
		return ICPVoAssembler.create(domainICP);
	}

	
	/**
	 * Function used to check if there is an active ICP saved for problem, different from the one provided
	 * If problem is null, then it returns false - consider no ICP exists for problem
	 */
	private boolean existsICPwithProblem(ICPRefVo icp, ClinicalProblemRefVo problem)
	{
		if (problem == null)
			return false;
		
		StringBuilder hqlQuery = new StringBuilder();
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		hqlQuery.append("SELECT COUNT(icp) FROM ICP AS icp LEFT JOIN icp.problem AS problem WHERE icp.status.id = :ACTIVE_STATUS AND icp.isRIE is null AND problem.id = :PROBLEM ");
		
		paramNames.add("ACTIVE_STATUS");	paramValues.add(PreActiveActiveInactiveStatus.ACTIVE.getID());
		paramNames.add("PROBLEM");			paramValues.add(problem.getID_ClinicalProblem());
		
		if (icp != null && icp.getID_ICPIsNotNull())
		{
			hqlQuery.append(" AND icp.id <> :ICP_ID");
			
			paramNames.add("ICP_ID");		paramValues.add(icp.getID_ICP());
		}

		long count = getDomainFactory().countWithHQL(hqlQuery.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray());
		
		if (count > 0)
			return true;
		
		return false;
	}


	/**
	 * Function used to save provided ICP Stage to database
	 */
	public ICPStageVo saveICPStage(ICPStageVo icpStage) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		// Check for parameter
		if (icpStage == null)
			throw new DomainRuntimeException("Logical error - Can not save null ICP Stage");

		// Check VO for validation
		if (!icpStage.isValidated())
			throw new DomainRuntimeException("Logical error - ICP Stage Vo must be validated before save");

		// Get domain factory
		DomainFactory factory = getDomainFactory();

		// Extract ICP Stage domain object
		ICPStage domainICPStage = ICPStageVoAssembler.extractICPStage(factory, icpStage);

		// Save domain object
		factory.save(domainICPStage);

		// Returned saved domain object
		return ICPStageVoAssembler.create(domainICPStage);
	}

	/**
	 * Function used to save provided ICP Phase to database
	 */
	public ICPPhaseVo saveICPPhase(ICPPhaseVo icpPhase) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		// Check for parameter
		if (icpPhase == null)
			throw new DomainRuntimeException("Logical error - Can not save null ICP Phase");

		// Check VO for validation
		if (!icpPhase.isValidated())
			throw new DomainRuntimeException("Logical error - ICP Phase Vo must be validated before save");

		// Get domain factory
		DomainFactory factory = getDomainFactory();

		// Extract ICP Phase domain object
		ICPPhase domainICPPhase = ICPPhaseVoAssembler.extractICPPhase(factory, icpPhase);

		// Save domain object
		factory.save(domainICPPhase);

		// Returned saved domain object
		return ICPPhaseVoAssembler.create(domainICPPhase);
	}

	/**
	 * Function used to save provided ICP Action to database
	 */
	public ICPActionShortVo saveICPAction(ICPActionShortVo icpAction) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		// Check for parameter
		if (icpAction == null)
			throw new DomainRuntimeException("Logical error - Can not save null ICP Action");

		// Check VO for validation
		if (!icpAction.isValidated())
			throw new DomainRuntimeException("Logical error - ICP Action Vo must be validated before save");

		// Get domain factory
		DomainFactory factory = getDomainFactory();

		// Extract ICP Action domain object
		ICPAction domainICPAction = ICPActionShortVoAssembler.extractICPAction(factory, icpAction);

		// Save domain object
		factory.save(domainICPAction);

		// Returned saved domain object
		return ICPActionShortVoAssembler.create(domainICPAction);
	}

	/**
	 * Function used to add an ICP Stage to an ICP
	 */
	@SuppressWarnings("unchecked")
	public ICPStageVo addStage(ICPStageVo stage, ICPShortVo icp) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		// Check for parameters
		if (icp == null)
			throw new DomainRuntimeException("Logical error - Can not add an ICP Stage to a null ICP");

		if (stage == null)
			throw new DomainRuntimeException("Logical error - Can not add a null ICP Stage to an ICP");

		// Check VO for validation
		if (!icp.isValidated() || !stage.isValidated())
			throw new DomainRuntimeException("Logical error - ICP Stage Vo and ICP Vo must be validated before save");

		// Get domain factory
		DomainFactory factory = getDomainFactory();

		// Extract ICP Stage domain object
		ICPStage domainICPStage = ICPStageVoAssembler.extractICPStage(factory, stage);

		// Extract ICP domain object
		ICP domainICP = ICPShortVoAssembler.extractICP(factory, icp);

		// Add ICP Stage to ICP stage collection
		domainICP.getStages().add(domainICPStage);

		// Save ICP domain object
		factory.save(domainICP);

		// Return the saved stage
		return ICPStageVoAssembler.create(domainICPStage);
	}

	/**
	 * WDEV-13773
	 * Function used to add a cloned ICP Stage to the ICP
	 */
	@SuppressWarnings("unchecked")
	public ICPStageVo addClonedStage(ICPStageFullVo stage, ICPShortVo icp) throws StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException
	{
		// Check for parameters
		if (icp == null)
			throw new DomainRuntimeException("Logical error - Can not add an ICP Stage to a null ICP");
		
		if (stage == null)
			throw new DomainRuntimeException("Logical error - Can not add a null ICP Stage to an ICP");
		
		// Check VO for validation
		if (!icp.isValidated() || !stage.isValidated())
			throw new DomainRuntimeException("Logical error - ICP Stage Vo and ICP Vo must be validated before save");
		
		// Get domain factory
		DomainFactory factory = getDomainFactory();
		
		// Extract ICP Stage domain object
		ICPStage domainICPStage = ICPStageFullVoAssembler.extractICPStage(factory, stage);
		
		// Extract ICP domain object
		ICP domainICP = ICPShortVoAssembler.extractICP(factory, icp);
		
		// Add ICP Stage to ICP Stage collection
		domainICP.getStages().add(domainICPStage);
		
		// Save ICP domain object
		factory.save(domainICP);
		
		// Return the saved stage
		return ICPStageVoAssembler.create(domainICPStage);
	}

	/**
	 * Function used to add an ICP Phase to an ICP Stage
	 */
	@SuppressWarnings("unchecked")
	public ICPPhaseVo addPhase(ICPPhaseVo phase, ICPStageShortVo stage) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		// Check for parameters
		if (stage == null)
			throw new DomainRuntimeException("Logical error - Can not add an ICP Phase to a null ICP Stage");

		if (phase == null)
			throw new DomainRuntimeException("Logical error - Can not add a null ICP Phase to an ICP Stage");

		// Check VO for validation
		if (!stage.isValidated() || !phase.isValidated())
			throw new DomainRuntimeException("Logical error - ICP Phase Vo and ICP Stage Vo must be validated before save");

		// Get domain factory
		DomainFactory factory = getDomainFactory();

		// Extract ICP Phase domain object
		ICPPhase domainICPPhase = ICPPhaseVoAssembler.extractICPPhase(factory, phase);

		// Extract ICP Stage domain object
		ICPStage domainICPStage = ICPStageShortVoAssembler.extractICPStage(factory, stage);

		domainICPStage.getPhases().add(domainICPPhase);

		// Save ICP domain object
		factory.save(domainICPStage);

		// Return the saved phase
		return ICPPhaseVoAssembler.create(domainICPPhase);
	}

	/**
	 * WDEV-13773
	 * Function used to add a cloned ICP Phase to the stage
	 */
	@SuppressWarnings("unchecked")
	public ICPPhaseVo addClonedPhase(ICPPhaseFullVo phase, ICPStageShortVo stage) throws StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException
	{
		// Check for parameters
		if (stage == null)
			throw new DomainRuntimeException("Logical error - Can not add an ICP Phase to a null ICP Stage");
		
		if (phase == null)
			throw new DomainRuntimeException("Logical error - Can not add a null ICP Phase to an ICP Stage");
		
		// Check VO for validation
		if (!stage.isValidated() || !phase.isValidated())
			throw new DomainRuntimeException("Logical error - ICP Phase Vo and ICP Stage Vo must be validated before save");

		// Get domain factory
		DomainFactory factory = getDomainFactory();
		
		// Extract ICP Phase domain object
		ICPPhase domainICPPhase = ICPPhaseFullVoAssembler.extractICPPhase(factory, phase);
		
		// Extract ICP Stage domain object
		ICPStage domainICPStage = ICPStageShortVoAssembler.extractICPStage(factory, stage);
		
		domainICPStage.getPhases().add(domainICPPhase);
		
		// Save ICP Stage domain object
		factory.save(domainICPStage);
		
		// Return the saved phase
		return ICPPhaseVoAssembler.create(domainICPPhase);
	}

	/**
	 * Function used to add an ICP Action to an ICP Phase
	 */
	@SuppressWarnings("unchecked")
	public ICPActionShortVo addAction(ICPActionShortVo action, ICPPhaseShortVo phase) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		// Check for parameters
		if (phase == null)
			throw new DomainRuntimeException("Logical error - Can not add an ICP Action to a null ICP Phase");

		if (action == null)
			throw new DomainRuntimeException("Logical error - Can not add a null ICP Action to an ICP Phase");

		// Check VO for validation
		if (!phase.isValidated() || !action.isValidated())
			throw new DomainRuntimeException("Logical error - ICP Action Vo and ICP Phase Vo must be validated before save");

		// Get domain factory
		DomainFactory factory = getDomainFactory();

		// Extract ICP Action domain object
		ICPAction domainICPAction = ICPActionShortVoAssembler.extractICPAction(factory, action);

		// Extract ICP Action domain object
		ICPPhase domainICPPhase = ICPPhaseShortVoAssembler.extractICPPhase(factory, phase);

		domainICPPhase.getActions().add(domainICPAction);

		// Save ICP Phase domain object
		factory.save(domainICPPhase);

		// Return the saved action
		return ICPActionShortVoAssembler.create(domainICPAction);
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------
	// Functions used for saving double items - used when moving up and down an
	// item
	// --------------------------------------------------------------------------------------------------------------------------------------------------

	/**
	 * Function used to save two ICP Stages - used for moving up or down a stage
	 */
	public ICPStageLiteVo save(ICPStageLiteVo stage1, ICPStageLiteVo stage2) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		// Check for parameters
		if (stage1 == null || stage2 == null)
			return stage1;

		// Check if they are validated
		if (!stage1.isValidated() || !stage2.isValidated())
			throw new DomainRuntimeException("Stages must be validated");

		// Get factory
		DomainFactory factory = getDomainFactory();

		// Extract ICP Stages domain objects
		ICPStage domainICPStage1 = ICPStageLiteVoAssembler.extractICPStage(factory, stage1);
		ICPStage domainICPStage2 = ICPStageLiteVoAssembler.extractICPStage(factory, stage2);

		// Save ICP Stage domain objects
		factory.save(domainICPStage1);
		factory.save(domainICPStage2);

		// Return the saved stage
		return ICPStageLiteVoAssembler.create(domainICPStage1);
	}

	/**
	 * Function used to save two ICP Phases - used for moving up or down a stage
	 */
	public ICPPhaseLiteVo save(ICPPhaseLiteVo phase1, ICPPhaseLiteVo phase2) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		// Check for parameters
		if (phase1 == null || phase2 == null)
			return phase1;

		// Check if they are validated
		if (!phase1.isValidated() || !phase2.isValidated())
			throw new DomainRuntimeException("Phases must be validated");

		// Get factory
		DomainFactory factory = getDomainFactory();

		// Extract ICP Phases domain objects
		ICPPhase domainICPPhase1 = ICPPhaseLiteVoAssembler.extractICPPhase(factory, phase1);
		ICPPhase domainICPPhase2 = ICPPhaseLiteVoAssembler.extractICPPhase(factory, phase2);

		// Save ICP Phase domain objects
		factory.save(domainICPPhase1);
		factory.save(domainICPPhase2);

		// Return the saved phase
		return ICPPhaseLiteVoAssembler.create(domainICPPhase1);
	}

	/**
	 * Function used to save two ICP Actions - used for moving up or down an
	 * action
	 */
	public ICPActionLiteVo save(ICPActionLiteVo action1, ICPActionLiteVo action2) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		// Check for parameters
		if (action1 == null || action2 == null)
			return action1;

		// Check if they are validated
		if (!action1.isValidated() || !action2.isValidated())
			throw new DomainRuntimeException("Actions must be validated");

		// Get factory
		DomainFactory factory = getDomainFactory();

		// Extract ICP Action domain objects
		ICPAction domainICPAction1 = ICPActionLiteVoAssembler.extractICPAction(factory, action1);
		ICPAction domainICPAction2 = ICPActionLiteVoAssembler.extractICPAction(factory, action2);

		// Save ICP Action domain objects
		factory.save(domainICPAction1);
		factory.save(domainICPAction2);

		// Return the saved phase
		return ICPActionLiteVoAssembler.create(domainICPAction1);
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------
	// Functions used for inactivating items
	// --------------------------------------------------------------------------------------------------------------------------------------------------

	/**
	 * Function used to generally inactivate an item It will call specific
	 * functions to inactivate based on the type of the item provided
	 */
	public Object inactivateItem(Object item) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		// Get domain factory
		DomainFactory factory = getDomainFactory();

		if (item instanceof ICPRefVo)
		{
			return inactivateICP((ICP) factory.getDomainObject(ICP.class, ((ICPRefVo) item).getID_ICP()));
		}

		if (item instanceof ICPStageRefVo)
			return inactivateICPStage((ICPStage) factory.getDomainObject(ICPStage.class, ((ICPStageRefVo) item).getID_ICPStage()));

		if (item instanceof ICPPhaseRefVo)
			return inactivateICPPhase((ICPPhase) factory.getDomainObject(ICPPhase.class, ((ICPPhaseRefVo) item).getID_ICPPhase()));

		if (item instanceof ICPActionRefVo)
			return inactivateICPAction((ICPAction) factory.getDomainObject(ICPAction.class, ((ICPActionRefVo) item).getID_ICPAction()));

		return null;
	}

	/**
	 * Function used to inactivate an ICP
	 */
	@SuppressWarnings("unchecked")
	public ICPVo inactivateICP(ICP icp) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		final int INACTIVE_STATUS = -618;

		// Check parameters
		if (icp == null)
			return null;

		// Get domain factory
		DomainFactory factory = getDomainFactory();

		// Modify the status for ICP and stages
		Iterator<ICPStage> iterator = icp.getStages().iterator();

		while (iterator.hasNext())
		{
			// Inactive stages
			inactivateICPStage(iterator.next());
		}

		icp.setStatus(factory.getLookupInstance(INACTIVE_STATUS));

		// Save ICP
		factory.save(icp);

		return ICPVoAssembler.create(icp);
	}

	/**
	 * Function used to inactivate an ICP Stage
	 */
	@SuppressWarnings("unchecked")
	public ICPStageVo inactivateICPStage(ICPStage icpStage) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		final int INACTIVE_STATUS = -618;

		// Check parameters
		if (icpStage == null)
			return null;

		// Get domain factory
		DomainFactory factory = getDomainFactory();

		// Modify the status for stage and phases
		Iterator<ICPPhase> iterator = icpStage.getPhases().iterator();

		while (iterator.hasNext())
		{
			// Inactivate phase
			inactivateICPPhase(iterator.next());
		}

		icpStage.setStatus(factory.getLookupInstance(INACTIVE_STATUS));

		// Save ICP Stage - We need to save, the function might be called by
		// itself
		factory.save(icpStage);

		return ICPStageVoAssembler.create(icpStage);
	}

	/**
	 * Function used to inactivate an ICP Phase
	 */
	@SuppressWarnings("unchecked")
	public ICPPhaseVo inactivateICPPhase(ICPPhase icpPhase) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		final int INACTIVE_STATUS = -618;

		// Check parameters
		if (icpPhase == null)
			return null;

		// Get domain factory
		DomainFactory factory = getDomainFactory();

		// Modify the status for phase and actions
		Iterator<ICPAction> iterator = icpPhase.getActions().iterator();

		while (iterator.hasNext())
		{
			// Inactivate action
			inactivateICPAction(iterator.next());
		}

		icpPhase.setStatus(factory.getLookupInstance(INACTIVE_STATUS));

		// Save ICP Phase - We need to save, the function might be called by
		// itself
		factory.save(icpPhase);

		return ICPPhaseVoAssembler.create(icpPhase);
	}

	/**
	 * Function used to inactivate an ICP Action
	 */
	public ICPActionShortVo inactivateICPAction(ICPAction icpAction) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException, UnqViolationUncheckedException
	{
		final int INACTIVE_STATUS = -618;

		// Check parameters
		if (icpAction == null)
			return null;

		// Get domain factory
		DomainFactory factory = getDomainFactory();

		// Retrieve ICP Action and modify the status
		icpAction.setStatus(factory.getLookupInstance(INACTIVE_STATUS));

		// Save ICP Action - We need to save, the function might be called by
		// itself
		factory.save(icpAction);

		return ICPActionShortVoAssembler.create(icpAction);
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------
	// Functions used for retrieving data for populating the instance controls
	// --------------------------------------------------------------------------------------------------------------------------------------------------

	public ProcedureLiteVoCollection listProcedures(String name)
	{
		// Use StringBuilder to build the HQL query (more memory efficient)
		StringBuilder hqlQuery = new StringBuilder();
		hqlQuery.append("from Procedure as proc");

		// Declare the ArrayList for parameters names and parameters values
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		// Create parameters string
		if (name != null && name.length() > 0)
		{
			hqlQuery.append(" where UPPER(proc.procedureName) like :NAME");

			paramNames.add("NAME");
			paramValues.add("%" + name.toUpperCase() + "%");
		}

		// Set order mode
		hqlQuery.append(" order by UPPER(proc.procedureName) asc");

		return ProcedureLiteVoAssembler.createProcedureLiteVoCollectionFromProcedure(getDomainFactory().find(hqlQuery.toString(), paramNames, paramValues));
	}

	public MemberOfStaffLiteVoCollection listContactPersons(String name)
	{
		// Use StringBuilder to build the HQL query (more memory efficient)
		StringBuilder hqlQuery = new StringBuilder();
		hqlQuery.append("from MemberOfStaff as mos");

		// Declare the ArrayList for parameters names and parameters values
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		// Create parameters string
		if (name != null && name.length() > 0)
		{
			hqlQuery.append(" where UPPER(mos.name.surname) like :NAME or UPPER(mos.name.forename) like :NAME");

			paramNames.add("NAME");
			paramValues.add("%" + name.toUpperCase() + "%");
		}

		// Set order mode
		hqlQuery.append(" order by UPPER(mos.name.surname) asc");

		return MemberOfStaffLiteVoAssembler.createMemberOfStaffLiteVoCollectionFromMemberOfStaff(getDomainFactory().find(hqlQuery.toString(), paramNames, paramValues));
	}

	public DiagLiteVoCollection listDiagnosis(String name)
	{
		// Use StringBuilder to build the HQL query (more memory efficient)
		StringBuilder hqlQuery = new StringBuilder();
		hqlQuery.append("from Diagnosis as diag");

		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		// Create parameters string
		if (name != null && name.length() > 0)
		{
			hqlQuery.append(" where UPPER(diag.diagnosisName) like :NAME");

			paramNames.add("NAME");
			paramValues.add("%" + name.toUpperCase() + "%");
		}

		// Set order mode
		hqlQuery.append(" order by UPPER(diag.diagnosisName) asc");

		return DiagLiteVoAssembler.createDiagLiteVoCollectionFromDiagnosis(getDomainFactory().find(hqlQuery.toString(), paramNames, paramValues));
	}

	public ClinicalProblemShortVoCollection listProblems(String name)
	{
		// Use StringBuilder to build the HQL query
		StringBuilder hqlQuery = new StringBuilder();
		hqlQuery.append("SELECT problem ");
		hqlQuery.append(" FROM ClinicalProblem AS problem LEFT JOIN problem.keywords AS keyw ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		// Create parameters string
		if (name != null && name.length() > 0)
		{
			hqlQuery.append(" WHERE (UPPER(problem.pCName) LIKE :NAME");
			hqlQuery.append(" OR UPPER(keyw.keyword) LIKE :NAME) AND problem.isActive = 1 ");
			
			paramNames.add("NAME");
			paramValues.add("%" + name.toUpperCase() + "%");
		}
		
		// Set order mode
		hqlQuery.append(" ORDER BY UPPER(problem.pCName) ASC");
		
		return ClinicalProblemShortVoAssembler.createClinicalProblemShortVoCollectionFromClinicalProblem(getDomainFactory().find(hqlQuery.toString(), paramNames, paramValues));
	}
}
