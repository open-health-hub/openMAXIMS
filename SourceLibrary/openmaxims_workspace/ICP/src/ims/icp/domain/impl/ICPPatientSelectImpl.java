//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by George Cristian Josan using IMS Development Environment (version 1.70 build 3454.29123)
// Copyright (C) 1995-2009 IMS MAXIMS. All rights reserved.

package ims.icp.domain.impl;

import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.core.admin.pas.domain.objects.PASEvent;
import ims.core.admin.pas.vo.PASEventRefVo;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.clinical.domain.objects.Service;
import ims.core.clinical.vo.ProcedureRefVo;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.vo.AuthoringInformationVo;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.ServiceVo;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.PasEventVoAssembler;
import ims.core.vo.domain.ServiceVoAssembler;
import ims.core.vo.lookups.HcpDisType;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.DateTime;
import ims.icp.domain.base.impl.BaseICPPatientSelectImpl;
import ims.icp.vo.ICPActionShortVo;
import ims.icp.vo.ICPLiteVo;
import ims.icp.vo.ICPLiteVoCollection;
import ims.icp.vo.ICPPhaseFullVo;
import ims.icp.vo.ICPStageFullVo;
import ims.icp.vo.ICPVo;
import ims.icp.vo.PatientICPActionFullVo;
import ims.icp.vo.PatientICPActionFullVoCollection;
import ims.icp.vo.PatientICPActionStatusVo;
import ims.icp.vo.PatientICPActionStatusVoCollection;
import ims.icp.vo.PatientICPFullVo;
import ims.icp.vo.PatientICPPhaseStatusVo;
import ims.icp.vo.PatientICPPhaseStatusVoCollection;
import ims.icp.vo.PatientICPPhasesFullVo;
import ims.icp.vo.PatientICPPhasesFullVoCollection;
import ims.icp.vo.PatientICPStageStatusVo;
import ims.icp.vo.PatientICPStageStatusVoCollection;
import ims.icp.vo.PatientICPStagesFullVo;
import ims.icp.vo.PatientICPStagesFullVoCollection;
import ims.icp.vo.domain.ICPLiteVoAssembler;
import ims.icp.vo.domain.ICPStageFullVoAssembler;
import ims.icp.vo.domain.ICPVoAssembler;
import ims.icp.vo.domain.PatientICPFullVoAssembler;
import ims.icp.vo.lookups.ICPActionStatus;
import ims.icp.vo.lookups.ICPPhaseStatus;
import ims.icp.vo.lookups.ICPStageStatus;
import ims.icps.configuration.domain.objects.ICP;
import ims.icps.configuration.domain.objects.ICPStage;
import ims.icps.configuration.vo.ICPRefVo;
import ims.icps.instantiation.domain.objects.PatientICP;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentRefVoCollection;

import java.util.ArrayList;
import java.util.Iterator;

public class ICPPatientSelectImpl extends BaseICPPatientSelectImpl
{

	private static final long serialVersionUID = 1L;

	/**
	 * Lists all the ICP that match either the Procedure or the Service (compared after Specialty)
	 */
	public ICPLiteVoCollection listICP(ProcedureRefVo procedure, ServiceRefVo service) throws DomainInterfaceException
	{
		if (procedure == null && service == null)
			throw new DomainInterfaceException("Patient must have at least a service selected");

		// Create factory
		DomainFactory factory = getDomainFactory();

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		StringBuffer condStr = new StringBuffer();
		String hql = " select icp from ICP icp left join icp.procedures as procs ";
		String andStr = " ";

		condStr.append(andStr + " icp.status = :stat");
		markers.add("stat");
		values.add(getDomLookup(PreActiveActiveInactiveStatus.ACTIVE));
		andStr = " and ";

		if (procedure != null && service == null)
		{
			condStr.append(andStr + " procs.id = :procId");
			markers.add("procId");
			values.add(procedure.getID_Procedure());
			andStr = " and ";
		}

		if (procedure == null && service != null)
		{
			ServiceVo serviceVo = ServiceVoAssembler.create((Service) factory.getDomainObject(Service.class, service.getID_Service()));

			if (serviceVo.getSpecialtyIsNotNull())
			{
				condStr.append(andStr + " icp.specialty.id = :specID");
				markers.add("specID");
				values.add(serviceVo.getSpecialty().getID());
				andStr = " and ";
			}
			else
				return null;
		}

		if (procedure != null && service != null)
		{

			ServiceVo serviceVo = ServiceVoAssembler.create((Service) factory.getDomainObject(Service.class, service.getID_Service()));

			if (serviceVo.getSpecialtyIsNotNull())
				condStr.append(andStr + " ( procs.id = :procId");
			else
				condStr.append(andStr + " procs.id = :procId");

			markers.add("procId");
			values.add(procedure.getID_Procedure());
			andStr = " and ";

			if (serviceVo.getSpecialtyIsNotNull())
			{

				condStr.append(" or icp.specialty.id = :specID) ");
				markers.add("specID");
				values.add(serviceVo.getSpecialty().getID());
				andStr = " and ";
			}
		}

		if (andStr.equals(" and "))
			hql += " where ";

		hql += condStr.toString();

		return ICPLiteVoAssembler.createICPLiteVoCollectionFromICP(factory.find(hql, markers, values));
	}

	/**
	 * Function used to create a PatientICP from a CATSReferralRef and an ICPConfiguration.
	 */
	public void createPatientICP(CareContextRefVo careContext, PatientRefVo patient, CatsReferralRefVo catsReferral, ICPRefVo icpConfiguration, HcpLiteVo voHCP) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException
	{
		// Check the parameters
		if (icpConfiguration == null)
			throw new DomainInterfaceException("An ICP must be selected");

		if (careContext == null)
			throw new DomainInterfaceException("A care context must be selected");

		if (patient == null)
			throw new DomainInterfaceException("A patient must be selected");

		// Initial estimate of boolean fields
		boolean hasAdminActions = false;
		boolean hasNursingActions = false;
		boolean hasClinicalActions = false;
		boolean hasPhisioActions = false;

		DomainFactory factory = getDomainFactory();

		// Get the CatsReferral and ICP
		ICP icp = (ICP) factory.getDomainObject(ICP.class, icpConfiguration.getID_ICP());

		// Create the PatientICP BO
		PatientICPFullVo patientICP = new PatientICPFullVo();

		// Set the patient
		patientICP.setPatient(patient);
		// Set the care context
		patientICP.setCareContext(careContext);
		// Set the ICP configuration
		ICPLiteVo icpLite = ICPLiteVoAssembler.create(icp);
		patientICP.setICP(icpLite);

		// Set authoring information
		AuthoringInformationVo authoring = new AuthoringInformationVo();
		authoring.setAuthoringDateTime(new DateTime());
		authoring.setAuthoringHcp(voHCP);

		patientICP.setAuthoringInformation(authoring);

		patientICP.setStartedDateTime(new DateTime());

		// Set the stages
		PatientICPStagesFullVoCollection stages = new PatientICPStagesFullVoCollection();

		if (icp.getStages() != null)
		{
			for (int i = 0; i < icp.getStages().size(); i++)
			{
				// Get the ICP stage
				ICPStageFullVo icpStage = ICPStageFullVoAssembler.create((ICPStage) icp.getStages().get(i));

				if (!PreActiveActiveInactiveStatus.ACTIVE.equals(icpStage.getStatus()))
					continue;

				// Build the PatientICP stage
				PatientICPStagesFullVo stage = new PatientICPStagesFullVo();

				stage.setICP(patientICP);
				stage.setStage(icpStage);
				stage.setStatusHistory(new PatientICPStageStatusVoCollection());

				// Stage status
				PatientICPStageStatusVo statusStage = new PatientICPStageStatusVo();
				statusStage.setStatusDate(new DateTime());
				statusStage.setChangedBy(getSession().getUser().getUsername());

				if (Boolean.TRUE.equals(icpStage.getIsActivatedOnInitiation()))
				{
					statusStage.setStatus(ICPStageStatus.OUTSTANDING);
				}
				else
				{
					statusStage.setStatus(ICPStageStatus.NOTINSCOPE);
				}

				stage.setCurrentStatus(statusStage);
				stage.getStatusHistory().add(statusStage);
				stage.setPatient(patient);
				stage.setCareContext(careContext);

				// Phases
				PatientICPPhasesFullVoCollection phases = new PatientICPPhasesFullVoCollection();

				if (icpStage.getPhases() != null)
				{
					for (int j = 0; j < icpStage.getPhases().size(); j++)
					{
						ICPPhaseFullVo icpPhase = icpStage.getPhases().get(j);

						if (!PreActiveActiveInactiveStatus.ACTIVE.equals(icpPhase.getStatus()))
							continue;

						PatientICPPhasesFullVo phase = new PatientICPPhasesFullVo();

						phase.setPatient(patient);
						phase.setCareContext(careContext);
						phase.setPhase(icpPhase);
						phase.setParentStage(stage);
						phase.setStatusHistory(new PatientICPPhaseStatusVoCollection());
						phase.setICP(patientICP);

						// Phase's status
						PatientICPPhaseStatusVo statusPhase = new PatientICPPhaseStatusVo();

						statusPhase.setStatusDate(new DateTime());
						statusPhase.setChangedBy(getSession().getUser().getUsername());

						if (Boolean.TRUE.equals(icpPhase.getIsActivatedOnInitiation()) && ICPStageStatus.OUTSTANDING.equals(stage.getCurrentStatus().getStatus()))
						{
							statusPhase.setStatus(ICPPhaseStatus.INPROGRESS);
						}
						else
						{
							statusPhase.setStatus(ICPPhaseStatus.NOTINSCOPE);
						}

						phase.setCurrentStatus(statusPhase);
						phase.getStatusHistory().add(statusPhase);

						// Phase's actions
						PatientICPActionFullVoCollection actions = new PatientICPActionFullVoCollection();

						if (icpPhase.getActions() != null)
						{
							for (ICPActionShortVo icpAction : icpPhase.getActions())
							{
								if (!PreActiveActiveInactiveStatus.ACTIVE.equals(icpAction.getStatus()))
									continue;

								PatientICPActionFullVo action = new PatientICPActionFullVo();

								action.setPatient(patient);
								action.setCareContext(careContext);
								action.setICP(patientICP);
								action.setAction(icpAction);
								action.setParentPhase(phase);
								action.setStatusHistory(new PatientICPActionStatusVoCollection());

								// Action's current status
								PatientICPActionStatusVo statusAction = new PatientICPActionStatusVo();

								statusAction.setStatusDate(new DateTime());
								statusAction.setChangedBy(getSession().getUser() != null ? MemberOfStaffLiteVoAssembler.create((MemberOfStaff) getDomainFactory().getDomainObject(MemberOfStaff.class, getSession().getUser().getMosId())) : null);

								if (ICPStageStatus.OUTSTANDING.equals(stage.getCurrentStatus().getStatus()) && ICPPhaseStatus.INPROGRESS.equals(phase.getCurrentStatus().getStatus()))
								{
									statusAction.setStatus(ICPActionStatus.OUTSTANDING);
								}
								else
								{
									statusAction.setStatus(ICPActionStatus.NOTINSCOPE);
								}

								action.setCurrentStatus(statusAction);
								action.getStatusHistory().add(statusAction);

								actions.add(action);
								
								
								// Check if ICP Action disciplines contain required disciplines mark the Patient ICP
								if (icpAction.getDisciplineIsNotNull() && ICPActionStatus.OUTSTANDING.equals(statusAction.getStatus()))
								{
									if (icpAction.getDiscipline().contains(HcpDisType.OTHER))
										hasAdminActions = true;

									if (icpAction.getDiscipline().contains(HcpDisType.MEDICAL))
										hasClinicalActions = true;

									if (icpAction.getDiscipline().contains(HcpDisType.NURSING))
										hasNursingActions = true;

									if (icpAction.getDiscipline().contains(HcpDisType.THERAPY))
										hasPhisioActions = true;
								}

							}
						}

						phase.setPhaseActions(actions);

						phases.add(phase);
					}
				}

				stage.setStagePhases(phases);

				stages.add(stage);

			}
		}

		patientICP.setHasOutstandingAdminActions(hasAdminActions);
		patientICP.setHasOutstandingClinicalActions(hasClinicalActions);
		patientICP.setHasOutstandingNursingActions(hasNursingActions);
		patientICP.setHasOutstandingPhysioActions(hasPhisioActions);

		patientICP.setStages(stages);

		// wdev-8539
		// Get the CatsReferral - add referral check for null (it can be null now when creating an ICP from CareContext)
		if (catsReferral != null && catsReferral.getID_CatsReferralIsNotNull())
		{
			CatsReferral referral = (CatsReferral) factory.getDomainObject(CatsReferral.class, catsReferral.getID_CatsReferral());
	
			if (referral != null && referral.getAppointments() != null && referral.getAppointments().size() > 0)
			{
				Booking_AppointmentRefVoCollection voApptsColl = patientICP.getAppointments();
				if (voApptsColl == null)
					voApptsColl = new Booking_AppointmentRefVoCollection();

				Iterator<Booking_Appointment> it = referral.getAppointments().iterator();
				while (it.hasNext())
				{
					Booking_Appointment ba = (Booking_Appointment) it.next();
					if (ba != null)
					{
						Booking_AppointmentRefVo voApptRef = new Booking_AppointmentRefVo(ba.getId(), ba.getVersion());
						voApptsColl.add(voApptRef);
					}
				}
				patientICP.setAppointments(voApptsColl);
			}
		}

		// wdev-8617
		patientICP.setPasEvent(getPasEventFromCareContext(careContext));

		String[] err = patientICP.validate();

		if (err != null && err.length > 0)
		{
			throw new CodingRuntimeException("Can not create a valid Patient ICP with selected ICP Configuration. Please check ICP configuration.");
		}

		PatientICP bo = PatientICPFullVoAssembler.extractPatientICP(factory, patientICP);

		factory.save(bo);
	}

	private PASEventRefVo getPasEventFromCareContext(CareContextRefVo voCarecontext)
	{
		if (voCarecontext == null || voCarecontext.getID_CareContext() == null)
			throw new CodingRuntimeException("voCarecontext is null or id not provide for voCarecontext");

		DomainFactory factory = getDomainFactory();

		return PasEventVoAssembler.create((PASEvent) factory.findFirst("select pasEvent from CareContext as cc where cc.isRIE is not null and cc.id = '" + voCarecontext.getID_CareContext() + "'"));
	}

	public ICPVo getICP(ICPRefVo icpRefVo)
	{
		if (icpRefVo == null)
			throw new RuntimeException("Cannot get ICPVo for null ICPRefVo");

		ICP doICP = (ICP) getDomainFactory().getDomainObject(ICP.class, icpRefVo.getID_ICP());
		return ICPVoAssembler.create(doICP);
	}
}
