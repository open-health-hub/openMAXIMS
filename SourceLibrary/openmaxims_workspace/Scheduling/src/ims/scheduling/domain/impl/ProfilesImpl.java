//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Barbara Worwood using IMS Development Environment (version 1.22 build 50304.930)
// Copyright (C) 1995-2005 IMS MAXIMS plc. All rights reserved.

package ims.scheduling.domain.impl;

import ims.admin.domain.ApplicationRoles;
import ims.admin.domain.ApplicationUsers;
import ims.admin.domain.HcpAdmin;
import ims.admin.domain.LocationService;
import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.ApplicationRolesImpl;
import ims.admin.domain.impl.ApplicationUsersImpl;
import ims.admin.domain.impl.HcpAdminImpl;
import ims.admin.domain.impl.LocationServiceImpl;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.admin.vo.AppRoleShortVo;
import ims.admin.vo.AppRoleShortVoCollection;
import ims.admin.vo.AppUserShortVoCollection;
import ims.admin.vo.AppUserVo;
import ims.core.clinical.domain.objects.ProceduresPerformedByHCP;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.resource.people.vo.HcpRefVoCollection;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.ActivityLiteVoCollection;
import ims.core.vo.HcpFilter;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.LocShortVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.LocationServiceVo;
import ims.core.vo.LocationServiceVoCollection;
import ims.core.vo.ProcedureLiteVo;
import ims.core.vo.ProcedureLiteVoCollection;
import ims.core.vo.ServiceShortVo;
import ims.core.vo.ServiceVoCollection;
import ims.core.vo.domain.ActivityLiteVoAssembler;
import ims.core.vo.domain.LocationServiceVoAssembler;
import ims.core.vo.domain.ProcedureLiteVoAssembler;
import ims.core.vo.lookups.ActivityType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.hibernate3.IMSCriteria;
import ims.domain.impl.DomainImpl;
import ims.framework.enumerations.SortOrder;
import ims.framework.exceptions.CodingRuntimeException;
import ims.scheduling.domain.DirectoryOfServiceAdmin;
import ims.scheduling.domain.objects.ProfileTemplate;
import ims.scheduling.domain.objects.Profile_Slot;
import ims.scheduling.domain.objects.Sch_Profile;
import ims.scheduling.domain.objects.Sch_Session;
import ims.scheduling.domain.objects.Session_Slot;
import ims.scheduling.helper.SlotGenerationUtils;
import ims.scheduling.vo.DirectoryOfServiceVo;
import ims.scheduling.vo.DirectoryOfServiceVoCollection;
import ims.scheduling.vo.ProfileShortVo;
import ims.scheduling.vo.ProfileShortVoCollection;
import ims.scheduling.vo.ProfileTemplateVoCollection;
import ims.scheduling.vo.Sch_ProfileGenericVo;
import ims.scheduling.vo.Sch_ProfileRefVo;
import ims.scheduling.vo.Sch_ProfileVo;
import ims.scheduling.vo.domain.ProfileShortVoAssembler;
import ims.scheduling.vo.domain.ProfileTemplateVoAssembler;
import ims.scheduling.vo.domain.Sch_ProfileGenericVoAssembler;
import ims.scheduling.vo.domain.Sch_ProfileVoAssembler;
import ims.scheduling.vo.lookups.Sched_Profile_Type;
import ims.vo.interfaces.IMos;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

public class ProfilesImpl extends DomainImpl implements ims.scheduling.domain.Profiles, ims.domain.impl.Transactional
{
	/**
	* Saves the given profile to the database
	*/
	public ims.scheduling.vo.Sch_ProfileGenericVo saveGenericProfile(ims.scheduling.vo.Sch_ProfileGenericVo profile, ProfileTemplateVoCollection templates) throws ims.domain.exceptions.StaleObjectException, UniqueKeyViolationException
	{
		if (!profile.isValidated())
			throw new DomainRuntimeException("Profile ValueObject has not been validated");
		
		if (!isProfileNameUnique(profile))
			throw new UniqueKeyViolationException("A Profile with the same name already exists, Please change");

		DomainFactory factory = getDomainFactory();
		
		Sch_Profile domProfile = Sch_ProfileGenericVoAssembler.extractSch_Profile(factory, profile);
		
		//WDEV-8531
		if(!domProfile.isIsActive())
		{
			Iterator it = domProfile.getProfileSlots().iterator();
			while(it.hasNext())
			{
				Profile_Slot doSlot = (Profile_Slot)it.next();
				doSlot.setIsActive(false);
			}
		}
		
		factory.save(domProfile);
		
		saveProfileTemplates(factory, domProfile, templates);
		return Sch_ProfileGenericVoAssembler.create(domProfile);
	}	

	private boolean isProfileNameUnique(Sch_ProfileGenericVo profile)
	{
		if (profile == null)
			throw new CodingRuntimeException("Mandatory argument - Organisation Name");
		
		DomainFactory factory = getDomainFactory();
		
		String hql = "from Sch_Profile prof where prof.name = :name and prof.isActive = :active";
		
		//to ensure we are not checking the current record
		if (profile != null && profile.getID_Sch_ProfileIsNotNull())
			hql += " and prof.id != '" + profile.getID_Sch_Profile() + "'";
		
		List profiles = factory.find(hql, new String[]{"name","active"}, new Object[] {profile.getName(),Boolean.TRUE});

		if(profiles != null && profiles.size() > 0)
			return false;
		
		return true;	
	}

	private void saveProfileTemplates(DomainFactory factory, Sch_Profile domProfile, ProfileTemplateVoCollection templates) throws DomainRuntimeException, StaleObjectException
	{
		try
		{
			factory.delete("from ProfileTemplate pt where pt.profile.id = '" + domProfile.getId() + "'" );
		}
		catch (ForeignKeyViolationException e)
		{
			throw new DomainRuntimeException("DomainException occurred saving profile - " + e.getMessage(), e);
		}
		
		if(templates != null)
		{
			for(int i=0; i<templates.size(); i++)
			{
				templates.get(i).setID_ProfileTemplate(null);
				ProfileTemplate doProfTemplate = ProfileTemplateVoAssembler.extractProfileTemplate(factory, templates.get(i));
				doProfTemplate.setProfile(domProfile);
				factory.save(doProfTemplate);
			}
		}
	}

	/**
	 * rippleOutToSessions
	 * <p> This method updates all sessions associated with
	 * the profile with the modified values
	 * @parem factory	  DomainFactory
	 * @param domProfile  The modified profile
	 * </p>
	 * @throws StaleObjectException
	 */
	private void rippleOutToSessions(DomainFactory factory, Sch_Profile domProfile) throws StaleObjectException
	{
		// List all sessions with a session date greater than today for the profile
		List sessList = factory.find(" from Sch_Session s where s.sessionDate > :sessDate and s.sch_Profile.id = :profile", new String[]{"sessDate", "profile"}, new Object[]{new java.util.Date(), domProfile.getId()});
		for (int i=0; i<sessList.size(); i++)
		{
			Sch_Session session = (Sch_Session) sessList.get(i);
			if (session.isIsModified().booleanValue())
				continue;
			
			session.setName(domProfile.getName());
			session.setDescription(domProfile.getDescription());
			session.setStartTm(domProfile.getStartTm());
			session.setEndTm(domProfile.getEndTm());
			session.setService(domProfile.getService());
			session.setIsFixed(domProfile.isIsFixed());
			session.setDuration(SlotGenerationUtils.calculateDuration(domProfile.getStartTm(), domProfile.getEndTm()));
			session.setSchLocation(domProfile.getSchLocation());
			session.setSessionType(factory.getLookupInstance(Sched_Profile_Type.TYPE_ID, Sched_Profile_Type.SINGLE.getID()));
			session.setMinInt(domProfile.getMinInt());
			session.setRoundAttTime(domProfile.getRoundAttTime());
			session.setLastAppInterval(domProfile.getLastAppInterval());
			session.setMaxNoAppts(domProfile.getMaxNoAppts());
			session.setDirectoryofServices(SlotGenerationUtils.copyDirectoryOfServices(domProfile.getDirectoryOfServices()));
			session.setSessionSlots(updateSlots(factory, session, domProfile.getProfileSlots()));
			session.setBookingRights(SlotGenerationUtils.copyBookingRights(domProfile.getBookingRights()));
			session.setListOwners(SlotGenerationUtils.copyListOwners(domProfile.getListOwners()));
			session.setExclusionTimes(SlotGenerationUtils.copyExclusionTimes(domProfile.getExclusionTimes()));
		}
	}

	
	private Set updateSlots(DomainFactory factory, Sch_Session session, Set profileSlots) throws StaleObjectException
	{
		Set sessionSlots = new HashSet();
		StringBuffer cancelledSlotStr = new StringBuffer(); 
		
		Iterator profIt = profileSlots.iterator();
		while (profIt.hasNext())
		{
			// Calculate the number of session slots required with the current profileSlot
			Profile_Slot profSlot = (Profile_Slot) profIt.next();
			int noSlots = profSlot.getNoOfInstances().intValue() * profSlot.getNumberSlotsReq().intValue();
			
			// Get the number of existing session slots for this profile slot
			Iterator slotIt = session.getSessionSlots().iterator();
			HashMap sessSlots = new HashMap();
			while (slotIt.hasNext())
			{
				Session_Slot sessSlot = (Session_Slot) slotIt.next();
				if (sessSlot.getProfileSlot().getId().equals(profSlot.getId()))
					sessSlots.put(sessSlot.getInstanceNo(), sessSlot);
			}
			
			// TODO
			// This is definitely not working properly, inactivating some
			// session slots, seems to sometimes inactivate the ones that are
			// booked.  We need to decide whether we can modify the start time,
			// duration, no instances etc.. of a slot and whether or not that
			// slot can be updated.
			
			// All existing session slots for the profile slots are in the map sessSlots
			int noNewSlotsRequired = noSlots - sessSlots.size();
			
			// Calculate all the slots for the profile and then get the session slot
			// instances that match
			int slotCount=0;
			for (int i=0; i<profSlot.getNumberSlotsReq().intValue(); i++)
			{
				int startTime = new Integer(profSlot.getStartTm().replaceAll(":", "")).intValue();
				String newStartTime = String.valueOf(startTime);
				if (newStartTime.length() == 3)
					newStartTime = "0" + newStartTime;
				if (i > 0)
					newStartTime = SlotGenerationUtils.calculateNextSlotTime(startTime, profSlot.getDuration().intValue(), i);
				else 
					newStartTime = profSlot.getStartTm();
			
				
				for (int j=0; j<profSlot.getNoOfInstances().intValue(); j++)
				{
					// Find this instance for the session slot
					Session_Slot slot;
					slotCount++;
					Integer instanceNo = new Integer(slotCount);
					
					if (sessSlots.containsKey(instanceNo))
					{
						slot = (Session_Slot) sessSlots.get(instanceNo);
					}
					else
					{
						// 	New slot required
						slot = new Session_Slot();
						slot.setProfileSlot(profSlot);
						slot.setSessDateTime(session.getSessionDate());
						slot.setInstanceNo(instanceNo);
						slot.setSlotResp(SlotGenerationUtils.getSessionListOwner(session, profSlot.getSlotResp()));
					}
					
					sessionSlots.add(slot);		
					if (slot.getAppointment() != null || slot.getSessDateTime().before(new java.util.Date()))
						continue;
				
					slot.setIsActive(profSlot.isIsActive());
					slot.setActivity(profSlot.getActivity());
					slot.setStartTm(newStartTime);
					// Dealloc date should be set to session date - no of dealloc days
					ims.framework.utils.Date sessDate = new ims.framework.utils.Date(slot.getSessDateTime());
					if (profSlot.getDeallocNoOfDays() != null)
					{
						ims.framework.utils.Date deallocDate = sessDate.addDay(profSlot.getDeallocNoOfDays().intValue());
						slot.setDeallocDate(deallocDate.getDate());
					}
					slot.setDirectoryOfServices(profSlot.getDirectoryOfServices());
					slot.setDuration(profSlot.getDuration());
					slot.setPriority(profSlot.getPriority());
					slot.setDirectAccessSlot(profSlot.getDirectAccessSlot());

				}
			}

			// For any slots with instanceNo > noSlots, we want to de-activate the session slots
			for (int i=noSlots; i<sessSlots.size(); i++)
			{
				Integer instanceNo = new Integer(i+1);
				if (sessSlots.containsKey(instanceNo))
				{
					// Deactivate that slot
					Session_Slot slot = (Session_Slot) sessSlots.get(instanceNo);
					slot.setIsActive(Boolean.FALSE);
					sessionSlots.add(slot);
					cancelledSlotStr.append(slot.buildCabMessage());
				}
			}
			
		}
		return sessionSlots;
	}

	public AppUserShortVoCollection listUsers() 
	{
		// Make a call to the Admin ApplicationUser list
		// Active only
		AppUserVo filter = new AppUserVo();
		filter.setIsActive(new Boolean(true));
		ApplicationUsers userAdmin = (ApplicationUsers)getDomainImpl(ApplicationUsersImpl.class);
		return userAdmin.listAppUsers(filter);
	}

	public AppRoleShortVoCollection listRoles() 
	{
		// Make a call to the Admin ApplicationRoles list
		ApplicationRoles roleAdmin = (ApplicationRoles)getDomainImpl(ApplicationRolesImpl.class);
		AppRoleShortVoCollection coll = roleAdmin.listRoles();
		AppRoleShortVoCollection filteredColl = new AppRoleShortVoCollection();
		// Remove inactive roles
		for (int i=0; i<coll.size(); i++)
		{
			AppRoleShortVo vo = coll.get(i);
			if (vo.getIsActiveIsNotNull() && vo.getIsActive().booleanValue())
				filteredColl.add(vo);
		}
		
		return filteredColl;
	}

	public LocationServiceVoCollection listLocationServices(LocShortVo locShort) 
	{		
		LocationService impl = (LocationService) getDomainImpl(LocationServiceImpl.class);
		return impl.listLocationService(locShort);
	}

	public DirectoryOfServiceVoCollection listDOS(DirectoryOfServiceVo directoryOfService) 
	{
		DirectoryOfServiceAdmin impl = (DirectoryOfServiceAdmin) getDomainImpl(DirectoryOfServiceAdminImpl.class);
		return impl.listDirectoryOfService(directoryOfService);
	}

	public HcpLiteVoCollection listHcpLite(HcpFilter filter) 
	{
		HcpAdmin impl = (HcpAdmin) getDomainImpl(HcpAdminImpl.class);
		return impl.listHcpLite(filter);
	}

	public ServiceVoCollection listServices() 
	{
		LocationService impl = (LocationService) getDomainImpl(LocationServiceImpl.class);
		return impl.listService(Boolean.TRUE);
	}
	
	public Sch_ProfileVo getProfileDetails(ProfileShortVo profile)
	{
		DomainFactory factory = getDomainFactory();
		
		Sch_Profile domProfile = (Sch_Profile)factory.getDomainObject(Sch_Profile.class, profile.getID_Sch_Profile());
		Sch_ProfileVo voProfile = Sch_ProfileVoAssembler.create(domProfile);
		
		return voProfile;
	}
	
	public Sch_ProfileGenericVo getGenericProfileDetails(ProfileShortVo profile)
	{
		DomainFactory factory = getDomainFactory();
		
		Sch_Profile domProfile = (Sch_Profile)factory.getDomainObject(Sch_Profile.class, profile.getID_Sch_Profile());
		Sch_ProfileGenericVo voProfile = Sch_ProfileGenericVoAssembler.create(domProfile);
		
		return voProfile;
	}

	public LocationServiceVo getLocationService(LocationRefVo location, ServiceRefVo service)
	{
		if(location == null || service == null) 
			throw new CodingRuntimeException("location and service are madatory in method getLocationService");

		DomainFactory factory = getDomainFactory();
		List locServics = factory.find("from LocationService locSer where locSer.location.id = :idLocation and locSer.service.id = :idService", new String[] {"idLocation", "idService"}, new Object[] { location.getID_Location(), service.getID_Service()});
		if(locServics != null && locServics.size() > 0)
			return LocationServiceVoAssembler.create((ims.core.resource.place.domain.objects.LocationService) locServics.get(0));
		
		return null;
	}
	
	public ProfileTemplateVoCollection listProfileTemplatesByProfile(Sch_ProfileRefVo profile)
	{
		if(profile == null || profile.getID_Sch_Profile() == null)
			throw new CodingRuntimeException("profile not provided in method listProfileTemplatesByProfile");
		
		DomainFactory factory = getDomainFactory();
		List pTemps = factory.find("from ProfileTemplate pt where pt.profile.id = '" + profile.getID_Sch_Profile() + "'" );
	
		return ProfileTemplateVoAssembler.createProfileTemplateVoCollectionFromProfileTemplate(pTemps);
	}

	//list all procedures performed by Hcp list provided 
	public ProcedureLiteVoCollection listProcedureByHcpAndName(HcpRefVoCollection collHcp, String name) 
	{
		DomainFactory factory=getDomainFactory();
		IMSCriteria imsc=new IMSCriteria(ProceduresPerformedByHCP.class,factory);
		ProcedureLiteVo aux=new ProcedureLiteVo();
		if (collHcp!=null)
			imsc.in("performingHCP.id", getIdArray(collHcp));
		
		if(name != null)
		{
			imsc.join("this.procedures", "proc");
			imsc.like("proc.procedureName", name + "%");			
		}
	
		List proceduresPerformedByHCP = imsc.find();
		ProcedureLiteVoCollection voCollProcedureLite =new ProcedureLiteVoCollection();
		Iterator it = proceduresPerformedByHCP.iterator();
		while(it.hasNext())
		{
			ProceduresPerformedByHCP doProcHcp = (ProceduresPerformedByHCP) it.next();
			
			ProcedureLiteVoCollection voCollProc = ProcedureLiteVoAssembler.createProcedureLiteVoCollectionFromProcedure(doProcHcp.getProcedures());
			for(ProcedureLiteVo voProc : voCollProc)
				voCollProcedureLite.add(voProc);
		}

		return voCollProcedureLite;
	}

	private Object[] getIdArray(HcpRefVoCollection collHcp)
	{
		if (collHcp == null)
			throw new CodingRuntimeException("collHcp is null or id not provided in method getIdArray");
		
		Object[] ids = new Object[collHcp.size()];
		int i=0;
		for(HcpRefVo hcp : collHcp)
		{
			ids[i] = hcp.getID_Hcp();
			i++;
		}
			
		return ids;
	}

	public LocationLiteVoCollection listActiveHospitalsLite()
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveHospitalsLite();
	}

	public ActivityLiteVoCollection listActivity()
	{
		DomainFactory factory = getDomainFactory();
		String hql = "from Activity act";
		
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		String andStr = " ";
		StringBuffer condStr = new StringBuffer();
		
		condStr.append(andStr + " act.isActive = :active");
		markers.add("active");
		values.add(Boolean.TRUE);	
		andStr = " and ";
		
		condStr.append(andStr + " act.activityType != :investigation");
		markers.add("investigation");
		values.add(getDomLookup(ActivityType.INVESTIGATION));	
		andStr = " and ";
		
		if(andStr.equals(" and "))
			hql += " where ";
			
		hql += condStr.toString();	
		List activities =  factory.find(hql, markers, values);
		return ActivityLiteVoAssembler.createActivityLiteVoCollectionFromActivity(activities);
	}

	public ProfileShortVoCollection listProfiles(ServiceShortVo service, DirectoryOfServiceVo directoryOfService, LocationRefVo hosp, Boolean activeOnly, Boolean isOutpatient, Boolean isTheatre, String name, IMos listOwner)
	{
		DomainFactory factory = getDomainFactory();
		
		String hql = " Select profile from Sch_Profile profile ";
		
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		String andStr = " where ";
		StringBuffer condStr = new StringBuffer();
		
		String joinDos = "";
		String joinListOwner = "";
				
		if(directoryOfService != null)
		{
			joinDos = " left join profile.directoryOfServices as dos ";
			condStr.append(andStr + "dos.id = :idDos");
			markers.add("idDos");
			values.add(directoryOfService.getID_DirectoryofService());	
			andStr = " and ";
		}
		if(listOwner != null)
		{
			joinListOwner = " left join profile.listOwners as lo ";
			condStr.append(andStr + "lo.hCP.id = :idHcp");
			markers.add("idHcp");
			values.add(listOwner.getIMosHcpId());	
			andStr = " and ";
		}
		
		if(service != null)
		{
			condStr.append(andStr + " profile.service.id = :serviceId");
			markers.add("serviceId");
			values.add(service.getID_Service());	
			andStr = " and ";
		}
		if(hosp != null)
		{
			condStr.append(andStr + "( profile.schLocation.id = :idHosp or profile.schLocation.parentLocation.id = :idHosp ) ");
			markers.add("idHosp");
			values.add(hosp.getID_Location());	
			andStr = " and ";
		}
		
		if(activeOnly != null)
		{
			condStr.append(andStr + " profile.isActive = :activeOnly");
			markers.add("activeOnly");
			values.add(activeOnly);	
			andStr = " and ";
		}
		if(name != null)
		{
			condStr.append(andStr + " profile.name like :name ");
			markers.add("name");
			values.add("%" + name + "%");	
			andStr = " and ";
		}
		
		//WDEV-13362 values can be null when called from other forms (eg. SessionAdmin)
		if(isOutpatient != null && isTheatre != null)
		{
			if(!isOutpatient || !isTheatre)
			{
				if(isOutpatient)
				{
					condStr.append(andStr + " (profile.isTheatreProfile is null or profile.isTheatreProfile = 0) ");
					andStr = " and ";
				}
				else if(isTheatre)
				{
					condStr.append(andStr + " profile.isTheatreProfile = 1 ");
					andStr = " and ";
				}
			}
		}
				
		hql += joinDos + joinListOwner + condStr.toString();	
		hql += " order by upper(profile.name) asc ";

		List profiles =  factory.find(hql, markers, values, 2000);
		return ProfileShortVoAssembler.createProfileShortVoCollectionFromSch_Profile(profiles);
	}
}

	


