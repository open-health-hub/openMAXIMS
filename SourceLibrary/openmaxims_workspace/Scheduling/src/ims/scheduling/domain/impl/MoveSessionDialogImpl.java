//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.80 build 4198.17562)
// Copyright (C) 1995-2011 IMS MAXIMS. All rights reserved.

package ims.scheduling.domain.impl;

import ims.domain.lookups.LookupInstance;
import ims.framework.exceptions.CodingRuntimeException;
import ims.scheduling.domain.base.impl.BaseMoveSessionDialogImpl;
import ims.scheduling.domain.objects.Appointment_Status;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.Sch_Session;
import ims.scheduling.domain.objects.SessionParentChildSlot;
import ims.scheduling.domain.objects.SessionTheatreTCISlot;
import ims.scheduling.domain.objects.Session_Slot;
import ims.scheduling.vo.Sch_SessionRefVo;
import ims.scheduling.vo.domain.SessionShortVoAssembler;
import ims.scheduling.vo.lookups.Status_Reason;

import java.util.Iterator;
import java.util.List;

public class MoveSessionDialogImpl extends BaseMoveSessionDialogImpl
{

	private static final long serialVersionUID = 1L;

	/**
	* moveSessionToDate
	* all appointments slots etc need to move to the new date
	*/
	public void moveSessionToDate(ims.scheduling.vo.SessionShortVo session, ims.framework.utils.Date toDate) throws ims.domain.exceptions.StaleObjectException
	{
		if (session == null)
			throw new CodingRuntimeException("session cannot be null in method moveSessionToDate");
		if (toDate == null)
			throw new CodingRuntimeException("toDate cannot be null in method moveSessionToDate");
		
		Sch_Session doSession = SessionShortVoAssembler.extractSch_Session(getDomainFactory(), session);
		
		//Theatre TCI
		doSession.setSessionDate(toDate.getDate());
		if(doSession.getTheatreSlots() != null)
		{
			Iterator tciSlotIterator = doSession.getTheatreSlots().iterator();
			while(tciSlotIterator.hasNext())
			{
				SessionTheatreTCISlot doTCISlot = (SessionTheatreTCISlot) tciSlotIterator.next();
				doTCISlot.setSessDateTime(toDate.getDate());
				if(doTCISlot.getAppointment() != null)
				{
					doTCISlot.getAppointment().setAppointmentDate(toDate.getDate());
					//update appointment Status and History
					updateAppointmentStatus(toDate, doTCISlot.getAppointment(), doSession.getCancellationReason(), doSession.getComment());
				}
			}
		}
		
		//Theatre Fixed
		if(doSession.getParentChildSlots() != null)
		{
			Iterator pcSlotIterator = doSession.getParentChildSlots().iterator();
			while(pcSlotIterator.hasNext())
			{
				SessionParentChildSlot doSessPcSlot = (SessionParentChildSlot) pcSlotIterator.next();
				doSessPcSlot.setSessDateTime(toDate.getDate());
				if(doSessPcSlot.getAppointment() != null)
				{
					doSessPcSlot.getAppointment().setAppointmentDate(toDate.getDate());
					//update appointment Status and History
					updateAppointmentStatus(toDate, doSessPcSlot.getAppointment(), doSession.getCancellationReason(), doSession.getComment());
				}
			}
		}
		
		//O/P Slots
		if(doSession.getSessionSlots() != null)
		{
			Iterator sessSlotIterator = doSession.getSessionSlots().iterator();
			while(sessSlotIterator.hasNext())
			{
				Session_Slot doSessSlot = (Session_Slot) sessSlotIterator.next();
				doSessSlot.setSessDateTime(toDate.getDate());
				if(doSessSlot.getAppointment() != null)
				{
					doSessSlot.getAppointment().setAppointmentDate(toDate.getDate());
					//update appointment Status and History
					updateAppointmentStatus(toDate, doSessSlot.getAppointment(), doSession.getCancellationReason(), doSession.getComment());
				}
			}
		}
		
		getDomainFactory().save(doSession); 
		
		//CANCEL and Rebook Theatre Fixed Appointments
		Integer[] arrBookedAppts = getBookedAppointmentIdsForSession(session);
		if(arrBookedAppts != null)
		{
			
		}
		
	}

	/**
	 * @param toDate
	 * @param cancelComment 
	 * @param cancellationReason 
	 * @param appointment
	 */
	private void updateAppointmentStatus(ims.framework.utils.Date toDate, Booking_Appointment doAppointment, LookupInstance cancellationReason, String cancelComment)
	{
		Appointment_Status doCurrent = doAppointment.getCurrentStatusRecord();
	
		//WDEV-12918 only cancel and rebook bookead appointments (not dna etc.)
		if(!doCurrent.getStatus().equals(getDomLookup(Status_Reason.BOOKED)))
			return;
		
		Appointment_Status bookedStatus = null;
		Appointment_Status cancelledStatus = null;
	
		if(doCurrent != null)
		{				
			//add a cancelled
			cancelledStatus = new Appointment_Status();
			cancelledStatus.setApptDate(doCurrent.getApptDate());
			cancelledStatus.setApptTime(doCurrent.getApptTime());
			cancelledStatus.setComment("Move Theatre Session -  old appointment cancelled");
			cancelledStatus.setStatus(getDomLookup(Status_Reason.CANCELLED));
			cancelledStatus.setStatusReason(getDomLookup(Status_Reason.APPOINTMENTMOVED));
			cancelledStatus.setStatusChangeDateTime(new ims.framework.utils.DateTime().getJavaDate());
			cancelledStatus.setCancellationReason(cancellationReason);
			
			// WDEV-16523 
			if (cancelComment != null && cancelComment.length() >0)
			{
			cancelledStatus.setComment("Move Theatre Session -  old appointment cancelled \nComment: " + cancelComment.trim());
			}
			
					
			//add a booked
			bookedStatus = new Appointment_Status();
			bookedStatus.setApptDate(toDate.getDate());
			bookedStatus.setApptTime(doCurrent.getApptTime());
			bookedStatus.setComment("Move Theatre Session - new appointment Booked");
			bookedStatus.setStatus(getDomLookup(Status_Reason.BOOKED));
			bookedStatus.setStatusReason(getDomLookup(Status_Reason.BOOKED));
			bookedStatus.setStatusChangeDateTime(new ims.framework.utils.DateTime().getJavaDate());
		}
		
		if(doAppointment.getApptStatusHistory() != null)
		{		
			doAppointment.getApptStatusHistory().add(cancelledStatus);
			doAppointment.getApptStatusHistory().add(bookedStatus);
		}
		doAppointment.setCurrentStatusRecord(bookedStatus);
	}

	/**
	* getSession
	*/
	public ims.scheduling.vo.SessionShortVo getSession(ims.scheduling.vo.Sch_SessionRefVo session)
	{
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not provided in method getSession");
		
		return SessionShortVoAssembler.create((Sch_Session) getDomainFactory().getDomainObject(session));
	}

	public Integer[] getBookedAppointmentIdsForSession(Sch_SessionRefVo session)
	{
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not provided in method getBookedAppointmentIdsForSession");
		
		String hql = "select distinct appt.id from Sch_Session as sess left join sess.parentChildSlots as pcSlots left join pcSlots.appointment as appt left join appt.apptStatus as lkpStatus where  (sess.id = " + session.getID_Sch_Session() + " and lkpStatus.id = " + Status_Reason.BOOKED.getID() + ")";
		
		Integer[] arrIds = null;
		List<Integer> ids = getDomainFactory().find(hql);
		if(ids != null && ids.size() > 0)
		{
			//arrIds = new Integer[ids.size()];
			arrIds = ids.toArray(new Integer[0]);
		}
		
		return arrIds;
	}

	public Integer countNonCancelledAppointmentsForSession(Sch_SessionRefVo session)
	{
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not provided in method countNonCancelledAppointmentsForSession");

		List lstCount = getDomainFactory().find("select count(appt.id) from Booking_Appointment appt where appt.session.id = " + session.getID_Sch_Session() + " and appt.apptStatus.id <> " + Integer.valueOf(Status_Reason.CANCELLED.getID()));

		int count = 0;
		if (lstCount != null)
		{
			Iterator it = lstCount.iterator();
			if (it.hasNext())
			{
				Long res = (Long) it.next();
				count = res.intValue();
			}
		}

		return count;
	}
}
