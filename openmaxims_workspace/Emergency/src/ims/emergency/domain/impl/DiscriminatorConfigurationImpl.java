//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Bogdan Tofei using IMS Development Environment (version 1.80 build 4342.23748)
// Copyright (C) 1995-2012 IMS MAXIMS. All rights reserved.

package ims.emergency.domain.impl;

import ims.admin.helper.Keywords;
import ims.core.vo.TaxonomyMap;
import ims.core.vo.lookups.TaxonomyType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.emergency.configuration.domain.objects.DiscriminatorConfig;
import ims.emergency.configuration.vo.DiscriminatorConfigRefVo;
import ims.emergency.domain.base.impl.BaseDiscriminatorConfigurationImpl;
import ims.emergency.vo.DiscriminatorConfigVo;
import ims.emergency.vo.DiscriminatorConfigVoCollection;
import ims.emergency.vo.domain.DiscriminatorConfigVoAssembler;
import ims.framework.exceptions.CodingRuntimeException;

import java.util.ArrayList;
import java.util.List;

public class DiscriminatorConfigurationImpl extends BaseDiscriminatorConfigurationImpl
{

	private static final long serialVersionUID = 1L;

	public DiscriminatorConfigVoCollection listDiscriminators(String filter, Boolean activeOnly, DiscriminatorConfigRefVo discriminatorRef)  //wdev-15985
	{

		List<?> resultsList;

		try
		{
			resultsList = listItemInfo(filter, activeOnly.booleanValue());
		}
		catch (DomainInterfaceException e)
		{
			return null;
		}

		if (resultsList.size() > 0)
		{
			return DiscriminatorConfigVoAssembler.createDiscriminatorConfigVoCollectionFromDiscriminatorConfig(resultsList);
		}
		else //wdev-15985
		{
			if( discriminatorRef != null )
			{
				DomainFactory factory = getDomainFactory();
				StringBuffer hql = new StringBuffer();

				hql.append(" select Discriminator from DiscriminatorConfig as Discriminator where Discriminator.id = :discriminatorID");

				List<?> list = factory.find(hql.toString(), new String[] { "discriminatorID" }, new Object[] { discriminatorRef.getID_DiscriminatorConfig() });

				if ( list != null && list.size() > 0)
				{
					DiscriminatorConfigVoCollection temp = DiscriminatorConfigVoAssembler.createDiscriminatorConfigVoCollectionFromDiscriminatorConfig(list);
					return temp;
				}
					

			}
		}

		return null;
	}

	private List<?> listItemInfo(String filter, boolean activeOnly) throws DomainInterfaceException
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer(" from DiscriminatorConfig x");

		String ret = "";
		if (filter != null)
			ret = filter.replaceAll("%", "");
		if (ret.length() != 0)
			hql.append(" join x.keywords as kw");

		ArrayList<String> names = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		if (activeOnly)
		{
			hql.append(" where x.isActive = :isActive");
			names.add("isActive");
			values.add(Boolean.TRUE);
		}

		return Keywords.searchByKeywords(factory, filter, hql.toString(), names, values);
	}

	public DiscriminatorConfigVo saveDiscriminatorConfig(DiscriminatorConfigVo discriminatorConfig) throws UniqueKeyViolationException, StaleObjectException, DomainInterfaceException
	{
		if (discriminatorConfig == null)
			throw new CodingRuntimeException("Cannot save null DiscriminatorConfig");

		if (!discriminatorConfig.isValidated())
			throw new DomainRuntimeException("discriminatorConfigVo Not Validated.");

		DomainFactory factory = getDomainFactory();

		discriminatorConfig.setDiscriminatorName(discriminatorConfig.getDiscriminatorName().trim());

		DiscriminatorConfigVo savedDiscriminator = null;

		DiscriminatorConfig domDiscriminator = DiscriminatorConfigVoAssembler.extractDiscriminatorConfig(factory, discriminatorConfig);

		if ((discriminatorConfig.getKeywords() == null || discriminatorConfig.getKeywords().size() == 0) && domDiscriminator.getDiscriminatorName() != null)
			domDiscriminator.setKeywords(Keywords.setupKeyWords((List<?>) domDiscriminator.getKeywords(), domDiscriminator.getDiscriminatorName()));

		if (domDiscriminator.getKeywords().size() <= 0)
			throw new DomainInterfaceException("No keywords were created. Please amend Discriminator name.");

		if (discriminatorConfig.getTaxonomyMapIsNotNull())
		{
			boolean found = false;

			StringBuilder errors = new StringBuilder();

			for (int i = 0; i < discriminatorConfig.getTaxonomyMap().size(); i++)
			{
				TaxonomyMap code = discriminatorConfig.getTaxonomyMap().get(i);
				DiscriminatorConfig discriminatorRole = getDiscriminatorRoleByTaxonomy(code.getTaxonomyCode(), code.getTaxonomyName());
				if (discriminatorRole != null && !discriminatorRole.getId().equals(discriminatorConfig.getID_DiscriminatorConfig()))
				{
					found = true;

					errors.append("\nDiscriminator '" + discriminatorRole.getDiscriminatorName() + "' already has mapped :");
					errors.append(" External Code Type '" + code.getTaxonomyName() + "' and code '" + code.getTaxonomyCode() + "'");
				}
			}

			if (found)
				throw new UniqueKeyViolationException(errors.toString());
		}

		factory.save(domDiscriminator);

		savedDiscriminator = DiscriminatorConfigVoAssembler.create(domDiscriminator);

		return savedDiscriminator;
	}

	private DiscriminatorConfig getDiscriminatorRoleByTaxonomy(String taxonomyCode, TaxonomyType taxonomyName)
	{
		if (taxonomyCode == null || taxonomyName == null)
			return null;

		DomainFactory factory = (DomainFactory) this.getDomainFactory();
		String hql = " from DiscriminatorConfig dc join dc.taxonomyMap as tm where tm.taxonomyName = :taxType and tm.taxonomyCode = :extId ";
		List<?> discriminator = factory.find(hql, new String[] { "taxType", "extId" }, new Object[] { getDomLookup(taxonomyName), taxonomyCode });

		if (discriminator != null && discriminator.size() >= 1)
			return (DiscriminatorConfig) discriminator.get(0);

		return null;
	}

	public DiscriminatorConfigVo getDiscriminatorConfig(DiscriminatorConfigVo discriminatorConfig)
	{
		DomainFactory factory = getDomainFactory();

		if (discriminatorConfig == null || !discriminatorConfig.getID_DiscriminatorConfigIsNotNull())
		{
			throw new CodingRuntimeException("Cannot get DiscriminatorConfig on null Id ");
		}

		StringBuffer hql = new StringBuffer();

		hql.append(" select Discriminator from DiscriminatorConfig as Discriminator where Discriminator.id = :discriminatorID");

		List<?> list = factory.find(hql.toString(), new String[] { "discriminatorID" }, new Object[] { discriminatorConfig.getID_DiscriminatorConfig() });

		if (list != null && list.size() > 0)
			return DiscriminatorConfigVoAssembler.createDiscriminatorConfigVoCollectionFromDiscriminatorConfig(list).get(0);

		return null;
	}


}
