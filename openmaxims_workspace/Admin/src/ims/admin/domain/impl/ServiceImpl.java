//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Sean Nesbitt using IMS Development Environment (version 1.43 build 2232.25589)
// Copyright (C) 1995-2006 IMS MAXIMS plc. All rights reserved.

package ims.admin.domain.impl;

import ims.admin.domain.LocationService;
import ims.admin.domain.base.impl.BaseServiceImpl;
import ims.admin.helper.Keywords;
import ims.configuration.gen.ConfigFlag;
import ims.core.clinical.domain.objects.Service;
import ims.core.clinical.domain.objects.ServiceFunction;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.resource.domain.objects.ServiceActivity;
import ims.core.resource.place.vo.ActivityRefVo;
import ims.core.vo.ActivityVoCollection;
import ims.core.vo.LocationServiceActivityVo;
import ims.core.vo.LocationServiceActivityVoCollection;
import ims.core.vo.LocationServiceVo;
import ims.core.vo.LocationServiceVoCollection;
import ims.core.vo.ProcedureVo;
import ims.core.vo.ProcedureVoCollection;
import ims.core.vo.ServiceActivityVo;
import ims.core.vo.ServiceActivityVoCollection;
import ims.core.vo.ServiceFunctionVoCollection;
import ims.core.vo.ServiceLiteVoCollection;
import ims.core.vo.ServiceShortVo;
import ims.core.vo.ServiceVo;
import ims.core.vo.ServiceVoCollection;
import ims.core.vo.SpecialtyListVo;
import ims.core.vo.SpecialtyListVoCollection;
import ims.core.vo.TaxonomyMap;
import ims.core.vo.TaxonomyMapCollection;
import ims.core.vo.domain.ActivityVoAssembler;
import ims.core.vo.domain.ProcedureVoAssembler;
import ims.core.vo.domain.ServiceActivityVoAssembler;
import ims.core.vo.domain.ServiceFunctionVoAssembler;
import ims.core.vo.domain.ServiceLiteVoAssembler;
import ims.core.vo.domain.ServiceVoAssembler;
import ims.core.vo.lookups.ActivityType;
import ims.core.vo.lookups.ServiceCategoryCollection;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ServiceImpl extends BaseServiceImpl
{
	/**
	 * 
	 */
	private static final long	serialVersionUID	= 1L;

	/**
	 * list services
	 */
	public ims.core.vo.ServiceVoCollection listService(ims.core.vo.ServiceShortVo filter)
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer(" ");
		String query = "from Service s ";
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		String andStr = " ";

		if (filter != null && filter.getServiceName() != null)
		{
			String name = filter.getServiceName().toUpperCase();
			if (name.endsWith("%"))
				name = name.substring(0, name.length() - 1);

			hql.append(andStr + " (UPPER(s.serviceName) like :SERVICENAME ");
			markers.add("SERVICENAME");
			values.add("%" + name + "%");
			hql.append(")");
			andStr = " and ";
		}
		if (filter != null && filter.getIsActive() != null)
		{
			hql.append(andStr + " s.isActive = :isActive");
			markers.add("isActive");
			values.add(filter.getIsActive());
			andStr = " and ";
		}
		if (filter != null && filter.getID_ServiceIsNotNull())
		{
			hql.append(andStr + " s.id = :serviceId");
			markers.add("serviceId");
			values.add(filter.getID_Service());
			andStr = " and ";
		}

		if (markers.size() > 0)
			query += " where ";
		query += hql.toString();
		int configAmount = ConfigFlag.DOM.CLINICAL_ADMIN_SEARCH_MAX_SIZE.getValue();
		List services = factory.find(query, markers, values, configAmount);

		return ServiceVoAssembler.createServiceVoCollectionFromService(services).sort();

	}

	public ims.core.vo.ServiceLiteVoCollection listServiceLite(ims.core.vo.ServiceShortVo filter)
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer(" ");
		String query = "from Service s ";
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		String andStr = " ";

		if (filter != null && filter.getServiceName() != null)
		{
			String name = filter.getServiceName().toUpperCase();
			if (name.endsWith("%"))
				name = name.substring(0, name.length() - 1);

			hql.append(andStr + " (s.upperName like :serviceName ");
			markers.add("serviceName");
			values.add("%" + name + "%");
			hql.append(")");
			andStr = " and ";
		}
		if (filter != null && filter.getIsActive() != null)
		{
			hql.append(andStr + " s.isActive = :isActive");
			markers.add("isActive");
			values.add(filter.getIsActive());
			andStr = " and ";
		}
		if (filter != null && filter.getID_ServiceIsNotNull())
		{
			hql.append(andStr + " s.id = :serviceId");
			markers.add("serviceId");
			values.add(filter.getID_Service());
			andStr = " and ";
		}

		if (markers.size() > 0)
			query += " where ";
		query += hql.toString();
		int configAmount = ConfigFlag.DOM.CLINICAL_ADMIN_SEARCH_MAX_SIZE.getValue();
		List services = factory.find(query, markers, values, configAmount);

		return ServiceLiteVoAssembler.createServiceLiteVoCollectionFromService(services).sort();

	}


	private String activeLocationServiceLinks(ims.core.vo.ServiceVo voService)
	{
		LocationService impl = (LocationService) getDomainImpl(LocationServiceImpl.class);
		LocationServiceVo voLocSer = new LocationServiceVo();
		voLocSer.setService(voService);
		voLocSer.setIsActive(new Boolean(true));
		LocationServiceVoCollection voColl = impl.listLocationService(voLocSer);
		if (voColl != null && voColl.size() > 0)
		{

			String activeMessage = "These " + ConfigFlag.UI.DISPLAY_NAME_LOCATION.getValue(true) + " contain active records for the " + ConfigFlag.UI.DISPLAY_NAME_SERVICE.getValue(false) + " : " + voService.getServiceName();
			for (int i = 0; i < voColl.size(); i++)
			{
				activeMessage += "\r\n" + voColl.get(i).getLocation().getName();
			}

			return activeMessage;
		}
		else
			return null;
	}

	/**
	 * save a service and associated functions/activities
	 */
	public ims.core.vo.ServiceVo saveService(ims.core.vo.ServiceVo voService) throws ims.domain.exceptions.StaleObjectException, ims.domain.exceptions.UniqueKeyViolationException
	{
		if (!voService.isValidated())
			throw new DomainRuntimeException("ServiceVo not Validated");

		// WDEV-1348 check if inactivating a service that
		// Can only make the Service Activity inactive is there are no active
		// Location Service Activity links
		if (!voService.getIsActive().booleanValue())
		{
			// get list of active Location Service links
			String activeSerLocMess = activeLocationServiceLinks(voService);
			if (activeSerLocMess != null)
			{
				throw new UniqueKeyViolationException(activeSerLocMess);
			}
		}

		DomainFactory factory = getDomainFactory();
		Service doService = ServiceVoAssembler.extractService(factory, voService);
		doService.setUpperName(doService.getServiceName().substring(0, Math.min(10, doService.getServiceName().length())).toUpperCase());

		try
		{
			factory.save(doService);
		}
		catch (UnqViolationUncheckedException e)
		{
			// check which constraint was violated (name/taxononmy map)

			// /name
			ServiceShortVo filter = new ServiceShortVo();
			filter.setServiceName(voService.getServiceName());
			ServiceVoCollection voCollSer = listService(filter);
			if (voCollSer != null && voCollSer.size() > 0 && !voCollSer.get(0).getID_Service().equals(voService.getID_Service()))
				throw new UniqueKeyViolationException("Record called \"" + voService.getServiceName() + "\" already exists. Duplicates not allowed.", e);

			// taxonomy map
			String dupMessage = Keywords.checkDuplicateTaxonomy(factory, doService, "taxonomyMap", voService.getTaxonomyMap(), "getServiceName");
			if (dupMessage != null)
				throw new UniqueKeyViolationException(dupMessage);

			throw new UniqueKeyViolationException("Record called \"" + voService.getServiceName() + "\" already exists and is marked as Recorded In Error. Duplicates not allowed.", e);
		}

		return ServiceVoAssembler.create(doService);

	}

	public ServiceActivityVoCollection listServiceActivity(ServiceShortVo voService)
	{
		DomainFactory factory = getDomainFactory();

		if (voService == null)
			return ServiceActivityVoAssembler.createServiceActivityVoCollectionFromServiceActivity(factory.listDomainObjects(ServiceActivity.class)).sort();

		if (voService.getID_ServiceIsNotNull())
		{
			java.util.List servactList = factory.find("from  ServiceActivity servact where servact.service.id = :serviceid", new String[]{"serviceid"}, new Object[]{voService.getID_Service()}, 1000);
			return ServiceActivityVoAssembler.createServiceActivityVoCollectionFromServiceActivity(servactList).sort();
		}

		return null;
	}

	public ServiceFunctionVoCollection listServiceFunction(ServiceShortVo voService)
	{
		DomainFactory factory = getDomainFactory();

		if (voService == null)
			return ServiceFunctionVoAssembler.createServiceFunctionVoCollectionFromServiceFunction(factory.listDomainObjects(ServiceFunction.class)).sort();

		if (voService.getID_ServiceIsNotNull())
		{
			java.util.List servfuncList = factory.find("from  ServiceFunction servfunc where servfunc.service.id = :serviceid", new String[]{"serviceid"}, new Object[]{voService.getID_Service()});
			return ServiceFunctionVoAssembler.createServiceFunctionVoCollectionFromServiceFunction(servfuncList).sort();
		}

		return null;
	}

	public ServiceFunctionVoCollection saveServiceFunction(ServiceFunctionVoCollection vocollServiceFunction, ServiceFunctionVoCollection voCollServiceFunctionDelete) throws StaleObjectException, ForeignKeyViolationException, UniqueKeyViolationException
	{
		DomainFactory factory = getDomainFactory();
		ServiceFunction doServiceFunction = null;

		if (voCollServiceFunctionDelete.size() > 0)
		{

			for (int i = 0; i < voCollServiceFunctionDelete.size(); i++)
			{
				doServiceFunction = ServiceFunctionVoAssembler.extractServiceFunction(factory, voCollServiceFunctionDelete.get(i));
				try
				{
					factory.delete(doServiceFunction);
				}
				catch (DomainRuntimeException e)
				{
					throw new ForeignKeyViolationException(voCollServiceFunctionDelete.get(i).getFunction().getText());
				}
			}

		}

		if (vocollServiceFunction.size() > 0)
		{
			for (int i = 0; i < vocollServiceFunction.size(); i++)
			{
				doServiceFunction = ServiceFunctionVoAssembler.extractServiceFunction(factory, vocollServiceFunction.get(i));
				Service domSserv = (Service) factory.getDomainObject(Service.class, doServiceFunction.getService().getId());
				try
				{
					factory.save(doServiceFunction);
				}
				catch (UnqViolationUncheckedException e)
				{
					// check which constraint was violated (taxononmy map)
					// taxonomy map
					String dupMessage = Keywords.checkDuplicateTaxonomy(factory, domSserv, "taxonomyMap", vocollServiceFunction.get(i).getTaxonomyMap(), "getServiceName");
					if (dupMessage != null)
						throw new UniqueKeyViolationException(dupMessage);

					throw new UniqueKeyViolationException(e.getMessage());
				}
				vocollServiceFunction.set(i, ServiceFunctionVoAssembler.create(doServiceFunction));
			}
			return vocollServiceFunction;
		}

		return null;
	}

	public SpecialtyListVoCollection listService(Boolean bActive)
	{
		DomainFactory factory = getDomainFactory();
		SpecialtyListVoCollection voCollReturn = new SpecialtyListVoCollection();

		List lstServices = factory.find("from Service s where s.isActive = :active", new String[]{"active"}, new Object[]{bActive});
		for (Iterator iter = lstServices.iterator(); iter.hasNext();)
		{
			Service doService = (Service) iter.next();
			SpecialtyListVo voBaseList = new SpecialtyListVo();
			voBaseList.setSingleID(doService.getId());
			voBaseList.setBoolValue(doService.isIsActive());
			voBaseList.setName(doService.getServiceName());

			if (doService.getTaxonomyMap() != null)
			{
				String sDescription = null;
				List taxonomyMap = doService.getTaxonomyMap();
				for (Iterator iter1 = taxonomyMap.iterator(); iter1.hasNext();)
				{
					TaxonomyMap doMap = (TaxonomyMap) iter1.next();
					{
						if (doMap.getTaxonomyCode().equals(ims.core.vo.lookups.TaxonomyType.PAS))
							sDescription = doMap.getTaxonomyCode();
					}
				}
				voBaseList.setDescription(sDescription);
			}
			voCollReturn.add(voBaseList);
		}
		return voCollReturn;
	}

	public ServiceVoCollection listService(Integer[] nServiceIds)
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hqlStart = new StringBuffer();
		String hql;

		hqlStart.append("from Service s where s.id in ( ");
		for (int i = 0; i < nServiceIds.length; i++)
			hqlStart.append(nServiceIds[i] + ",");

		if (hqlStart.toString().endsWith(","))
			hql = hqlStart.toString().substring(0, hqlStart.length() - 1);
		else
			hql = hqlStart.toString();

		hql += " )";

		return ServiceVoAssembler.createServiceVoCollectionFromService(factory.find(hql));
	}

	public ActivityVoCollection listActivity(String nameFilter, ActivityType activityType, Boolean bActive) throws DomainInterfaceException
	{
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		StringBuffer condStr = new StringBuffer();
		String andStr = " ";
		String hql = null;
		DomainFactory factory = getDomainFactory();

		if (ConfigFlag.DOM.LINK_ACTIVITY_TO_PROCEDURE.getValue() && activityType.equals(ActivityType.PROCEDURE))
		{
			hql = "select act from Activity act, Procedure proc join proc.keywords as kw";
			condStr.append(andStr + " where act = proc.activity");
			andStr = " and ";

		}
		else
		{
			hql = "select act from Activity act";
			condStr.append(" where");
			andStr = " ";
		}

		if (bActive != null)
		{
			condStr.append(andStr + " act.isActive = :isActive");
			markers.add("isActive");
			values.add(bActive);
			andStr = " and ";
		}
		if (activityType != null)
		{
			condStr.append(andStr + " act.activityType =:actType");
			markers.add("actType");
			values.add(getDomLookup(activityType));
			andStr = " and ";
		}
		if (!ConfigFlag.DOM.LINK_ACTIVITY_TO_PROCEDURE.getValue() && nameFilter != "")
		{
			condStr.append(andStr + " act.name like :filterStr ");
			markers.add("filterStr");
			values.add(nameFilter + "%");
		}

		hql += condStr.toString();
		List activities = null;
		if (ConfigFlag.DOM.LINK_ACTIVITY_TO_PROCEDURE.getValue() && activityType.equals(ActivityType.PROCEDURE))
			activities = Keywords.searchByKeywords(factory, nameFilter, hql.toString(), markers, values);
		else
			activities = factory.find(hql, markers, values, 1000);

		return ActivityVoAssembler.createActivityVoCollectionFromActivity(activities).sort();
	}

	private String checkActiveLSALinksForInactiveSA(ims.core.vo.ServiceActivityVoCollection voCollServiceActivity) throws DomainInterfaceException
	{
		// for all inactive records, check that there are no active
		// LocationServiceActivity links
		for (int i = 0; i < voCollServiceActivity.size(); i++)
		{
			if (!voCollServiceActivity.get(i).getIsActive().booleanValue())
			{
				// check if an active Location Service Activity records
				LocationService impl = (LocationService) getDomainImpl(LocationServiceImpl.class);
				LocationServiceActivityVo voLocSerAct = new LocationServiceActivityVo();
				voLocSerAct.setServiceActivity(voCollServiceActivity.get(i));
				voLocSerAct.setIsActive(new Boolean(true));
				LocationServiceVo voLocSer = new LocationServiceVo();
				ServiceVo voService = new ServiceVo();
				voService.setID_Service(voCollServiceActivity.get(i).getService().getID_Service());
				voService.setIsActive(voCollServiceActivity.get(i).getService().getIsActive());
				voLocSer.setService(voService);
				voLocSerAct.setLocationService(voLocSer);
				LocationServiceActivityVoCollection voColl = impl.listLocationServiceActivity(voLocSerAct.getLocationService(), voLocSerAct.getServiceActivity().getActivity());

				if (voColl != null && voColl.size() > 0 && voLocSerAct.getIsActiveIsNotNull())
				{
					String text = "The following " + ConfigFlag.UI.DISPLAY_NAME_LOCATION.getValue(false) + "," + ConfigFlag.UI.DISPLAY_NAME_SERVICE.getValue(false) + "," + ConfigFlag.UI.DISPLAY_NAME_ACTIVITY.getValue(false) + " links are still used and active.\r\n";
					String activeMessage = null;

					for (int j = 0; j < voColl.size(); j++)
					{
						if (voColl.get(j).getIsActiveIsNotNull() && voColl.get(j).getIsActive().booleanValue())
						{
							activeMessage += "\r\n" + ConfigFlag.UI.DISPLAY_NAME_LOCATION.getValue(false) + " : " + (voColl.get(j).getLocationService().getLocation().getNameIsNotNull() ? voColl.get(j).getLocationService().getLocation().getName() : "");
							activeMessage += "  " + ConfigFlag.UI.DISPLAY_NAME_SERVICE.getValue(false) + " : " + (voColl.get(j).getLocationService().getService().getServiceNameIsNotNull() ? voColl.get(j).getLocationService().getService().getServiceName() : "");
							for (int k = 0; k < voColl.get(j).getLocationService().getActivities().size(); k++)
							{
								if (voColl.get(j).getLocationService().getActivities().get(k).getServiceActivity().getActivityIsNotNull() && voColl.get(j).getLocationService().getActivities().get(k).getServiceActivity().equals(voCollServiceActivity.get(i)) && voColl.get(j).getLocationService().getActivities().get(k).getLocationService().getActivities().get(k).getIsActive().booleanValue() && !voCollServiceActivity.get(i).getIsActive().booleanValue())
								{
									activeMessage += "\r\n" + ConfigFlag.UI.DISPLAY_NAME_ACTIVITY.getValue(false) + " : " + (voColl.get(j).getLocationService().getActivities().get(k).getServiceActivity().getActivity().getNameIsNotNull() ? voColl.get(j).getLocationService().getActivities().get(k).getServiceActivity().getActivity().getName() : "");
								}
							}
						}

					}
					if (activeMessage != null)
						return text + activeMessage.replace("null", "");
				}
			}
		}
		return null;
	}

	public ims.core.vo.ServiceActivityVoCollection saveServiceActivity(ims.core.vo.ServiceActivityVoCollection voCollServiceActivity, ims.core.vo.ServiceActivityVoCollection voCollServiceActivityDelete) throws ims.domain.exceptions.StaleObjectException, ims.domain.exceptions.ForeignKeyViolationException, ims.domain.exceptions.UniqueKeyViolationException, DomainInterfaceException
	{
		DomainFactory factory = getDomainFactory();
		ServiceActivity doServiceActivity = null;

		// check that there are no active Location Service Activity links
		String activeMassage = checkActiveLSALinksForInactiveSA(voCollServiceActivity);
		if (activeMassage != null)
		{
			throw new ForeignKeyViolationException(activeMassage);
		}

		if (voCollServiceActivityDelete.size() > 0)
		{

			for (int i = 0; i < voCollServiceActivityDelete.size(); i++)
			{
				doServiceActivity = ServiceActivityVoAssembler.extractServiceActivity(factory, voCollServiceActivityDelete.get(i));
				try
				{
					factory.delete(doServiceActivity);
				}
				catch (DomainRuntimeException e)
				{
					if (voCollServiceActivityDelete.get(i).getActivityIsNotNull())
					{
						// throw new
						// ForeignKeyViolationException(Check_LSA_Links(voCollServiceActivityDelete.get(i)));
						throw new ForeignKeyViolationException("There are records against this " + ConfigFlag.UI.DISPLAY_NAME_ACTIVITY.getValue(false) + ". Cannot remove record : " + voCollServiceActivityDelete.get(i).getActivity().getName());
					}
					else
						throw new ForeignKeyViolationException(e.getMessage());
				}
			}

		}

		if (voCollServiceActivity.size() > 0)
		{
			for (int i = 0; i < voCollServiceActivity.size(); i++)
			{
				doServiceActivity = ServiceActivityVoAssembler.extractServiceActivity(factory, voCollServiceActivity.get(i));
				Service domSserv = (Service) factory.getDomainObject(Service.class, doServiceActivity.getService().getId());
				doServiceActivity.setService(domSserv);
				try
				{
					factory.save(doServiceActivity);
				}
				catch (UnqViolationUncheckedException e)
				{
					if (voCollServiceActivity.get(i).getTaxonomyMap().get(0).getTaxonomyCodeIsNotNull())
						throw new UniqueKeyViolationException(voCollServiceActivity.get(i).getTaxonomyMap().get(0).getTaxonomyCode() + " is already linked to a " + ConfigFlag.UI.DISPLAY_NAME_SERVICE.getValue(false));
					else
						throw new UniqueKeyViolationException("Taxonomy is already linked to a " + ConfigFlag.UI.DISPLAY_NAME_SERVICE.getValue(false));
				}
				voCollServiceActivity.set(i, ServiceActivityVoAssembler.create(doServiceActivity));
			}
			return voCollServiceActivity;
		}
		return null;
	}

	public void removeServiceActivity(ims.core.vo.ServiceActivityVo voServiceActivity) throws ims.domain.exceptions.StaleObjectException, ims.domain.exceptions.ForeignKeyViolationException, ims.domain.exceptions.UniqueKeyViolationException
	{
		DomainFactory factory = getDomainFactory();

		ServiceActivity doServiceActivity = ServiceActivityVoAssembler.extractServiceActivity(factory, voServiceActivity);
		try
		{
			factory.delete(doServiceActivity);
		}
		catch (DomainRuntimeException e) // SN: catching
											// DomainRuntimeException here as
											// this is what Hib is returning
											// with e.getCause() =
											// ConstrainViolationException
		{
			throw new UniqueKeyViolationException(e.getMessage());
		}
	}

	public void removeServiceFunction(ims.core.vo.ServiceFunctionVo voServiceFunction) throws ims.domain.exceptions.StaleObjectException, ims.domain.exceptions.ForeignKeyViolationException, ims.domain.exceptions.UniqueKeyViolationException
	{
		DomainFactory factory = getDomainFactory();

		ServiceFunction doServiceFunction = ServiceFunctionVoAssembler.extractServiceFunction(factory, voServiceFunction);
		try
		{
			factory.delete(doServiceFunction);
		}
		catch (DomainRuntimeException e) // SN: catching
											// DomainRuntimeException here as
											// this is what Hib is returning
											// with e.getCause() =
											// ConstrainViolationException
		{
			throw new UniqueKeyViolationException(e.getMessage());
		}
	}

	public ServiceActivityVo getServiceActivity(ServiceRefVo serviceRefVo, ActivityRefVo activityRefVo)
	{
		DomainFactory factory = getDomainFactory();

		if ((serviceRefVo == null) || (activityRefVo == null))
			throw new DomainRuntimeException("getServiceActivity : Either serviceRefVo or activityRefVo are Null.");

//		java.util.List servactList = factory.find("from  ServiceActivity servact where servact.service.id = :serviceid and servact.activity.id = :activityid", new String[]{"serviceid", "activityid"}, new Object[]{serviceRefVo.getID_Service(), activityRefVo.getID_Activity()});
		//entpf473 wdev-6344
		java.util.List servactList = factory.find("from  ServiceActivity servact where servact.service.id = :serviceid and servact.activity.id = :activityid and servact.isActive = :isAct", new String[]{"serviceid", "activityid", "isAct"}, new Object[]{serviceRefVo.getID_Service(), activityRefVo.getID_Activity(), Boolean.TRUE});
		ServiceActivityVoCollection coll = ServiceActivityVoAssembler.createServiceActivityVoCollectionFromServiceActivity(servactList).sort();

		if (coll != null && coll.size() > 0)
			return coll.get(0);

		return null;
	}

	public ServiceLiteVoCollection listActiveServiceLiteByName(String name)
	{
		DomainFactory factory = getDomainFactory();
		List services = factory.find("from Service s where s.upperName like :serviceName and s.isActive = :isActive", new String[]{"serviceName", "isActive"}, new Object[]{"%" + name.toUpperCase() + "%", Boolean.TRUE});
		return ServiceLiteVoAssembler.createServiceLiteVoCollectionFromService(services).sort();
	}

	public ServiceLiteVoCollection listActiveServiceLiteByNameAndCategories(String name, ServiceCategoryCollection categoryCollection)
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer query = new StringBuffer("from Service s where s.upperName like :serviceName and s.isActive = :isActive");
		for (int i = 0; i < categoryCollection.size(); i++)
		{
			if (i == 0)
				query.append(" and s.serviceCategory.id in(");
			query.append(categoryCollection.get(i).getID());

			if (i < (categoryCollection.size() - 1))
				query.append(", ");
			else
				query.append(")");
		}
		List services = factory.find(query.toString(), new String[]{"serviceName", "isActive"}, new Object[]{"%" + name.toUpperCase() + "%", Boolean.TRUE});
		return ServiceLiteVoAssembler.createServiceLiteVoCollectionFromService(services).sort();
	}

	public String checkLSALinks(ServiceActivityVo voServiceActivity) throws DomainInterfaceException
	{
		if (voServiceActivity != null)
		{
			// check if an active Location Service Activity records
			LocationService impl = (LocationService) getDomainImpl(LocationServiceImpl.class);
			LocationServiceActivityVo voLocSerAct = new LocationServiceActivityVo();
			voLocSerAct.setServiceActivity(voServiceActivity);
			voLocSerAct.setIsActive(new Boolean(true));
			LocationServiceVo voLocSer = new LocationServiceVo();
			ServiceVo voSer = new ServiceVo();
			voSer.setID_Service(voServiceActivity.getService().getID_Service());
			voSer.setIsActive(voServiceActivity.getService().getIsActive());
			voLocSer.setService(voSer);
			voLocSerAct.setLocationService(voLocSer);
			LocationServiceActivityVoCollection voColl = impl.listLocationServiceActivity(voLocSerAct.getLocationService(), voLocSerAct.getServiceActivity().getActivity());
			if (voColl != null && voColl.size() > 0)
			{
				String activeMessage = "The following " + ConfigFlag.UI.DISPLAY_NAME_LOCATION.getValue(false) + "," + ConfigFlag.UI.DISPLAY_NAME_SERVICE.getValue(false) + "," + ConfigFlag.UI.DISPLAY_NAME_ACTIVITY.getValue(false) + " links are still active.\r\n";
				for (int j = 0; j < voColl.size(); j++)
				{
					activeMessage += "\r\n" + ConfigFlag.UI.DISPLAY_NAME_LOCATION.getValue(false) + " : " + (voColl.get(j).getLocationService().getLocation().getNameIsNotNull() ? voColl.get(j).getLocationService().getLocation().getName() : "");
					activeMessage += "  " + ConfigFlag.UI.DISPLAY_NAME_SERVICE.getValue(false) + " : " + (voColl.get(j).getLocationService().getService().getServiceNameIsNotNull() ? voColl.get(j).getLocationService().getService().getServiceName() : "");
					for (int k = 0; k < voColl.get(j).getLocationService().getActivities().size(); k++)
					{
						if (voColl.get(j).getLocationService().getActivities().get(k).getServiceActivity().getActivityIsNotNull())
						{
							activeMessage += "\r\n" + ConfigFlag.UI.DISPLAY_NAME_ACTIVITY.getValue(false) + " : " + (voColl.get(j).getLocationService().getActivities().get(k).getServiceActivity().getActivity().getNameIsNotNull() ? voColl.get(j).getLocationService().getActivities().get(k).getServiceActivity().getActivity().getName() : "");
						}
					}
				}
				return activeMessage;
			}
		}

		return null;
	}

	public ProcedureVo getProcedureForActivity(ActivityRefVo activityRefVo)
	{
		DomainFactory factory = getDomainFactory();

		if (activityRefVo.getID_ActivityIsNotNull())
		{
			java.util.List procList = factory.find("from Procedure proc where proc.activity.id = :actid", new String[]{"actid"}, new Object[]{activityRefVo.getID_Activity()});

			if (procList.size() > 1)
				throw new DomainRuntimeException("More then one Procedure is configured for this Activity.");
			else if (procList.size() == 1)
			{
				ProcedureVoCollection coll = ProcedureVoAssembler.createProcedureVoCollectionFromProcedure(procList);
				return coll.get(0);
			}
			else
				return null;
		}

		return null;
	}

	public String isServiceActivityUnique(TaxonomyMapCollection map, ServiceVo voService)
	{
		DomainFactory factory = getDomainFactory();

		if (map != null)
		{
			String result = "";
			for (int i = 0; i < map.size(); i++)
			{
				java.util.List list = factory.find("select s1_1.service.id, s2_1.serviceName, t1_1.taxonomyCode, l1_1.id from ServiceActivity as s1_1 left join s1_1.service as s2_1 left join s1_1.taxonomyMap as t1_1 left join t1_1.taxonomyName as l1_1 where (t1_1.taxonomyCode = :code and s2_1.serviceName <> :name and l1_1.id = :id)", new String[]{"code", "name", "id"}, new Object[]{map.get(i).getTaxonomyCode(), voService.getServiceName(), new Integer(map.get(i).getTaxonomyName().getID())});

				if (list.size() != 0 && map.get(i).getTaxonomyCodeIsNotNull())
					result = result + (map.get(i).getTaxonomyCode() + " ");

			}
			return result;
		}

		return "";
	}

	public ServiceVo getServiceById(ServiceVo voService)
	{
		DomainFactory factory = getDomainFactory();
		Service doService = (Service) factory.getDomainObject(Service.class, voService.getID_Service());
		return (ServiceVoAssembler.create(doService));
	}
}
