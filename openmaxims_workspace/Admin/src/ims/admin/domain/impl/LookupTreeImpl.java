//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
//This code was generated by John MacEnri using IMS Development Environment (version 1.22 build 41103.1700)
//Copyright (C) 1995-2004 IMS MAXIMS plc. All rights reserved.

package ims.admin.domain.impl;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import ims.admin.domain.base.impl.BaseLookupTreeImpl;
import ims.admin.vo.AppFormVoCollection;
import ims.admin.vo.FormLookupVo;
import ims.admin.vo.FormLookupVoCollection;
import ims.admin.vo.domain.AppFormVoAssembler;
import ims.admin.vo.domain.FormLookupVoAssembler;
import ims.core.clinical.domain.objects.TaxonomyMap;
import ims.core.configuration.domain.objects.AppForm;
import ims.core.configuration.domain.objects.AppFormLookup;
import ims.core.configuration.domain.objects.AppImage;
import ims.core.configuration.domain.objects.PrivateInsuranceCompany;
import ims.core.configuration.vo.AppFormRefVo;
import ims.core.vo.IfLookupInstanceVo;
import ims.core.vo.IfLookupVo;
import ims.core.vo.lookups.TaxonomyType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainException;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.domain.lookups.Lookup;
import ims.domain.lookups.LookupInstance;
import ims.domain.lookups.LookupMapping;
import ims.framework.utils.Image;
import ims.framework.utils.ImagePath;
import ims.vo.LookupInstVo;
import ims.vo.LookupInstanceCollection;
import ims.vo.LookupMappingVo;
import ims.vo.LookupMappingVoCollection;
import ims.vo.LookupTypeVo;
import ims.vo.LookupTypeVoCollection;

public class LookupTreeImpl extends BaseLookupTreeImpl
{
	/**
	 * 
	 */
	private static final long	serialVersionUID	= 1L;

	public ims.vo.LookupTypeVoCollection getTypes(String nameFilter, Boolean activeOnly, Boolean userTypesOnly, Boolean systemTypes)
	{
		DomainFactory factory = getDomainFactory();
		String hqlString = " from Lookup l ";
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		StringBuffer condString = new StringBuffer();
		String prepend = " where ";

		if (nameFilter != null && !nameFilter.equals(""))
		{
			condString.append(prepend + " upper(l.name) like :nameFilter ");
			markers.add("nameFilter");
			values.add("%" + nameFilter.toUpperCase() + "%");
			prepend = " and ";
		}

		if (userTypesOnly.booleanValue())
		{
			condString.append(prepend + " l.id < 0");
			prepend = " and ";
		}
		else
		{
			condString.append(prepend + " l.id > 0");
			prepend = " and ";
		}

		if (activeOnly.booleanValue())
		{
			condString.append(prepend + " l.active = true");
			prepend = " and ";
		}
		
		if(!systemTypes.booleanValue())
		{
			condString.append(prepend + " l.systemType = false");
			prepend = " and ";
		}

		hqlString += condString.toString();

		List lookupTypes = factory.find(hqlString, markers, values);
		LookupTypeVoCollection collection = new LookupTypeVoCollection();
		for (Iterator iter = lookupTypes.iterator(); iter.hasNext();)
		{
			Lookup element = (Lookup) iter.next();
			LookupTypeVo valueObject = createLookupVo(element);
			collection.add(valueObject);
		}
		collection.sort();
		return collection;
	}

	public LookupInstanceCollection getLookupInstances(LookupTypeVo typeVo)
	{
		LookupInstanceCollection collection = new LookupInstanceCollection();
		DomainFactory factory = getDomainFactory();
		ims.domain.lookups.Lookup lookupType = factory.getLookup(typeVo.getId());
		if (null != lookupType)
		{
			java.util.Set set = lookupType.getInstances();
			for (Iterator iter = set.iterator(); iter.hasNext();)
			{
				LookupInstance element = (LookupInstance) iter.next();
				LookupInstVo valueObject = createLookupinstanceVo(element);
				collection.add(valueObject);
			}
		}
		return collection;
	}

	public LookupInstanceCollection saveLookupInstance(LookupTypeVo typeVo, LookupInstVo instance) throws StaleObjectException, DomainInterfaceException
	{
		DomainFactory factory = getDomainFactory();
		ims.domain.lookups.Lookup type = factory.getLookup(typeVo.getId());
		if (null == type)
		{
			throw new DomainRuntimeException("No lookup type exists with ID = " + typeVo.getId());
		}

		// Check if it's a new one, with no ID assigned.
		LookupInstance dol = null;
		if (instance.getId() != 0)
		{
			dol = factory.getLookupInstance(instance.getId());
		}
		if (null == dol)
		{
			// Get the next val
			java.util.List lst = factory.find("from LookupInstance l where l.id = (select max(l1.id) from LookupInstance l1)");
			int nextVal = ((LookupInstance) lst.get(0)).getId();
			if (nextVal < 0)
				nextVal = 0;
			dol = new LookupInstance(nextVal + 1, type, instance.isActive(), instance.getText());
			type.getInstances().add(dol);
		}
		else
		{
			dol.setActive(instance.isActive());
			dol.setText(instance.getText());
		}
		if (instance.getImage() != null)
		{
			dol.setImage((Image) factory.getDomainObject(AppImage.class, instance.getImage().getImageId()));
		}
		else
		{
			dol.setImage(null);
		}
		dol.setOrder(instance.getOrder());

		if (instance.getParentInstance() != null)
		{
			LookupInstance parentDol = factory.getLookupInstance(instance.getParentInstance().getId());
			dol.setParent(parentDol);
		}
		else
		{
			dol.setParent(null);
		}
		dol.setColor(instance.getColor());
		populateMappings(dol, instance);
		
		//JME: 20070321: Totally ugly hack to ensure mapppings for both SpecimenType and SpecimenSite are unique in combination
		// wdev-3305 Remove this constraint checkSpecimenTypeAndSpecimenSiteMappings(type);
			
		checkSpecimenTypeAndResultSpecimenTypesMappings(type);
		factory.save(dol);
		refreshCache(typeVo);
		return getLookupInstances(typeVo);
	}

	private void checkSpecimenTypeAndSpecimenSiteMappings(Lookup type) throws DomainInterfaceException
	{
		int specimenTypeId = 1161029;
		int specimenSiteId = 1161028;
		if (type.getId() == specimenTypeId || type.getId() == specimenSiteId)
		{		
			ims.domain.lookups.Lookup thisType = type;
			ims.domain.lookups.Lookup otherType;
			if (thisType.getId() == specimenTypeId)
				otherType = this.getDomainFactory().getLookup(specimenSiteId);
			else
				otherType = this.getDomainFactory().getLookup(specimenTypeId);			
			
			Set thisInstSet = thisType.getInstances();
			Set otherInstSet = otherType.getInstances();

			Iterator thisInstIter = thisInstSet.iterator();
			while (thisInstIter.hasNext())
			{
				LookupInstance thisInst = (LookupInstance)thisInstIter.next();				
				Iterator otherInstIter = otherInstSet.iterator();				
				while (otherInstIter.hasNext())
				{
					LookupInstance otherInst = (LookupInstance)otherInstIter.next();
					Iterator otherInstMappingsIter = otherInst.getMappings().iterator();
					while (otherInstMappingsIter.hasNext())
					{
						LookupMapping otherInstMapping = (LookupMapping)otherInstMappingsIter.next();
						if ( thisInst.getMappings().contains(otherInstMapping)) 
						{
							// An error - cannot add the same mapping twice
							StringBuffer message = new StringBuffer("Another lookup instance '" + otherInst.getText() + "', ID=" + otherInst.getId() + " of type = " + otherType.getName() + " already has a mapping which equals - ");
							message.append(" systemName:").append(otherInstMapping.getExtSystem());
							message.append(", extCode:").append(otherInstMapping.getExtCode());
							message.append(". Duplicate mappings not permitted between SpecimenType and Specimen Site. ");
							throw new DomainInterfaceException(message.toString());				
						}
					}
				}
			}					
		}
	}

	
	// new method for http://jira/browse/WDEV-11733
	private void checkSpecimenTypeAndResultSpecimenTypesMappings(Lookup type) throws DomainInterfaceException
	{
		int specimenTypeId = 1161029;
		int resultSpecimenTypesId = 1161052;
		if (type.getId() == specimenTypeId || type.getId() == resultSpecimenTypesId)
		{		
			ims.domain.lookups.Lookup thisType = type;
			ims.domain.lookups.Lookup otherType;
			if (thisType.getId() == specimenTypeId)
				otherType = this.getDomainFactory().getLookup(resultSpecimenTypesId);
			else
				otherType = this.getDomainFactory().getLookup(specimenTypeId);			
			
			Set thisInstSet = thisType.getInstances();
			Set otherInstSet = otherType.getInstances();

			Iterator thisInstIter = thisInstSet.iterator();
			while (thisInstIter.hasNext())
			{
				LookupInstance thisInst = (LookupInstance)thisInstIter.next();				
				Iterator otherInstIter = otherInstSet.iterator();				
				while (otherInstIter.hasNext())
				{
					LookupInstance otherInst = (LookupInstance)otherInstIter.next();
					Iterator otherInstMappingsIter = otherInst.getMappings().iterator();
					while (otherInstMappingsIter.hasNext())
					{
						LookupMapping otherInstMapping = (LookupMapping)otherInstMappingsIter.next();
						if ( thisInst.getMappings().contains(otherInstMapping)) 
						{
							// An error - cannot add the same mapping twice
							StringBuffer message = new StringBuffer("Another lookup instance '" + otherInst.getText() + "', ID=" + otherInst.getId() + " of type = " + otherType.getName() + " already has a mapping which equals - ");
							message.append(" systemName:").append(otherInstMapping.getExtSystem());
							message.append(", extCode:").append(otherInstMapping.getExtCode());
							message.append(". Duplicate mappings not permitted between SpecimenType and ResultSpecimenTypes. ");
							throw new DomainInterfaceException(message.toString());				
						}
					}
				}
			}					
		}
	}

	
	
	public void refreshCache(LookupTypeVo typeVo)
	{
		DomainFactory factory = getDomainFactory();
		ims.domain.lookups.Lookup type = factory.getLookup(typeVo.getId());
		if (null == type)
		{
			throw new DomainRuntimeException("No lookup type exists with ID = " + typeVo.getId());
		}
		factory.refresh(type);
		this.getLookupService().refreshCache(typeVo.getId());
	}

	public LookupInstVo getMappings(LookupInstVo instance)
	{
		DomainFactory factory = getDomainFactory();
		ims.domain.lookups.LookupInstance doInst = factory.getLookupInstance(instance.getId());
		Set mappings = doInst.getMappings();
		LookupMappingVoCollection mapColl = new LookupMappingVoCollection();
		Iterator iter = mappings.iterator();
		LookupMapping doMapping;
		while (iter.hasNext())
		{
			doMapping = (LookupMapping) iter.next();
			mapColl.add(new LookupMappingVo(doMapping.getExtSystem(), doMapping.getExtCode()));
		}
		mapColl.sort();
		instance.setMappings(mapColl);
		return instance;
	}

	public FormLookupVoCollection getFormLookups(AppFormRefVo formRef)
	{
		DomainFactory factory = getDomainFactory();
		AppForm domForm = (AppForm) factory.getDomainObject(formRef);
		return FormLookupVoAssembler.createFormLookupVoCollectionFromAppFormLookup(domForm.getLookups());
	}

	public LookupInstVo deactivateInstance(LookupTypeVo typeVo, LookupInstVo voInstance) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		ims.domain.lookups.Lookup doType = factory.getLookup(typeVo.getId());
		ims.domain.lookups.LookupInstance doInstance = doType.getInstance(voInstance.getId());
		doInstance.getText();
		doInstance.setActive(!doInstance.isActive());
		factory.save(doInstance);
		voInstance.setActive(doInstance.isActive());
		refreshCache(typeVo);
		return voInstance;

	}

	public LookupInstanceCollection saveInstanceOrder(LookupTypeVo type, LookupInstanceCollection instances) throws StaleObjectException
	{
		int typeId = type.getId();
		DomainFactory factory = getDomainFactory();
		ims.domain.lookups.Lookup doType = factory.getLookup(typeId);
		for (int i = 0; i < instances.size(); i++)
		{
			LookupInstVo vo = instances.getIndex(i);
			ims.domain.lookups.LookupInstance doInstance = doType.getInstance(vo.getId());
			doInstance.getText();
			doInstance.setOrder(i);
			doInstance.setParent(getDomLookup(vo.getParentInstance()));
		}
		factory.save(doType);

		refreshCache(type);
		return getLookupInstances(type);
	}

	public LookupTypeVo saveLookupType(LookupTypeVo typeVo) throws StaleObjectException, UniqueKeyViolationException
	{
		DomainFactory factory = getDomainFactory();
		Lookup typeDo = null;
		if (typeVo.getId() != 0)
		{
			typeDo = factory.getLookup(typeVo.getId());
		}
		if (typeDo == null)
		{
			Integer negId = getNextNegId();
			typeDo = new Lookup(negId.intValue(), typeVo.getName(), typeVo.getDescription());
		}
		else
		{
			typeDo.setDescription(typeVo.getDescription());
			typeDo.setName(typeVo.getName());
		}
		typeDo.setActive(typeVo.isActive());
		typeDo.setHierarchical(typeVo.isHierarchical());
		typeDo.setSystemType(typeVo.isSystemType());
		try
		{
			factory.save(typeDo);
		}
		catch (UnqViolationUncheckedException e)
		{
			throw new UniqueKeyViolationException("A lookup type with name = " + typeVo.getName() + " already exists. Duplicates not allowed.");
		}

		typeVo.setId(typeDo.getId());
		return typeVo;
	}

	private Integer getNextNegId()
	{
		DomainFactory factory = getDomainFactory();
		List l = factory.find(" from Lookup lk where lk.id = (select min(lk2.id) from Lookup lk2)");
		if (l.size() == 0)
			return Integer.valueOf(-1);
		Lookup lookup = (Lookup) l.get(0);
		int ret = lookup.getId();
		if (ret > 0)
			ret = 0;
		return Integer.valueOf(ret - 1);
	}

	private LookupInstVo createLookupinstanceVo(LookupInstance element)
	{
		if (element == null)
			return null;
		Image img = null;
		Image regImage = element.getImage();
		if (regImage != null)
		{
			img = new ImagePath(regImage.getImageId(), regImage.getImagePath());
		}
		LookupInstVo valueObject = new LookupInstVo(element.getId(), element.getText(), element.isActive(), null, img, element.getColor(), element.getOrder());
		LookupInstance doParent = element.getParent();
		if (doParent != null)
		{
			LookupInstVo voParent = createLookupinstanceVo(doParent);
			valueObject.setParentInstance(voParent);
		}
		return valueObject;
	}

	private ims.vo.LookupTypeVo createLookupVo(Lookup type)
	{
		ims.vo.LookupTypeVo typeVo = new ims.vo.LookupTypeVo(type.getId(), type.getName(), type.getDescription(), type.getActive(), type.getHierarchical(), type.getSystemType());
		return typeVo;
	}

	private void populateMappings(LookupInstance dol, LookupInstVo instance) throws DomainInterfaceException
	{
		dol.getMappings().clear();
		LookupMappingVoCollection mapColl = instance.getMappings();
		if (mapColl == null || mapColl.size() == 0)
			return;

		for (int i = 0; i < mapColl.size(); i++)
		{
			LookupMappingVo mapping = mapColl.get(i);
			if (mapping == null)
				continue;
			try
			{
				dol.addMapping(mapping.getExtSystem(), mapping.getExtCode());
			}
			catch (DomainException e)
			{
				throw new DomainInterfaceException(e.getMessage(), e);
			}
		}
	}

	public void saveDefaultInstance(AppFormRefVo formRef, FormLookupVo defInst) throws StaleObjectException
	{
		if (formRef == null)
			return;
		if (defInst == null)
			return;

		DomainFactory factory = getDomainFactory();
		AppForm domForm = (AppForm) factory.getDomainObject(formRef);

		LookupInstance lookupInst = null;
		if (defInst.getDefaultInstance() != null)
		{
			lookupInst = factory.getLookupInstance(defInst.getDefaultInstance().getId());
		}

		List lookupTypes = domForm.getLookups();
		for (Iterator iter = lookupTypes.iterator(); iter.hasNext();)
		{
			AppFormLookup element = (AppFormLookup) iter.next();
			if (element.getLookupType().getId() == defInst.getLookupType().getId())
			{
				element.setDefaultInstance(lookupInst);
				factory.save(domForm);
			}
		}
//MN		this.getLookupService().clearDefaultInstanceCache(formRef.getID_AppForm().intValue(), defInst.getLookupType().getId());
	}

	public AppFormVoCollection listForms(String nameFilter)
	{
		DomainFactory factory = getDomainFactory();
		String hql = " from AppForm af where upper(af.name) like :name and af.isComponent = :isComp and af.isAlias = :isAlias";
		String filter = "%" + nameFilter.trim().toUpperCase() + "%";
		return AppFormVoAssembler.createAppFormVoCollectionFromAppForm(factory.find(hql, new String[]{"name", "isComp", "isAlias"}, new Object[]{filter, Boolean.FALSE, Boolean.FALSE})).sort();
	}

	public void saveInstanceDataFromHL7(IfLookupVo lookupData)throws DomainInterfaceException, StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		validateIfLookupVo(lookupData);
		if("Insurer".equalsIgnoreCase(lookupData.getLookupType())) //http://jira/browse/WDEV-17968
		{
			for (IfLookupInstanceVo object : lookupData.getInstances())
			{
				if(object.getInstanceName()!=null)
				{
					String hqlString = " from PrivateInsuranceCompany comp  where  upper(comp.upperName) = :nameFilter ";
					List<?> companies = factory.find(hqlString, "nameFilter",object.getInstanceName().toUpperCase());
					
					if(companies==null)
						throw new DomainInterfaceException("LookupType not found: "+lookupData.getLookupType());
					
					PrivateInsuranceCompany company = null;
					if (companies.isEmpty())
					{
						company = new PrivateInsuranceCompany();
						company.setName(object.getInstanceName());
						company.setUpperName(object.getInstanceName().toUpperCase());
						company.setIsActive(true);
					}
					else 
					{
						//get the active one if it 
						company= getActiveCompany( companies);
					}
					if(company!=null)//WDEV-17968
					{
						if(object.getVerbIsNotNull()&&object.getVerb().equals("MDC")) //WDEV-17968
						{
							company.setIsActive(false);
						}
						else // don't update the mappings if it is deactivate
						{
							addMapping(company,object.getCode(),object.getSystem());
						}
						factory.save(company);
					}
				}
			}			
		}
		else
		{
			String hqlString = " from Lookup l  where  upper(l.name) = :nameFilter ";
			List<?> lookupTypes = factory.find(hqlString, "nameFilter",lookupData.getLookupType().toUpperCase());
			
			if(lookupTypes==null||lookupTypes.isEmpty())
				throw new DomainInterfaceException("LookupType not found: "+lookupData.getLookupType());
			else if(lookupTypes.size()>1)
				throw new DomainInterfaceException("More than one LookupType found for : "+lookupData.getLookupType());
			
			Lookup lookup = (Lookup)lookupTypes.get(0);
			for (IfLookupInstanceVo object : lookupData.getInstances())
			{
				LookupInstance instance = getInstance(lookup, object.getInstanceName());
				if (instance==null)
				{
					int nextVal = getNextLookupInstanceId(factory);
					instance = new LookupInstance(nextVal, lookup, true, object.getInstanceName());
					lookup.getInstances().add(instance);
				}
				if(object.getVerbIsNotNull()&&object.getVerb().equals("MDC"))
				{
					instance.setActive(false);
				}
				else // don't update the mappings if it is deactivate
				{
					addMapping(instance,object.getCode(),object.getSystem());
				}
				factory.save(instance);
				factory.refresh(lookup);
				this.getLookupService().refreshCache(lookup.getId());
			}
		}
	}

	private PrivateInsuranceCompany getActiveCompany(List<?> companies)
	{
		if (companies!=null)
		{
			for (Object object : companies)
			{
				PrivateInsuranceCompany company = (PrivateInsuranceCompany)object;
				if(company.isIsActive())
					return company;
			}
		}
		return null;
	}
	
	private int getNextLookupInstanceId(DomainFactory factory) {
		java.util.List<?> lst = factory.find("from LookupInstance l where l.id = (select max(l1.id) from LookupInstance l1)");
		int nextVal = ((LookupInstance) lst.get(0)).getId();
		if (nextVal < 0)
			nextVal = 0;
		return nextVal+1;
	}

	private LookupInstance getInstance(Lookup lookup,String instanceName)
	{
		if(lookup==null||lookup.getInstances()==null||lookup.getInstances().isEmpty())
			return null;
		
		Iterator<?> iter = lookup.getInstances().iterator();
		while(iter.hasNext())
		{
			LookupInstance instance=(LookupInstance)iter.next();
			if(instanceName.equals(instance.getText()))
				return instance;
		}
		return null;
	}
	
	private void validateIfLookupVo(IfLookupVo lookupData)throws DomainInterfaceException
	{
		if(lookupData==null)
			throw new DomainInterfaceException("Lookup data not populated in message");
		if(lookupData.getLookupType()==null||lookupData.getLookupType().length()==0)
			throw new DomainInterfaceException("Empty lookup name field not supported");
	}
	
	
	private void addMapping(PrivateInsuranceCompany company,String code,String system) throws DomainInterfaceException
	{
		if(code!=null&&system!=null)
		{
				DomainFactory factory = getDomainFactory();
				TaxonomyMap taxonomyMap = new TaxonomyMap();
				taxonomyMap.setTaxonomyCode(code);
				taxonomyMap.setTaxonomyName(getInstance(factory.getLookup(TaxonomyType.TYPE_ID), system));
				if(!company.getCodeMappings().contains(taxonomyMap))
					company.getCodeMappings().add(taxonomyMap);
		}
	}
	
	private void addMapping(LookupInstance doli,String code,String system) throws DomainInterfaceException
	{
		if(code!=null&&system!=null)
		{
			try
			{
				doli.addMapping(system, code);
			}
			catch (DomainException e)
			{
	//			throw new DomainInterfaceException(e.getMessage(), e);
			}
		}
	}
	
}
