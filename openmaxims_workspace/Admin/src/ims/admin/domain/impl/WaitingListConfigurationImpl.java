//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Florin Blindu using IMS Development Environment (version 1.80 build 4910.25978)
// Copyright (C) 1995-2013 IMS MAXIMS. All rights reserved.

package ims.admin.domain.impl;

import ims.admin.domain.base.impl.BaseElectiveListConfigurationImpl;
import ims.admin.vo.ServiceForElectiveListConfigVo;
import ims.admin.vo.domain.ElectiveListConfigurationVoAssembler;
import ims.admin.vo.domain.ServiceForElectiveListConfigVoAssembler;
import ims.core.configuration.domain.objects.ElectiveListConfiguration;
import ims.core.configuration.vo.ElectiveListConfigurationRefVo;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.ServiceCategory;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;

import java.util.ArrayList;
import java.util.List;


public class WaitingListConfigurationImpl extends BaseElectiveListConfigurationImpl
{

	private static final long serialVersionUID = 1L;

	/*
	public ims.core.vo.HcpLiteVoCollection listConsultants(String name)
	{
		HcpFilter filter = new HcpFilter();
		PersonName voName = new PersonName();
		voName.setSurname(name);
		filter.setQueryName(voName);
		
		HcpAdmin impl = (HcpAdmin) getDomainImpl(HcpAdminImpl.class);
		return impl.listHcpLite(filter);
	}
	*/
	
	public LocationLiteVoCollection listHospitals(String name)
	{
		DomainFactory factory = getDomainFactory();

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		StringBuffer hql = new StringBuffer();

		hql.append(" select loc from Location as loc ");
		hql.append(" where loc.upperName like :LocName and loc.isActive = 1 and loc.isVirtual = 0 and loc.type <> :surgery ");
		hql.append(" order by loc.upperName asc");
		
		markers.add("LocName");
		values.add(name.toUpperCase()+"%");
		
		markers.add("surgery");
		values.add(getDomLookup(LocationType.SURGERY));
		
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(factory.find(hql.toString(), markers, values));
	}

	public ims.admin.vo.ServiceForElectiveListConfigVoCollection listServices(String name)
	{
		StringBuilder hqlBuilder = new StringBuilder("select s1_1 from Service as s1_1 where s1_1.upperName like :servName and s1_1.isActive = 1 and s1_1.serviceCategory.id <> :patCategoryID ");
				
		List <?> dos = getDomainFactory().find(hqlBuilder.toString(),new String[] {"servName","patCategoryID"},new Object[] {name.toUpperCase()+"%",ServiceCategory.PATHOLOGY_DISCIPLINE.getID()});
		
		if (dos == null || dos.size() == 0)
			return null;
		
		return ServiceForElectiveListConfigVoAssembler.createServiceForElectiveListConfigVoCollectionFromService(dos); 
	}

	public ims.admin.vo.ElectiveListConfigurationVo save(ims.admin.vo.ElectiveListConfigurationVo configurationToSave) throws ims.domain.exceptions.StaleObjectException
	{
		if (configurationToSave == null)
		{
			throw new CodingRuntimeException("Cannot save null ElectiveListConfigurationVo");
		}

		DomainFactory factory = getDomainFactory();
		
		ElectiveListConfiguration domainWaitinngListConfig = ElectiveListConfigurationVoAssembler.extractElectiveListConfiguration(factory, configurationToSave);
		factory.save(domainWaitinngListConfig);
		
		return ElectiveListConfigurationVoAssembler.create(domainWaitinngListConfig);
	}

	public ims.admin.vo.ElectiveListConfigurationVo getConfiguration(ims.core.configuration.vo.ElectiveListConfigurationRefVo configurationRef)
	{
		if (configurationRef==null ||configurationRef.getID_ElectiveListConfiguration()==null)
		{
			throw new CodingRuntimeException("Cannot get ElectiveListConfigurationVo on null Id ");
		}

		DomainFactory factory = getDomainFactory();

		ElectiveListConfiguration domainWaitListConfig = (ElectiveListConfiguration) factory.getDomainObject(ElectiveListConfiguration.class,configurationRef.getID_ElectiveListConfiguration());

		return ElectiveListConfigurationVoAssembler.create(domainWaitListConfig);
	}

	public ims.admin.vo.ElectiveListConfigurationVoCollection search(ims.admin.vo.ElectiveListConfigSearchCriteriaVo searchCriteria)
	{
		if (searchCriteria == null)
			throw new CodingRuntimeException("At least one search criteria must be provided");

		DomainFactory factory = getDomainFactory();

		StringBuffer hqlConditions = new StringBuffer();
		
		StringBuffer hql = new StringBuffer("select wLC from ElectiveListConfiguration as wLC  ");
		
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		String andStr = "";

		if (searchCriteria.getWaitingListNameIsNotNull())
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" UPPER(wLC.waitingListName) like :WaitingListName ");
			markers.add("WaitingListName");
			values.add(searchCriteria.getWaitingListName().toUpperCase()+"%");
			andStr = " and ";
		}
		
		if (searchCriteria.getServiceIsNotNull())
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" wLC.service.id = :Service ");
			markers.add("Service");
			values.add(searchCriteria.getService().getID_Service());
			andStr = " and ";
		}
		
		if (searchCriteria.getFromDateIsNotNull())
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" wLC.startDate >= :dateFrom ");
			markers.add("dateFrom");
			DateTime fromDateTime = new DateTime(searchCriteria.getFromDate(), new Time(0, 0));
			values.add(fromDateTime.getJavaDate());
			andStr = " and ";
		}

		if (searchCriteria.getToDateIsNotNull())
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" wLC.endDate <= :dateTo ");
			markers.add("dateTo");
			DateTime toDateTime = new DateTime( searchCriteria.getToDate(), new Time(0, 0));
			values.add(toDateTime.getJavaDate());
			andStr = " and ";
		}
		
		if (searchCriteria.getActiveIsNotNull() && searchCriteria.getActive())
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" wLC.isActive = :Active ");
			markers.add("Active");
			values.add(Boolean.TRUE);
			andStr = " and ";
		}

		if (searchCriteria.getConsultantIsNotNull())
		{
			hql.append(" left join wLC.hCPs as hcps left join hcps.hCP as hcp");
			hqlConditions.append(andStr);
			hqlConditions.append(" hcp.id = :HCPId");
			markers.add("HCPId");
			values.add(searchCriteria.getConsultant().getID_Hcp());
			andStr = " and ";
		}
		
		if (searchCriteria.getHospitalIsNotNull())
		{
			hql.append(" left join wLC.listLocations as listLocs left join listLocs.listLocation as listLoc");
			hqlConditions.append(andStr);
			hqlConditions.append(" listLoc.id = :locId");
			markers.add("locId");
			values.add(searchCriteria.getHospital().getID());
			andStr = " and ";
		}
		
		if (hqlConditions.length() > 0)
		{
			hqlConditions.insert(0, " where (");
			hqlConditions.append(" ) ");
		}

		List<?> list = factory.find((hql.toString() + hqlConditions.toString() + "order by UPPER(wLC.waitingListName) asc ").toString(), markers, values);

		if (list == null || list.size() == 0)
			return null;

		return ElectiveListConfigurationVoAssembler.createElectiveListConfigurationVoCollectionFromElectiveListConfiguration(list);
	}

	public HcpLiteVoCollection listConsultants(String name)
	{
		if(name == null || (name != null && name.length() == 0))
			throw new DomainRuntimeException("Can not search on null name.");
		
		StringBuffer hqlConditions = new StringBuffer();

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		String hql = "select hcp from Hcp as hcp where hcp.isActive = 1 and (hcp.mos.name.upperSurname like :hcpSname or hcp.mos.name.upperForename like :hcpFname) ";
		markers.add("hcpSname");
		values.add(name.toUpperCase() + "%");
		
		markers.add("hcpFname");
		values.add(name.toUpperCase() + "%");
		
		DomainFactory factory = getDomainFactory();
		List<?> list = factory.find((hql + hqlConditions.toString() + " order by hcp.mos.name.upperSurname , hcp.mos.name.upperForename asc").toString(), markers, values);
		 
		if (list != null && list.size() > 0)
			return HcpLiteVoAssembler.createHcpLiteVoCollectionFromHcp(list);
			
		return null;
	}

	public Boolean existConfigurationWithSameName(String name, ElectiveListConfigurationRefVo waitingListConfigRef)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		StringBuffer hql = new StringBuffer("select wLC from ElectiveListConfiguration as wLC where wLC.isActive = 1 and wLC.waitingListName = :WaitingListName  ");
		markers.add("WaitingListName");
		values.add(name);
		
		if (waitingListConfigRef!=null && waitingListConfigRef.getID_ElectiveListConfigurationIsNotNull())
		{
			hql.append(" and wLC.id <> :WaitingListID");
			markers.add("WaitingListID");
			values.add(waitingListConfigRef.getID_ElectiveListConfiguration());
		}
		
		
		List <?> list = getDomainFactory().find(hql.toString(),markers,values);
		
		if (list!=null && list.size()>0)
			return true;
		
		return false;
	}

	public Boolean existConfigurationWithSameCode(String code, ElectiveListConfigurationRefVo waitingListConfigRef, Date startDate, Date endDate)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
	
		StringBuffer hql = new StringBuffer("select wLC from ElectiveListConfiguration as wLC where wLC.isActive = 1 and wLC.waitingListCode = :WaitingListCode ");
		markers.add("WaitingListCode");
		values.add(code);
	
		if (waitingListConfigRef!=null && waitingListConfigRef.getID_ElectiveListConfigurationIsNotNull())
		{
			hql.append(" and wLC.id <> :WaitingListID");
			markers.add("WaitingListID");
			values.add(waitingListConfigRef.getID_ElectiveListConfiguration());
		}
		
		if (startDate!=null && endDate!=null)
		{
			hql.append(" and ((wLC.startDate <= :StartDate and  wLC.endDate >= :StartDate ) or ( wLC.startDate <= :EndDate and wLC.endDate >= :EndDate) or (wLC.startDate >= :StartDate and wLC.endDate <= :EndDate) )");
			
			markers.add("StartDate");
			DateTime startDateTime = new DateTime(startDate, new Time(0, 0));
			values.add(startDateTime.getJavaDate());
			
			markers.add("EndDate");
			DateTime endDateTime = new DateTime(endDate, new Time(0, 0));
			values.add(endDateTime.getJavaDate());
		}
		else if (startDate!=null)
		{
			hql.append(" and (wLC.startDate <= :StartDate and  wLC.endDate >= :StartDate ) ");
			
			markers.add("StartDate");
			DateTime startDateTime = new DateTime(startDate, new Time(0, 0));
			values.add(startDateTime.getJavaDate());
		}
		
		
		List <?> list = getDomainFactory().find(hql.toString(),markers,values);
		
		if (list!=null && list.size()>0)
			return true;
		
		return false;
	}

	public Boolean isConsultantMarkedAsDefaultForSameServiceForOtherConfiguration(HcpRefVo consultantRef, ServiceForElectiveListConfigVo serviceVo, ElectiveListConfigurationRefVo waitingListConfigRef, Date startDate, Date endDate)
	{
		if (consultantRef==null || consultantRef.getID_Hcp()==null || serviceVo==null || serviceVo.getID_Service()==null)
		{
			throw new CodingRuntimeException("ConsultantRef and ServiceRef should not be null");
		}
		
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
	
		StringBuffer hql = new StringBuffer("select wLC from ElectiveListConfiguration as wLC left join wLC.hCPs as wLCC where wLC.isActive = 1 and wLCC.hCP.id = :hcp and wLCC.defaultForHCP=1 ");
		
		markers.add("hcp");
		values.add(consultantRef.getID_Hcp());
		
		if (serviceVo.getSpecialty()!=null)
		{
			hql.append(" and wLC.service.specialty.id=:Specialty ");
			markers.add("Specialty");
			values.add(serviceVo.getSpecialty().getID());
		}
		else
		{
			hql.append(" and wLC.service.id = :serv "); 
			markers.add("serv");
			values.add(serviceVo.getID_Service());
		}
			
		
		if (waitingListConfigRef!=null && waitingListConfigRef.getID_ElectiveListConfigurationIsNotNull())
		{
			hql.append(" and wLC.id <> :WaitingListID");
			markers.add("WaitingListID");
			values.add(waitingListConfigRef.getID_ElectiveListConfiguration());
		}
		
		if (startDate!=null && endDate!=null)
		{
			hql.append(" and ((wLC.startDate <= :StartDate and  wLC.endDate >= :StartDate ) or ( wLC.startDate <= :EndDate and wLC.endDate >= :EndDate) or (wLC.startDate >= :StartDate and wLC.endDate <= :EndDate) )");
			
			markers.add("StartDate");
			DateTime startDateTime = new DateTime(startDate, new Time(0, 0));
			values.add(startDateTime.getJavaDate());
			
			markers.add("EndDate");
			DateTime endDateTime = new DateTime(endDate, new Time(0, 0));
			values.add(endDateTime.getJavaDate());
		}
		else if (startDate!=null && endDate==null)
		{
			hql.append(" and (wLC.startDate <= :StartDate and  wLC.endDate >= :StartDate ) ");
			
			markers.add("StartDate");
			DateTime startDateTime = new DateTime(startDate, new Time(0, 0));
			values.add(startDateTime.getJavaDate());
		}
		
		
		List <?> list = getDomainFactory().find(hql.toString(),markers,values);
		
		if (list!=null && list.size()>0)
			return true;
		
		return false;
	}

	//WDEV-18499
	public Boolean canInactivateConfiguration(ElectiveListConfigurationRefVo configRef)
	{
		if (configRef == null)
		{
			throw new CodingRuntimeException("Cannot get Elective Lists on null configurationRef");
		}

		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer();

		hql.append(" SELECT COUNT(pel.id) FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS elConfig WHERE elConfig.id = :configID ");

		Object[] count = factory.find(hql.toString(), new String[] { "configID" }, new Object[] { configRef.getID_ElectiveListConfiguration() }).toArray();

		if (count != null && count.length > 0)
		{
			if (((Long) count[0]).intValue() == 0)
				return Boolean.FALSE;
		}

		return Boolean.TRUE;
	}

	
}
