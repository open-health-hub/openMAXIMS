//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Sean Nesbitt using IMS Development Environment (version 1.70 build 3338.27167)
// Copyright (C) 1995-2009 IMS MAXIMS plc. All rights reserved.

package ims.admin.domain.impl;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import ims.admin.domain.base.impl.BaseTaxonomyCodeAdminImpl;
import ims.admin.vo.Icd10AmProcVo;
import ims.admin.vo.Opcs4Vo;
import ims.admin.vo.TaxonomySnomedConWrdIdxVo;
import ims.admin.vo.TaxonomySnomedConWrdIdxVoCollection;
import ims.admin.vo.TaxonomySnomedConceptVo;
import ims.admin.vo.TaxonomySnomedConceptVoCollection;
import ims.admin.vo.TaxonomyUploadVo;
import ims.admin.vo.TaxonomyUploadVoCollection;

import ims.admin.vo.domain.Icd10AmProcVoAssembler;
import ims.admin.vo.domain.Opcs4VoAssembler;
import ims.admin.vo.domain.TaxonomySnomedConWrdIdxVoAssembler;
import ims.admin.vo.domain.TaxonomySnomedConceptVoAssembler;
import ims.admin.vo.domain.TaxonomyUploadVoAssembler;
import ims.core.admin.domain.objects.TaxonomyUpload;

import ims.configuration.gen.ConfigFlag;
import ims.configuration.EnvironmentConfig;
import ims.core.admin.vo.TaxonomyUploadRefVo;
import ims.core.clinical.coding.domain.objects.Opcs4;
import ims.core.clinical.coding.domain.objects.Icd10AmProc;
import ims.core.resource.people.domain.objects.Gp;
import ims.core.resource.place.domain.objects.CCGPCTPCCodes;
import ims.core.resource.place.domain.objects.LocSite;
import ims.core.resource.place.domain.objects.Organisation;
import ims.core.resource.place.vo.CCGPCTPCCodesRefVoCollection;
import ims.core.vo.AddressVo;
import ims.core.vo.CCGPCTPCCodesVo;
import ims.core.vo.CCGPCTPCCodesVoCollection;
import ims.core.vo.GpShortVo;
import ims.core.vo.GpShortVoCollection;
import ims.core.vo.GpVo;
import ims.core.vo.GpVoCollection;
import ims.core.vo.LocSiteUpprNameVo;
import ims.core.vo.LocSiteUpprNameVoCollection;
import ims.core.vo.OrgVo;
import ims.core.vo.OrgVoCollection;
import ims.core.vo.PostCodePcodeVo;
import ims.core.vo.TaxonomyMap;
import ims.core.vo.domain.CCGPCTPCCodesVoAssembler;
import ims.core.vo.domain.GpShortVoAssembler;
import ims.core.vo.domain.GpVoAssembler;
import ims.core.vo.domain.LocSiteUpprNameVoAssembler;
import ims.core.vo.domain.OrgVoAssembler;
import ims.core.vo.lookups.OrganisationType;
import ims.core.vo.lookups.PersonTitle;
import ims.core.vo.lookups.PersonTitleCollection;
import ims.core.vo.lookups.TaxonomyType;
//import ims.core.clinical.coding.domain.objects.snomed_concept;
import ims.domain.DbType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.lookups.LookupInstance;
import ims.framework.utils.Image;
import ims.framework.utils.ImagePath;
import ims.vo.LookupInstVo;
import ims.vo.LookupInstanceCollection;


public class TaxonomyCodeAdminImpl extends BaseTaxonomyCodeAdminImpl
{

	private static final long serialVersionUID = 1L;
	private Connection conn;
	private static File taxonomyLoadLogFile;
	private static FileWriter taxonmyLogout;
	
	int count =0;
	
	public void openLogFiles() 
	{
		//setup log file
		if (taxonmyLogout == null)
		{
			try {
				String tempDir = EnvironmentConfig.getBaseUri() + ConfigFlag.GEN.FILE_UPLOAD_DIR.getValue() + "/log";
				File flDir = new File(tempDir);
				if (!flDir.exists())
					flDir.mkdirs();
				taxonomyLoadLogFile = new File(tempDir + "/taxonmyLoad.log");
				if (!taxonomyLoadLogFile.exists())
					taxonomyLoadLogFile.createNewFile();
				taxonmyLogout = new FileWriter(taxonomyLoadLogFile);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		
	}

	public Icd10AmProcVo getIcd10Code(String code) throws DomainInterfaceException 
	{
		if(code == null || code.trim().length() == 0)
			return null;
		
		ims.admin.vo.Icd10AmProcVoCollection coll = Icd10AmProcVoAssembler.createIcd10AmProcVoCollectionFromIcd10AmProc(getDomainFactory().find("" +
				"from Icd10AmProc icd10 WHERE icd10.code_id = '" + code + "'"));
		
		if (coll != null && coll.size()>0)
			return coll.get(0);
		
		return null;

	}


	public Opcs4Vo getOpcs4Code(String code) throws DomainInterfaceException 
	{
		
		if(code == null || code.trim().length() == 0)
			return null;
		
		ims.admin.vo.Opcs4VoCollection coll = Opcs4VoAssembler.createOpcs4VoCollectionFromOpcs4(getDomainFactory().find("from Opcs4 opcs4 WHERE opcs4.opcode = '" + code + "'"));
		
		if (coll != null && coll.size()>0)
			return coll.get(0);
		
		return null;
	}


	public Icd10AmProcVo saveIcd10Record(Icd10AmProcVo vo) throws DomainInterfaceException, StaleObjectException, UniqueKeyViolationException 
	{
		if (!vo.isValidated())
		{
			throw new DomainRuntimeException("Opcs4 Vo has not been validated.");
		}
		
		DomainFactory factory = getDomainFactory();
		
		Icd10AmProc icd10ProcBo = Icd10AmProcVoAssembler.extractIcd10AmProc(factory, vo);
		
		if (vo.getID_Icd10AmProcIsNotNull())
		{
			//update
			factory.update(icd10ProcBo);
		}
		else
		{
			//insert
			factory.save(icd10ProcBo);
		}
		
		return Icd10AmProcVoAssembler.create(icd10ProcBo);

	}


	public Opcs4Vo saveOpcs4Record(Opcs4Vo vo) throws DomainInterfaceException, StaleObjectException, UniqueKeyViolationException 
	{
		if (!vo.isValidated())
		{
			throw new DomainRuntimeException("Opcs4 Vo has not been validated.");
		}
		
		DomainFactory factory = getDomainFactory();
		
		Opcs4 opcs4Bo = Opcs4VoAssembler.extractOpcs4(factory, vo);
		
		if (vo.getID_Opcs4IsNotNull())
		{
			//update
			factory.update(opcs4Bo);
		}
		else
		{
			//insert
			factory.save(opcs4Bo);
		}
		
		return Opcs4VoAssembler.create(opcs4Bo);

	}


	public TaxonomyUploadVo getCodeLoaderDef(TaxonomyUploadRefVo codeLoaderDefRef) throws DomainInterfaceException 
	{
		if(codeLoaderDefRef == null || codeLoaderDefRef.getBoId() == null)
			throw new DomainInterfaceException("Invalid TaxonomyUpload reference");
		
		return TaxonomyUploadVoAssembler.create((TaxonomyUpload)getDomainFactory().getDomainObject(codeLoaderDefRef));
	}


	public TaxonomyUploadVo getCodeLoaderDef(Integer externalCodeTypeId, Integer taxonomyElementId) throws DomainInterfaceException 
	{
		if(externalCodeTypeId == null)
			throw new DomainInterfaceException("Invalid TaxonomyUpload reference");
		
		DomainFactory factory = getDomainFactory();
		String hql = " from TaxonomyUpload as ct where ct.taxonomyCode = " + externalCodeTypeId + " and ct.taxonomyElement = " + taxonomyElementId;
		List taxMap = factory.find(hql);
		
		if (taxMap != null && taxMap.size() > 0)
			return TaxonomyUploadVoAssembler.create((TaxonomyUpload)taxMap.get(0));
		
		return null;
	}


	public TaxonomyUploadVoCollection listCodeLoaderDef() throws DomainInterfaceException 
	{
		// TODO Auto-generated method stub
		return null;
	}


	public TaxonomyUploadVo saveCodeLoaderDef(TaxonomyUploadVo codeLoaderDef) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException 
	{
		if (!codeLoaderDef.isValidated())
		{
			throw new DomainRuntimeException("Column Map VO has not been validated.");
		}
		
		DomainFactory factory = getDomainFactory();
		
		TaxonomyUpload tmBo = TaxonomyUploadVoAssembler.extractTaxonomyUpload(factory, codeLoaderDef);
		
		if (codeLoaderDef.getID_TaxonomyUploadIsNotNull())
		{
			//update
			factory.update(tmBo);
		}
		else
		{
			//insert
			factory.save(tmBo);
		}
		
		return TaxonomyUploadVoAssembler.create(tmBo);
	}

	public TaxonomySnomedConceptVo getSnomedConcept(String code) throws DomainInterfaceException 
	{
		if(code == null || code.trim().length() == 0)
			return null;
		
		TaxonomySnomedConceptVoCollection coll = TaxonomySnomedConceptVoAssembler.createTaxonomySnomedConceptVoCollectionFromsnomed_concept(getDomainFactory().find("from snomed_concept WHERE conceptid = '" + code + "'"));
		
		if (coll != null && coll.size()>0)
			return coll.get(0);
		
		return null;
	}

	public TaxonomySnomedConceptVo saveSnomedConceptRecord(TaxonomySnomedConceptVo snomedConceptVo) throws DomainInterfaceException, StaleObjectException, UniqueKeyViolationException 
	{
		if (!snomedConceptVo.isValidated())
		{
			throw new DomainRuntimeException("SnomedConcept Vo has not been validated.");
		}
		
		DomainFactory factory = getDomainFactory();
	
		// TODO code for update
		
		String l_specname = "";
		if (snomedConceptVo.getFullyspecifiednameIsNotNull())
		{			
			l_specname = snomedConceptVo.getFullyspecifiedname().replaceAll("'", "\\\\''");
		}
		
		String l_isPrimitive = "0";
		if (snomedConceptVo.getIsprimitiveIsNotNull())
			l_isPrimitive = snomedConceptVo.getIsprimitive().toString();

		String l_str_oracle = "";
		if (ConfigFlag.DBTYPE.equals(DbType.ORACLE))
			l_str_oracle = "hibernate_sequence.nextval,";
		
		//straight sql connection
		StringBuffer sql = new StringBuffer();
		sql.append("insert into core_snomed_concept values(")
			.append(l_str_oracle)
			.append("null,0,null,null,null,null,null,") //class 
			.append("'" + snomedConceptVo.getConceptid() + "'")
			.append(",")
			.append("'" + snomedConceptVo.getConceptstatus() + "'")
			.append(",")
			.append("'" + l_specname + "'")
			.append(",")
			.append("'" + snomedConceptVo.getCtv3id() + "'")
			.append(",")
			.append("'" + snomedConceptVo.getSnomedid() + "'")
			.append(",")			
			.append("'" + l_isPrimitive + "')");
			
		
		conn = factory.getJdbcConnection();
		
		try 
		{
			conn.createStatement().execute(sql.toString());
		}
		catch (SQLException e) 
		{
			throw new DomainRuntimeException(e.getMessage(),e);
		}			
		
		count++;
		if ( count % 100 == 0 ) {
			try {
				conn.commit();
			} catch (SQLException e) {
				throw new DomainRuntimeException(e.getMessage(),e);
			}
        }
		
		return snomedConceptVo;
		
		//snomed_concept snomedConcept = TaxonomySnomedConceptVoAssembler.extractsnomed_concept(factory, snomedConceptVo);
		
		//if (snomedConceptVo.getID_snomed_conceptIsNotNull())
		//{
			//update
			//factory.update(snomedConcept);
		//}
		//else
		//{
			//insert
			//factory.save(snomedConcept);
		//}
		
		//return TaxonomySnomedConceptVoAssembler.create(snomedConcept);
	}

	public TaxonomySnomedConWrdIdxVo saveSnomedConceptWrdIdx(TaxonomySnomedConWrdIdxVo vo) throws DomainInterfaceException, StaleObjectException 
	{
		if (!vo.isValidated())
		{
			throw new DomainRuntimeException("SnomedConceptWordIndex Vo has not been validated.");
		}			
		
		String l_str_oracle = "";
		if (ConfigFlag.DBTYPE.equals(DbType.ORACLE))
			l_str_oracle = "hibernate_sequence.nextval,";
		
		//straight sql connection
		StringBuffer sql = new StringBuffer();
		sql.append("insert into core_snomed_cwrdidx values(")
			.append(l_str_oracle)
			.append("null,0,null,null,null,null,null,") //class 
			.append("'" + vo.getKeyword() + "'")
			.append(",")
			.append("'" + vo.getConceptid() + "')");
		
		DomainFactory factory = getDomainFactory();	
		conn = factory.getJdbcConnection();;
			
		try 
		{
			conn.createStatement().execute(sql.toString());
		}
		catch (SQLException e) 
		{
			throw new DomainRuntimeException(e.getMessage(),e);
		}			
			
		count++;
		if ( count % 100 == 0 ) {
			try {
				conn.commit();
			} catch (SQLException e) {
				throw new DomainRuntimeException(e.getMessage(),e);
			}
        }
		
		return vo;
		
	}

	public TaxonomySnomedConWrdIdxVo getSnomedConceptWrdIdx(String keyword, String conceptId) throws DomainInterfaceException 
	{
		if(keyword == null || keyword.trim().length() == 0)
			return null;

		if(conceptId == null)
			return null;
		
		TaxonomySnomedConWrdIdxVoCollection coll = TaxonomySnomedConWrdIdxVoAssembler.createTaxonomySnomedConWrdIdxVoCollectionFromsnomed_concept_wordindex(
				getDomainFactory().find("from snomed_concept_wordindex sn WHERE sn.keyword = '" + keyword + "' and sn.conceptid = '" + conceptId + "'"));
		
		if (coll != null && coll.size()>0)
			return coll.get(0);
		
		return null;
	}

	public void deleteSnomedConceptWrdIdx() throws DomainInterfaceException 
	{
		StringBuffer sql = new StringBuffer();
		sql.append("delete from core_snomed_cwrdidx");
		
		DomainFactory factory = getDomainFactory();	
		conn = factory.getJdbcConnection();;
			
		try 
		{
			conn.createStatement().execute(sql.toString());
		}
		catch (SQLException e) 
		{
			throw new DomainRuntimeException(e.getMessage(),e);
		}			

	}


	public OrgVo savePracticeRecord(OrgVo vo) throws DomainInterfaceException,
			StaleObjectException, UniqueKeyViolationException {
		
		if (!vo.isValidated())
		{
			throw new DomainRuntimeException("OrgVo Vo has not been validated.");
		}
		
		DomainFactory factory = getDomainFactory();
		
		//Opcs4 opcs4Bo = Opcs4VoAssembler.extractOpcs4(factory, vo);
		
		Organisation orgBo = OrgVoAssembler.extractOrganisation(factory, vo);

		factory.save(orgBo);

		return OrgVoAssembler.create(orgBo);
				
	}
	
	public OrgVo getPracticeCode(String code) throws DomainInterfaceException {
		
		if(code == null || code.trim().length() == 0)
			return null;
		
		//OrgVoCollection coll= OrgVoAssembler.createOrgVoCollectionFromOrganisation(getDomainFactory().find("from Organisation as o1_1 left join o1_1.codeMappings as t1_1 left join t1_1.taxonomyName as l1_1 where  l1_1.id = -828 and t1_1.taxonomyCode = ") 
//" ));
			
		ArrayList names = new ArrayList();
		ArrayList values = new ArrayList();
			
		StringBuffer taxonomyHql = new StringBuffer(" select distinct org from Organisation org join org.codeMappings as mappings" +
						" where mappings.taxonomyName = :taxonomyType and mappings.taxonomyCode = :taxonomyCode and org.type = :gpPractice");
			
		names.add("taxonomyType");
		names.add("taxonomyCode");
		names.add("gpPractice");
		
		values.add(getDomLookup(TaxonomyType.NAT_LOC_CODE));
		values.add(code);
		values.add(getDomLookup(OrganisationType.GPP));
		
		OrgVoCollection  coll = OrgVoAssembler.createOrgVoCollectionFromOrganisation(getDomainFactory().find(taxonomyHql.toString(), names, values));
		
		if (coll != null && coll.size()>0)
			return coll.get(0);
		
		return null;
		
	}

	
	public GpVo saveGPRecord(GpVo vo) throws DomainInterfaceException,
			StaleObjectException, UniqueKeyViolationException 
	{
		
		if (!vo.isValidated())
		{
			throw new DomainRuntimeException("GpVo Vo has not been validated.");
		}
		
		DomainFactory factory = getDomainFactory();			
		
		Gp gpBo = GpVoAssembler.extractGp(factory, vo);
		
		factory.save(gpBo);
		
		return GpVoAssembler.create(gpBo);
		
	}

	
	public GpVo getGPCode(String code) throws DomainInterfaceException
	{
		if(code == null || code.trim().length() == 0)
			return null;
				
		ArrayList names = new ArrayList();
		ArrayList values = new ArrayList();
			
		StringBuffer taxonomyHql = new StringBuffer(" select distinct gp from Gp gp join gp.codeMappings as mappings" +
						" where mappings.taxonomyName = :taxonomyType and mappings.taxonomyCode = :taxonomyCode");
			
		names.add("taxonomyType");
		names.add("taxonomyCode");
				
		values.add(getDomLookup(TaxonomyType.NAT_GP_CODE));
		values.add(code);
				
		GpVoCollection  coll = GpVoAssembler.createGpVoCollectionFromGp(getDomainFactory().find(taxonomyHql.toString(), names, values));
		
		if (coll != null && coll.size()>0)
			return coll.get(0);
		
	
		return null;
	}

	
	public PersonTitle getLkpPersonTitle(String text)
			throws DomainInterfaceException 
	{
		// TODO Auto-generated method stub
		ArrayList names = new ArrayList();
		ArrayList values = new ArrayList();
			
		StringBuffer taxonomyHql = new StringBuffer(" select l1_1 from LookupInstance as l1_1 where  (l1_1.type.id = :lookupType and l1_1.active = :isActive and (upper(l1_1.text) = :lkptext or upper(l1_1.text) = :lkptextdot))"); 
		
		names.add("lookupType");								
		names.add("lkptext");
		names.add("lkptextdot");
		names.add("isActive");
		
		values.add(PersonTitle.TYPE_ID);					
		if(text.endsWith("."))
			{
				values.add(text.substring(0, text.length()-1).toUpperCase());
			}
		else			
		{
			values.add(text.toUpperCase());			
		}
		values.add(text.concat(".").toUpperCase());	
		values.add(true);
		
		List <LookupInstance> list = getDomainFactory().find(taxonomyHql.toString(), names, values);
				
		if (list != null && list.size()>0)	
		{
			
			LookupInstance element=list.get(0);
			
			Image img = null;
			Image regImage = element.getImage();
			if (regImage != null)
			{
				img = new ImagePath(regImage.getImageId(), regImage.getImagePath());
			}
			
			LookupInstVo valueObject = new LookupInstVo(element.getId(), element.getText(), element.isActive(), null, img, element.getColor(), element.getOrder());
					
			PersonTitle t=new PersonTitle();
			t.setId(valueObject.getId());
			
			return t;
		}	
		else
		{
			throw new DomainInterfaceException("A Person Title with text Dr is required to import the Gp file");
		}
		
	}

	
	public LocSiteUpprNameVo saveSurgeryRecord(LocSiteUpprNameVo surgery)
			throws DomainInterfaceException, StaleObjectException,
			UniqueKeyViolationException 	
	{
		
		if (!surgery.isValidated())
		{
			throw new DomainRuntimeException("LocSiteUpprNameVo Vo has not been validated.");
		}
		
		DomainFactory factory = getDomainFactory();			
		
		LocSite locSiteBo = LocSiteUpprNameVoAssembler.extractLocSite(factory, surgery);
		
		factory.save(locSiteBo);
		
		return LocSiteUpprNameVoAssembler.create(locSiteBo);			
	}

	
	public LocSiteUpprNameVo getSurgeryCode(String code)
			throws DomainInterfaceException 
	{
		// TODO Auto-generated method stub
		
		if(code == null || code.trim().length() == 0)
			return null;
				
		ArrayList names = new ArrayList();
		ArrayList values = new ArrayList();
			
		StringBuffer taxonomyHql = new StringBuffer(" select distinct locSite from LocSite locSite join locSite.codeMappings as mappings" +
						" where mappings.taxonomyName = :taxonomyType and mappings.taxonomyCode = :taxonomyCode");
			
		names.add("taxonomyType");
		names.add("taxonomyCode");
				
		values.add(getDomLookup(TaxonomyType.PAS));
		values.add(code);
				
		LocSiteUpprNameVoCollection  coll = LocSiteUpprNameVoAssembler.createLocSiteUpprNameVoCollectionFromLocSite(getDomainFactory().find(taxonomyHql.toString(), names, values));
		
		if (coll != null && coll.size()>0)
			return coll.get(0);
		
			
		return null;
	}

	
	public LocSiteUpprNameVo getSurgery(AddressVo address, OrgVo parent_org)throws DomainInterfaceException {
		// TODO Auto-generated method stub
						
		ArrayList names = new ArrayList();
		ArrayList values = new ArrayList();
			
		StringBuffer taxonomyHql = new StringBuffer("select l1_1 from LocSite as l1_1 " +
				"left join l1_1.parentOrganisation as o1_1 " +
				"where  (o1_1.id is null  " );
		if(address.getLine1().length()==0)
		{
			taxonomyHql.append("and l1_1.address.line1 is null ");
		}
		else
		{
			taxonomyHql.append("and l1_1.address.line1 = :addressline1 ");
			names.add("addressline1");									
			values.add(address.getLine1());
			
		}
			
		if(address.getLine2().length()==0)
		{
			taxonomyHql.append("and l1_1.address.line2 is null ");
		}
		else
		{
			taxonomyHql.append("and l1_1.address.line2 = :addressline2 ");
			names.add("addressline2");									
			values.add(address.getLine2());
		}
			
		if(address.getLine3().length()==0)
		{
			taxonomyHql.append("and l1_1.address.line3 is null ");
		}
		else
		{
			taxonomyHql.append("and l1_1.address.line3 = :addressline3 ");
			names.add("addressline3");									
			values.add(address.getLine3());
		}
				
		if(address.getLine4().length()==0)
		{
			taxonomyHql.append("and l1_1.address.line4 is null ");
		}
		else
		{
			taxonomyHql.append("and l1_1.address.line4 = :addressline4 ");
			names.add("addressline4");									
			values.add(address.getLine4());
		}
		if(address.getLine5().length()==0)
		{
			taxonomyHql.append("and l1_1.address.line5 is null ");
		}
		else
		{
			taxonomyHql.append("and l1_1.address.line5 = :addressline5 ");
			names.add("addressline5");									
			values.add(address.getLine5());
		}
				
		if(address.getPostCode().length()==0)
		{
			taxonomyHql.append("and l1_1.address.postCode is null )");
		}
		else
		{
			taxonomyHql.append("and l1_1.address.postCode = :postcode )");
			names.add("postcode");	
			values.add(address.getPostCode());
		}		
				
		
		/*names.add("addressline1");
		names.add("addressline2");
		names.add("addressline3");
		names.add("addressline4");
		names.add("addressline5");
		names.add("postcode");		
		//names.add("org_null");
				
		
		values.add(address.getLine1());
		values.add(address.getLine2());
		values.add(address.getLine3());
		values.add(address.getLine4());
		values.add(address.getLine5());
		values.add(address.getPostCode());
		//values.add(parent_org.getID_Organisation());*/
				
		LocSiteUpprNameVoCollection  coll = LocSiteUpprNameVoAssembler.createLocSiteUpprNameVoCollectionFromLocSite(getDomainFactory().find(taxonomyHql.toString(), names, values));
		
		if (coll != null && coll.size()>0)
			return coll.get(0);
		
		return null;
	}

	public PostCodePcodeVo getPcode(String postcode) 
	{
		//TODO
		//PostCodePcodeVoCollection coll = PostCodePcodeVoAssembler.createTaxonomySnomedConceptVoCollectionFromsnomed_concept(getDomainFactory().find("from snomed_concept WHERE conceptid = '" + code + "'"));
		
		return null;
	}

	public void savePcode(PostCodePcodeVo pcodeVo) throws DomainInterfaceException, StaleObjectException 
	{
		
	}

	public CCGPCTPCCodesVo saveCCGRecord(CCGPCTPCCodesVo ccgVO)
			throws DomainInterfaceException, StaleObjectException,
			UniqueKeyViolationException 
	{
		if (!ccgVO.isValidated())
		{
			throw new DomainRuntimeException("ccgVO has not been validated.");
		}
		
		String l_str_oracle = "";
		if (ConfigFlag.DBTYPE.equals(DbType.ORACLE))
			l_str_oracle = "hibernate_sequence.nextval,";
		
		//stripout spaces
		String str = ccgVO.getPostcode().replace(" ", "");
		ccgVO.setPostcode(str);
		
		
		//straight sql connection
		StringBuffer sql = new StringBuffer();
		if (ccgVO.getID_CCGPCTPCCodesIsNotNull())
		{
			//prep update
			sql.append("update core_ccgpctpccodes set ccgcode = ")
			.append("'" + ccgVO.getCCGCode() + "', postcode = '")
			.append(ccgVO.getPostcode() + "', sys_lastupdate_datetime = GETDATE()")
			.append("where id = " + ccgVO.getID_CCGPCTPCCodes());			
		}
		else
		{
			sql.append("insert into core_ccgpctpccodes values(")
				.append(l_str_oracle)
				.append("null,0,null,GETDATE(),null,'MAXIMS',null,") //class 
				.append("'" + ccgVO.getCCGCode()+ "'")
				.append(",null" + ",'")
				.append(ccgVO.getDHACode() + "',")
				.append("'" + ccgVO.getPostcode() + "')");
		}
		
		DomainFactory factory = getDomainFactory();	
		conn = factory.getJdbcConnection();;
			
		try 
		{ 
			conn.createStatement().execute(sql.toString());
		}
		catch (SQLException e) 
		{
			throw new DomainRuntimeException(e.getMessage(),e);
		}			
			
		count++;
		if ( count % 100 == 0 ) {
			try {
				conn.commit();
			} catch (SQLException e) {
				throw new DomainRuntimeException(e.getMessage(),e);
			}
        }
		
		return ccgVO;
		
	}

	public CCGPCTPCCodesVo getCCGRecord(String postcode) 
	{
		if(postcode == null || postcode.trim().length() == 0)
			return null;
		
		//stripout spaces
		String str = postcode.replace(" ", "");
		
		StringBuffer sql = new StringBuffer();
		sql.append(" select c.id,c.class,c.vstp,c.rie,c.sys_creation_datetime," +
				"sys_creation_user,c.sys_lastupdate_user," +
				"c.ccgcode,c.ccgdescrip,c.dhacode,c.postcode from core_ccgpctpccodes c where postcode = ")
		.append("'" + str +"'");
			
		DomainFactory factory = getDomainFactory();		
		Connection conn = factory.getJdbcConnection();
		ResultSet rs;
		CCGPCTPCCodesVo vo = null;
		try 
		{
			rs = conn.createStatement().executeQuery(sql.toString());
			if(rs.next())
			{
				vo = new CCGPCTPCCodesVo();
				vo.setID_CCGPCTPCCodes(new Integer(rs.getString("id")));
				vo.setCCGCode(rs.getString("ccgcode"));
				vo.setCCGDescription(rs.getString("ccgdescrip"));
				vo.setDHACode(rs.getString("dhacode"));
				//vo.setIsRIE(rs.getString("rie")); not needed
				vo.setPostcode(rs.getString("postcode"));
			}
			else
			{
				if (rs != null)
					rs.close();
				return null;
			}
			if (rs != null)
				rs.close();
		}
		catch (SQLException e) 
		{
			throw new DomainRuntimeException(e.getMessage(),e);
		}
		
		return vo;
	}
}
