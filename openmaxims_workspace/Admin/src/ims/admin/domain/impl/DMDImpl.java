//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Marius Mihalec using IMS Development Environment (version 1.65 build 3223.30681)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.admin.domain.impl;

import java.util.List;

import ims.admin.domain.base.impl.BaseDMDImpl;
import ims.clinical.configuration.domain.objects.VMP;
import ims.clinical.configuration.domain.objects.VTM;
import ims.clinical.configuration.domain.objects.VTMHotlist;
import ims.clinical.configuration.vo.VMPRefVo;
import ims.clinical.configuration.vo.VTMRefVo;
import ims.clinical.vo.AMPVoCollection;
import ims.clinical.vo.VMPVo;
import ims.clinical.vo.VMPVoCollection;
import ims.clinical.vo.VTMVo;
import ims.clinical.vo.domain.AMPVoAssembler;
import ims.clinical.vo.domain.VMPVoAssembler;
import ims.clinical.vo.domain.VTMVoAssembler;
import ims.clinical.vo.enums.DMDType;
import ims.clinicaladmin.vo.VTMHotlistItemVo;
import ims.clinicaladmin.vo.VTMHotlistItemVoCollection;
import ims.clinicaladmin.vo.VTMHotlistVo;
import ims.clinicaladmin.vo.domain.VTMHotlistVoAssembler;
import ims.core.vo.lookups.Specialty;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.vo.interfaces.IDMDValue;

public class DMDImpl extends BaseDMDImpl
{  
	private static final long serialVersionUID = 1L;

	public VMPVo getVMP(VMPRefVo vmp) throws DomainInterfaceException 
	{
		if(vmp == null || vmp.getBoId() == null)
			throw new DomainInterfaceException("Invalid VMP reference");
		
		return VMPVoAssembler.create((VMP)getDomainFactory().getDomainObject(vmp));
	}
	public VTMVo getVTM(VTMRefVo vtm) throws DomainInterfaceException 
	{
		if(vtm == null || vtm.getBoId() == null)
			throw new DomainInterfaceException("Invalid VTM reference");
		
		return VTMVoAssembler.create((VTM)getDomainFactory().getDomainObject(vtm));
	}	
	public IDMDValue[] searchAMP(IDMDValue vmp) throws DomainInterfaceException 
	{
		if(vmp == null || vmp.getIDMDValueId() == null || vmp.getIDMDValueType() != DMDType.VMP)
			throw new DomainInterfaceException("Invalid VMP reference");
		
		AMPVoCollection result = AMPVoAssembler.createAMPVoCollectionFromAMP(getDomainFactory().find("from AMP vm WHERE vm.vMP.id = " + vmp.getIDMDValueId()));
		if(result != null)
			return result.toIDMDValueArray();
		return new IDMDValue[] {};
	}
	public IDMDValue[] searchVMP(IDMDValue vtm) throws DomainInterfaceException 
	{
		if(vtm == null || vtm.getIDMDValueId() == null || vtm.getIDMDValueType() != DMDType.VTM)
			throw new DomainInterfaceException("Invalid VMP reference");
		
		VMPVoCollection result = VMPVoAssembler.createVMPVoCollectionFromVMP(getDomainFactory().find("from VMP vm WHERE vm.vTM.id = " + vtm.getIDMDValueId()));
		if(result != null)
			return result.toIDMDValueArray();
		return new IDMDValue[] {};
	}
	@SuppressWarnings("unchecked")
	private VTMHotlistVo getHotlist(Specialty specialty)
	{
		if(specialty == null)
			throw new CodingRuntimeException("Invalid specialty");
		
		DomainFactory factory = getDomainFactory();		
		String hql = " from VTMHotlist as h where h.specialty.id = " + specialty.getID();
		List hotlists = factory.find(hql);
		
		VTMHotlist hotlist = null;
		if(hotlists != null && hotlists.size() == 1)
		{
			hotlist = (VTMHotlist)hotlists.get(0);
		}
		
		return hotlist == null ? new VTMHotlistVo() : VTMHotlistVoAssembler.create(hotlist); 
	}
	public void addToHotlist(Specialty specialty, VTMVo vtm) throws StaleObjectException 
	{
		if(specialty == null)
			throw new CodingRuntimeException("Invalid specialty");
		if(vtm == null || vtm.getBoId() == null)
			throw new CodingRuntimeException("Invalid VTM");
		
		DomainFactory factory = getDomainFactory();
		VTMHotlistVo hotlistVo = getHotlist(specialty);
		
		hotlistVo.setSpecialty(specialty);
		if(hotlistVo.getHotListItem() == null)
			hotlistVo.setHotListItem(new VTMHotlistItemVoCollection());
		
		VTMHotlistItemVo item = new VTMHotlistItemVo();
		item.setVTM(vtm);
		
		for(int x = 0; x < hotlistVo.getHotListItem().size(); x++)
		{
			VTMHotlistItemVo existingItem = hotlistVo.getHotListItem().get(x);
			if(existingItem != null && existingItem.equals(vtm))
				return;
		}
		
		hotlistVo.getHotListItem().add(item);
			
		factory.save(VTMHotlistVoAssembler.extractVTMHotlist(factory, hotlistVo));
	}
	public void removeFromHotlist(Specialty specialty, VTMRefVo vtm)  throws StaleObjectException 
	{
		if(vtm == null || vtm.getBoId() == null)
			throw new CodingRuntimeException("Invalid VTM");
		
		DomainFactory factory = getDomainFactory();
		VTMHotlistVo hotlistVo = getHotlist(specialty);
		
		if(hotlistVo.getHotListItem() == null || hotlistVo.getHotListItem().size() == 0)
			return;
		
		boolean found = false;
		for(int x = 0; x < hotlistVo.getHotListItem().size(); x++)
		{
			VTMHotlistItemVo existingItem = hotlistVo.getHotListItem().get(x);
			if(existingItem != null && existingItem.getVTMIsNotNull() && existingItem.getVTM().getID_VTM().equals(vtm.getID_VTM()))
			{
				found = true;
				hotlistVo.getHotListItem().remove(x);
				break;
			}
		}
		
		if(!found)
			return;
		
		factory.save(VTMHotlistVoAssembler.extractVTMHotlist(factory, hotlistVo));
	}
}
