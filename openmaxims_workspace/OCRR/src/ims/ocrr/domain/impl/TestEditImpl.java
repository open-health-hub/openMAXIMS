//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Vasile Purdila using IMS Development Environment (version 1.30 build 2012.21169)
// Copyright (C) 1995-2005 IMS MAXIMS plc. All rights reserved.

package ims.ocrr.domain.impl;

import ims.core.resource.place.domain.objects.Activity;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.TaxonomyMap;
import ims.core.vo.domain.ActivityVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.TaxonomyMapAssembler;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.domain.impl.DomainImpl;
import ims.domain.lookups.LookupInstance;
import ims.framework.exceptions.CodingRuntimeException;
import ims.ocrr.configuration.domain.objects.InvSynonym;
import ims.ocrr.configuration.domain.objects.Investigation;
import ims.ocrr.configuration.domain.objects.InvestigationIndex;
import ims.ocrr.configuration.vo.InvestigationIndexRefVo;
import ims.ocrr.domain.TestList;
import ims.ocrr.helper.TemplateAndProfileConflict;
import ims.ocrr.vo.InvestigationIndexShortVoCollection;
import ims.ocrr.vo.InvestigationIndexVo;
import ims.ocrr.vo.InvestigationQuestionVoCollection;
import ims.ocrr.vo.InvestigationShortVo;
import ims.ocrr.vo.InvestigationVo;
import ims.ocrr.vo.LocSvcProviderSysVoCollection;
import ims.ocrr.vo.OrderEntryTemplateShortVoCollection;
import ims.ocrr.vo.PathSpecimenContainerDetailVoCollection;
import ims.ocrr.vo.SecurityLevelConfigVoCollection;
import ims.ocrr.vo.domain.InvestigationIndexShortVoAssembler;
import ims.ocrr.vo.domain.InvestigationIndexVoAssembler;
import ims.ocrr.vo.domain.InvestigationVoAssembler;
import ims.ocrr.vo.domain.LocSvcProviderSysVoAssembler;
import ims.ocrr.vo.domain.OrderEntryTemplateShortVoAssembler;
import ims.ocrr.vo.domain.PathSpecimenContainerDetailVoAssembler;
import ims.ocrr.vo.domain.SecurityLevelConfigVoAssembler;
import ims.ocrr.vo.lookups.Category;
import ims.ocrr.vo.lookups.SpecimenSiteCollection;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class TestEditImpl extends DomainImpl implements ims.ocrr.domain.TestEdit, ims.domain.impl.Transactional
{
	private static final long	serialVersionUID	= 1L;

	/**
	 * saveInvestigationIndexRecord
	 * 
	 * @throws UniqueKeyViolationException
	 */
	public InvestigationIndexVo saveInvestigationIndexRecord(InvestigationIndexVo voInvestigationIndex, Integer idInvestigation, InvestigationQuestionVoCollection voCollInvQuestionToRemove) throws StaleObjectException, DomainInterfaceException, UniqueKeyViolationException
	{
		DomainFactory factory = getDomainFactory();

		if (voInvestigationIndex.isValidated() == false)
			throw new DomainRuntimeException("InvestigationIndexVo not validated");

		// Duplicate investigation names not allowed
		List duplicates;
		if (voInvestigationIndex.getID_InvestigationIndexIsNotNull())
		{
			String hql = " from InvestigationIndex where name = :name  and id != :id";
			duplicates = factory.find(hql, new String[]{"name", "id"}, new Object[]{voInvestigationIndex.getName(), voInvestigationIndex.getID_InvestigationIndex()});
		}
		else
		{
			String hql = " from InvestigationIndex where name = :name";
			duplicates = factory.find(hql, new String[]{"name"}, new Object[]{voInvestigationIndex.getName()});
		}
		if (duplicates != null && duplicates.size() > 0)
			throw new DomainInterfaceException("This name has already been assigned to an existing investigation or profile");
		
		// WDEV-2053 Not allowed to mark exiting active investigation records as
		// inactive if they are associated with an active profile or active
		// template/orderset within a template
		checkTemplatesAndProfiles(idInvestigation, voInvestigationIndex, factory);

		// go through investigations doing a list from investigation for
		// providerservice and inv code
		for (int i = 0; i < voInvestigationIndex.getInvestigations().size(); i++)
		{
			boolean isPathology = voInvestigationIndex.getInvestigations().get(i).getInvestigationIndex().getCategory().equals(Category.PATHOLOGY);
			boolean isSite = voInvestigationIndex.getInvestigations().get(i).getInvestigationIndex().getRequiresSiteSpecifierIsNotNull() && voInvestigationIndex.getInvestigations().get(i).getInvestigationIndex().getRequiresSiteSpecifier().equals(Boolean.TRUE);
			boolean addOn = voInvestigationIndex.getInvestigations().get(i).getIsAddonIsNotNull() && voInvestigationIndex.getInvestigations().get(i).getIsAddon().booleanValue();

			// if saving active inv
			if (voInvestigationIndex.getInvestigations().get(i).getActiveStatus().equals(PreActiveActiveInactiveStatus.ACTIVE))
			{
				//WDEV-5847 - don't do this validation for Inv's of the new category 'CLINICAL'
				if(voInvestigationIndex.getInvestigations().get(i).getProviderService() == null)
					continue;
				
				// check 1
				// if creating an addon ensure that no inv record exists having
				// the same provider service and inv code
				if (addOn)
				{
					ArrayList markers = new ArrayList();
					ArrayList values = new ArrayList();

					String hql = "select count(inv.investigationIndex.id)" + " from Investigation as inv left join inv.investigationIndex as invIndex " +
					" where inv.providerService.id = :idProviderService and inv.providerInvCode = :provInvCode and inv.activeStatus = :status";

					markers.add("idProviderService");
					values.add(voInvestigationIndex.getInvestigations().get(i).getProviderService().getID_LocSvcProviderSys());
					markers.add("provInvCode");
					values.add(voInvestigationIndex.getInvestigations().get(i).getProviderInvCode());
					markers.add("status");
					values.add(getDomLookup(PreActiveActiveInactiveStatus.ACTIVE));

					if (voInvestigationIndex.getID_InvestigationIndexIsNotNull())
					{
						markers.add("invIndexId");
						values.add(voInvestigationIndex.getID_InvestigationIndex());
						hql += " and inv.investigationIndex.id != :invIndexId";
					}

					List count = factory.find(hql, markers, values);

					if (count != null && count.get(0) != null)
					{
						if (count.get(0) instanceof Integer)
						{
							Integer iCount = (Integer) count.get(0);
							if (iCount.intValue() > 0)
								throw new DomainInterfaceException("An active investigation using this Provider System Inv. Code exists for this Provider Service");
						}
						else if (count.get(0) instanceof Long)
						{
							Long lCount = (Long) count.get(0);
							if (lCount.intValue() > 0)
								throw new DomainInterfaceException("An active investigation using this Provider System Inv. Code exists for this Provider Service");
						}
					}
				}
				else if (isSite)
				{
					// check 2
					// if creating a site inv ensure that no inv record exists
					// having the same provider service and inv code
					// where any inv sites exist for the collection of sites
					// being saved or an existing inv has no sites or an addon
					// inv exists

					String siteIds = getSiteIdString(voInvestigationIndex.getSites());
					if (siteIds != null)
					{
						// WDEV-2618 - make sure site and inv code havent been
						// used before
						ArrayList markers = new ArrayList();
						ArrayList values = new ArrayList();

						String hql = "select count(inv.investigationIndex.id)" + " from Investigation as inv left join inv.investigationIndex as invIndex left join invIndex.sites as site left join site.instance as inst" + " where (inv.providerService.id = :idProviderService and inv.providerInvCode = :provInvCode and inv.activeStatus = :status and ( " + 
						" inst.id in " + siteIds + " or (invIndex.requiresSiteSpecifier is false or inv.isAddon is true))) ";

						markers.add("idProviderService");
						values.add(voInvestigationIndex.getInvestigations().get(i).getProviderService().getID_LocSvcProviderSys());
						markers.add("provInvCode");
						values.add(voInvestigationIndex.getInvestigations().get(i).getProviderInvCode());
						markers.add("status");
						values.add(getDomLookup(PreActiveActiveInactiveStatus.ACTIVE));

						if (voInvestigationIndex.getID_InvestigationIndexIsNotNull())
						{
							markers.add("invIndexId");
							values.add(voInvestigationIndex.getID_InvestigationIndex());
							hql += " and inv.investigationIndex.id != :invIndexId";
						}

						List count = factory.find(hql, markers, values);

						if (count != null && count.get(0) != null)
						{
							if (count.get(0) instanceof Integer)
							{
								Integer iCount = (Integer) count.get(0);
								if (iCount.intValue() > 0)
									throw new DomainInterfaceException("An active Investigation using this Provider System Inv. Code and Provider Service either using a selected Site or not requiring a Site exists");
							}
							else if (count.get(0) instanceof Long)
							{
								Long lCount = (Long) count.get(0);
								if (lCount.intValue() > 0)
									throw new DomainInterfaceException("An active Investigation using this Provider System Inv. Code and Provider Service either using a selected Site or not requiring a Site exists");
							}
						}
					}
				}

				//check 3 was removed as per WDEV-16274

				if (!isSite)
				{
					// check 4
					// if we are creating a record that doesnt require site and
					// its not an addon and it is pathology
					// ensure that no records exist where specimetype is equal
					// and is addon = true
					String hql = "select inv from Investigation inv left join inv.pathInvDetails path left join path.specimens as spec left join inv.investigationIndex idx where inv.providerService.id = :idProviderService and inv.providerInvCode = :invCode and inv.activeStatus = :activeStatus ";
					ArrayList markers = new ArrayList();
					ArrayList values = new ArrayList();

					markers.add("idProviderService");
					markers.add("invCode");
					markers.add("activeStatus");

					values.add(voInvestigationIndex.getInvestigations().get(i).getProviderService().getID_LocSvcProviderSys());
					values.add(voInvestigationIndex.getInvestigations().get(i).getProviderInvCode());
					values.add(getDomLookup(PreActiveActiveInactiveStatus.ACTIVE));

					if (isPathology)
					{
						if (!addOn)
						{
							hql += " and ( spec.type = :specType or inv.isAddon is true ) ";
							markers.add("specType");
							values.add(getDomLookup(voInvestigationIndex.getInvestigations().get(i).getPathInvDetails().getSpecimens().get(0).getType()));
						}

						hql += " and idx.requiresSiteSpecifier is false ";
					}

					// to make sure we are not testing the validity of the
					// current record if it has been saved before
					if (voInvestigationIndex.getInvestigations().get(i).getID_InvestigationIsNotNull())
					{
						hql += " and inv.id != :currentInvId";
						markers.add("currentInvId");
						values.add(voInvestigationIndex.getInvestigations().get(i).getID_Investigation());
					}

					List invs = factory.find(hql, markers, values);

					if (invs != null && invs.size() > 0)
						throw new DomainInterfaceException("An active Investigation (" + ((Investigation) invs.get(0)).getInvestigationIndex().getName() + ") using this Provider Service and Provider System Inv. Code  already exists");

				}

				// check 5
				// if we are creating a pathology inv ensure that no active inv
				// exists where the provider service and
				// inv code are equal and if the record to be saved requires
				// sites check all saved inv's where requires site equals false
				// and vice versa
				if (isPathology)
				{
					String hql = "select inv from Investigation inv left join inv.pathInvDetails path join inv.investigationIndex idx where inv.providerService.id = :idProviderService and inv.activeStatus = :activeStatus and inv.providerInvCode = :invCode";
					ArrayList markers = new ArrayList();
					ArrayList values = new ArrayList();

					markers.add("idProviderService");
					markers.add("activeStatus");
					markers.add("invCode");

					values.add(voInvestigationIndex.getInvestigations().get(i).getProviderService().getID_LocSvcProviderSys());
					values.add(getDomLookup(PreActiveActiveInactiveStatus.ACTIVE));
					values.add(voInvestigationIndex.getInvestigations().get(i).getProviderInvCode());

					if (isSite)
						hql += " and idx.requiresSiteSpecifier is false ";
					else
						hql += " and idx.requiresSiteSpecifier is true ";

					// to make sure we are not testing the validity of the
					// current record if it has been saved before
					if (voInvestigationIndex.getInvestigations().get(i).getID_InvestigationIsNotNull())
					{
						hql += " and inv.id != :currentInvId";
						markers.add("currentInvId");
						values.add(voInvestigationIndex.getInvestigations().get(i).getID_Investigation());
					}

					List invs = factory.find(hql, markers, values);

					if (invs != null && invs.size() > 0)
					{
						String strMessage = "An active Investigation (" + ((Investigation) invs.get(0)).getInvestigationIndex().getName() + ") using this Provider Service and Provider Inv. Code ";
						if (isSite)
						{
							strMessage += "without site specifier already exists";
						}
						else
						{
							strMessage += "with site specifier already exists";
						}

						throw new DomainInterfaceException(strMessage);
					}
				}
			}
		}
		Activity doActivity = ActivityVoAssembler.extractActivity(factory, voInvestigationIndex.getActivity());
		InvestigationIndex doInvestigationIndex = InvestigationIndexVoAssembler.extractInvestigationIndex(factory, voInvestigationIndex);

		//WDEV-5893
		doInvestigationIndex.getTaxonomyMap().clear();
		List lst = TaxonomyMapAssembler.extractTaxonomyMapList(factory, voInvestigationIndex.getTaxonomyMap());
		doInvestigationIndex.setTaxonomyMap(lst);

		Iterator it = doInvestigationIndex.getInvestigations().iterator();
		while (it.hasNext())
		{
			Investigation doInvest = (Investigation) it.next();
			doInvest.setInvestigationIndex(doInvestigationIndex);
		}

		factory.save(doActivity);
		doInvestigationIndex.setActivity(doActivity);

		// uppercase relevant fields
		if (doInvestigationIndex.getName() != null)
			doInvestigationIndex.setUpperName(doInvestigationIndex.getName().toUpperCase().substring(0, Math.min(100, doInvestigationIndex.getName().length())));

		Iterator it1 = doInvestigationIndex.getSynonyms().iterator();
		while (it1.hasNext())
		{
			InvSynonym doSyn = (InvSynonym) it1.next();
			if (doSyn.getName() != null)
				doSyn.setUpperName(doSyn.getName().toUpperCase().substring(0, Math.min(100, doSyn.getName().length())));
		}

		try
		{
			factory.save(doInvestigationIndex);
		}
		catch (UnqViolationUncheckedException e)
		{
			throw new UniqueKeyViolationException();
		}

		return InvestigationIndexVoAssembler.create(doInvestigationIndex);
	}


	/*
	 * WDEV-4338 07/04/08 checks for if a certain taxonomy is already in use.
	 * 
	 */

	public Boolean checkDuplicateTaxonomyMapping(TaxonomyMap voTaxonomyMap)
	{
		DomainFactory factory = getDomainFactory();

		String hql = "select map.taxonomyCode" + " from InvestigationIndex as index left join index.taxonomyMap as map" + " where(map.taxonomyCode ='" + voTaxonomyMap.getTaxonomyCode().toString() + "')";

		List duplicates = factory.find(hql);

		return duplicates.size() == 0;

	}

	private void checkTemplatesAndProfiles(Integer idInvestigation, InvestigationIndexVo voInvestigationIndex, DomainFactory factory) throws DomainInterfaceException
	{
		// a new investigation provider record
		if (idInvestigation == null)
			return;

		// get investigation provider from collection
		InvestigationShortVo voInv = null;
		for (int i = 0; i < voInvestigationIndex.getInvestigations().size(); i++)
		{
			if (voInvestigationIndex.getInvestigations().get(i).getID_InvestigationIsNotNull() && voInvestigationIndex.getInvestigations().get(i).getID_Investigation().equals(idInvestigation))
				voInv = voInvestigationIndex.getInvestigations().get(i);
		}

		if (voInv.getActiveStatusIsNotNull() && voInv.getActiveStatus().equals(PreActiveActiveInactiveStatus.INACTIVE))
		{
			Investigation doInvRecord = (Investigation) factory.getDomainObject(Investigation.class, voInv.getID_Investigation());
			if (doInvRecord.getActiveStatus().equals(getDomLookup(PreActiveActiveInactiveStatus.ACTIVE)))
			{
				// check if this record is associated with an active
				// templates\profiles\ordersets
				List items = getAssociatedItems(factory, doInvRecord.getId());
				handleErrors(items);
			}
		}
	}

	private void handleErrors(List items) throws DomainInterfaceException
	{
		if (items == null || items.size() == 0)
			return;
		// parse the list selecting only distinct records of the same type and
		// id
		List distictList = new ArrayList();

		for (int i = 0; i < items.size(); i++)
		{
			if (!alreadyExists(distictList, (TemplateAndProfileConflict) items.get(i)))
				distictList.add(items.get(i));
		}

		String templateErrorItems = "";

		int templatesFound = 0;
		for (int i = 0; i < distictList.size(); i++)
		{
			if (((TemplateAndProfileConflict) distictList.get(i)).getType().equals("OT"))
			{
				templateErrorItems += (templatesFound > 0 ? "," : "") + ((TemplateAndProfileConflict) distictList.get(i)).getName();
				templatesFound++;
			}
		}

		String orderSetErrorItems = "";
		int orderSetsFound = 0;
		for (int i = 0; i < distictList.size(); i++)
		{
			if (((TemplateAndProfileConflict) distictList.get(i)).getType().equals("OS"))
			{
				orderSetErrorItems += (orderSetsFound > 0 ? "," : "") + ((TemplateAndProfileConflict) distictList.get(i)).getName();
				orderSetsFound++;
			}
		}

		String profileErrorItems = "";
		int profilesFound = 0;
		for (int i = 0; i < distictList.size(); i++)
		{
			if (((TemplateAndProfileConflict) distictList.get(i)).getType().equals("INV"))
			{
				profileErrorItems += (profilesFound > 0 ? "," : "") + ((TemplateAndProfileConflict) distictList.get(i)).getName();
				profilesFound++;
			}
		}

		StringBuffer errorMessage = new StringBuffer("The following items are using this Investigation, please remove the Investigation from each respective item if you wish to make the Investigation inactive.\n");
		if (templatesFound > 0)
		{
			errorMessage.append("\nTemplates :");
			errorMessage.append(templateErrorItems);
		}
		if (orderSetsFound > 0)
		{
			errorMessage.append("\nOrderSets :");
			errorMessage.append(orderSetErrorItems);
		}
		if (profilesFound > 0)
		{
			errorMessage.append("\nProfiles :");
			errorMessage.append(profileErrorItems);
		}

		throw new DomainInterfaceException(errorMessage.toString());
	}

	private boolean alreadyExists(List distictList, TemplateAndProfileConflict item)
	{
		TemplateAndProfileConflict listItem = null;
		for (int i = 0; i < distictList.size(); i++)
		{
			listItem = (TemplateAndProfileConflict) distictList.get(i);
			if (listItem.getId().equals(item.getId()) && listItem.getType().equals(item.getType()))
				return true;
		}
		return false;
	}

	/**
	 * Using a helper class called TemplateAndProfileConflict list active config records that are using this investigation
	 * 
	 * @param factory
	 * @param countOnly
	 * @param code
	 * @param invRecordId
	 * @return
	 */
	private List getAssociatedItems(DomainFactory factory, Integer invRecordId)
	{
		// The list of active Ordersets that use this inv
		String hql = "select new ims.ocrr.helper.TemplateAndProfileConflict (orderSet.id, orderSet.name, 'OS')" + " from OrderSet as orderSet left join orderSet.component as comp left join comp.investigation as inv " + " where (inv.id = :idInv and orderSet.activeStatus = :activeStatus)";

		List orderSetItems = factory.find(hql, new String[]{"idInv", "activeStatus"}, new Object[]{invRecordId, getDomLookup(PreActiveActiveInactiveStatus.ACTIVE)});

		// The list of active templates that use the orderset list from above
		List templateOrdSetItems = null;
		if (orderSetItems != null && orderSetItems.size() > 0)
		{
			String orderSetIds = getOrderSetIdString(orderSetItems);

			hql = "select new ims.ocrr.helper.TemplateAndProfileConflict (template.id, template.menuName,'OT') " + " from OrderEntryTemplate as template left join template.components as comp left join comp.orderSet as orderSet" + " where orderSet.id in " + orderSetIds + " and template.activeStatus = :activeStatus";

			templateOrdSetItems = factory.find(hql, new String[]{"activeStatus"}, new Object[]{getDomLookup(PreActiveActiveInactiveStatus.ACTIVE)});
		}

		// The list of templates that directly use this investigation
		hql = "select new ims.ocrr.helper.TemplateAndProfileConflict (template.id, template.menuName,'OT')" + " from OrderEntryTemplate as template left join template.components as comp left join comp.investigation as inv" + " where inv.id = :idInv and template.activeStatus = :activeStatus";

		List templateItems = factory.find(hql, new String[]{"idInv", "activeStatus"}, new Object[]{invRecordId, getDomLookup(PreActiveActiveInactiveStatus.ACTIVE)});

		// The list of active profiles using this inv
		hql = "select new ims.ocrr.helper.TemplateAndProfileConflict (inv.id, invIndex.name,'INV') " + " from Investigation as inv left join inv.assocInvestigations as assocInv left join inv.investigationIndex as invIndex " + " where (assocInv.id = :idInv and invIndex.isProfile = true and inv.activeStatus = :activeStatus)";

		List profItems = factory.find(hql, new String[]{"idInv", "activeStatus"}, new Object[]{invRecordId, getDomLookup(PreActiveActiveInactiveStatus.ACTIVE)});

		List fullList = new ArrayList();
		fullList.addAll(orderSetItems);
		if (templateOrdSetItems != null)
			fullList.addAll(templateOrdSetItems);
		fullList.addAll(templateItems);
		fullList.addAll(profItems);

		return fullList;
	}

	private String getOrderSetIdString(List items)
	{
		String ordSetIds = "(";
		String seperator = ",";

		for (int i = 0; i < items.size(); i++)
		{
			ordSetIds += ((TemplateAndProfileConflict) items.get(i)).getId();
			ordSetIds += items.size() >= 2 && items.size() > (i + 1) ? seperator : "";
		}

		ordSetIds += ")";
		return ordSetIds;
	}

	private String getSiteIdString(SpecimenSiteCollection sites)
	{
		if (sites == null || sites.size() == 0)
			return null;

		String siteIds = "(";
		String seperator = ",";

		for (int i = 0; i < sites.size(); i++)
		{
			siteIds += sites.get(i).getId();
			siteIds += sites.size() >= 2 && sites.size() > (i + 1) ? seperator : "";
		}

		siteIds += ")";
		return siteIds;
	}

	public LocationLiteVoCollection listProvidersByCategory(Category lookupCategory)
	{
		if (lookupCategory == null)
			return null;

		DomainFactory factory = getDomainFactory();

		java.util.List locations = null;
		LookupInstance type = null;

		if (lookupCategory.equals(Category.PATHOLOGY))
			type = getDomLookup(LocationType.PATHOLOGYLABORATORY);
		else if (lookupCategory.equals(Category.CLINICALIMAGING))
			type = getDomLookup(LocationType.CLINICALIMAGINGDEPARTMENT);
		else if (lookupCategory.equals(Category.CLINICAL))
			type = getDomLookup(LocationType.CLINICAL);

		if (type == null)
			throw new DomainRuntimeException("type id not found (listProvidersByCategory method)");

		locations = factory.find("from Location loc where loc.type = :type", new String[]{"type"}, new Object[]{type});

		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations).sort();
	}

	public InvestigationIndexVo getInvestigationIndex(Integer recordId)
	{
		TestList impl = (TestList) getDomainImpl(TestListImpl.class);
		return impl.getInvestigationIndex(recordId);
	}

	public LocSvcProviderSysVoCollection listProviderSystem(LocationRefVo voLocation)
	{
		DomainFactory factory = getDomainFactory();
		if (voLocation == null)
			throw new DomainRuntimeException("Location parameter cannot be null");

		java.util.List lsps = factory.find("from LocSvcProviderSys lsps where lsps.locationService.location.id = :locationId", new String[]{"locationId"}, new Object[]{voLocation.getID_Location()});
		if (lsps != null)
			return LocSvcProviderSysVoAssembler.createLocSvcProviderSysVoCollectionFromLocSvcProviderSys(lsps);

		return null;
	}

	public PathSpecimenContainerDetailVoCollection listPathSpecimenContainer()
	{			
		List containers=getDomainFactory().find("from PathSpecimenContainer pathCont where pathCont.isActive = true order by pathSpecimenOrder ASC");
		return PathSpecimenContainerDetailVoAssembler.createPathSpecimenContainerDetailVoCollectionFromPathSpecimenContainer(containers);
	}

	public InvestigationVo getInvestigation(Integer idInvestigation)
	{
		DomainFactory factory = getDomainFactory();
		return InvestigationVoAssembler.create((Investigation) factory.getDomainObject(Investigation.class, idInvestigation));
	}

	public OrderEntryTemplateShortVoCollection listTemplatesUsingInvestigation(InvestigationIndexRefVo invIndex)
	{
		if (invIndex == null)
			throw new CodingRuntimeException("parameter invIndex is null in method listTemplatesUsingInvestigation");

		DomainFactory factory = getDomainFactory();
		return OrderEntryTemplateShortVoAssembler.createOrderEntryTemplateShortVoCollectionFromOrderEntryTemplate(getAssociatedItems(factory, invIndex.getID_InvestigationIndex()));
	}

	public InvestigationIndexShortVoCollection listProfilesUsingInvestigation(InvestigationIndexRefVo invIndex)
	{
		if (invIndex == null)
			throw new CodingRuntimeException("parameter invIndex is null in method listProfilesUsingInvestigation");

		DomainFactory factory = getDomainFactory();
		return InvestigationIndexShortVoAssembler.createInvestigationIndexShortVoCollectionFromInvestigationIndex(getAssociatedItems(factory, invIndex.getID_InvestigationIndex()));
	}

	public SecurityLevelConfigVoCollection listSecurityLevel()
	{
		String hql = "from SecurityLevel sec order by sec.securityLevel asc";
		List lstSecs = getDomainFactory().find(hql);
		return SecurityLevelConfigVoAssembler.createSecurityLevelConfigVoCollectionFromSecurityLevel(lstSecs);
	}


	public String validatePreActiveInvestigations(InvestigationIndexVo invIndex) //WDEV-11940
	{
		if (!invIndex.getInvestigationsIsNotNull())
			return null;
		
		ArrayList<String> result = new ArrayList<String>();
		DomainFactory factory = getDomainFactory();
		for (int i = 0 ; i < invIndex.getInvestigations().size() ; i++)
		{
			if (!PreActiveActiveInactiveStatus.PREACTIVE.equals(invIndex.getInvestigations().get(i).getActiveStatus()))
				continue;
			
			
			boolean isPathology = invIndex.getInvestigations().get(i).getInvestigationIndex().getCategory().equals(Category.PATHOLOGY);
			boolean isSite = invIndex.getInvestigations().get(i).getInvestigationIndex().getRequiresSiteSpecifierIsNotNull() && invIndex.getInvestigations().get(i).getInvestigationIndex().getRequiresSiteSpecifier().equals(Boolean.TRUE);
			boolean addOn = invIndex.getInvestigations().get(i).getIsAddonIsNotNull() && invIndex.getInvestigations().get(i).getIsAddon().booleanValue();
			
			//WDEV-5847 - don't do this validation for Inv's of the new category 'CLINICAL'
			if(invIndex.getInvestigations().get(i).getProviderService() == null)
				continue;
			
			// check 1
			// if creating an addon ensure that no inv record exists having
			// the same provider service and inv code
			if (addOn)
			{
				ArrayList markers = new ArrayList();
				ArrayList values = new ArrayList();

				String hql = "select invIndex.name from Investigation as inv left join inv.investigationIndex as invIndex " +
				" where inv.providerService.id = :idProviderService and inv.providerInvCode = :provInvCode and inv.activeStatus = :status";

				markers.add("idProviderService");
				values.add(invIndex.getInvestigations().get(i).getProviderService().getID_LocSvcProviderSys());
				markers.add("provInvCode");
				values.add(invIndex.getInvestigations().get(i).getProviderInvCode());
				markers.add("status");
				values.add(getDomLookup(PreActiveActiveInactiveStatus.ACTIVE));

				if (invIndex.getID_InvestigationIndexIsNotNull())
				{
					markers.add("invIndexId");
					values.add(invIndex.getID_InvestigationIndex());
					hql += " and inv.investigationIndex.id != :invIndexId";
				}

				List list = factory.find(hql, markers, values);

				if (list != null && list.size() > 0)
				{
					
							result.add("An active investigation("+list.get(0)+" using this Provider System Inv. Code exists for this Provider Service");
				}
			}
			else if (isSite)
			{
				// check 2
				// if creating a site inv ensure that no inv record exists
				// having the same provider service and inv code
				// where any inv sites exist for the collection of sites
				// being saved or an existing inv has no sites or an addon
				// inv exists

				String siteIds = getSiteIdString(invIndex.getSites());
				if (siteIds != null)
				{
					// WDEV-2618 - make sure site and inv code havent been
					// used before
					ArrayList markers = new ArrayList();
					ArrayList values = new ArrayList();

					String hql = "select invIndex.name from Investigation as inv left join inv.investigationIndex as invIndex left join invIndex.sites as site left join site.instance as inst" + " where (inv.providerService.id = :idProviderService and inv.providerInvCode = :provInvCode and inv.activeStatus = :status and ( " + 
					" inst.id in " + siteIds + " or (invIndex.requiresSiteSpecifier is false or inv.isAddon is true))) ";

					markers.add("idProviderService");
					values.add(invIndex.getInvestigations().get(i).getProviderService().getID_LocSvcProviderSys());
					markers.add("provInvCode");
					values.add(invIndex.getInvestigations().get(i).getProviderInvCode());
					markers.add("status");
					values.add(getDomLookup(PreActiveActiveInactiveStatus.ACTIVE));

					if (invIndex.getID_InvestigationIndexIsNotNull())
					{
						markers.add("invIndexId");
						values.add(invIndex.getID_InvestigationIndex());
						hql += " and inv.investigationIndex.id != :invIndexId";
					}

					List list = factory.find(hql, markers, values);
					if (list != null && list.size() > 0)
					{
						
							result.add("An active investigation("+list.get(0)+" using this Provider System Inv. Code and Provider Service either using a selected Site or not requiring a Site exists");
					}
				}
			}

			//check 3 was removed as per WDEV-16274

			if (!isSite)
			{
				// check 4
				// if we are creating a record that doesnt require site and
				// its not an addon and it is pathology
				// ensure that no records exist where specimetype is equal
				// and is addon = true
				String hql = "select idx.name from Investigation inv left join inv.pathInvDetails path left join path.specimens as spec left join inv.investigationIndex idx where inv.providerService.id = :idProviderService and inv.providerInvCode = :invCode and inv.activeStatus = :activeStatus ";
				ArrayList markers = new ArrayList();
				ArrayList values = new ArrayList();

				markers.add("idProviderService");
				markers.add("invCode");
				markers.add("activeStatus");

				values.add(invIndex.getInvestigations().get(i).getProviderService().getID_LocSvcProviderSys());
				values.add(invIndex.getInvestigations().get(i).getProviderInvCode());
				values.add(getDomLookup(PreActiveActiveInactiveStatus.ACTIVE));

				if (isPathology)
				{
					if (!addOn)
					{
						hql += " and ( spec.type = :specType or inv.isAddon is true ) ";
						markers.add("specType");
						values.add(getDomLookup(invIndex.getInvestigations().get(i).getPathInvDetails().getSpecimens().get(0).getType()));
					}

					hql += " and idx.requiresSiteSpecifier is false ";
				}

				// to make sure we are not testing the validity of the
				// current record if it has been saved before
				if (invIndex.getInvestigations().get(i).getID_InvestigationIsNotNull())
				{
					hql += " and inv.id != :currentInvId";
					markers.add("currentInvId");
					values.add(invIndex.getInvestigations().get(i).getID_Investigation());
				}

				List invs = factory.find(hql, markers, values);

				if (invs != null && invs.size() > 0)
					result.add("An active Investigation (" + invs.get(0) + ") using this Provider Service and Provider System Inv. Code  already exists");

			}

			// check 5
			// if we are creating a pathology inv ensure that no active inv
			// exists where the provider service and
			// inv code are equal and if the record to be saved requires
			// sites check all saved inv's where requires site equals false
			// and vice versa
			if (isPathology)
			{
				String hql = "select idx.name from Investigation inv left join inv.pathInvDetails path join inv.investigationIndex idx where inv.providerService.id = :idProviderService and inv.activeStatus = :activeStatus and inv.providerInvCode = :invCode";
				ArrayList markers = new ArrayList();
				ArrayList values = new ArrayList();

				markers.add("idProviderService");
				markers.add("activeStatus");
				markers.add("invCode");

				values.add(invIndex.getInvestigations().get(i).getProviderService().getID_LocSvcProviderSys());
				values.add(getDomLookup(PreActiveActiveInactiveStatus.ACTIVE));
				values.add(invIndex.getInvestigations().get(i).getProviderInvCode());

				if (isSite)
					hql += " and idx.requiresSiteSpecifier is false ";
				else
					hql += " and idx.requiresSiteSpecifier is true ";

				// to make sure we are not testing the validity of the
				// current record if it has been saved before
				if (invIndex.getInvestigations().get(i).getID_InvestigationIsNotNull())
				{
					hql += " and inv.id != :currentInvId";
					markers.add("currentInvId");
					values.add(invIndex.getInvestigations().get(i).getID_Investigation());
				}

				List invs = factory.find(hql, markers, values);

				if (invs != null && invs.size() > 0)
				{
					String strMessage = "An active Investigation (" + invs.get(0) + ") using this Provider Service and Provider Inv. Code ";
					if (isSite)
					{
						strMessage += "without site specifier already exists";
					}
					else
					{
						strMessage += "with site specifier already exists";
					}

					result.add(strMessage);
				}
			}
		}
		
		if (result.size() == 0)
			return null;
		StringBuilder fResult = new StringBuilder();
		for (int i = 0 ; i < result.size() ; i++)
		{
			fResult.append(result.get(i)+"\n");
		}
		return fResult.toString();
	}


	
}
