//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Marius Mihalec using IMS Development Environment (version 1.45 build 2327.20708)
// Copyright (C) 1995-2006 IMS MAXIMS plc. All rights reserved.

package ims.ocrr.domain.impl;

import ims.admin.domain.ClinicAdmin;
import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.ClinicAdminImpl;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.configuration.gen.ConfigFlag;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.resource.people.domain.objects.Medic;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.ClinicRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.ClinicLiteVoCollection;
import ims.core.vo.GpLiteVo;
import ims.core.vo.GpLiteVoCollection;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MedicVo;
import ims.core.vo.ServiceLiteVoCollection;
import ims.core.vo.domain.GpLiteVoAssembler;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.MedicVoAssembler;
import ims.core.vo.domain.ServiceLiteVoAssembler;
import ims.core.vo.lookups.HcpDisType;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.ServiceCategory;
import ims.core.vo.lookups.Specialty;
import ims.core.vo.lookups.TaxonomyType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.impl.DomainImpl;
import ims.framework.enumerations.SortOrder;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.IAppRole;
import ims.framework.interfaces.ILocation;
import ims.framework.utils.Date;
import ims.ocrr.domain.RefManNewResults;
import ims.ocrr.domain.ClinicalImagingResults;
import ims.ocrr.domain.MyOrder;
import ims.ocrr.domain.SelectandOrder;
import ims.ocrr.orderingresults.domain.objects.OrderInvestigation;
import ims.ocrr.orderingresults.domain.objects.OrderSpecimen;
import ims.ocrr.orderingresults.vo.OrderSpecimenRefVo;
import ims.ocrr.vo.NewResultsListVo;
import ims.ocrr.vo.NewResultsListVoCollection;
import ims.ocrr.vo.OrdInvXOStatusHistoryLiteVoCollection;
import ims.ocrr.vo.RoleDisciplineSecurityLevelLiteGCVo;
import ims.ocrr.vo.domain.NewResultsListVoAssembler;
import ims.ocrr.vo.lookups.InvEventType;
import ims.ocrr.vo.lookups.OrderInvStatus;
import ims.ocrr.vo.lookups.OrderInvStatusCollection;
import ims.ocrr.vo.lookups.ResultStatus;
import ims.vo.ValueObject;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class NewResultsImpl extends DomainImpl implements ims.ocrr.domain.NewResults, RefManNewResults, ims.domain.impl.Transactional
{
	private static final long serialVersionUID = 1L;

	/**
	 * WDEV-13876
	 * List responsible HCP (active & marked as responsible HCP)
	 */
	public HcpLiteVoCollection listClinicians(String name)
	{
		if (name == null || name.length() == 0)
			return null;
		
		String query = "SELECT hcp FROM Hcp AS hcp LEFT JOIN hcp.mos AS mos WHERE mos.name.upperSurname LIKE :HCP_NAME AND hcp.isActive = 1 AND hcp.isHCPaResponsibleHCP = 1 ORDER BY mos.name.upperSurname";

		return HcpLiteVoAssembler.createHcpLiteVoCollectionFromHcp(getDomainFactory().find(query, "HCP_NAME", name.toUpperCase() + "%"));
	}
	
	/**
	 * WDEV-13876
	 * List reviewing HCP (only active HCP marked as responsible HCP)
	 */
	public HcpLiteVoCollection listReviewingHCP(String name)
	{
		if (name == null || name.length() == 0)
			return null;
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		String query = "SELECT hcp FROM Hcp AS hcp LEFT JOIN hcp.mos AS mos WHERE mos.name.upperSurname LIKE :HCP_NAME AND hcp.isActive = 1 AND hcp.hcpType.id = :MEDIC_TYPE ORDER BY mos.name.upperSurname";
		
		paramNames.add("HCP_NAME");
		paramValues.add(name.toUpperCase() + "%");
		
		paramNames.add("MEDIC_TYPE");
		paramValues.add(HcpDisType.MEDICAL.getID());
		
		return HcpLiteVoAssembler.createHcpLiteVoCollectionFromHcp(getDomainFactory().find(query, paramNames, paramValues));
	}
	
	public GpLiteVoCollection listGps(String nameFilter)
	{
		return GpLiteVoAssembler.createGpLiteVoCollectionFromGp(getDomainFactory().find("from Gp gp where gp.name.upperSurname like :name", new String[]{"name"}, new Object[]{nameFilter.toUpperCase() + "%"}));
	}
	
	public LocationLiteVoCollection listWards(String name, LocationRefVo voLocRef)
	{	 
		OrganisationAndLocation orgAdmin = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return orgAdmin.listActiveWardsForHospitalByNameLite(voLocRef, name);
	}
	public LocationLiteVoCollection listSurgeries(String nameFilter)
	{
		return listLocations(nameFilter, LocationType.SURGERY);
	}

	public LocationLiteVoCollection listHospitals()
	{
		return listLocations(null, LocationType.HOSP);
	}

	public LocationLiteVoCollection listErDepts(String nameFilter, LocationRefVo voLocRef)
	{
		OrganisationAndLocation orgAdmin = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return orgAdmin.listActiveAandEForHospitalByNameLite(voLocRef, nameFilter);
		
	}

	public LocationLiteVoCollection listOtherLocations(String nameFilter, LocationRefVo voLocRef)
	{
		MyOrder myOrder = (MyOrder)getDomainImpl(MyOrderImpl.class);
		 return myOrder.listUserEnteredLocationsForHospitalByNameLite(voLocRef, nameFilter);	
	}

	private LocationLiteVoCollection listLocations(String name, LocationType locType)
	{
		ArrayList<String> names = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		String hql = "from Location loc where (loc.type.id = :typeId";
		names.add("typeId");
		values.add(new Integer(locType.getId()));
		
		if (name != null)
		{
			hql += " and loc.upperName like :name ";
			names.add("name");
			values.add(name.toUpperCase() + "%");
		}
		hql += (" and loc.isVirtual =:virtual) order by loc.upperName asc");
		names.add("virtual");
		values.add(Boolean.FALSE);
		
		List<?> l = this.getDomainFactory().find(hql, names, values);
		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(l);
	}
	
	//for Existing NewResults
	public NewResultsListVoCollection listNewResultsByDateRange(Date dateFrom, Date dateTo, ValueObject location, ValueObject clinician, OrderInvStatusCollection statuses, Boolean includeCurrentInpatients, Boolean excludeInpatients, Integer orderingHCPId, ServiceRefVo discipline,Specialty specialty)
	{
		return listNewResultsByDateRange(dateFrom, dateTo, location, clinician, statuses, includeCurrentInpatients, excludeInpatients,orderingHCPId,discipline,specialty, null);
	}

	/**
	 * WDEV-13321
	 */
	public NewResultsListVoCollection listNewResultsByDateRange(Date dateFrom, Date dateTo, ValueObject location, ValueObject clinician, OrderInvStatusCollection statuses, Boolean includeCurrentInpatients, Boolean excludeInpatients, Integer orderingHCPId, ServiceRefVo discipline,Specialty specialty, HcpLiteVo initiatingHcp) 
	{
		if(dateFrom == null)
			throw new CodingRuntimeException("Invalid start date");
		
		Date dtFrom = new Date(dateFrom);
		Date dtTo = new Date();
		if (dateTo == null)
			dtTo = new Date().addDay(1);
		else{
			dtTo = (Date) dateTo.clone();
			dtTo.addDay(1);
		}
						
		if (statuses == null || statuses.size() == 0)
			return new NewResultsListVoCollection();
	
		if (specialty != null)
		{
			ArrayList<String> markers = new ArrayList<String>();
			ArrayList<Object> values = new ArrayList<Object>();		
			StringBuffer sb = new StringBuffer(" select DISTINCT (oi) from CatsReferral as cats left join cats.investigationOrders as io left join io.investigations as oi left join cats.referralDetails as rd left join rd.service as serv where ");
			
			sb.append("(");
			sb.append("(oi.repDateTime >= :fromDate AND oi.repDateTime < :toDate)");
			
			markers.add("fromDate");
			values.add(dtFrom.getDate());
			markers.add("toDate");			
			values.add(dtTo.getDate());
			
			if (statuses != null && statuses.contains(OrderInvStatus.REVIEW))
			{
				sb.append(" OR (oi.allocatedDateForReview >= :fromDate AND oi.allocatedDateForReview < :toDate)");
			}
			
			sb.append(")");
			
			sb.append(" and serv.specialty.id = :idSpecialty");
			markers.add("idSpecialty");			
			values.add(specialty.getID());
			
			if (!includeCurrentInpatients && !excludeInpatients)
			{
				if(location != null && location instanceof LocationRefVo)
				{
					LocationRefVo locRef = (LocationRefVo)location;
					sb.append(" and oi.patientLocation.id = :location");
					markers.add("location");
					values.add(locRef.getID_Location());			
				}
				else if (location != null && location instanceof ClinicRefVo)
				{
					ClinicRefVo clinRef = (ClinicRefVo)location;
					sb.append(" and oi.patientClinic.id = :clinic");
					markers.add("clinic");
					values.add(clinRef.getID_Clinic());			
					
				}
			}
			if(clinician != null && clinician instanceof HcpLiteVo)
			{
				HcpLiteVo hcp = (HcpLiteVo)clinician;
				if(hcp.getID_Hcp() == null)
					throw new DomainRuntimeException("Invalid clinician");
				
				sb.append(" and oi.responsibleClinician.id = :hcp");
				markers.add("hcp");			
				values.add(hcp.getID_Hcp());
			}		
			else if(clinician != null && clinician instanceof GpLiteVo)
			{
				GpLiteVo gp = (GpLiteVo)clinician;
				if(gp.getID_Gp() == null)
					throw new DomainRuntimeException("Invalid GP");
				
				sb.append(" and oi.responsibleGp.id = :gp");
				markers.add("gp");			
				values.add(gp.getID_Gp());
			}
			if (includeCurrentInpatients)
			{
				sb.append(" and oi.orderDetails.patient.ward is not null");	
			}
			if (excludeInpatients)
			{
				sb.append(" and oi.orderDetails.patient.ward is null");	
			}
			
			if (statuses.size() == 1 && statuses.contains(OrderInvStatus.REVIEW))
			{
				HcpLiteVo hcpUser = (HcpLiteVo) getHcpLiteUser();
				
				if (hcpUser != null)
				{
					sb.append(" and oi.ordInvCurrentStatus.ordInvStatus.id = ").append(OrderInvStatus.REVIEW.getID());
					sb.append(" and oi.allocatedHCPforReview.id = ").append(hcpUser.getID_Hcp());
				}
			}
			else
			{
				sb.append(" and (oi.ordInvCurrentStatus.ordInvStatus.id in (");
				StringBuffer sts = new StringBuffer();
				for (int i = 0; i < statuses.size(); i++)
				{
					if (OrderInvStatus.REVIEW.equals(statuses.get(i)))
						continue;
					
					sts.append(statuses.get(i).getId());

					if (i != statuses.size() - 1 &&																		// Not the last element
							!(i == statuses.size() - 2 && OrderInvStatus.REVIEW.equals(statuses.get(i + 1))) )				// Not the last element except "For Review"
					{
						sts.append(",");
					}
				}
				sb.append(sts.toString());
				sb.append(")");

				HcpLiteVo hcpUser = (HcpLiteVo) getHcpLiteUser();

				if (statuses.contains(OrderInvStatus.REVIEW) && hcpUser != null)
				{
					sb.append(" or (oi.ordInvCurrentStatus.ordInvStatus.id = ").append(OrderInvStatus.REVIEW.getID());
					sb.append(" and oi.allocatedHCPforReview.id = ").append(hcpUser.getID_Hcp());
					sb.append(") )");
				}
				else
				{
					sb.append(")");
				}
			}
			
			if(orderingHCPId != -1)
			{
				sb.append(" and ");
				sb.append(" (oi.orderDetails.orderedBy is not null and oi.orderDetails.orderedBy.id = :orderedById) ");
				markers.add("orderedById");
				values.add(orderingHCPId);
			}
				
			if(discipline != null && discipline.getID_ServiceIsNotNull())
			{
				sb.append(" and ");
				sb.append(" oi.investigation.providerService.locationService.service.id = :discipline ");
				markers.add("discipline");
				values.add(discipline.getID_Service());
			}
			
			//WDEV-9913, WDEV-9946
			if(initiatingHcp != null && initiatingHcp.getIMosHcpId() != null)
			{
				sb.append(" and ");
				sb.append(" (oi.orderDetails.responsibleClinician.id = :initiatingHcp) ");
				markers.add("initiatingHcp");
				values.add(initiatingHcp.getIMosHcpId());
			}
			
			sb.append(" order by oi.allocatedDateForReview desc, oi.repDateTime desc, oi.ordInvSeq asc");
			
			return NewResultsListVoAssembler.createNewResultsListVoCollectionFromOrderInvestigation(getDomainFactory().find(sb.toString(), markers, values));						
		}
		
		
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();		
		StringBuffer sb = new StringBuffer("SELECT DISTINCT (oi) from OrderInvestigation as oi where ");
		
		sb.append("(");
		sb.append("( oi.repDateTime >= :fromDate");
		markers.add("fromDate");
		values.add(dtFrom.getDate());
		
		sb.append(" and oi.repDateTime < :toDate) ");
		markers.add("toDate");			
		values.add(dtTo.getDate());
		
		sb.append(" or ( oi.investigationDateTime >= :fromDate ");
		sb.append(" and oi.investigationDateTime < :toDate)");
		
		if (statuses != null && statuses.contains(OrderInvStatus.REVIEW))
		{
			sb.append(" OR (oi.allocatedDateForReview <= :fromDate AND oi.allocatedDateForReview < :toDate)");
		}
		
		sb.append(")");
		
		

		if (!includeCurrentInpatients && !excludeInpatients)
		{
			if(location != null && location instanceof LocationRefVo)
			{
				LocationRefVo locRef = (LocationRefVo)location;
				sb.append(" and oi.patientLocation.id = :location");
				markers.add("location");
				values.add(locRef.getID_Location());			
			}
			else if (location != null && location instanceof ClinicRefVo)
			{
				ClinicRefVo clinRef = (ClinicRefVo)location;
				sb.append(" and oi.patientClinic.id = :clinic");
				markers.add("clinic");
				values.add(clinRef.getID_Clinic());			
				
			}
		}
		if(clinician != null && clinician instanceof HcpLiteVo)
		{
			HcpLiteVo hcp = (HcpLiteVo)clinician;
			if(hcp.getID_Hcp() == null)
				throw new DomainRuntimeException("Invalid clinician");
			
			sb.append(" and oi.responsibleClinician.id = :hcp");
			markers.add("hcp");			
			values.add(hcp.getID_Hcp());
		}		
		else if(clinician != null && clinician instanceof GpLiteVo)
		{
			GpLiteVo gp = (GpLiteVo)clinician;
			if(gp.getID_Gp() == null)
				throw new DomainRuntimeException("Invalid GP");
			
			sb.append(" and oi.responsibleGp.id = :gp");
			markers.add("gp");			
			values.add(gp.getID_Gp());
		}
		if (includeCurrentInpatients)
		{
			sb.append(" and oi.orderDetails.patient.ward is not null");	
		}
		if (excludeInpatients)
		{
			sb.append(" and oi.orderDetails.patient.ward is null");	
		}
		
		
		if (statuses.size() == 1 && statuses.contains(OrderInvStatus.REVIEW))
		{
			HcpLiteVo hcpUser = (HcpLiteVo) getHcpLiteUser();
			
			if (hcpUser != null)
			{
				sb.append(" and oi.ordInvCurrentStatus.ordInvStatus.id = ").append(OrderInvStatus.REVIEW.getID());
				sb.append(" and oi.allocatedHCPforReview.id = ").append(hcpUser.getID_Hcp());
			}
		}
		else
		{
			sb.append(" and (oi.ordInvCurrentStatus.ordInvStatus.id in (");
			StringBuffer sts = new StringBuffer();
			for (int i = 0; i < statuses.size(); i++)
			{
				if (OrderInvStatus.REVIEW.equals(statuses.get(i)))
					continue;
				
				sts.append(statuses.get(i).getId());

				if (i != statuses.size() - 1 &&																		// Not the last element
						!(i == statuses.size() - 2 && OrderInvStatus.REVIEW.equals(statuses.get(i + 1))) )				// Not the last element except "For Review"
				{
					sts.append(",");
				}
			}
			sb.append(sts.toString());
			sb.append(")");

			HcpLiteVo hcpUser = (HcpLiteVo) getHcpLiteUser();

			if (statuses.contains(OrderInvStatus.REVIEW) && hcpUser != null)
			{
				sb.append(" or (oi.ordInvCurrentStatus.ordInvStatus.id = ").append(OrderInvStatus.REVIEW.getID());
				sb.append(" and oi.allocatedHCPforReview.id = ").append(hcpUser.getID_Hcp());
				sb.append(") )");
			}
			else
			{
				sb.append(")");
			}
		}
		
		if(orderingHCPId != -1)
		{
			sb.append(" and ");
			sb.append(" (oi.orderDetails.orderedBy is not null and oi.orderDetails.orderedBy.id = :orderedById) ");
			markers.add("orderedById");
			values.add(orderingHCPId);
		}
			
		if(discipline != null && discipline.getID_ServiceIsNotNull())
		{
			sb.append(" and ");
			sb.append(" oi.investigation.providerService.locationService.service.id = :discipline ");
			markers.add("discipline");
			values.add(discipline.getID_Service());
		}
		//WDEV-9913
		if(initiatingHcp != null && initiatingHcp.getIMosHcpId() != null)
		{
			sb.append(" and ");
			sb.append(" (oi.orderDetails.responsibleClinician.id = :initiatingHcp) ");
			markers.add("initiatingHcp");
			values.add(initiatingHcp.getIMosHcpId());
		}
		
		sb.append(" order by oi.allocatedDateForReview desc, oi.repDateTime desc, oi.ordInvSeq asc");
		
		List<?> results = getDomainFactory().find(sb.toString(), markers, values, ConfigFlag.UI.CARE_UK_MAX_NEW_RESULTS.getValue());
		
		//WDEV-12054
		NewResultsListVoCollection voCollResults = processResults(results);
		voCollResults.sort(SortOrder.DESCENDING);
			
		return voCollResults;
	}
	
//	private String getResultedStatusIds() 
//	{
//		StringBuffer ret = new StringBuffer();
//		ret.append(OrderInvStatus.CHECKED.getId());
//		ret.append("," + OrderInvStatus.NEW_RESULT.getId());
//		ret.append("," + OrderInvStatus.REVIEW.getId());
//		ret.append("," + OrderInvStatus.SEEN.getId());
//		ret.append("," + OrderInvStatus.UNSEEN.getId());
//		ret.append("," + OrderInvStatus.UPDATED_RESULT.getId());
//		
//		return ret.toString();
//	}

	public OrderSpecimenRefVo getSpecimenForResult(Integer orderInvId)
	{
		if(orderInvId == null)
			throw new CodingRuntimeException("orderInvId parameter is null in method getSpecimeForResult");
		
		DomainFactory factory = getDomainFactory();
		OrderInvestigation doOrderInvest = (OrderInvestigation) factory.getDomainObject(OrderInvestigation.class, orderInvId);
		
		OrderSpecimenRefVo voSpecRef = new OrderSpecimenRefVo();
		voSpecRef.setID_OrderSpecimen(((OrderSpecimen)doOrderInvest.getSpecimen().get(0)).getId());
		
		return voSpecRef;
	}
	
	public ClinicLiteVoCollection listClinics(String nameFilter, LocationRefVo voLocRef)
	{
		ClinicAdmin clinAdmin = (ClinicAdmin)getDomainImpl(ClinicAdminImpl.class);
		return clinAdmin.listClinicsForLocationByClinicName(voLocRef, nameFilter, true);
	}

	public ServiceLiteVoCollection listDiscipline() 
	{
		//WDEV-11246
		return ServiceLiteVoAssembler.createServiceLiteVoCollectionFromService(getDomainFactory().find("from Service as srv where srv.isActive = 1 and srv.serviceCategory.id in ( " + getIdStringForPathRad() + " ) order by srv.serviceName")); 
	}

	private String getIdStringForPathRad() 
	{	
		String ids = "";
		ids += ServiceCategory.PATHOLOGY_DISCIPLINE.getID();
		ids += "," + ServiceCategory.RADIOLOGY_MODALITY.getID();
		
		return ids;
	}

	/**
	 * WDEV-13321
	 * WDEV-13876 - 'For Review' status no longer depends on the logged on user; 'Reviewing HCP' criteria added
	 * 
	 * This search works as follows Dates AND (Search Criteria OR Reviewing HCP) AND statuses
	 */
	public NewResultsListVoCollection listNewResultsByDateRange(Date dateFrom, Date dateTo, ValueObject location, ValueObject clinician, OrderInvStatusCollection statuses, Boolean inpatientOrders, Boolean outpatientOrders, Boolean excludeInpatients, Integer orderingHCPId, HcpRefVo responsibleClinician, HcpRefVo reviewingHCP, ServiceRefVo discipline)
	{
		if(dateFrom == null)
			throw new CodingRuntimeException("Invalid start date");
		
		Date dtFrom = new Date(dateFrom);
		Date dtTo = new Date();
		if (dateTo == null)
			dtTo = new Date().addDay(1);
		else
			dtTo = new Date(dateTo).addDay(1);
						
		if ((statuses == null || statuses.size() == 0) && reviewingHCP == null)
			return new NewResultsListVoCollection();
		
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();		
		StringBuffer sb = new StringBuffer("SELECT DISTINCT (oi) FROM OrderInvestigation AS oi ");
		
		if(responsibleClinician != null) //WDEV-15901
		{
			HcpLiteVo hcp = (HcpLiteVo)responsibleClinician;
			if(hcp.getID_Hcp() == null)
				throw new DomainRuntimeException("Invalid Clinician");
			
			sb.append(" LEFT JOIN oi.orderDetails as ordDet LEFT JOIN ordDet.patient as ordPat LEFT JOIN ordPat.ward AS ward LEFT JOIN ward.type AS type ");
			
			sb.append(" LEFT JOIN ordPat.currentResponsibleConsultant AS cons WHERE ");
		}
		else
		{
			sb.append(" WHERE ");
		}
		
		// Dates will be a mandatory filter for all records
		sb.append("(");
		sb.append("(oi.repDateTime >= :fromDate AND oi.repDateTime < :toDate)");

		markers.add("fromDate");
		values.add(dtFrom.getDate());
		markers.add("toDate");			
		values.add(dtTo.getDate());
		
		if (statuses != null && statuses.contains(OrderInvStatus.REVIEW))
		{
			sb.append(" OR (oi.allocatedDateForReview >= :fromDate AND oi.allocatedDateForReview < :toDate)");
		}
		
		sb.append(")");

		sb.append(" AND ( ");
		
		String condition = "";
		
		// Search criteria
		String openBracket = "(";
		String closeBracket = "";
		String conditionalOperator = " "; 
		
		if (!Boolean.TRUE.equals(inpatientOrders) && !Boolean.TRUE.equals(outpatientOrders))
		{
			if(location != null && location instanceof LocationRefVo)
			{
				LocationRefVo locRef = (LocationRefVo)location;
				
				sb.append(openBracket);
				
				sb.append(condition);
				sb.append(" oi.patientLocation.id = :location");
				markers.add("location");
				values.add(locRef.getID_Location());
				
				condition = " AND ";
				
				openBracket = " ";
				closeBracket = " ) ";
				conditionalOperator = " OR ";
			}
			else if (location != null && location instanceof ClinicRefVo)
			{
				ClinicRefVo clinRef = (ClinicRefVo)location;
				
				sb.append(openBracket);
				
				sb.append(condition);
				sb.append(" oi.patientClinic.id = :clinic");
				markers.add("clinic");
				values.add(clinRef.getID_Clinic());
				
				condition = " AND ";
				
				openBracket = " ";
				closeBracket = " ) ";
				conditionalOperator = " OR ";
 			}
		}
		
		// Current Reponsible HCP
		if(responsibleClinician != null) //WDEV-15901
		{
			HcpLiteVo hcp = (HcpLiteVo)responsibleClinician;
			if(hcp.getID_Hcp() == null)
				throw new DomainRuntimeException("Invalid Clinician");
			
			sb.append(openBracket);
			sb.append(condition);

			sb.append(" (type.id = :WARD_TYPE AND cons.id = :RESPONSIBLE_CLINICIAN) ");
			
			markers.add("WARD_TYPE");
			markers.add("RESPONSIBLE_CLINICIAN");
			values.add(LocationType.WARD.getID());
			values.add(responsibleClinician.getID_Hcp());
			condition = " AND ";

			openBracket = " ";
			closeBracket = " ) ";
			conditionalOperator = " OR ";
		}
		
		
		if(clinician != null && clinician instanceof HcpLiteVo)
		{
			HcpLiteVo hcp = (HcpLiteVo)clinician;
			if(hcp.getID_Hcp() == null)
				throw new DomainRuntimeException("Invalid clinician");
			
			sb.append(openBracket);
			
			sb.append(condition);
			sb.append(" oi.responsibleClinician.id = :hcp");
			markers.add("hcp");			
			values.add(hcp.getID_Hcp());
			
			condition = " AND ";

			openBracket = " ";
			closeBracket = " ) ";
			conditionalOperator = " OR ";
		}		
		else if(clinician != null && clinician instanceof GpLiteVo)
		{
			GpLiteVo gp = (GpLiteVo)clinician;
			if(gp.getID_Gp() == null)
				throw new DomainRuntimeException("Invalid GP");

			sb.append(openBracket);
			
			sb.append(condition);
			sb.append(" oi.responsibleGp.id = :gp");
			markers.add("gp");			
			values.add(gp.getID_Gp());
			
			condition = " AND ";
			
			openBracket = " ";
			closeBracket = " ) ";
			conditionalOperator = " OR ";
		}
		if (Boolean.TRUE.equals(inpatientOrders))
		{
			sb.append(openBracket);
			
			sb.append(condition);
			sb.append(" oi.orderDetails.patientLocation is not null AND oi.orderDetails.patientLocation.type.id = :WARD_TYPE ");
			
			markers.add("WARD_TYPE");
			values.add(LocationType.WARD.getID());
			
			condition = " AND ";
			
			openBracket = " ";
			closeBracket = " ) ";
			conditionalOperator = " OR ";
		}
		if (Boolean.TRUE.equals(outpatientOrders))
		{
			sb.append(openBracket);
			
			sb.append(condition);
			sb.append(" oi.orderDetails.patientClinic is not null ");
			
			condition = " AND ";
			
			openBracket = " ";
			closeBracket = " ) ";
			conditionalOperator = " OR ";
		}
		
		if (Boolean.TRUE.equals(excludeInpatients))
		{
			sb.append(openBracket);
			
			sb.append(condition);
			sb.append(" oi.orderDetails.patient.ward is null");
			
			condition = " AND ";
			
			openBracket = " ";
			closeBracket = " ) ";
			conditionalOperator = " OR ";
		}
				
		if(orderingHCPId != -1)
		{
			sb.append(openBracket);
			
			sb.append(condition);
			sb.append(" (oi.orderDetails.orderedBy is not null AND oi.orderDetails.orderedBy.id = :orderedById) ");
			markers.add("orderedById");
			values.add(orderingHCPId);
			
			condition = " AND ";
			
			openBracket = " ";
			closeBracket = " ) ";
			conditionalOperator = " OR ";
		}
			
		if(discipline != null && discipline.getID_ServiceIsNotNull())
		{
			sb.append(openBracket);
			
			sb.append(condition);
			sb.append(" oi.investigation.providerService.locationService.service.id = :discipline ");
			markers.add("discipline");
			values.add(discipline.getID_Service());
			
			condition = " AND ";
			
			openBracket = " ";
			closeBracket = " ) ";
			conditionalOperator = " OR ";
		}
		
		sb.append(closeBracket);
		
		if (reviewingHCP != null)
		{
			sb.append(conditionalOperator);
			sb.append(" oi.allocatedHCPforReview.id = ").append(reviewingHCP.getID_Hcp());
		}
		
		sb.append(" ) ");
		
		
		sb.append(" AND oi.ordInvCurrentStatus.ordInvStatus.id in (");

		StringBuffer sts = new StringBuffer();

		for (int i = 0; i < statuses.size(); i++)
		{
			sts.append(statuses.get(i).getId());

				if (i != statuses.size() - 1) 																			// Not the last element
				{
					sts.append(",");
				}
		}
		
		sb.append(sts.toString());
		sb.append(")");
		
		//WDEV-16232 - starts here
		sb.append(" and (oi.investigation.eventType.id = :SingleSeries or (oi.investigation.eventType.id = :TimeSeries and oi.resultStatus.id = :Final))");
		markers.add("SingleSeries");
		values.add(InvEventType.SINGLE_EVENT.getID());
		markers.add("TimeSeries");
		values.add(InvEventType.TIME_SERIES.getID());
		markers.add("Final");
		values.add(ResultStatus.FINAL.getID());
		//WDEV-16232 - ends here
		
			
		sb.append(" ORDER BY oi.allocatedDateForReview desc, oi.repDateTime DESC, oi.ordInvSeq ASC");
		
		List<?> results = getDomainFactory().find(sb.toString(), markers, values);
		
		//WDEV-12054
		NewResultsListVoCollection voCollResults = processResults(results);
			
		return voCollResults;
	}

	private NewResultsListVoCollection processResults(List<?> results)
	{
		HashMap map = new HashMap();
		ClinicalImagingResults impl = (ClinicalImagingResults) getDomainImpl(ClinicalImagingResultsImpl.class);
		map = impl.getListXoHistory(map, results);
		
		NewResultsListVoCollection voCollResults = NewResultsListVoAssembler.createNewResultsListVoCollectionFromOrderInvestigation(results);
		
		if(voCollResults != null)
		{
			for(NewResultsListVo voResult : voCollResults)
			{
				if(map.containsKey(voResult.getID_OrderInvestigation()))
				{
					voResult.setOrdInvXOStatusHistory((OrdInvXOStatusHistoryLiteVoCollection) map.get(voResult.getID_OrderInvestigation()));
				}
			}
		}
		return voCollResults;
	}

	public RoleDisciplineSecurityLevelLiteGCVo getRoleDisciplineSecurityLevels(IAppRole role) 
	{
		SelectandOrder impl = (SelectandOrder)getDomainImpl(SelectandOrderImpl.class);
		return impl.getRoleDisciplineSecurityLevels(role);
	}

	public HcpLiteVoCollection listHcpLiteByName(String hcpName)
	{
		MyOrder impl = (MyOrder)getDomainImpl(MyOrderImpl.class);
		return impl.listHcpLiteByName(hcpName);
	}

	// WDEV-12070
	public MedicVo getConsultantMedicForHCP(HcpRefVo hcp)
	{
		if (hcp == null || !hcp.getID_HcpIsNotNull())
			return null;
		
		return MedicVoAssembler.create((Medic) getDomainFactory().getDomainObject(Medic.class, hcp.getID_Hcp()));
	}

	// WDEV-15709
	public String getMappingForResultStatusLookup(ResultStatus resultStatusInstance, TaxonomyType extSystem) 
	{
		if(resultStatusInstance == null || extSystem == null || extSystem.getText() == null)
			return null;
		
		String query = "select lm.extCode from LookupInstance as li left join li.mappings as lm where (li.id = :ResultStatusId and lm.extSystem = :TaxonomyType) ";
		
		List<?> list = getDomainFactory().find(query, new String[] {"ResultStatusId", "TaxonomyType"}, new Object[] {resultStatusInstance.getID(), extSystem.getText()});
		
		if(list != null && list.size() > 0)
		{
			if(list.get(0) instanceof String)
				return (String) list.get(0);
		}
		
		return null;
	}

	//WDEV-17494
	public LocationLiteVo getCurrentHospital(ILocation currentLocation) 
	{
		if(currentLocation == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		Location currentHospital = getHospital((Location) factory.getDomainObject(Location.class, currentLocation.getID()));
		
		if(currentHospital instanceof Location)
			return LocationLiteVoAssembler.create((Location) currentHospital);
		
		return null;
	}
	
	private Location getHospital(Location doLocation)
	{
		if(doLocation == null)
			return null;
		
		if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
			return doLocation;
	
		while(doLocation.getParentLocation() != null) 
		{
			doLocation = doLocation.getParentLocation();
			if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
				return doLocation;
		}
		
		return null;
	}
}
