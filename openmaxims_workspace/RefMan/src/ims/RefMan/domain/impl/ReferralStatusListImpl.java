// This code was generated by Rory Fitzpatrick using IMS Development Environment (version 1.62 build 3110.16630)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.RefMan.domain.impl;

import ims.admin.domain.MosAdmin;
import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.MosAdminImpl;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.RefMan.domain.AtConsultation;
import ims.RefMan.domain.ClinicList;
import ims.RefMan.domain.PatientReferralStatusList;
import ims.RefMan.domain.ReferralDetails;
import ims.RefMan.domain.ReferralDetailsComponent;
import ims.RefMan.domain.ReferralWizard;
import ims.RefMan.domain.base.impl.BaseReferralStatusListImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.ConsultationDetails;
import ims.RefMan.domain.objects.DischargeSummaryPacuAndWard;
import ims.RefMan.domain.objects.ProviderCancellation;
import ims.RefMan.domain.objects.ReferralReject;
import ims.RefMan.domain.objects.ReferralService;
import ims.RefMan.helper.CatsReferralManualClass;
import ims.RefMan.vo.CATSReferralFilterVo;
import ims.RefMan.vo.CatsReferralListManualAssemblyVo;
import ims.RefMan.vo.CatsReferralListManualAssemblyVoCollection;
import ims.RefMan.vo.CatsReferralListVo;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.CatsReferralStatusVo;
import ims.RefMan.vo.CatsReferralStatusVoCollection;
import ims.RefMan.vo.CatsReferralWizardVo;
import ims.RefMan.vo.ConsultationDetailsVo;
import ims.RefMan.vo.ContractConfigForReferralDetailsComponentVo;
import ims.RefMan.vo.ContractConfigForReferralDetailsComponentVoCollection;
import ims.RefMan.vo.ContractConfigurationVoCollection;
import ims.RefMan.vo.ContractServiceLocationsConfigVo;
import ims.RefMan.vo.ContractServiceLocationsConfigVoCollection;
import ims.RefMan.vo.DischargeSummaryPacuAndWardLiteVoCollection;
import ims.RefMan.vo.OnwardReferralFromTriageVo;
import ims.RefMan.vo.PatientElectiveListRefVo;
import ims.RefMan.vo.ProviderCancellationRefVo;
import ims.RefMan.vo.ProviderCancellationVo;
import ims.RefMan.vo.ReferralServiceFullVo;
import ims.RefMan.vo.RejectReferralVo;
import ims.RefMan.vo.domain.CatsReferralListVoAssembler;
import ims.RefMan.vo.domain.CatsReferralStatusVoAssembler;
import ims.RefMan.vo.domain.CatsReferralWizardVoAssembler;
import ims.RefMan.vo.domain.ConsultationDetailsVoAssembler;
import ims.RefMan.vo.domain.ContractConfigForReferralDetailsComponentVoAssembler;
import ims.RefMan.vo.domain.ContractConfigurationVoAssembler;
import ims.RefMan.vo.domain.ContractServiceLocationsConfigVoAssembler;
import ims.RefMan.vo.domain.DischargeSummaryPacuAndWardLiteVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListVoAssembler;
import ims.RefMan.vo.domain.ProviderCancellationVoAssembler;
import ims.RefMan.vo.domain.ReferralServiceFullVoAssembler;
import ims.RefMan.vo.domain.RejectReferralVoAssembler;
import ims.RefMan.vo.lookups.AdditionalInvestigationAppointmentsStatus;
import ims.RefMan.vo.lookups.DischargeToGPDetailsReviewStatus;
import ims.RefMan.vo.lookups.DischargeType;
import ims.RefMan.vo.lookups.FollowupManagementType;
import ims.RefMan.vo.lookups.OnwardReferralReason;
import ims.RefMan.vo.lookups.ReferralApptStatus;
import ims.RefMan.vo.lookups.ReferralWorklistStatus;
import ims.RefMan.vo.lookups.ReportNoteType;
import ims.RefMan.vo.lookups.ReportStatus;
import ims.RefMan.vo.lookups.ReportsRequiredSubCategory;
import ims.RefMan.vo.lookups.SecondOpinionCategory;
import ims.RefMan.vo.lookups.TLTType;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.admin.vo.EpisodeOfCareRefVo;
import ims.core.clinical.vo.ProcedureRefVo;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.configuration.domain.objects.ContractConfig;
import ims.core.configuration.vo.ContractConfigRefVo;
import ims.core.configuration.vo.ContractConfigRefVoCollection;
import ims.core.documents.domain.objects.PatientDocument;
import ims.core.domain.ADT;
import ims.core.domain.Alerts;
import ims.core.domain.ProcedureList;
import ims.core.domain.impl.ADTImpl;
import ims.core.domain.impl.AlertsImpl;
import ims.core.domain.impl.ProcedureListImpl;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.domain.objects.Organisation;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.resource.place.vo.OrganisationRefVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MemberOfStaffShortVo;
import ims.core.vo.MemberOfStaffVo;
import ims.core.vo.OrgShortVo;
import ims.core.vo.OrganisationLiteVo;
import ims.core.vo.OrganisationVoCollection;
import ims.core.vo.PatientDocumentLiteVo;
import ims.core.vo.PatientShort;
import ims.core.vo.ProcedureLiteVo;
import ims.core.vo.ProcedureLiteVoCollection;
import ims.core.vo.ReferralNoteVo;
import ims.core.vo.ServiceFunctionLiteVoCollection;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.PatientDocumentLiteVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.domain.ReferralNoteVoAssembler;
import ims.core.vo.domain.ServiceFunctionLiteVoAssembler;
import ims.core.vo.lookups.DocumentCategory;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.PatIdType;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.core.vo.lookups.ReferralManagementContractType;
import ims.core.vo.lookups.ServiceCategory;
import ims.core.vo.lookups.WaitingListStatus;
import ims.domain.DomainFactory;
import ims.domain.DomainFactory.ORDERMODE;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.hibernate3.IMSCriteria;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;
import ims.ocrr.vo.lookups.OrderInvStatus;
import ims.scheduling.domain.DirectoryOfServiceAdmin;
import ims.scheduling.domain.impl.DirectoryOfServiceAdminImpl;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentShortVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.DirectoryOfServiceLiteVoCollection;
import ims.scheduling.vo.DirectoryofServiceRefVo;
import ims.scheduling.vo.ProfileShortVoCollection;
import ims.scheduling.vo.domain.Booking_AppointmentShortVoAssembler;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.DirectoryOfServiceLiteVoAssembler;
import ims.scheduling.vo.domain.ProfileShortVoAssembler;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.vo.LookupInstVo;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

public class ReferralStatusListImpl extends BaseReferralStatusListImpl implements PatientReferralStatusList
{
	private static final long serialVersionUID = 1L;

	/**
	* based on the parameter passed will return a DirectoryOfServiceVoCollection
	*/
	public DirectoryOfServiceLiteVoCollection listDirectoryOfService(ims.scheduling.vo.DirectoryOfServiceVo directoryOfService)
	{
		DomainFactory factory = getDomainFactory();

		StringBuffer query = new StringBuffer(" FROM DirectoryofService dos "); 
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		if (directoryOfService.getIsActiveIsNotNull())
		{
			query.append("WHERE dos.isActive = :IS_ACTIVE");

			paramNames.add("IS_ACTIVE");
			paramValues.add(directoryOfService.getIsActive());		
		}
		
		return DirectoryOfServiceLiteVoAssembler.createDirectoryOfServiceLiteVoCollectionFromDirectoryofService(factory.find(query.toString(), paramNames, paramValues));
	}

	
	public ProfileShortVoCollection listClinics_Profiles(DirectoryofServiceRefVo voDOSRef)
	{
		if (voDOSRef == null)
			return null;
		
		String query = "select distinct profile from Sch_Profile as profile left join profile.directoryOfServices as doServices where doServices.id = :idDOS and doServices.isRIE is null and doServices.isActive = " + Boolean.TRUE;

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
	
		markers.add("idDOS");
		values.add(voDOSRef.getID_DirectoryofService());

		return ProfileShortVoAssembler.createProfileShortVoCollectionFromSch_Profile(getDomainFactory().find(query, markers, values));		
	}

	
	public CatsReferralListManualAssemblyVoCollection listCATSReferrals(CATSReferralFilterVo voCATSFilter, Boolean bIncludeICPColumn, Boolean bIncludeELEColumn) 
	{
		if (voCATSFilter == null)
			throw new CodingRuntimeException("Invalid voCATSFilter");

		String hqlSB = getBaseSelectQuery(bIncludeICPColumn, bIncludeELEColumn);
		hqlSB += "from CatsReferral as catsref ";
		hqlSB += getBaseJoinQuery();
		
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();

		StringBuffer sb = new StringBuffer();
		String hqlJoin = "";
		String andStr = "";

		if(voCATSFilter.getPatientIsNotNull())
		{
			sb.append(" catsref.patient.id = :pat");
			markers.add("pat");
			values.add(voCATSFilter.getPatient().getID_Patient());
			
			sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
			hqlSB+= " where ";
			
			hqlSB+= sb.toString();
			
			return assembleRecords(getDomainFactory().find(hqlSB.toString(), markers, values));
		}
		
		if (voCATSFilter.getContractIsNotNull())
		{
			sb.append(andStr + " ( catsref.contract.id = :contra ) ");
			markers.add("contra");
			values.add(voCATSFilter.getContract().getID_ContractConfig());
			andStr = " and ";
		}
		else if (voCATSFilter.getContractsForOrgIsNotNull())
		{
			StringBuffer sbContracts = new StringBuffer();
			for (int cOrgs = 0 ; voCATSFilter.getContractsForOrgIsNotNull() && cOrgs < voCATSFilter.getContractsForOrg().size() ; cOrgs++)
			{
				sbContracts.append(voCATSFilter.getContractsForOrg().get(cOrgs).getID_ContractConfig());
				if (cOrgs+1 < voCATSFilter.getContractsForOrg().size())
					sbContracts.append(", ");
			}

			sb.append(andStr + " ( catsref.contract.id in (" + sbContracts.toString() + ") ) ");
			andStr = " and ";
		}

		//WDEV-7447
		if (voCATSFilter.getLocationIsNotNull())
		{
			sb.append(andStr + " ( refDetails.location.id = :loc ) ");
			markers.add("loc");
			values.add(voCATSFilter.getLocation().getID_Location());
			andStr = " and ";
		}
		//wdev-13652
		if(voCATSFilter.getTreatmentCenterIsNotNull())
		{
			sb.append(andStr + " ( catsref.nearestTreatmentCentre.id = :treatCenter ) ");
			markers.add("treatCenter");
			values.add(voCATSFilter.getTreatmentCenter().getLocation().getID_Location());
			andStr = " and ";
			
		}
		//---------------

		if (voCATSFilter.getServiceIsNotNull())
		{
			sb.append(andStr + " ( (refDetails.service.id = :serv ) ");
			markers.add("serv");
			values.add(voCATSFilter.getService().getID_Service());

			sb.append(" or (catsref.isCAB = :cab2 and refDetails = null) ) ");
			markers.add("cab2");
			values.add(Boolean.TRUE);
			andStr = " and ";
		}
		
		if (voCATSFilter.getReviewTypeIsNotNull())
		{
			hqlJoin += " join catsref.currentReviewDetail as reviewedRecs ";

			sb.append(andStr + " reviewedRecs.reviewType.id = :type");
			markers.add("type");
			values.add(voCATSFilter.getReviewType().getID());
			andStr = " and ";
		}
		
		if (voCATSFilter.getClinicTypeIsNotNull())
		{
			sb.append(andStr + " refDetails.function.id = :ct");
			markers.add("ct");
			values.add(voCATSFilter.getClinicType().getID_ServiceFunction());
			andStr = " and ";
		}
		// WDEV-17895 isDad label has been removed
		/*
		if (voCATSFilter.getIsDADIsNotNull() 
			&& voCATSFilter.getIsDAD().booleanValue())
		{
			sb.append(andStr + " refDetails.isDADReferral = :dad");
			markers.add("dad");
			values.add(Boolean.TRUE);
			andStr = " and ";
		}
		 */
		
		if (voCATSFilter.getIsCABIsNotNull() 
			&& voCATSFilter.getIsCAB().booleanValue())
		{
			sb.append(andStr + " catsref.isCAB = :cab");
			markers.add("cab");
			values.add(Boolean.TRUE);
			andStr = " and ";
		}

		if (voCATSFilter.getIsManualIsNotNull() 
			&& voCATSFilter.getIsManual().booleanValue())
		{
			sb.append(andStr + " catsref.isCAB = :cab");
			markers.add("cab");
			values.add(Boolean.FALSE);
			andStr = " and ";
		}

		if (voCATSFilter.getDOSIsNotNull())
		{
			sb.append(andStr + " catsref.dOS.id = :dos");
			markers.add("dos");
			values.add(voCATSFilter.getDOS().getID_DirectoryofService());
			andStr = " and ";
		}

		if (voCATSFilter.getNHSNumberIsNotNull())
		{
			hqlJoin += " join catsref.patient.identifiers as patids ";
			
			sb.append(andStr + " patids.type = :idType");
			markers.add("idType");
			values.add(getDomLookup(PatIdType.NHSN));
			andStr = " and ";

			sb.append(andStr + " patids.value like :idValue");
			markers.add("idValue");
			values.add(voCATSFilter.getNHSNumber() + "%");
			andStr = " and ";
		}

		if (voCATSFilter.getExcludeProviderCancellationIsNotNull()
			&& voCATSFilter.getExcludeProviderCancellation().booleanValue()
			&& ( voCATSFilter.getStatus() == null
				|| ( voCATSFilter.getStatusIsNotNull()
						&& ! voCATSFilter.getStatus().equals(ReferralWorklistStatus.PROVIDER_CANCELLATION)) ))
		{
			sb.append(andStr + " catsref.currentStatus.referralStatus != :providerCancellation ");
			markers.add("providerCancellation");
			values.add(getDomLookup(ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER));
			andStr = " and ";
		}
		
		if (voCATSFilter.getFromDateIsNotNull() && voCATSFilter.getToDateIsNotNull())
		{
			sb.append(andStr + " ( ( refDetails != null and refDetails.dateOfReferral between :fromdate and :todate )");
			markers.add("fromdate");
			values.add(new DateTime(voCATSFilter.getFromDate(), new Time("00:00:00")).getJavaDate() );
			markers.add("todate");
			values.add(new DateTime(voCATSFilter.getToDate(), new Time("23:59:59")).getJavaDate() );
			andStr = " and ";

			sb.append(" or (refDetails = null and catsref.isCAB = :cab1) )");
			markers.add("cab1");
			values.add(Boolean.TRUE);

		}
		else if (voCATSFilter.getFromDateIsNotNull() && voCATSFilter.getToDate() == null)
		{
			sb.append(andStr + " ( (refDetails = null and catsref.isCAB = :cab1) " +
					"or (refDetails != null and refDetails.dateOfReferral >= :fromdate) ) ");
			markers.add("cab1");
			values.add(Boolean.TRUE);
			markers.add("fromdate");
			values.add(new DateTime(voCATSFilter.getFromDate(), new Time("00:00:00")).getJavaDate() );
			andStr = " and ";
			
		}
		else if (voCATSFilter.getFromDate() == null && voCATSFilter.getToDateIsNotNull())
		{
			sb.append(andStr + " ( (refDetails = null and catsref.isCAB = :cab1)" +
				"or (refDetails != null and refDetails.dateOfReferral <= :todate) ) ");
			markers.add("cab1");
			values.add(Boolean.TRUE);
			markers.add("todate");
			values.add(new DateTime(voCATSFilter.getToDate(), new Time("23:59:59")).getJavaDate() );
			andStr = " and ";
		}
	
		//wdev-15109
		PatIdType dispIdType = PatIdType.getNegativeInstance(ConfigFlag.UI.DISPLAY_PATID_TYPE.getValue()); 
		if (dispIdType == null)
			sb.append(andStr + "  patidtype1.id = -9 ");
		else
			sb.append(andStr + "  patidtype1.id = " + dispIdType.getID() );
		//wdev-15109
		
		andStr = " and ";

		List<?> refList = null;
		
		if (voCATSFilter.getStatusIsNotNull())
		{
			if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.AWAITING_REFERRAL_LETTER))
				refList = domListAwaitingReferralLetter(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.AWAITING_TRIAGE))
				refList = domListAwaitingTriage(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.CONSULTATION_APPOINTMENT_REQUIRED))
				refList = domListConsAppointmentRequired(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.OTHER_APPOINTMENTS_REQUIRED))
				refList = domListOtherApptsRequired(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.PROVISIONAL_REJECTION))
				refList = domListProvisionalRejection(hqlSB, sb, markers, values, andStr, voCATSFilter.getSecondOpinionReason(), hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REFERRAL_ACCEPTED))
				refList = domListReferralAccepted(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REFERRAL_REJECTED))
				refList = domListReferralRejected(hqlSB, sb, markers, values, andStr,voCATSFilter.getIsCAB(), hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REVIEW_APPOINTMENTS))
				refList = domListReviewAppointments(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REJECTED_INVESTIGATIONS))
				refList = domListRejectedInvestigations(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REFERRALS_PENDING_RESULTS))
				refList = domListPendingResults(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.FLAGGED_FOR_REVIEW))
				refList = domListFlaggedForReview(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.PROVIDER_CANCELLATION))
				refList = domListProviderCancellation(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.FURTHER_MANAGMENT_REQUIRED))
				refList = domListFurtherManagementRequired(bIncludeICPColumn, bIncludeELEColumn, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.FINAL_DISCHARGE_DOCUMENT_REQUIRED))
				refList = domListFinalDischargeDocumentRequired(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.DISCHARGED_REFERRALS))
				refList = domListDischargeReferrals(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.ORDERINV_ACCEPTED_APPT_REQUIRED))
				refList = domListOrderInvAcceptedApptRequired(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.FIT_FOR_SURGERY_NEED_APPT))
				refList = domListFitForSurgeryAndNeedAppointment(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REVIEW_CANCELLED_APPOINTMENTS))
				refList = domListReviewCancelledAppointments(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REVIEW_DNA_APPOINTMENTS))
				refList = domListReviewDNAAppointments(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.CAB_REFERRALS_TO_BE_ACCEPTED_ON_CAB))
				refList = domListCABReferralsToBeAcceptedOnCAB(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.ONWARD_REFERRAL_WORKLIST))
				refList = domListOnwardReferralWorklist(bIncludeICPColumn, bIncludeELEColumn, sb, markers, values, andStr, hqlJoin, voCATSFilter.getOnwardReferralReason());
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REPORTS_REQUIRED_WORKLIST))
				refList = domListReportsRequiredWorklist(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter.getReportSubCategory());
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.DISCHARGE_REPORT_WORKLIST))
				refList = domListDischargeReportRequired(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.MY_ALLOCATED_WORKLIST))
				refList = domListMyAllocatedWorklist(bIncludeICPColumn, bIncludeELEColumn, sb, markers, values, andStr, hqlJoin, voCATSFilter.getAllocatedTo());
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.FURTHER_MANAGEMENT_REQUIRED_TLT))
				refList = domListFurtherManagementTLTRequired(bIncludeICPColumn, bIncludeELEColumn, sb, markers, values, andStr, hqlJoin, voCATSFilter.getTLTType());
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.NOT_FIT_OR_SUITABLE_FOR_SURGERY))
				refList = domListNotFitOrUnsuitableForSurgery(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter.getTLTType());
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.RefMan_REPORTS_REQUIRED_WORKLIST))
				refList = domListRefManReportsRequiredWorklist(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter.getNoteType());
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.DISCHARGED_TO_GP))
				refList = domListDischargeToGPWorklist(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter.getNoteType());
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REFER_BACK_TO_CONS_WORKLIST))
				refList = domListReferBackToConsultantWorklist(bIncludeICPColumn, bIncludeELEColumn, sb, markers, values, andStr, hqlJoin, voCATSFilter.getNoteType());
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.AWAITING_CLINICAL_INFO))
				refList = domListAwaitingClinicalInformationWorklist(bIncludeICPColumn, bIncludeELEColumn, sb, markers, values, andStr, hqlJoin, voCATSFilter.getNoteType());
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.ACTIVE_MONITORING_REQ_APPOINTMENT))
				refList = domListActiveMonitoringWorklistApptRequired(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.ACTIVE_MONITORING))
				refList = domListActiveMonitoringWorklist(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.TWENTYFOUR_HOUR_POST_OP))
				refList = domList24HourMonitoringWorklist(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter.getProcedure());
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.REFERRAL_TRIAGE_WORKLIST))
				refList = domListReferralTriageWorklist(hqlSB, sb, markers, values, andStr, hqlJoin);
			else if (voCATSFilter.getStatus().equals(ReferralWorklistStatus.OP_PROCEDURE_AWAITING_APPOINTMENT))    //wdev-13765
				refList = domListopProcedureAawaittingAppointment(hqlSB, sb, markers, values, andStr, hqlJoin, voCATSFilter.getTLTType(),voCATSFilter); //wdev-13765
			
		}
		else
		{
			if (hqlJoin != "")
				hqlSB += hqlJoin;
			
			sb.append(andStr + " catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
			hqlSB += " where ";
			
			hqlSB += sb.toString();
			return assembleRecords(getDomainFactory().find(hqlSB.toString(), markers, values));
		}
		
		if (refList == null || refList.size() == 0)
			return null;
		else
			return assembleRecords(refList);
	}

	private List<?> domListReferralTriageWorklist(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin)
	{
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " ( catsref.currentStatus.referralStatus = :ID ");
		markers.add("ID");
		values.add(getDomLookup(ReferralApptStatus.ONWARDREFERRALREQUESTED));

		sb.append(" and catsref.isOnwardReferralTriage = :id2) ");
		markers.add("id2");
		values.add(Boolean.TRUE);

		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private String getBaseJoinQuery() 
	{
		return 	"left join catsref.patient as pat1 " +
			"left join catsref.additionalInvApptsStatus as addinv " +
			"left join pat1.name.title as title1 " +
			"left join pat1.identifiers as patid1 " +
			"left join patid1.type as patidtype1 " +
			"left join catsref.referralDetails as refDetails " +
			"left join refDetails.service as service1 " +
			"left join refDetails.location as loc1 " +
			"left join catsref.currentStatus as stat1 " +
			"left join stat1.referralStatus as refstat1 " +
			"left join catsref.consultationAppt as appt1 ";
	}


	private String getBaseSelectQuery(Boolean includeICPColumn, Boolean includeELEColumn) 
	{
		//wdev-15109
		String hqlSB = "select new ims.RefMan.helper.CatsReferralManualClass( catsref.id, title1.text, pat1.name.surname, pat1.name.forename, " +
		" (select max(p21_1.value) from Patient as p11_1 left join p11_1.identifiers as p21_1 where (p21_1.type = -9 and p11_1.id = pat1.id)) as ANY_NHS, " +
		" (select max(p211_1.value) from Patient as p111_1 left join p111_1.identifiers as p211_1 where (p211_1.type = -9 and p211_1.verified = 1 and p111_1.id = pat1.id)) as VERIFIED_NHS," +
		" pat1.dod, ";
		//wdev-15109

		if (includeICPColumn)
			hqlSB+="(select max(icp.careContext.id) from PatientICP as icp where icp.careContext.id = catsref.careContext.id),";//WDEV-12965
		else
			hqlSB+= "catsref.id, ";
		
		if (includeELEColumn)
			hqlSB+="(select max(ele.id) from PatientElectiveList as ele where ele.referral.id = catsref.id),";//WDEV-18389
		else
			hqlSB+= "catsref.id, ";
			
		hqlSB+="refDetails.dateOfReferral, catsref.isCAB, loc1.name, service1.serviceName, catsref.isFlaggedForReview, refDetails.end18WW, catsref.isCurrentlyAllocated, " +
		"catsref.hasInvestigations, addinv.id, refstat1.id, refstat1.text, catsref.hasAppointments, " +
		"appt1.apptStatus.id, appt1.appointmentDate, appt1.apptStartTime, pat1.associatedPatient.id , refDetails.dateReferralReceived, catsref.hasDocuments, catsref.hasReferralLetter)";
		return hqlSB;
	}

	private List<?> domListActiveMonitoringWorklist(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.currentStatus.referralStatus = :ID ");
		
		markers.add("ID");
		values.add(getDomLookup(ReferralApptStatus.ACTIVE_MONITORING));

		sb.append(" and ( catsref.isActiveMonitorApptRequired = :id2 or catsref.isActiveMonitorApptRequired = null ) ");
		markers.add("id2");
		values.add(Boolean.FALSE);

		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}
	
	private List<?> domList24HourMonitoringWorklist(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin, ProcedureRefVo voProc) 
	{
		//String hql = "select catsref from CatsReferral as catsref left join catsref.referralDetails as refDetails "; 

		if (hqlJoin != "")
			hql += hqlJoin;

		if (voProc != null)
		{
			sb.append(andStr + " catsref.procedureForPostOpReview.procedure.id = :procID ");
			markers.add("procID");
			values.add(voProc.getID_Procedure());
			andStr = " and ";
		}
		else
		{
			sb.append(andStr + " catsref.procedureForPostOpReview is not null");
			andStr = " and ";
		}
		
		sb.append(andStr + " catsref.dischargeDate != null");

		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}
	
	private List<?> domListActiveMonitoringWorklistApptRequired(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
	//	String hql = "select catsref from CatsReferral as catsref left join catsref.referralDetails as refDetails "; 

		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.currentStatus.referralStatus = :ID ");
		markers.add("ID");
		values.add(getDomLookup(ReferralApptStatus.ACTIVE_MONITORING));
	
		sb.append(" and catsref.isActiveMonitorApptRequired = :id2 ");
		markers.add("id2");
		values.add(Boolean.TRUE);

		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	
	private List<?> domListAwaitingClinicalInformationWorklist(Boolean includeICPColumn, Boolean bIncludeELEColumn, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin, ReportNoteType noteType) 
	{
	//	String hql = "select catsref from CatsReferral as catsref left join catsref.referralDetails as refDetails "; 
	//	hql += "left join catsref.appointments as bappts";

		String hql = getBaseSelectQuery(includeICPColumn, bIncludeELEColumn);
		hql += "from CatsReferral as catsref ";
		hql += getBaseJoinQuery();
		hql += "left join catsref.appointments as bappts ";

		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.isAwaitingClinicalInfo = :awaiting ");
		markers.add("awaiting");
		values.add(Boolean.TRUE);

		sb.append(" and ( ( catsref.appointments is empty )");
		sb.append(" or ( (bappts.arrivalTime is null) )");

		sb.append(" and catsref.careContext.id not in ( ");

		sb.append("select catsref2.careContext.id from CatsReferral as catsref2 left join catsref2.appointments as bappts2 " +
				"where ( ( catsref2.appointments is empty ) or (bappts2.arrivalTime is not null) )");

		sb.append(" ) )");
		
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListReferBackToConsultantWorklist(Boolean includeICPColumn, Boolean bIncludeELEColumn, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin, ReportNoteType noteType) 
	{
	//	String hql ="select catsref from ReferralOutcome as ra right join ra.catsReferral as catsref " +
	//	"left join catsref.referralDetails as refDetails " +
	//	"left join ra.furtherManagementDetails as fmd "; 
		
		
		String hql = getBaseSelectQuery(includeICPColumn, bIncludeELEColumn);
		hql += "from ReferralOutcome as ra right join ra.catsReferral as catsref ";
		hql += getBaseJoinQuery();
		hql += "left join ra.furtherManagementDetails as fmd ";

		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.currentStatus.referralStatus = :id1");
		sb.append(" and catsref.wasFurtherManagementDetailsReviewed = null");
		sb.append(" and fmd.followupType = :id2");
	
		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.FURTHER_MANAGEMENT_REQUIRED));
		markers.add("id2");
		values.add(getDomLookup(FollowupManagementType.REFER_BACK_TO_CONSULTANT));
	
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);	
	}

	private List<?> domListDischargeToGPWorklist(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin, ReportNoteType noteType) 
	{
		//String hql = "select catsref from CatsReferral as catsref left join catsref.referralDetails as refDetails ";
		
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.dischargeDate is not null");					
		sb.append(" and catsref.dischargeToGPDetailsReviewStatus = :id1");					
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		markers.add("id1");
		values.add(getDomLookup(DischargeToGPDetailsReviewStatus.TO_BE_REVIEWED));
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListNotFitOrUnsuitableForSurgery(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin, TLTType type) 
	{
		//String hql = "select catsref from CatsReferral as catsref left join catsref.referralDetails as refDetails "; 

		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " ( (catsref.isSuitableForSurgery is not null and catsref.isSuitableForSurgery = :id1) ");
		sb.append(" or ( catsref.isFitForSurgery is not null and catsref.isFitForSurgery = :id2) ) ");
		sb.append(" and catsref.currentStatus.referralStatus not in (:id3) ");

		markers.add("id3");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER));
	
		markers.add("id1");
		values.add(Boolean.FALSE);
		markers.add("id2");
		values.add(Boolean.FALSE);
	
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);	
	}
	//wdev-`13765
	private List<?> domListopProcedureAawaittingAppointment(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin, TLTType type,CATSReferralFilterVo voCATSFilter) 
	{
		//String hql = "select catsref from CatsReferral as catsref left join catsref.referralDetails as refDetails "; 

		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + "  catsref.suitableForSurgeryDate is not null and catsref.hasOPProcAwaitingAppt = :id1 ");
		sb.append(" and catsref.currentStatus.referralStatus not in (:id3) ");

		markers.add("id3");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER));
	
		markers.add("id1");
		values.add(Boolean.TRUE);
				
		if(voCATSFilter.getOPDSiteIsNotNull())
		{
			sb.append(" and catsref.oPDLocation.id = :opdSite ");
			markers.add("opdSite");
			values.add(voCATSFilter.getOPDSite().getID_Location());
			andStr = " and ";
		}
		
		if(voCATSFilter.getSfSFromDateIsNotNull())
		{
			sb.append(" and catsref.suitableForSurgeryDate >= :sfsFrom ");
			markers.add("sfsFrom");
			values.add(voCATSFilter.getSfSFromDate().getDate());
			andStr = " and ";
		}
		
		if(voCATSFilter.getSfSToDateIsNotNull())
		{
			sb.append(" and catsref.suitableForSurgeryDate < :sfsTo ");
			markers.add("sfsTo");
			values.add(((Date) voCATSFilter.getSfSToDate().clone()).addDay(1).getDate());
			andStr = " and ";
		}
		
	
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);	
	}
	//-----------
	private List<?> domListOnwardReferralWorklist(Boolean includeICPColumn, Boolean bIncludeELEColumn, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin, OnwardReferralReason onwardReferralReason) 
	{
		String hql = getBaseSelectQuery(includeICPColumn, bIncludeELEColumn);
		hql += "from ReferralOutcome as ra right join ra.catsReferral as catsref ";
		hql += getBaseJoinQuery();
		hql += "left join ra.referralDischarge as rd "; 


		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.currentStatus.referralStatus = :id1");
		sb.append(" and rd.dischargeType = :id2");
		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.DISCHARGED));
		markers.add("id2");
		values.add(getDomLookup(DischargeType.SEC_CARE));
	
		if (onwardReferralReason != null)
		{
			sb.append(" and catsref.onwardReferralReason = :id3");
			markers.add("id3");
			values.add(getDomLookup(onwardReferralReason));
		}
		else
			sb.append(" and catsref.onwardReferralReason is not null");
		
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);	

	}

	private List<?> domListMyAllocatedWorklist(Boolean includeICPColumn, Boolean bIncludeELEColumn, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin, MemberOfStaffRefVo voAllocatedTo) 
	{
		if (voAllocatedTo == null)
			return null;
		
		String hql = getBaseSelectQuery(includeICPColumn, bIncludeELEColumn);
		hql += "from WorkAllocation as wa right join wa.catsReferral as catsref ";
		hql += getBaseJoinQuery();

	//	String hql = "select catsref from WorkAllocation as wa right join wa.catsReferral as catsref left join catsref.referralDetails as refDetails "; 

		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " wa.allocatedTo.id = :alloc");
		markers.add("alloc");
		values.add(voAllocatedTo.getID_MemberOfStaff());
		andStr = " and ";

		sb.append(andStr + " wa.unallocatedDate is null and wa.completedDateTime is null");
		markers.add("alloc");
		values.add(voAllocatedTo.getID_MemberOfStaff());

		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListDischargeReportRequired(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin, CATSReferralFilterVo voCATSFilter) 
	{
		//String hql = "select catsref from CatsReferral as catsref left join catsref.referralDetails as refDetails "; 

		if (hqlJoin != "")
			hql += hqlJoin;

		
		if(voCATSFilter.getDischargeFromDateIsNotNull())
		{
			sb.append(andStr + " catsref.dischargeDate >= :dischFrom ");
			markers.add("dischFrom");
			values.add(voCATSFilter.getDischargeFromDate().getDate());
			andStr = " and ";
		}
		
		if(voCATSFilter.getDischargeToDateIsNotNull())
		{
			sb.append(" and catsref.dischargeDate < :dischTo ");
			markers.add("dischTo");
			values.add(((Date) voCATSFilter.getDischargeToDate().clone()).addDay(1).getDate());
			andStr = " and ";
		}


		sb.append(andStr + " catsref.requiresDischargeRep = :isReq");
	
		markers.add("isReq");
		values.add(Boolean.TRUE);
	
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private CatsReferralListManualAssemblyVoCollection assembleRecords(List<?> refList) 
	{
		CatsReferralListManualAssemblyVo voItem = null;
		CatsReferralListManualAssemblyVoCollection voColl = new CatsReferralListManualAssemblyVoCollection();
		for (int i = 0 ; i < refList.size(); i ++)
		{
			CatsReferralManualClass doCats = (CatsReferralManualClass)refList.get(i);
			voItem = new CatsReferralListManualAssemblyVo();
	
			voItem.setCatsReferralId(doCats.getCatsReferralId());
			voItem.setPatientName(doCats.getPatientName());
			voItem.setVerifiedNHSNumber(doCats.getPatientnhsnum());
			voItem.setAnyNHSNumber(doCats.getAnynhsnum());
			voItem.setPatientDOD(doCats.getPatientDOD() != null ? new ims.framework.utils.Date(doCats.getPatientDOD()) : null);
			voItem.setLinkedICPID(doCats.getLinkedICPID() != null ? Boolean.TRUE : null);
			voItem.setLinkedELEID(doCats.getLinkedELEID() != null ? Boolean.TRUE : null);
			voItem.setIsCAB(doCats.getisCAB());
			voItem.setReferralLocationName(doCats.getReferralLocationName());
			voItem.setServiceName(doCats.getServiceName());
			voItem.setIsFlaggedForReview(doCats.getisFlaggedForReview());
			voItem.setEnd18WW(doCats.getEnd18WW() != null ? new ims.framework.utils.Date(doCats.getEnd18WW()) : null);
			voItem.setIsCurrentlyAllocated(doCats.getisCurrentlyAllocated());
			voItem.setHasInvestigations(doCats.getHasInvestigations());
			voItem.setCatsCurrentStatus(doCats.getCatsCurrentStatusId() != null ? new LookupInstVo(doCats.getCatsCurrentStatusId(), doCats.getCatsCurrentStatusText(), Boolean.TRUE) : null);
			voItem.setAdditionalInvStatus(doCats.getAdditionalInvStatusID() != null ? new LookupInstVo(doCats.getAdditionalInvStatusID(), "", Boolean.TRUE) : null);
			voItem.setHasApointments(doCats.getHasApointments());
			voItem.setConsultationApptStatus(doCats.getConsAppointmentStatusID() != null ? new LookupInstVo(doCats.getConsAppointmentStatusID(), "", Boolean.TRUE) : null);
			voItem.setConsAppointmentDate(doCats.getConsAppointmentDate() != null ? new ims.framework.utils.Date(doCats.getConsAppointmentDate()) : null);
			voItem.setConsultationApptStartTime(doCats.getConsAppointmentStartTime() != null ? doCats.getConsAppointmentStartTime() : null);
			voItem.setAssociatedPatientId(doCats.getAssociatedPatientId());
			voItem.setDateReceived(doCats.getDateRecieved() != null ? new ims.framework.utils.Date(doCats.getDateRecieved()) : null);

			if (doCats.getEnd18WW() != null)
			{
				StringBuffer sb = new StringBuffer();
				sb.append(voItem.getEnd18WW().getYear());
				
				if (voItem.getEnd18WW().getMonth() > 9)
					sb.append(voItem.getEnd18WW().getMonth());
				else
				{
					sb.append("0");
					sb.append(voItem.getEnd18WW().getMonth());
				}
					
				if (voItem.getEnd18WW().getDay() > 9)
					sb.append(voItem.getEnd18WW().getDay());
				else
				{
					sb.append("0");
					sb.append(voItem.getEnd18WW().getDay());
				}
				voItem.setEnd18wwJulianDate(sb.toString());
			}
			
			//WDEV-12994
			if( voItem.getConsultationApptStatusIsNotNull()	&& voItem.getConsultationApptStatus().equals(Status_Reason.BOOKED))
			{
				if (voItem.getConsAppointmentDateIsNotNull())
				{
					long lval = Date.daysBetween(new Date(voItem.getConsAppointmentDate()), new Date());

					voItem.setDaysLeft(-(int)lval);
				}
			}

			voColl.add(voItem);
		}
		
		return voColl;	
	}

	private List<?> domListReportsRequiredWorklist(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin, ReportsRequiredSubCategory category)
	{
	//	String hql = "select catsref from CatsReferral as catsref left join catsref.referralDetails as refDetails "; 

		if (hqlJoin != "")
			hql += hqlJoin;

		if (category.equals(ReportsRequiredSubCategory.CATS_REPORT_REQUIRED))
		{
			sb.append(andStr + " catsref.isFinalReportRequired = :isRequired");

			markers.add("isRequired");
			values.add(getDomLookup(ReportStatus.REQUIRED));
		}
		//else if (category.equals(ReportsRequiredSubCategory.FOLLOW_UP_NOTES_REP_REQUIRED))
		//	sb.append(andStr + " catsref.isFollowUpNotesReportRequired = :isRequired");				
		//else if (category.equals(ReportsRequiredSubCategory.SUPPLEMENTARY_NOTES_REPORT_REQUIRED))
		//	sb.append(andStr + " catsref.isSupplementaryReportRequired = :isRequired");				
		else if (category.equals(ReportsRequiredSubCategory.SECONDARY_CARE_REPORT))
		{
			sb.append(andStr + " catsref.isSecondaryReportRequired = :isRequired");				
	
			markers.add("isRequired");
			values.add(getDomLookup(ReportStatus.REQUIRED));
		}
				
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListRefManReportsRequiredWorklist(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin, ReportNoteType type)
	{
		hql += "left join catsref.reportsRequired as rr ";

		if (hqlJoin != "")
			hql += hqlJoin;

		if (type != null)
		{
			sb.append(andStr + " rr.reportsRequired = :rrID");
			markers.add("rrID");
			values.add(getDomLookup(type));

			sb.append(" and rr.printedDate = null");
		}
		else
		{
			sb.append(andStr + " rr is not null");//empty ");
			sb.append(" and rr.printedDate = null");
			
		}
			

		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListCABReferralsToBeAcceptedOnCAB(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin)
	{
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.currentStatus.referralStatus = :id1");
		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_ACCEPTED));


		//isSuitableForSurgery = TRUE and isFitrForSurgery = TRUE and hasTheatreAppt = NULL or FALSE 
		sb.append(" and catsref.isCAB = :isCAB ");
		markers.add("isCAB");
		values.add(Boolean.TRUE);
		sb.append(" and catsref.isAcceptedOnCAB = :accCAB ");
		markers.add("accCAB");
		values.add(Boolean.FALSE);
		
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
	
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);	
	}

	private List<?> domListReviewDNAAppointments(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
		sb.append(andStr + " catsref.currentStatus.referralStatus not in (:id1, :id2, :id3, :id4) " +
		" and catsref.hasDNAApptsForReview = :isTRUE ");

		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.DISCHARGED));
		markers.add("id2");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER));
		markers.add("id3");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_REJECTED));
		markers.add("id4");
		values.add(getDomLookup(ReferralApptStatus.CAB_CANCELLATION));
	
		markers.add("isTRUE");
		values.add(Boolean.TRUE);

		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListReviewCancelledAppointments(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
		sb.append(andStr + " catsref.currentStatus.referralStatus not in (:id1, :id2, :id3, :id4) " +
		" and catsref.hasCancelledApptsForReview = :isTRUE ");

		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.DISCHARGED));
		markers.add("id2");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER));
		markers.add("id3");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_REJECTED));
		markers.add("id4");
		values.add(getDomLookup(ReferralApptStatus.CAB_CANCELLATION));
	
		markers.add("isTRUE");
		values.add(Boolean.TRUE);

		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListFitForSurgeryAndNeedAppointment(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin, CATSReferralFilterVo voCATSFilter) 
	{
		
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.currentStatus.referralStatus = :id1");
		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_ACCEPTED));

		//isSuitableForSurgery = TRUE and isFitrForSurgery = TRUE and hasTheatreAppt = NULL or FALSE 
		sb.append(" and (catsref.isSuitableForSurgery = :sfs and catsref.isFitForSurgery = :ffs and ( catsref.hasTheatreAppt = null or  catsref.hasTheatreAppt = :ta) and (catsref.suitableForSurgeryDate is null or catsref.hasOPProcAwaitingAppt is null or catsref.hasOPProcAwaitingAppt = :idM))"); //wdev-13765
		markers.add("sfs");
		values.add(Boolean.TRUE);
		markers.add("ffs");
		values.add(Boolean.TRUE);
		markers.add("ta");
		values.add(Boolean.FALSE);
		markers.add("idM");        //wdev-13765
		values.add(Boolean.FALSE);  //wdev-13765 
		
		//WDEV-11692 - starts here
		if(voCATSFilter.getOPDSiteIsNotNull())
		{
			sb.append(" and catsref.oPDLocation.id = :opdSite ");
			markers.add("opdSite");
			values.add(voCATSFilter.getOPDSite().getID_Location());
			andStr = " and ";
		}
		
		if(voCATSFilter.getSfSFromDateIsNotNull())
		{
			sb.append(" and catsref.suitableForSurgeryDate >= :sfsFrom ");
			markers.add("sfsFrom");
			values.add(voCATSFilter.getSfSFromDate().getDate());
			andStr = " and ";
		}
		
		if(voCATSFilter.getSfSToDateIsNotNull())
		{
			sb.append(" and catsref.suitableForSurgeryDate < :sfsTo ");
			markers.add("sfsTo");
			values.add(((Date) voCATSFilter.getSfSToDate().clone()).addDay(1).getDate());
			andStr = " and ";
		}
		//WDEV-11692 - ends here
		
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
	
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);	
	}

	//WDEV-7448
	private List<?> domListOrderInvAcceptedApptRequired(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin)
	{
		hql += "left join catsref.investigationOrders as ocsOrder ";
		hql += "left join ocsOrder.investigations as orderInv ";
			
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr +  "  catsref.isCAB <> :isCABReferral");				
		markers.add("isCABReferral");
		values.add(Boolean.TRUE);
		andStr = " and ";

		sb.append(andStr + "orderInv.ordInvCurrentStatus.ordInvStatus  = :acceptedStatus ");				
		markers.add("acceptedStatus");
		values.add(getDomLookup(OrderInvStatus.ACCEPTED));
		
		sb.append(" and catsref.orderInvAppts is empty ");
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
	
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);	
	}
	
	private List<?> domListDischargeReferrals(String hql, StringBuffer sb,ArrayList<String> markers, ArrayList<Serializable> values,String andStr, String hqlJoin) 
	{
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.dischargeDate is not null");					
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListFinalDischargeDocumentRequired(String hql, StringBuffer sb,ArrayList<String> markers, ArrayList<Serializable> values,String andStr, String hqlJoin) 
	{
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.isFinalReportRequired = :isFinalReportRequired");				
	
		markers.add("isFinalReportRequired");
		values.add(getDomLookup(ReportStatus.REQUIRED));
				
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);	
	}

	private List<?> domListFurtherManagementRequired(Boolean includeICPColumn, Boolean bIncludeELEColumn, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
		String hql = getBaseSelectQuery(includeICPColumn, bIncludeELEColumn);
		hql += "from ReferralOutcome as ra right join ra.catsReferral as catsref ";
		hql += getBaseJoinQuery();
		hql += "left join ra.furtherManagementDetails as fmd";

		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.currentStatus.referralStatus = :id1");
		sb.append(" and catsref.wasFurtherManagementDetailsReviewed = null");
		sb.append(" and fmd.followupType not in (:id2, :id3)");//wdev-8482

		markers.add("id3");
		values.add(getDomLookup(FollowupManagementType.REFER_BACK_TO_CONSULTANT));

		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.FURTHER_MANAGEMENT_REQUIRED));
		markers.add("id2");
		values.add(getDomLookup(FollowupManagementType.TLT));
	
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);	
	}

	private List<?> domListFurtherManagementTLTRequired(Boolean includeICPColumn, Boolean bIncludeELEColumn, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin, TLTType type) 
	{
		String hql = getBaseSelectQuery(includeICPColumn, bIncludeELEColumn);
		hql += "from ReferralOutcome as ra right join ra.catsReferral as catsref ";
		hql += getBaseJoinQuery();
		hql += "left join ra.furtherManagementDetails as fmd";

		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.currentStatus.referralStatus = :id1");
		sb.append(" and catsref.wasFurtherManagementDetailsReviewed = null");
		
		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.FURTHER_MANAGEMENT_REQUIRED));
		
		sb.append(" and fmd.followupType = :id3");
		markers.add("id3");
		values.add(getDomLookup(FollowupManagementType.TLT));
		
		if (type != null)
		{
			sb.append(" and fmd.tLTType = :id2");//wdev-8482
			markers.add("id2");
			values.add(getDomLookup(type));
		}
		
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);	
	}

	private List<?> domListProviderCancellation(String hql, StringBuffer sb,ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
//		CAB						null		
		//	Referral Letter			SCANNED
		//	Cons Appt				to be booked
		//	Inv Appt				null
		//	Episode Status			Rejected
		
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.currentStatus.referralStatus = :id1");
		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER));
	
		sb.append(" and ( catsref.wasPatientProviderCancellationLetterSent = :b2 or catsref.wasPatientProviderCancellationLetterSent = null ) ");
		markers.add("b2");
		values.add(Boolean.FALSE);

		sb.append(" and ( catsref.isReferralRejectedOnCAB = :b1 or catsref.isReferralRejectedOnCAB = null ) ");
		markers.add("b1");
		values.add(Boolean.FALSE);
			
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");

		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);	
	}

	private List<?> domListFlaggedForReview(String hqlSB, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
		
/*		String hql = ("select new ims.RefMan.helper.CatsReferralManualClass( catsref.referralDetails.id,  " +
				"title1.text, pat1.name.surname, pat1.name.forename, patid1.value, pat1.dod, " +
				"(select icp.careContext.id from PatientICP as icp where icp.completedDateTime = null and icp.careContext.id = catsref.careContext.id)," + 
				"catsref.isCAB, loc1.name, service1.serviceName, catsref.isFlaggedForReview, refDetails.end18WW, catsref.isCurrentlyAllocated, " +
				"catsref.hasInvestigations, catsref.additionalInvApptsStatus.id, catsref.currentStatus.id, refstat1.text, catsref.hasAppointments, " +
				"appt1.apptStatus.id, appt1.appointmentDate,  pat1.associatedPatient.id ) " +
				"from CatsReferral as catsref " +
				"left join catsref.patient as pat1 " +
				"left join pat1.name.title as title1 " +
				"left join pat1.identifiers as patid1 " +
				"left join patid1.type as patidtype1 " +
				"left join catsref.referralDetails as refDetails " +
				"left join refDetails.service as service1 " +
				"left join refDetails.location as loc1 " +
				"left join catsref.currentStatus as stat1 " +
				"left join stat1.referralStatus as refstat1 " +
				"left join catsref.consultationAppt as appt1 "); 
*/	
		
		if (hqlJoin != "")
			hqlSB += hqlJoin;

		sb.append(andStr + " catsref.isFlaggedForReview = :isForReview");
		markers.add("isForReview");
		values.add(Boolean.TRUE);
		
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hqlSB += " where ";
		
		hqlSB += sb.toString();
		return getDomainFactory().find(hqlSB.toString(), markers, values);
	}

	private List<?> domListPendingResults(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
//		Referrals pending Results". 
//		When selected this will list all CATS Referrals based on the search criteria (Date Time, Type etc)entered
//		and where any investigation assocaiated with the referral has a status 
//		RefMan.CatsReferral.InvestigationOrders.Investigations.PathResultDetails = null and 
//		RefMan.CatsReferral.InvestigationOrders.Investigations.RadReportingDetails = null and 
//		RefMan.CatsReferral.InvestigationOrders.Investigations.ResultStatus = null and 
//		or invs.ordInvCurrentStatus.ordInvStatus in ORDERED or SENT or RECEIVED or ACCEPTED
		
		sb.append(andStr + " invs.resultDetails = null");
		andStr = " and";
		sb.append(andStr + " invs.resultStatus = null");
		sb.append(andStr + " invs.ordInvCurrentStatus.ordInvStatus in (:id1, :id2, :id3, :id4)");
		
		markers.add("id1");
		values.add(getDomLookup(OrderInvStatus.ORDERED));
		markers.add("id2");
		values.add(getDomLookup(OrderInvStatus.SENT));
		markers.add("id3");
		values.add(getDomLookup(OrderInvStatus.RECEIVED));
		markers.add("id4");		
		values.add(getDomLookup(OrderInvStatus.ACCEPTED));
		
		hql += "left join catsref.investigationOrders as invOrd ";
		hql += "left join invOrd.investigations as invs ";

		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values, 2000);

	}

	private List<?> domListRejectedInvestigations(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
		sb.append(andStr + " catsref.hasRejectedInv = :b1" );

		markers.add("b1");
		values.add(Boolean.TRUE);
		
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);

	}


	private List<?> domListReviewAppointments(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
	//	CAB				null		null		null		null		Yes			Yes			Yes
	//	Referral Letter	SCANNED		SCANNED		SCANNED		SCANNED		SCANNED		SCANNED		SCANNED
	//	Cons Appt		Rebooked	Booked		DNA			Booked		Booked		DNA			Booked
	//	Inv Appt		null		ReBooked	Booked		DNA			ReBooked	Booked		ReBooked
	//	Episode Status	Accepted	Accepted	Accepted	Accepted	Accepted	Accepted	Accepted
		

		sb.append(andStr + " catsref.currentStatus.referralStatus not in (:id1, :id2, :id3, :id4) " +
				" and (catsref.additionalInvApptsStatus in (:id5, :id6)  or  appt.apptStatus.id in (:apptDNA,:apptCancelled))");

		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.DISCHARGED));
		markers.add("id2");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER));
		markers.add("id3");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_REJECTED));
		markers.add("id4");
		values.add(getDomLookup(ReferralApptStatus.CAB_CANCELLATION));

		markers.add("apptDNA");
		values.add(Status_Reason.DNA.getID());
		markers.add("apptCancelled");
		values.add(Status_Reason.CANCELLED.getID());
		markers.add("id5");
		values.add(getDomLookup(AdditionalInvestigationAppointmentsStatus.TOBEBOOKED));
		markers.add("id6");
		values.add(getDomLookup(AdditionalInvestigationAppointmentsStatus.DNA));
	
		hql+= " left join catsref.appointments as appt ";
		
		if (hqlJoin != "")
			hql += hqlJoin;
		
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListReferralRejected(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, Boolean isCAB, String hqlJoin) 
	{
		//	CAB						null		
		//	Referral Letter			SCANNED
		//	Cons Appt				to be booked
		//	Inv Appt				null
		//	Episode Status			Rejected
		
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.currentStatus.referralStatus = :id1");
		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_REJECTED));

		sb.append(" and ( catsref.isReferralRejectedOnCAB = :b1 or catsref.isReferralRejectedOnCAB = null ) ");
		markers.add("b1");
		values.add(Boolean.FALSE);

		sb.append(" and ( catsref.wasPatientRejectionLetterSent = :b2 or catsref.wasPatientRejectionLetterSent = null ) ");
		markers.add("b2");
		values.add(Boolean.FALSE);
			
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListReferralAccepted(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
		//	CAB						null				Yes		
		//	Referral Letter			SCANNED				SCANNED
		//	Cons Appt				Booked				Booked
		//	Inv Appt				Booked				Booked
		//	Episode Status			Accepted			Accepted

		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.hasReferralLetter = :b2" +
				" and ( catsref.consultationAppt.apptStatus = :id1" +
				" or catsref.consultationAppt.apptStatus = null )" +
				" and (catsref.additionalInvApptsStatus = :id2" +
				" or catsref.additionalInvApptsStatus = :id4 )" + //added upon Annes advice.
				" and catsref.currentStatus.referralStatus = :id3");
	
		markers.add("b2");
		values.add(Boolean.TRUE);
		markers.add("id1");
		values.add(getDomLookup(Status_Reason.BOOKED));
		markers.add("id2");
		values.add(getDomLookup(AdditionalInvestigationAppointmentsStatus.ALLBOOKED));
		markers.add("id4");
		values.add(getDomLookup(AdditionalInvestigationAppointmentsStatus.NONE));
		markers.add("id3");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_ACCEPTED));
	
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListProvisionalRejection(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, SecondOpinionCategory category, String hqlJoin) 
	{
		//	CAB						null						Yes			
		//	Referral Letter			SCANNED						SCANNED
		//	Cons Appt				To be booked				Booked
		//	Inv Appt				null						null
		//	Episode Status			Provisional Rejection		Provisional Rejection
		
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.currentStatus.referralStatus = :id1");
		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.PROVISIONAL_REJECTION));
		if ( category != null)
		{
			andStr = " and ";
			sb.append(andStr + " catsref.currentStatus.secondOpinionCategory = :id2");
			markers.add("id2");
			values.add(getDomLookup(category));
		}

		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListOtherApptsRequired(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
		//	CAB						null				Yes			
		//	Referral Letter			SCANNED				SCANNED
		//	Cons Appt				Booked				Booked
		//	Inv Appt				To be booked		To be booked
		//	Episode Status			Accepted			Accepted
		
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.additionalInvApptsStatus = :id1");
	
		markers.add("id1");
		values.add(getDomLookup(AdditionalInvestigationAppointmentsStatus.TOBEBOOKED));

		sb.append(" and catsref.isRIE is null and catsref.currentStatus.referralStatus not in (:id5, :id2, :id3, :id4)" );
		
		markers.add("id5");
		values.add(getDomLookup(ReferralApptStatus.DISCHARGED));
	
		markers.add("id2");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER));
	
		markers.add("id3");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_REJECTED));

		markers.add("id4");
		values.add(getDomLookup(ReferralApptStatus.CAB_CANCELLATION));

		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListConsAppointmentRequired(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
		//	CAB						null				null			
		//	Referral Letter			SCANNED				SCANNED
		//	Cons Appt				To be booked		To be booked
		//	Inv Appt				null				To be booked
		//	Episode Status			Accepted			Accepted
		
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.hasReferralLetter = :b1" +
				" and catsref.consultationAppt is null and catsref.currentStatus.referralStatus not in (:id1, :id2, :id3, :id4, :id5, :id6, :id7)");
		
		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.AWAITING_TRIAGE));
	
		markers.add("id2");
		values.add(getDomLookup(ReferralApptStatus.PROVISIONAL_REJECTION));
	
		markers.add("id3");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_REJECTED));
	
		markers.add("id4");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER));
	
		markers.add("id5");
		values.add(getDomLookup(ReferralApptStatus.CAB_CANCELLATION));
	
		markers.add("id6");
		values.add(getDomLookup(ReferralApptStatus.DISCHARGED));
	
		markers.add("id7");
		values.add(getDomLookup(ReferralApptStatus.ONWARDREFERRALREQUESTED));
	
		markers.add("b1");
		values.add(Boolean.TRUE);

		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListAwaitingReferralLetter(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
		//	CAB 					null				YES
		//	Referral Letter			none				none
		//	Cons Appt				TO BE BOOKED		BOOKED
		//	Inv Appt				null				null
		//	Episode Status			Manual Referral		CAB appointment
		
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " ( catsref.hasReferralLetter = :b1 or catsref.hasReferralLetter = null ) and catsref.currentStatus.referralStatus not in (:id1, :id2, :id3, :id4)");
		
		markers.add("b1");
		values.add(Boolean.FALSE);

		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER));
	
		markers.add("id2");
		values.add(getDomLookup(ReferralApptStatus.REFERRAL_REJECTED));

		//wdev-8067
		markers.add("id3");
		values.add(getDomLookup(ReferralApptStatus.DISCHARGED));

		//wdev-8067
		markers.add("id4");
		values.add(getDomLookup(ReferralApptStatus.CAB_CANCELLATION));

		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	private List<?> domListAwaitingTriage(String hql, StringBuffer sb, ArrayList<String> markers, ArrayList<Serializable> values, String andStr, String hqlJoin) 
	{
		//	CAB						null					Yes	
		//	Referral Letter			SCANNED					SCANNED
		//	Cons Appt				TO BE Booked			Booked
		//	Inv Appt				null					null
		//	Episode Status			Awaiting Triage			Awaiting Triage
		
		if (hqlJoin != "")
			hql += hqlJoin;

		sb.append(andStr + " catsref.currentStatus.referralStatus = :id1");
	
		markers.add("id1");
		values.add(getDomLookup(ReferralApptStatus.AWAITING_TRIAGE));
	
		sb.append(" and catsref.isRIE is null order by refDetails.dateOfReferral asc, refDetails.id asc");
		sb.append(" order by refDetails.end18WW asc");//WDEV-11795
		
		hql += " where ";
		
		hql += sb.toString();
		return getDomainFactory().find(hql.toString(), markers, values);
	}

	public ServiceFunctionLiteVoCollection listServiceFunctionsLite(ServiceRefVo service) 
	{
		DomainFactory factory = getDomainFactory();

		if (service != null && service.getID_ServiceIsNotNull())
		{
			java.util.List<?> servfuncList = factory.find("from  ServiceFunction servfunc where servfunc.service.id = :serviceid and servfunc.isActive = :isAct", new String[]{"serviceid", "isAct"}, new Object[]{service.getID_Service(), Boolean.TRUE});
			return ServiceFunctionLiteVoAssembler.createServiceFunctionLiteVoCollectionFromServiceFunction(servfuncList).sort();
		}

		return null;
	}

	public PatientShort getPatientShort(PatientRefVo voPatientRef) 
	{
		DomainFactory factory = getDomainFactory();
		ims.core.patient.domain.objects.Patient patBo = (ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, voPatientRef.getID_Patient().intValue());
		return PatientShortAssembler.create(patBo);
	}

	public CareContextShortVo getCareContextShort(CareContextRefVo voCareContextRef) 
	{
		if (voCareContextRef == null)
			throw new RuntimeException("Cannot get CareContextShortVo for null CareContextRefVo");

		CareContext doCareContext = (CareContext) getDomainFactory().getDomainObject(CareContext.class, voCareContextRef.getID_CareContext());
		return CareContextShortVoAssembler.create(doCareContext);
	}

	public ReferralServiceFullVo getReferralServices() 
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer("from ReferralService");
	
		List<?> list = factory.find(hql.toString());
		if(list.size()>0)
			return ReferralServiceFullVoAssembler.create((ReferralService) list.get(0));
		else
			return null;
	}
	
	public Booking_AppointmentShortVo getArrivedBookingAppt(CatsReferralListVo catsReferralRefVo) 
	{
		if (catsReferralRefVo == null)
			throw new CodingRuntimeException("Invalid catsReferralRefVo");
		
		//WDEV-12878
		if (catsReferralRefVo.getLastApptArrivedDate() == null)
			throw new CodingRuntimeException("LastApptArrivedDate can not be null.");

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();

		StringBuffer sb = new StringBuffer();
		String andStr = "";

		String hql = "select bappts from CatsReferral as catsref join catsref.appointments as bappts"; 

		sb.append(" catsref.id = :catsid");
		markers.add("catsid");
		values.add(catsReferralRefVo.getID_CatsReferral());
		andStr = " and ";
			
		sb.append(andStr + " bappts.appointmentDate= :td");
		markers.add("td");
		values.add(catsReferralRefVo.getLastApptArrivedDate().getDate());
		andStr = " and ";

		sb.append(andStr + " bappts.apptStatus = :aStat");
		markers.add("aStat");
		values.add(getDomLookup(Status_Reason.ARRIVAL));
		andStr = " and ";
		
		sb.append(andStr + " bappts.session.sch_Profile.service.serviceCategory = :serCat");
		markers.add("serCat");
		values.add(getDomLookup(ServiceCategory.CLINICAL));
		andStr = " and ";

		sb.append(" and catsref.isRIE is null ");
		sb.append(" order by bappts.apptStartTime asc");
		
		hql += " where ";
		hql += sb.toString();
		List<?> list = getDomainFactory().find(hql.toString(), markers, values);	
		
		if (list == null || list.size() == 0)
			return null;
		else
			return Booking_AppointmentShortVoAssembler.create((Booking_Appointment)list.get(0));
	}

	public ConsultationDetailsVo getConsultation(CatsReferralRefVo voCATSRef) 
	{
		AtConsultation impl = (AtConsultation) getDomainImpl(AtConsultationImpl.class);
		return impl.getConsultation(voCATSRef);
	}

	public HcpLiteVo getHcpLiteById(HcpRefVo refId) 
	{
		if(refId == null)
			throw new CodingRuntimeException("null refId passed to getHcpById() !");

		DomainFactory factory = getDomainFactory();
		
		ims.core.resource.people.domain.objects.Hcp boHcp = (ims.core.resource.people.domain.objects.Hcp)factory.getDomainObject(ims.core.resource.people.domain.objects.Hcp.class, refId.getID_Hcp());
		
		return HcpLiteVoAssembler.create(boHcp);
	}

	/**
	 * Function used to save (start) a Consultation record
	 * <br>- will save ConsultationDetails record
	 * <br>- will update Booking_Appointment record associated with consultation
	 * <br>- will update CatsReferral record associated with consultation
	 * <br><br>
	 * <i>Changes:</i><br>
	 * <ul>
	 * <li><b>WDEV-12787</b> - changed returned type from <b>Boolean</b> (not used) to <b>CatsReferralRefVo</b>
	 * </ul>
	 */
	public CatsReferralRefVo saveConsultationAndBookingAppointmentAndCatsReferral(Booking_AppointmentShortVo voBooking, ConsultationDetailsVo voConsultation, CatsReferralListVo voReferral) throws StaleObjectException 
	{		
		if(voConsultation == null)
			throw new CodingRuntimeException("Invalid voConsultation");
		if(!voConsultation.isValidated())
			throw new CodingRuntimeException("voConsultation not validated");
		
		if(voReferral == null)
			throw new CodingRuntimeException("Invalid voReferral");
		if(!voReferral.isValidated())
			throw new CodingRuntimeException("voReferral not validated");
		
		DomainFactory factory = getDomainFactory();
		if(voBooking != null)
		{
			Booking_Appointment domainObject = Booking_AppointmentShortVoAssembler.extractBooking_Appointment(factory, voBooking);	
			factory.save(domainObject);
		}
		
		AtConsultation impl = (AtConsultation) getDomainImpl(AtConsultationImpl.class);
		impl.saveConsultation(voConsultation);
	
		CatsReferral doCats = CatsReferralListVoAssembler.extractCatsReferral(factory, voReferral);		
		factory.save(doCats);

		// WDEV-12787 - Return the CatsReferralRef 
		return new CatsReferralRefVo(doCats.getId(), doCats.getVersion());
	}

	public ConsultationDetailsVo saveConsultationAndReferralAndAppt(ConsultationDetailsVo voConsultation, CatsReferralListVo voReferral, Booking_AppointmentVo voAppt) throws StaleObjectException 
	{
		if(voConsultation == null)
			throw new CodingRuntimeException("Invalid voConsultation");
		if(!voConsultation.isValidated())
			throw new CodingRuntimeException("voConsultation not validated");
		
		if(voReferral == null)
			throw new CodingRuntimeException("Invalid voReferral");
		if(!voReferral.isValidated())
			throw new CodingRuntimeException("voReferral not validated");
		
		if(voAppt != null && !voAppt.isValidated())
			throw new CodingRuntimeException("voAppt not validated");
		
		DomainFactory factory = getDomainFactory();
		
		if(voAppt != null)
		{
			Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, voAppt);		
			factory.save(doAppt);
		}
		
		ConsultationDetails domainObject = ConsultationDetailsVoAssembler.extractConsultationDetails(factory, voConsultation);
		factory.save(domainObject);
	
		CatsReferral doCats = CatsReferralListVoAssembler.extractCatsReferral(factory, voReferral);		
		factory.save(doCats);

		return ConsultationDetailsVoAssembler.create(domainObject);
	}

	public CatsReferralListVo getCatsReferral(CatsReferralRefVo voReferralRef)
	{
		return CatsReferralListVoAssembler.create((CatsReferral)getDomainFactory().getDomainObject(CatsReferral.class, voReferralRef.getID_CatsReferral()));
	}

	public Booking_AppointmentShortVo getBookingAppt(Booking_AppointmentRefVo voBookingRef) 
	{
		return Booking_AppointmentShortVoAssembler.create((Booking_Appointment)getDomainFactory().getDomainObject(Booking_Appointment.class, voBookingRef.getID_Booking_Appointment()));
	}

	public ConsultationDetailsVo saveConsultation(ConsultationDetailsVo voConsultation) throws StaleObjectException 
	{
		if(voConsultation == null)
			throw new CodingRuntimeException("Invalid voConsultation");
		if(!voConsultation.isValidated())
			throw new CodingRuntimeException("voConsultation not validated");
		
		DomainFactory factory = getDomainFactory();
		ConsultationDetails domainObject = ConsultationDetailsVoAssembler.extractConsultationDetails(factory, voConsultation);
		
		factory.save(domainObject);
	
		return ConsultationDetailsVoAssembler.create(domainObject);
	}

	public CatsReferralWizardVo saveCatsReferral(CatsReferralWizardVo record) throws DomainInterfaceException, StaleObjectException 
	{
		ReferralWizard impl = (ReferralWizard) getDomainImpl(ReferralWizardImpl.class);
		return impl.saveCatsReferral(record);
	}

	public CatsReferralWizardVo getCatsReferralWizardVo(CatsReferralRefVo voCatsRef) 
	{
		ReferralWizard impl = (ReferralWizard) getDomainImpl(ReferralWizardImpl.class);
		return impl.getCatsReferral(voCatsRef);
	}

	public LocationLiteVoCollection listLocationLite()
	{
		DirectoryOfServiceAdmin impl = (DirectoryOfServiceAdmin) getDomainImpl(DirectoryOfServiceAdminImpl.class);
		return impl.listLocationLiteByName(null);
	}

	public Boolean isPatientAlreadyAdmitted(PatientRefVo voPatientRef)
	{
		ADT impl = (ADT) getDomainImpl(ADTImpl.class);
		if (impl.getCurrentAdmissionRecord(voPatientRef) != null)
			return true;
		else
			return false;
	}

	public MemberOfStaffVo getMemberOfStaff(MemberOfStaffShortVo mos) 
	{
		MosAdmin impl = (MosAdmin) getDomainImpl(MosAdminImpl.class);
		return impl.getMemberOfStaff(mos);
	}

	public CatsReferralWizardVo resetProviderCancellation(CatsReferralWizardVo catsReferral, ProviderCancellationVo provCancellationVo) throws StaleObjectException, ForeignKeyViolationException 
	{
		if(catsReferral == null)
			throw new CodingRuntimeException("Invalid CatsReferralWizardVo");
		if(!catsReferral.isValidated())
			throw new CodingRuntimeException("CatsReferralWizardVo not validated");
		
		if(provCancellationVo == null)
			throw new CodingRuntimeException("Invalid ProviderCancellationVo");
		if(!provCancellationVo.isValidated())
			throw new CodingRuntimeException("ProviderCancellationVo not validated");
		
		DomainFactory factory = getDomainFactory();
		
		CatsReferral doCats = CatsReferralWizardVoAssembler.extractCatsReferral(factory, catsReferral);		
		factory.save(doCats);
		
		ProviderCancellation domainObject = ProviderCancellationVoAssembler.extractProviderCancellation(factory, provCancellationVo);
		factory.delete(domainObject);
	

		return CatsReferralWizardVoAssembler.create(doCats);
	}

	public ProviderCancellationVo getProviderCancellation(ProviderCancellationRefVo voProvCanceRef) 
	{
		return ProviderCancellationVoAssembler.create((ProviderCancellation)getDomainFactory().getDomainObject(ProviderCancellation.class, voProvCanceRef.getID_ProviderCancellation()));
	}

	public CatsReferralWizardVo resetReferralRejection(CatsReferralWizardVo catsReferral, RejectReferralVo rejRefVo) throws StaleObjectException, ForeignKeyViolationException 
	{
		if(catsReferral == null)
			throw new CodingRuntimeException("Invalid CatsReferralWizardVo");
		if(!catsReferral.isValidated())
			throw new CodingRuntimeException("CatsReferralWizardVo not validated");
		
		if(rejRefVo == null)
			throw new CodingRuntimeException("Invalid RejectReferralVo");
		if(!rejRefVo.isValidated())
			throw new CodingRuntimeException("RejectReferralVo not validated");
		
		DomainFactory factory = getDomainFactory();
		
		CatsReferral doCats = CatsReferralWizardVoAssembler.extractCatsReferral(factory, catsReferral);		
		factory.save(doCats);

		ReferralReject domainObject = RejectReferralVoAssembler.extractReferralReject(factory, rejRefVo);
		factory.delete(domainObject);

		return CatsReferralWizardVoAssembler.create(doCats);
	}

	public OrganisationVoCollection listOrganisations(OrgShortVo filter) 
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listOrganisation(null, true,true);
	}

	public LocationLiteVoCollection listLocationByOrganisation(OrganisationRefVo organisation, String name) 
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listLocationByOrganisation(organisation, name);
	}

	public Boolean hadPreviousAdmissionForThisReferral(CatsReferralRefVo voCatsRef) 
	{
		DomainFactory factory = getDomainFactory();
		
		IMSCriteria criteria = new IMSCriteria(DischargeSummaryPacuAndWard.class, factory);
		criteria.equal("this.catsReferral.id", voCatsRef.getID_CatsReferral());
		criteria.addOrder(DischargeSummaryPacuAndWard.FieldNames.DischargeDate, ORDERMODE.DESC);
		
		DischargeSummaryPacuAndWardLiteVoCollection list = DischargeSummaryPacuAndWardLiteVoAssembler.createDischargeSummaryPacuAndWardLiteVoCollectionFromDischargeSummaryPacuAndWard(criteria.find());
		
		if (list == null || list.size() == 0)
			return false;
		
		return true;
	}

	public void undoProviderCancellation(CatsReferralListVo referral, ReferralNoteVo referralNote) throws StaleObjectException, ForeignKeyViolationException
	{
		
		if (!(referral.getCurrentStatusIsNotNull() && 
				ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER.equals(referral.getCurrentStatus().getReferralStatus())))
		{
			throw new DomainRuntimeException("The referral is not cancelled by provided !");
		}
		
		//referral.get
		DomainFactory factory = getDomainFactory();
		
		
		CatsReferralStatusVoCollection statusHistory = referral.getStatusHistory();
		if (statusHistory == null)
		{
			throw new DomainRuntimeException("Cats referral doesn't have any history");
		}
		
		//Hold the current status so that remove can be done in db
		CatsReferralStatusVo removeStatus = referral.getCurrentStatus();
		
		//Remove the current status from the history and set the current status to the latest
		statusHistory.remove(removeStatus);
		
		CatsReferralStatusVo latestStatus = getLatestStatus(statusHistory);
		
		// Check for a referral letter associated to referral
		PatientDocumentLiteVo referralLetter = getReferralLetter(referral);

		if (ReferralApptStatus.REFERRAL_RECEIVED.equals(latestStatus.getReferralStatus()) && referralLetter != null)
		{
			// Create new status for referral
			CatsReferralStatusVo status = new CatsReferralStatusVo();
			
			status.setReferralStatus(ReferralApptStatus.AWAITING_TRIAGE);
			status.setAuthoringUser(referralLetter.getRecordingUser());
			status.setComment("");
			status.setStatusDateTime(new DateTime());
			
			referral.setCurrentStatus(status);
			statusHistory.add(status);
		}
		else
		{
			referral.setCurrentStatus(latestStatus);
		}
		

		
		CatsReferral referralBo = CatsReferralListVoAssembler.extractCatsReferral(factory, referral);
			
		ProviderCancellation pCancellation = referralBo.getProviderCancellation();
		
		referralBo.setProviderCancellation(null);
		
		factory.save(referralBo);
		
		factory.delete(CatsReferralStatusVoAssembler.extractCATSReferralStatus(factory, removeStatus));
		
		if (pCancellation != null)
			factory.delete(pCancellation);
		
		//WDEV-12088
		ims.core.domain.objects.CorrespondenceNote domainObject = ReferralNoteVoAssembler.extractCorrespondenceNote(factory, referralNote);		
		factory.save(domainObject);
	}

	
	private PatientDocumentLiteVo getReferralLetter(CatsReferralListVo referral)
	{
		StringBuilder query = new StringBuilder();
		
		query.append("SELECT doc FROM CatsReferral as referral left join referral.referralDocuments as doc left join doc.category as cat ");
		query.append(" WHERE referral.id = :REF_ID and cat.id = :CAT_ID ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("REF_ID");
		paramValues.add(referral.getID_CatsReferral());
		
		paramNames.add("CAT_ID");
		paramValues.add(DocumentCategory.GPLETTER.getID());
		
		return PatientDocumentLiteVoAssembler.create((PatientDocument) getDomainFactory().findFirst(query.toString(), paramNames, paramValues));
	}

	/**
	 * Returns the latest (most recent) status from the status collection
	 * @param statusHistory
	 * @return latest status
	 */
	private CatsReferralStatusVo getLatestStatus(CatsReferralStatusVoCollection statusHistory)
	{
		if (statusHistory == null || statusHistory.size() == 0)
			throw new DomainRuntimeException("Referral's history doesn't contain any records");
		CatsReferralStatusVo latest = statusHistory.get(0);
		for (int i  = 1 ; i < statusHistory.size() ; i++)
		{
			if (statusHistory.get(i).getStatusDateTime().isGreaterThan(latest.getStatusDateTime()))
			{
				latest = statusHistory.get(i);
			}
		}
		return latest;
	}

	public void undoReferralRejection(CatsReferralListVo catsRef) throws StaleObjectException,ForeignKeyViolationException
	{

		if (!(catsRef.getCurrentStatusIsNotNull() && ReferralApptStatus.REFERRAL_REJECTED.equals(catsRef.getCurrentStatus().getReferralStatus())))
		{
			throw new DomainRuntimeException("Provided referral is not rejected");
		}
		
		DomainFactory factory = getDomainFactory();
		
		CatsReferralStatusVoCollection history = catsRef.getStatusHistory();
		
		if (history == null)
		{
			throw new DomainRuntimeException("Cats referral doesn't have any history");
		}
		
		//Hold the current status so that remove can be done in db
		CatsReferralStatusVo removeStatus = catsRef.getCurrentStatus();
		
		//Remove the current status from the history and set the current status to the latest
		history.remove(removeStatus);
		catsRef.setCurrentStatus(getLatestStatus(history));
		
		CatsReferral referralBo = CatsReferralListVoAssembler.extractCatsReferral(factory, catsRef);
			
		ReferralReject reject = referralBo.getRejectReferralDetail();
		
		referralBo.setRejectReferralDetail(null);
		
		factory.save(referralBo);
		
		factory.delete(CatsReferralStatusVoAssembler.extractCATSReferralStatus(factory, removeStatus));
		
		if (reject != null)
			factory.delete(reject);
		
		
	}

	//WDEV-11692 - starts here
	public LocationLiteVoCollection listOPDSite() 
	{
		DomainFactory factory=getDomainFactory();
		
		IMSCriteria imsc=new IMSCriteria(Location.class,factory);
		imsc.equal(Location.FieldNames.IsActive, true);
		imsc.equal(Location.FieldNames.IsVirtual, false);
		imsc.addOrder(Location.FieldNames.Name, ORDERMODE.ASC);
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.SURGERY.getID());
		
		List<?> locations=imsc.find();
		
		if (locations!=null&&locations.size()>0)
			return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations);
		
		return null;
	}
	//WDEV-11692 - ends here

	public ProcedureLiteVoCollection listProcedures(String strSearchText) throws DomainInterfaceException 
	{
		ProcedureList impl = (ProcedureList) getDomainImpl(ProcedureListImpl.class);
		return impl.listActiveProcedures(strSearchText);
	}

	public ProcedureLiteVo getProcedureLite(ProcedureRefVo procRef) 
	{
		ProcedureList impl = (ProcedureList) getDomainImpl(ProcedureListImpl.class);
		return impl.getProcedureVo(procRef);
	}

	public CatsReferralListManualAssemblyVoCollection listCATSReferrals(CATSReferralFilterVo voCATSFilter) 
	{
		return listCATSReferrals(voCATSFilter, false, false);
	}

	public ContractConfigForReferralDetailsComponentVoCollection listActiveContracts(OrganisationRefVo voOrgRef)
	{
		ReferralDetailsComponent impl = (ReferralDetailsComponent) getDomainImpl(ReferralDetailsComponentImpl.class);
		return impl.listActiveContracts(voOrgRef);
	}

	public ContractConfigRefVoCollection listAllContracts(OrganisationRefVo voOrgRef) 
	{
		String hql = "from ContractConfig as cc where (cc.contractOrganisation.id = :orgID and cc.isRIE is null) ";
		List<?> dos = getDomainFactory().find(hql,new String[]{"orgID"},new Object[]{voOrgRef.getID_Organisation()});
		if (dos == null || dos.size() == 0)
			return null;
		ContractConfigRefVoCollection voColl = new ContractConfigRefVoCollection(); 
		for (int i = 0 ; i <  dos.size() ; i++)
		{
			ContractConfig doCC = (ContractConfig)dos.get(i);
			voColl.add(new ContractConfigRefVo(new Integer(doCC.getId()),0));
		}
		
		return voColl;
	}

	public OrganisationLiteVo getOrganisationByLocation(Integer locationId) 
	{
		ClinicList impl = (ClinicList) getDomainImpl(ClinicListImpl.class);
		return impl.getOrganisationByLocation(locationId);
	}

	public Boolean isThereAnyDiagnosticContractsForThisSite(OrganisationRefVo voOrg) 
	{
		String hql = "from ContractConfig as cc where (cc.contractOrganisation.id = :orgID and cc.status = :actCC and cc.isRIE is null and cc.contractType = :DiagContra) ";
		List<?> dos = getDomainFactory().find(hql,new String[]{"orgID", "actCC", "DiagContra"},new Object[]{voOrg.getID_Organisation(), getDomLookup(PreActiveActiveInactiveStatus.ACTIVE), getDomLookup(ReferralManagementContractType.DIAGNOSTIC)});
		if (dos == null || dos.size() == 0)
			return Boolean.FALSE;
		else
			return Boolean.TRUE;
	}

	public OnwardReferralFromTriageVo getOnwardReferralByCatsReferral(CatsReferralRefVo catsReferral) 
	{
		ReferralDetails impl = (ReferralDetails) getDomainImpl(ReferralDetailsImpl.class);
		return impl.getOnwardReferralByCatsReferral(catsReferral);
	}

	
	//---------------------------------------------------------------------------------------------------------------------------------------------
	//	WDEV-12875
	//	Implemented functions needed to check if active ContractConfiguration records of type Diagnostic exist for current location
	//	fix: now the contracts for all organisations on the branch (up from provided location) are examined, not just the root organisation
	//---------------------------------------------------------------------------------------------------------------------------------------------

	/**
	 * WDEV-12875
	 * Function used to analyse ContractConfiguration records for all Organisations on the branch (up form provided location)
	 * @return <b>true</b> if at least one ContractConfiguration record active and of type Diagnostic, <b>false</b> otherwise
	 */
	public Boolean hasLocationDiagnosicContracts(LocationRefVo location)
	{
		// If location is not provided
		if (location == null)
			return false;
		
		// Get root Location id
		Integer rootLocation = getRootLocationID(location.getID_Location());
		// Get the ID for all organisations on the branch up to root organisation
		ArrayList<Integer> organisations = listParentOrganisations(rootLocation);
		
		// If no organisations are found then return false
		if (organisations == null || organisations.size() == 0)
			return false;
		
		// Build query to retrieve first Active contract or type Diagnostic for the organisations on the branch
		StringBuilder query = new StringBuilder();
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		query.append("SELECT contract FROM ContractConfig AS contract WHERE contract.status.id = :ACTIVE AND contract.contractType.id = :DIAG ");
		query.append("AND contract.isRIE is null AND contract.contractOrganisation.id IN (");

		paramNames.add("ACTIVE"); paramValues.add(PreActiveActiveInactiveStatus.ACTIVE.getID());
		paramNames.add("DIAG"); paramValues.add(ReferralManagementContractType.DIAGNOSTIC.getID());
		
		String separator = "";
		
		for (int i = 0; i < organisations.size(); i++)
		{
			query.append(separator);
			query.append(organisations.get(i));
			
			separator = ", ";
		}
		
		query.append(")");
		
		// Query the database for the first ContractConfig record (non RIE, Active, of type Diagnostic) for organisations on the branch of the provided location
		ContractConfigForReferralDetailsComponentVo contractConfig = ContractConfigForReferralDetailsComponentVoAssembler.create((ContractConfig) getDomainFactory().findFirst(query.toString(), paramNames, paramValues));
		
		// If at least one ContractConfig record is found then return true, otherwise return false
		if (contractConfig != null)
			return true;
		
		return false;
	}


	//---------------------------------------------------------------------------------------------------------------------------------------------
	//	WDEV-12866
	//	Implemented functions needed to retrieve active ContractConfiguration records for current location
	//	fix: now the contracts for all organisations on the branch (up from provided location) are provided, not just the root organisation
	//---------------------------------------------------------------------------------------------------------------------------------------------

	/**
	 * Function used to list all active ContractConfiguration records for current location
	 * <br>This function will progress recursively backwards in tree to the root parent location, then by organisation,
	 * build a collection with all Organisations and the query for all active contracts for all Organisations in the collection
	 */
	public ContractConfigForReferralDetailsComponentVoCollection listActiveContractsForLocation(LocationRefVo location)
	{
		// If location is not provided
		if (location == null)
			return null;
		
		// Get root Location id
		Integer rootLocation = getRootLocationID(location.getID_Location());
		// Get the ID for all organisations on the branch up to root organisation
		ArrayList<Integer> organisations = listParentOrganisations(rootLocation);

		// If no organisations are found then return null
		if (organisations == null || organisations.size() == 0)
			return null;
		
		// Build query to retrieve all active contract for the organisations on the branch
		StringBuilder query = new StringBuilder();
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		query.append("SELECT contract FROM ContractConfig AS contract WHERE contract.status.id = :ACTIVE AND contract.contractOrganisation.id IN (");
		paramNames.add("ACTIVE");
		paramValues.add(PreActiveActiveInactiveStatus.ACTIVE.getID());
		
		String separator = "";
		
		for (int i = 0; i < organisations.size(); i++)
		{
			query.append(separator);
			query.append(organisations.get(i));
			
			separator = ", ";
		}
		
		query.append(") ORDER BY UPPER(contract.contractName) ASC");

		// Return the query results
		return ContractConfigForReferralDetailsComponentVoAssembler.createContractConfigForReferralDetailsComponentVoCollectionFromContractConfig(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	
	/**
	 *	This function will return the id of the top most location in the branch
	 *	It will recursively attempt to return the parent of provided location,
	 *	until it finds a location without a parent
	 *	If the provided location is null then it will return null 
	 */
	private Integer getRootLocationID(Integer location)
	{
		if (location == null)
			return null;
		
		Integer parentLocation = getParentLocationID(location);
		
		if (parentLocation != null)
			return getRootLocationID(parentLocation);
		
		return location;
	}

	/**
	 * This function will return the parent location for provided location id 
	 */
	private Integer getParentLocationID(Integer location)
	{
		String query = "select parentLocation from Location as parentLocation left join parentLocation.locations as loc where loc.id = " + location;
		Location result = (Location) getDomainFactory().findFirst(query);
		
		if (result == null)
			return null;
		
		return result.getId();
	}

	/**
	 * This function will return the list with the ID for all Organisation records on the branch for provided
	 * location all the way to the top
	 */
	private ArrayList<Integer> listParentOrganisations(Integer rootLocation)
	{
		ArrayList<Integer> organisations = null;
		
		String query = "select org from Organisation as org left join org.locationSites as loc where loc.id = " + rootLocation;
		
		Organisation organisation = (Organisation) getDomainFactory().findFirst(query);

		if (organisation != null)
		{
			organisations = new ArrayList<Integer>();
			organisations.add(organisation.getId());
			
			return listParentOrganisationsForOrganisation(organisation, organisations);
		}
		
		return organisations;
	}

	/**
	 * This function will recursively step from organisation to it's parent organisation all the way to the top
	 * and add their ID to organisation list 
	 */
	private ArrayList<Integer> listParentOrganisationsForOrganisation(Organisation organisation, ArrayList<Integer> organisations)
	{
		if (organisation == null)
			return organisations;
		
		if (organisation.getParentOrganisation() != null)
		{
			organisations.add(organisation.getParentOrganisation().getId());
			
			return listParentOrganisationsForOrganisation(organisation.getParentOrganisation(), organisations);
		}
		
		return organisations;
	}

	//wdev-13652
	public ContractServiceLocationsConfigVoCollection listLocationServicesByServiceId( ServiceRefVo service) 
	{
		String hql = "select c1_1 from ContractServiceLocationsConfig as c1_1 left join c1_1.service as s1_1 where (s1_1.id = :servId) ) ";
		List<?> dos = getDomainFactory().find(hql,new String[]{"servId"},new Object[]{service.getID_Service()});
		if (dos != null && dos.size() > 0)
		{
			return ContractServiceLocationsConfigVoAssembler.createContractServiceLocationsConfigVoCollectionFromContractServiceLocationsConfig(dos); 
		}
		
		return null;
	}

	//wdev-13652
	public ContractServiceLocationsConfigVoCollection listLocationServices() 
	{
		String hql = "from ContractServiceLocationsConfig  ";
		List<?> dos = getDomainFactory().find(hql);
		if (dos != null && dos.size() > 0)
		{
			return ContractServiceLocationsConfigVoAssembler.createContractServiceLocationsConfigVoCollectionFromContractServiceLocationsConfig(dos); 
		}
		
		return null;
	}

	//wdev-13652
	public ContractServiceLocationsConfigVoCollection listLocationServiceByContract( ContractConfigRefVo contract) 
	{
		String hql = "from ContractConfig as c1_1 where (c1_1.id = :ContractId) ";
		List<?> dos = getDomainFactory().find(hql,new String[]{"ContractId"},new Object[]{contract.getID_ContractConfig()});
		if (dos != null && dos.size() > 0)
		{
			ContractConfigurationVoCollection contrVoColl = ContractConfigurationVoAssembler.createContractConfigurationVoCollectionFromContractConfig(dos);
			if(contrVoColl != null && contrVoColl.size() > 0)
				return contrVoColl.get(0).getServiceLocations();  
		}
		
		return null;
	}

	//wdev-13652
	public ContractServiceLocationsConfigVoCollection listLocationServiceByContractAndService(ContractConfigRefVo contract, ServiceRefVo service) 
	{
		String hql = "from ContractConfig as c1_1 where (c1_1.id = :ContractId) ";
		List<?> dos = getDomainFactory().find(hql,new String[]{"ContractId"},new Object[]{contract.getID_ContractConfig()});
		if (dos != null && dos.size() > 0)
		{
			ContractConfigurationVoCollection contrVoColl = ContractConfigurationVoAssembler.createContractConfigurationVoCollectionFromContractConfig(dos);
			if(contrVoColl != null && contrVoColl.size() > 0)
				return getContractServiceLocationsByServiceId(contrVoColl.get(0).getServiceLocations(),service);  
		}
		
		return null;
	}
	//wdev-13652
	private ContractServiceLocationsConfigVoCollection getContractServiceLocationsByServiceId(ContractServiceLocationsConfigVoCollection tempVoColl, ServiceRefVo service)
	{
		ContractServiceLocationsConfigVoCollection servLocVoColl = new ContractServiceLocationsConfigVoCollection();
		if(tempVoColl == null || service == null)
			return null;
		for(int i = 0;i < tempVoColl.size();i++ )
		{
			ContractServiceLocationsConfigVo tempVo = tempVoColl.get(i);
			if(tempVo == null)
				continue;
			if(tempVo.getService() != null && service.getID_Service().equals(tempVo.getService().getID_Service()))
				servLocVoColl.add(tempVo);
		}
		return servLocVoColl;
		
	}

	//WDEV-14660
	public String getPIDDiagnosisInfo(CareContextRefVo careContextRefVo, EpisodeOfCareRefVo episodeOfCareRefVo) 
	{
		Alerts impl = (Alerts) getDomainImpl(AlertsImpl.class);
		return impl.getPIDDiagnosisInfo(careContextRefVo, episodeOfCareRefVo);
	}

	//WDEV-16165
	public void undoEndOfCare(CatsReferralListVo catsRef)throws StaleObjectException, ForeignKeyViolationException 
	{
		if (!(catsRef.getCurrentStatusIsNotNull() && ReferralApptStatus.END_OF_CARE.equals(catsRef.getCurrentStatus().getReferralStatus())))
		{
			throw new DomainRuntimeException("Provided referral is not marked as End of Care");
		}
		
		DomainFactory factory = getDomainFactory();
		
		CatsReferralStatusVoCollection history = catsRef.getStatusHistory();
		
		if (history == null)
		{
			throw new DomainRuntimeException("Cats referral doesn't have any history");
		}
		
		//Hold the current status so that remove can be done in db
		CatsReferralStatusVo removeStatus = catsRef.getCurrentStatus();
		
		//Remove the current status from the history and set the current status to the latest
		history.remove(removeStatus);
		catsRef.setCurrentStatus(getLatestStatus(history));
		
		CatsReferral referralBo = CatsReferralListVoAssembler.extractCatsReferral(factory, catsRef);
			
		ReferralReject reject = referralBo.getRejectReferralDetail();
		
		referralBo.setEndOfCareDate(null);
		
		factory.save(referralBo);
		
		factory.delete(CatsReferralStatusVoAssembler.extractCATSReferralStatus(factory, removeStatus));
		
		if (reject != null)
			factory.delete(reject);
	}

	//WDEV-18247
	public PatientElectiveListRefVo getActivePatientElectiveListsForCurrentCatsReferral(CatsReferralRefVo catsRef)
	{
		if (catsRef == null || catsRef.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsRef is null");
		
		StringBuilder hqlBuilder = new StringBuilder("select PEL from PatientElectiveList as PEL left join PEL.referral as CATS left join CATS.journey as JNY left join PEL.electiveListStatus as ELS left join ELS.electiveListStatus as STATUS where CATS.id=:CATS_ID and (STATUS is null or STATUS.id <> :STATUS) and PEL.pathwayClock is not null and PEL.pathwayClock.id = JNY.currentClock.id ");
		
		List <?> list = getDomainFactory().find(hqlBuilder.toString(),new String[]{"CATS_ID","STATUS"},new Object[]{catsRef.getID_CatsReferral(),WaitingListStatus.REMOVED.getID()} );
		
		if (list == null || list.size() == 0)
			return null;
		
		return PatientElectiveListVoAssembler.createPatientElectiveListVoCollectionFromPatientElectiveList(list).get(0);
		
	}
	
}
