// This code was generated by Ander Telleria using IMS Development Environment (version 1.65 build 3196.15076)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.RefMan.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.RefMan.domain.ReferralAppointmentDetailsComponent;
import ims.RefMan.domain.ReferralStatusList;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.ConsultationDetails;
import ims.RefMan.domain.objects.OrderInvAppt;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.vo.CatsReferralForClinicListVo;
import ims.RefMan.vo.CatsReferralListVo;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.CatsReferralWizardVo;
import ims.RefMan.vo.ConsultationDetailsVo;
import ims.RefMan.vo.PatientElectiveListForDNAAppointmentsVo;
import ims.RefMan.vo.SessionSlotCatsReferralClinicListWrapperVo;
import ims.RefMan.vo.SessionSlotCatsReferralClinicListWrapperVoCollection;
import ims.RefMan.vo.TCIForPatientElectiveListAppointmentDNAVo;
import ims.RefMan.vo.domain.CatsReferralClinicListListVoAssembler;
import ims.RefMan.vo.domain.CatsReferralForClinicListVoAssembler;
import ims.RefMan.vo.domain.CatsReferralWizardVoAssembler;
import ims.RefMan.vo.domain.ConsultationDetailsVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListForDNAAppointmentsVoAssembler;
import ims.RefMan.vo.domain.TCIForPatientElectiveListAppointmentDNAVoAssembler;
import ims.RefMan.vo.lookups.AdditionalInvestigationAppointmentsStatus;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.domain.objects.CareSpell;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.patient.domain.objects.Patient;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.place.domain.objects.Organisation;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.resource.place.vo.OrganisationRefVo;
import ims.core.vo.ActivityVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.CareSpellVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.OrganisationLiteVo;
import ims.core.vo.OrganisationLiteVoCollection;
import ims.core.vo.PatientShort;
import ims.core.vo.ServiceFunctionVoCollection;
import ims.core.vo.ServiceShortVo;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.CareSpellVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.OrganisationLiteVoAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.lookups.ContextType;
import ims.core.vo.lookups.OrganisationType;
import ims.core.vo.lookups.ServiceCategory;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainException;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.hibernate3.IMSCriteria;
import ims.domain.impl.DomainImpl;
import ims.domain.lookups.LookupInstance;
import ims.domain.lookups.LookupMapping;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.ILocation;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Image;
import ims.framework.utils.ImagePath;
import ims.framework.utils.Time;
import ims.ocrr.orderingresults.domain.objects.OrderedInvestigationStatus;
import ims.ocrr.orderingresults.vo.OrderInvestigationRefVo;
import ims.ocrr.vo.lookups.OrderInvStatus;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.domain.HL7PathwayIf;
import ims.pathways.domain.objects.PathwayClock;
import ims.pathways.domain.objects.PathwayRTTStatus;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.scheduling.domain.DirectoryOfServiceAdmin;
import ims.scheduling.domain.OCSExternalEvents;
import ims.scheduling.domain.SessionAdmin;
import ims.scheduling.domain.impl.DirectoryOfServiceAdminImpl;
import ims.scheduling.domain.impl.OCSExternalEventsImpl;
import ims.scheduling.domain.impl.SessionAdminImpl;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.Sch_Session;
import ims.scheduling.domain.objects.Session_Slot;
import ims.scheduling.helper.CABRequests;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.ProfileShortVo;
import ims.scheduling.vo.ProfileShortVoCollection;
import ims.scheduling.vo.Sch_BookingVoCollection;
import ims.scheduling.vo.Sch_SessionRefVo;
import ims.scheduling.vo.Sch_SessionRefVoCollection;
import ims.scheduling.vo.SessionShortVo;
import ims.scheduling.vo.SessionShortVoCollection;
import ims.scheduling.vo.SessionSlotClinicListListVo;
import ims.scheduling.vo.SessionSlotVo;
import ims.scheduling.vo.SessionSlotVoCollection;
import ims.scheduling.vo.Session_SlotRefVo;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.ProfileShortVoAssembler;
import ims.scheduling.vo.domain.Sch_BookingVoAssembler;
import ims.scheduling.vo.domain.SessionShortVoAssembler;
import ims.scheduling.vo.domain.SessionSlotClinicListListVoAssembler;
import ims.scheduling.vo.domain.SessionSlotVoAssembler;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.vo.LookupInstVo;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

public class ClinicListImpl extends DomainImpl implements ims.RefMan.domain.ClinicList, ims.domain.impl.Transactional
{
	private static final long serialVersionUID = 1L;
	private static final int PATIENT_DNA_NAT_CODE = 33;

	public SessionShortVoCollection listSession(ServiceShortVo service, ServiceFunctionVoCollection functionColl, ProfileShortVo profile, Date sessionDate) 
	{
		DomainFactory factory = getDomainFactory();
		SessionShortVoCollection voCollSessionShort = new SessionShortVoCollection();
			
		List<?> sessions;
		if(service != null)
		{
			sessions = factory.find(" from Sch_Session session where session.sessionDate = :sessionDate and " +
										" session.service.id = :serviceId",
										new String[]{"sessionDate","serviceId"},
										new Object[]{sessionDate.getDate(), service.getID_Service()});
		}
		else
		{
			sessions = factory.find(" from Sch_Session session where session.sessionDate = :sessionDate and " +
									" session.sch_Profile.id = :profileId",
									new String[]{"sessionDate","profileId"},
									new Object[]{sessionDate.getDate(), profile.getID_Sch_Profile()});
		}
		
		voCollSessionShort = SessionShortVoAssembler.createSessionShortVoCollectionFromSch_Session(sessions).sort();
					
		return voCollSessionShort;	
	}

	public ims.core.vo.ServiceShortVoCollection listService(ims.core.vo.ServiceShortVo serviceShort)
	{
		DirectoryOfServiceAdmin impl = (DirectoryOfServiceAdmin) getDomainImpl(DirectoryOfServiceAdminImpl.class);
		return impl.listService(serviceShort);
	}

	public ims.core.vo.ServiceFunctionVoCollection listServiceFunctions(ims.core.vo.ServiceShortVo serviceShort)
	{
		DirectoryOfServiceAdmin impl = (DirectoryOfServiceAdmin) getDomainImpl(DirectoryOfServiceAdminImpl.class);
		return impl.listServiceFunctions(serviceShort);
	}

	/**
	 * Note: only one parameter can be filled 
	 */
	public SessionSlotVoCollection listSessionSlots(SessionShortVo session, Integer[] sessionIds) 
	{
		if(session != null && sessionIds != null)
			throw new CodingRuntimeException("parameters are mutually exclusive in method listSessionSlots");
		
		DomainFactory factory = getDomainFactory();

		SessionSlotVoCollection voCollSessionSlots = new SessionSlotVoCollection();
		if(session != null)
		{
			Sch_Session doSession = (Sch_Session) factory.getDomainObject(Sch_Session.class, session.getID_Sch_Session());
			voCollSessionSlots = SessionSlotVoAssembler.createSessionSlotVoCollectionFromSession_Slot(doSession.getSessionSlots()).sort();
		}
		else if(sessionIds != null)
		{
			SessionSlotVoCollection voCollSessionSlot = new SessionSlotVoCollection();
			for(int i=0;i<sessionIds.length;i++)
			{
				Sch_Session doSession = (Sch_Session) factory.getDomainObject(Sch_Session.class, sessionIds[i]);
				voCollSessionSlot = SessionSlotVoAssembler.createSessionSlotVoCollectionFromSession_Slot(doSession.getSessionSlots()).sort();
				for(int p=0;p<voCollSessionSlot.size();p++)
				{
					voCollSessionSlots.add(voCollSessionSlot.get(p));
				}
			}
		}
		return voCollSessionSlots;
	}

	public PatientShort getBookingPatient(Booking_AppointmentVo appointment) 
	{
		DomainFactory factory = getDomainFactory();
		List<?> bookings =  factory.find("select booking from Sch_Booking booking join booking.appointments as appt where appt.id = :apptId",new String[]{"apptId"},new Object[]{appointment.getID_Booking_Appointment()});
		if(bookings != null && bookings.size() > 0)
			return Sch_BookingVoAssembler.createSch_BookingVoCollectionFromSch_Booking(bookings).get(0).getPatient();
		return null;
	}

	
	public ProfileShortVoCollection listProfiles(ILocation location, Date date) 
	{
		DomainFactory factory = getDomainFactory();
		
		String hql = "from Sch_Profile profile";
		
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		String andStr = " ";
		StringBuffer condStr = new StringBuffer();
		
		if(location != null)
		{
			condStr.append(andStr + " profile.schLocation.id = :locId");
			markers.add("locId");
			values.add(location.getID());	
			andStr = " and ";
		}

		if(date != null)
		{
			condStr.append(andStr + " profile.effFrm <= :dateFrom"); 
			markers.add("dateFrom");
			values.add(new DateTime(date, new Time("00:00:00")).getJavaDate());
			andStr = " and ";
			
			condStr.append(andStr + " (profile.effTo = null or profile.effTo >= :dateTo)");
			markers.add("dateTo");
			values.add(new DateTime(date, new Time("23:59:59")).getJavaDate());
			andStr = " and ";
		}
		
		
		condStr.append(andStr + " profile.isActive = :activeOnly");
		markers.add("activeOnly");
		values.add(new Boolean(true));	

		condStr.append(andStr + " profile.isTheatreProfile != :thrProfile");
		markers.add("thrProfile");
		values.add(new Boolean(true));	

		if(andStr.equals(" and "))
			hql += " where ";
		
		hql += condStr.toString();	
		List<?> profiles =  factory.find(hql, markers, values, 1000);
		return ProfileShortVoAssembler.createProfileShortVoCollectionFromSch_Profile(profiles);
	}

	@SuppressWarnings("unchecked")
	public void dnaAppt(Booking_AppointmentVo appt, ActionRequestType requestType) throws StaleObjectException 
	{
		DomainFactory factory = getDomainFactory();
		
		Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, appt);
		
		//pathways  WDEV-5021
		updateJourney(doAppt, false);
		
		try {
			factory.save(doAppt);
		} catch (DomainException e) {
			throw new DomainRuntimeException("Domain Error occured in dnaAppt " + e.getMessage(),e);
		} 
		
		//WDEV-5711	
		if(doAppt.getApptStatus().equals(getDomLookup(Status_Reason.DNA)))
		{
			List<?> ordinvList = factory.find("from OrderInvAppt ordInvAppt where ordInvAppt.appointment.id = " + doAppt.getId());
			if(ordinvList != null && ordinvList.size() >= 0)
			{
				boolean catsReferralUpdated = false;	
				Iterator<?> it = ordinvList.iterator();
				while(it.hasNext())
				{
					OrderInvAppt doOrderInvAppt = (OrderInvAppt) it.next();
					OCSExternalEvents impl = (OCSExternalEvents) getDomainImpl(OCSExternalEventsImpl.class); 
					impl.generateOrderPatientDNAEvent(new Booking_AppointmentRefVo(doOrderInvAppt.getAppointment().getId(), doOrderInvAppt.getAppointment().getVersion()), new OrderInvestigationRefVo(doOrderInvAppt.getOrderInvestigation().getId(), doOrderInvAppt.getOrderInvestigation().getVersion()));
					
					//WDEV-5727 
					if(!catsReferralUpdated)
					{
						saveCatsReferralwithAddtionalInvApptStatus(factory, doOrderInvAppt, AdditionalInvestigationAppointmentsStatus.DNA);
						catsReferralUpdated = true;
					}
					
					//WDEV-5740
					OrderedInvestigationStatus voOrdInvStatus = new OrderedInvestigationStatus();
					voOrdInvStatus.setChangeDateTime(new Date().getDate());
					voOrdInvStatus.setProcessedDateTime(new Date().getDate());
					voOrdInvStatus.setOrdInvStatus(getDomLookup(OrderInvStatus.HOLD_REQUESTED));
					voOrdInvStatus.setStatusReason("Patient DNA'd associated Appt");
					doOrderInvAppt.getOrderInvestigation().setOrdInvCurrentStatus(voOrdInvStatus);
					doOrderInvAppt.getOrderInvestigation().getOrdInvStatusHistory().add(voOrdInvStatus);
					factory.save(doOrderInvAppt);
				}
			}
		}
	
		if(ConfigFlag.GEN.ICAB_ENABLED.getValue())
		{
			if(doAppt.isIsCABBooking() != null && doAppt.isIsCABBooking().booleanValue())
				sendRequestandUpdateReferences(factory, requestType, doAppt, "Appt DNA Requested from ClinicList");
		}
	}
	
	//WDEV-5727 update the AddtionalInvApptStatus in the CatsReferral
	private void saveCatsReferralwithAddtionalInvApptStatus(DomainFactory factory, OrderInvAppt doOrderInvAppt, AdditionalInvestigationAppointmentsStatus status) throws StaleObjectException
	{
		if(factory == null || doOrderInvAppt == null || status == null)
			throw new CodingRuntimeException("all mandatory params not populated for method saveCatsReferralwithAddtionalInvApptStatus");
		
		List<?> lstCatsRef = factory.find("from CatsReferral catsRef join fetch catsRef.orderInvAppts ordInvAppt where ordInvAppt.id = '" + doOrderInvAppt.getId() + "'");
		if(lstCatsRef != null && lstCatsRef.size() == 1)
		{
			CatsReferral doCatsRef = (CatsReferral) lstCatsRef.get(0);
			doCatsRef.setAdditionalInvApptsStatus(getDomLookup(status));
			factory.save(doCatsRef);
		}
	}
	
	public Booking_Appointment sendRequestandUpdateReferences(DomainFactory factory,  ActionRequestType requestType, ims.domain.DomainObject doAppt, String requestSource) throws StaleObjectException
	{
		return CABRequests.sendRequestandUpdateReferences(factory, getDomLookup(requestType), doAppt, "Appt DNA Requested from ClinicList");
	}

	public void cancelSlot(SessionSlotVo sessionSlot, ActionRequestType requestType, String requestSource) throws StaleObjectException
	{
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		impl.cancelSlot(sessionSlot, requestType, requestSource);
	}

	public Booking_AppointmentVo cancelAppt(Booking_AppointmentVo appt, ActionRequestType requestType, String requestSource) throws StaleObjectException 
	{		
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		return impl.cancelAppt(appt, requestType, requestSource);
	}
			
	public void reOpenSlot(SessionSlotVo sessionSlot) throws StaleObjectException 
	{
		DomainFactory factory = getDomainFactory();
		Session_Slot doSessionSlot = SessionSlotVoAssembler.extractSession_Slot(factory, sessionSlot);
		factory.save(doSessionSlot);
	}

	private Booking_Appointment saveAppt(DomainFactory factory, Booking_AppointmentVo appt) throws StaleObjectException
	{		
		Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, appt);
		
		//increment slots remaining if its a cancel
		// wdev-5745 only for non-icab bookings as they will get set to provisional only
		if ((doAppt.isIsCABBooking() == null || doAppt.isIsCABBooking().booleanValue() == false) && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.CANCELLED)))
			doAppt.getSession().incrementRemainingSlots(1);

		// WDEV-5745 only set to cancelled provisional at this stage
		if (doAppt.isIsCABBooking() != null &&  doAppt.isIsCABBooking().booleanValue() == true && ConfigFlag.GEN.ICAB_ENABLED.getValue())
			doAppt.setApptStatus(getDomLookup(Status_Reason.CANCEL_PROVISIONAL));
		
		//WDEV-5021
		updateJourney(doAppt, true);

		try {
			factory.save(doAppt);
		} catch (DomainException e) {
			throw new DomainRuntimeException("Domain Error occured in saveAppt " + e.getMessage(),e);
		} 
		return doAppt;
	}

	public Sch_BookingVoCollection listFlexibleBookings(Sch_SessionRefVo session) 
	{
		DomainFactory factory = getDomainFactory();
		
		List<?> bookings = factory.find("select booking from Sch_Booking as booking left join booking.appointments as appt where appt.session.id = :sessionId", new String[]{"sessionId"}, new Object[]{session.getID_Sch_Session()});
		return Sch_BookingVoAssembler.createSch_BookingVoCollectionFromSch_Booking(bookings);
	}

	public SessionSlotVoCollection listAppointments(Sch_SessionRefVo session, Integer[] sessionIds, Status_Reason apptType)
	{
		if(session != null && sessionIds != null)
			throw new CodingRuntimeException("parameters are mutually exclusive in method listAppointments");
		
		DomainFactory factory = getDomainFactory();

		String hql = "";
		if(session != null)
		{
			hql = "select sessionSlot from Sch_Session as session join session.sessionSlots as sessionSlot" + 
			" where (session.id = :idSession" +  (apptType == null ? ")" : "");
		}
		else if(sessionIds != null)
		{
			hql = "select sessionSlot from Sch_Session as session join session.sessionSlots as sessionSlot" + 
			" where (session.id in (" + getIdString(sessionIds) + ")" +  (apptType == null ? ")" : "");
		}
		
		if(apptType != null)
			hql += " and sessionSlot.appointment is not null and sessionSlot.appointment.apptStatus.id = " + apptType.getID() + ")";
		
		List<?> slots = factory.find(hql, new String[] {"idSession"}, new Object[] {session.getID_Sch_Session()});
		return SessionSlotVoAssembler.createSessionSlotVoCollectionFromSession_Slot(slots).sort();	
	}
	
	private String getIdString(Integer[] sessionIds)
	{
		String idString = "";
		
		for(int i=0;i<sessionIds.length;i++)
		{
			idString += sessionIds[i];
			idString += ((sessionIds.length - (i+1)) > 0 ? "," : "");
		}
		
		return idString;
	}

	public void saveAppointment(Booking_AppointmentVo appt) throws StaleObjectException
	{
		saveAppt(getDomainFactory(), appt);
	}

	public CareSpellVo saveCareSpell(CareSpellVo voCareSpell) throws StaleObjectException
	{
		if (voCareSpell == null  || !voCareSpell.isValidated())
			throw new CodingRuntimeException("Care Spell is null or has not been validated");
			
		DomainFactory factory = getDomainFactory();
		CareSpell doCareSpell = CareSpellVoAssembler.extractCareSpell(factory, voCareSpell);		
		factory.save(doCareSpell);

		return CareSpellVoAssembler.create(doCareSpell);		}

	public ContextType getPASCode(ActivityVo activity)
	{
		DomainFactory factory = getDomainFactory();
		ims.domain.lookups.Lookup lookupType = factory.getLookup(ContextType.TYPE_ID);
		
		if (null != lookupType)
		{
			java.util.Set<?> set = lookupType.getInstances();
			
			for (Iterator<?> iter = set.iterator(); iter.hasNext();)
			{
				LookupInstance lookup = (LookupInstance) iter.next();
				
				if(lookup.isActive())
				{
					Set<?> mappings = lookup.getMappings();
					
					for (Object object : mappings)
					{
						if(object instanceof LookupMapping)
						{
							LookupMapping mapping = (LookupMapping)object;
							
							if("PAS".equals(mapping.getExtSystem()) && activity.getID_Activity().toString().equalsIgnoreCase(mapping.getExtCode()))
							{
								LookupInstVo vo = createLookupinstanceVo(lookup);
								//public ContextType(int id, String text, boolean active, ContextType parent, Image image, Color color, int order)
								ContextType contextType = new ContextType(vo.getID(), vo.getText(), vo.isActive());
								return contextType;
							}
						}
					}
					
				}
				
			}
		}		
		
		return null;
	}
	
	private LookupInstVo createLookupinstanceVo(LookupInstance element)
	{
		if (element == null)
			return null;
		Image img = null;
		Image regImage = element.getImage();
		if (regImage != null)
		{
			img = new ImagePath(regImage.getImageId(), regImage.getImagePath());
		}
		LookupInstVo valueObject = new LookupInstVo(element.getId(), element.getText(), element.isActive(), null, img, element.getColor(), element.getOrder());
		LookupInstance doParent = element.getParent();
		if (doParent != null)
		{
			LookupInstVo voParent = createLookupinstanceVo(doParent);
			valueObject.setParentInstance(voParent);
		}
		return valueObject;
	}

	public void updateJourney(Booking_Appointment doAppt, Boolean isCancel) throws StaleObjectException
	{
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		impl.updateJourney(doAppt, isCancel);
	}

	public CatsReferralRefVo getCatsReferralForAppointment(Booking_AppointmentRefVo appt)
	{
		if(appt == null || appt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("appt is null or id not provide for getCatsReferralForAppointment");
		
		DomainFactory factory = getDomainFactory();
		List<?> catsRefId = factory.find("select catsRef.id from CatsReferral as catsRef left join catsRef.appointments as bookAppt where (bookAppt.id = '" + appt.getID_Booking_Appointment() + "')");
		if(catsRefId != null)
		{
			Integer val = (Integer) catsRefId.get(0);
			if(val != null && val.intValue() > 0)
			{
				return new CatsReferralRefVo(val, 0);
			}
		}	
		return null;
	}
	
	public CatsReferralWizardVo getCatsReferralWizardForAppointment(Booking_AppointmentRefVo appt)
	{
		if(appt == null || appt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("appt is null or id not provide for getCatsReferralForAppointment");
		
		DomainFactory factory = getDomainFactory();
		List<?> catsRef = factory.find("select catsRef from CatsReferral as catsRef join fetch catsRef.appointments as bookAppt where (bookAppt.id = '" + appt.getID_Booking_Appointment() + "')");
		if(catsRef != null && catsRef.size() > 0)
		{
			 CatsReferral val = (CatsReferral) catsRef.get(0);
			if(val != null)
			{
				return CatsReferralWizardVoAssembler.create(val);
			}
		}	
		return null;
	}

	public ConsultationDetailsVo getConsultationDetailsForCatsReferral(CatsReferralRefVo catsReferral)
	{
		DomainFactory factory = getDomainFactory();
		ArrayList <String> objects = new ArrayList <String>();
		objects.add("cATSReferral");
		IMSCriteria imsc=new IMSCriteria(ConsultationDetails.class,objects,factory);
		imsc.equal("this.cATSReferral.id", catsReferral.getID_CatsReferral());
		List<?> consults=imsc.find();
		if (consults.size()>0)
		{
			ConsultationDetails consultation = (ConsultationDetails)consults.get(0);
			if (consultation.getConsultationTimes()==null)
				return null;
			else
				return ConsultationDetailsVoAssembler.create(consultation);
		}
		else
			return null;
		
	}

	public void saveConsultationDetails(ConsultationDetailsVo consultation) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		factory.save(ConsultationDetailsVoAssembler.extractConsultationDetails(factory, consultation));
	}

	public void updateCatsReferralAdditionalInvStatus(CatsReferralRefVo catsReferral) throws StaleObjectException
	{
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		impl.updateCatsReferralAdditionalInvStatus(catsReferral);		
	}

	public ConsultationDetailsVo saveConsultationAndReferralAndAppt(ConsultationDetailsVo voConsultation, CatsReferralListVo voReferral, Booking_AppointmentVo voAppt) throws StaleObjectException 
	{
		ReferralStatusList impl = (ReferralStatusList) getDomainImpl(ReferralStatusListImpl.class);
		return impl.saveConsultationAndReferralAndAppt(voConsultation, voReferral, voAppt);		
	}

	public CatsReferralListVo getCatsReferral(CatsReferralRefVo voReferralRef) 
	{
		ReferralStatusList impl = (ReferralStatusList) getDomainImpl(ReferralStatusListImpl.class);
		return impl.getCatsReferral(voReferralRef);		
	}

	public CareContextShortVo getCareContextShort(CareContextRefVo voCareContextRef) 
	{
		if (voCareContextRef == null)
			throw new RuntimeException("Cannot get CareContextShortVo for null CareContextRefVo");

		CareContext doCareContext = (CareContext) getDomainFactory().getDomainObject(CareContext.class, voCareContextRef.getID_CareContext());
		return CareContextShortVoAssembler.create(doCareContext);
	}

	public PatientShort getPatient(PatientRefVo patient) 
	{
		if (patient!=null)
			if (patient.getID_Patient()!=null)
			{
				IMSCriteria imsc=new IMSCriteria(Patient.class,getDomainFactory());
				imsc.equal("this.id", patient.getID_Patient());
				List<?> patients = imsc.find();
				if (patients.size()>0)
					return PatientShortAssembler.create((Patient) patients.get(0));
				return null;
			}
		return null;
	}

	public LocationLiteVoCollection listLocationLite() 
	{
		DirectoryOfServiceAdmin impl = (DirectoryOfServiceAdmin) getDomainImpl(DirectoryOfServiceAdminImpl.class);
		return impl.listLocationLiteByName(null).sort();
	}

	public void updateCatsReferralCancelStatus(CatsReferralRefVo catsReferral) throws StaleObjectException 
	{
		ReferralAppointmentDetailsComponent impl = (ReferralAppointmentDetailsComponent) getDomainImpl(ReferralAppointmentDetailsComponentImpl.class);
		impl.updateCatsReferralCancelStatus(catsReferral);
	}

	public OrganisationLiteVoCollection listOrganisation() 
	{
		String hql = "from Organisation as org where  (org.type is not null  and org.type.id not in (:gpp,:supp,:pct) and org.isActive = 1 and org.parentOrganisation is null) order by org.upperName asc ";
		List<?> list = getDomainFactory().find(hql,new String[]{"gpp","supp","pct"},new Object[]{OrganisationType.GPP.getId(),OrganisationType.SUPPLIER.getId(),OrganisationType.NHS_PCT.getId()});
		if (list == null || list.size() == 0)
			return null;
		return OrganisationLiteVoAssembler.createOrganisationLiteVoCollectionFromOrganisation(list);
	}

	public LocationLiteVoCollection listLocationByOrganisation(OrganisationRefVo orgId) 
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listLocationByOrganisation(orgId, null);
	}

	public OrganisationLiteVo getOrganisationByLocation(Integer locationId) 
	{
		if(locationId == null)
			throw new CodingRuntimeException("Cannot get Organisation by null location id.");
		
		Integer parentLocationId = getParentLocation(locationId);
		
		Organisation org = getOrganisationFromLoc(parentLocationId);
		
		return org != null ? OrganisationLiteVoAssembler.create(org) : null;
	}

	@SuppressWarnings("unchecked")
	private Organisation getOrganisationFromLoc(Integer parentLocationId)
	{
		if(parentLocationId == null)
			return null;
		
		String query = "select org from Organisation as org left join org.locationSites as loc where loc.id = :locid";
		
		List<Organisation> orgList = getDomainFactory().find(query, new String[] {"locid"}, new Object[] {parentLocationId});
		
		if(orgList != null && orgList.size() > 0)
		{
			Organisation org = orgList.get(0);
			
			return getOrgByOrg(org);
		}
		
		return null;
		//throw new DomainRuntimeException("Invalid location id. ");
	}

	private Organisation getOrgByOrg(Organisation org) 
	{
		if(org == null)
			return null;
		
		if(org.getParentOrganisation() != null)
		{
			return getOrgByOrg(org.getParentOrganisation());
		}
		
		return org;
	}

	private Integer getParentLocation(Integer locationId) 
	{
		if(locationId == null)
			return null;
		
		List<Integer> locId = getLocation(locationId);
		
		if(locId != null && locId.size() > 0)
			return getParentLocation(locId.get(0));
		
		return locationId;
	}

	@SuppressWarnings("unchecked")
	private List<Integer> getLocation(Integer locationId) 
	{
		String query = "select parentLocation.id from Location as parentLocation left join parentLocation.locations as loc where loc.id = :locid";
		return getDomainFactory().find(query,new String[]{"locid"}, new Object[]{locationId});
	}

	public SessionSlotCatsReferralClinicListWrapperVoCollection listAppointments(Sch_SessionRefVoCollection sessions, Status_Reason apptType) 
	{
		if (sessions == null || sessions.size() == 0 )
			throw new DomainRuntimeException("No Sessions provided");
		
		
		String hql = "select sslot,cats from CatsReferral as cats left join cats.appointments as appo " +
				"right join appo.sessionSlot as sslot where (sslot.session.id in ("+generateListString(sessions)+")";
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		if (apptType != null)
		{
			hql +=  " and appo.apptStatus.id = :statusId ";
			paramNames.add("statusId");
			paramValues.add(apptType.getId());
		}
		hql += "  ) order by sslot.startTm asc, sslot.id asc ";
		List<?> list = getDomainFactory().find(hql,paramNames,paramValues);
		if (list == null || list.size() == 0)
			return null;
		SessionSlotCatsReferralClinicListWrapperVoCollection result = new SessionSlotCatsReferralClinicListWrapperVoCollection();
		for (int i = 0 ; i <list.size() ; i++)
		{
			if (list.get(i) instanceof Object[])
			{
			
			SessionSlotCatsReferralClinicListWrapperVo elem = new SessionSlotCatsReferralClinicListWrapperVo();
			Object[] objects = (Object[])list.get(i);
			elem.setSlot(SessionSlotClinicListListVoAssembler.create((Session_Slot) objects[0]));
			elem.setReferral(objects[1] == null ? null : CatsReferralClinicListListVoAssembler.create((CatsReferral) objects[1]));
			result.add(elem);
		
			}
		}
		
		return result;
	}

	private String generateListString(Sch_SessionRefVoCollection sessions) {
		StringBuilder result = new StringBuilder();
		String comma = "";
		for (int i = 0  ; sessions!= null && i < sessions.size() ; i++)
		{
			if (sessions.get(i) == null || !sessions.get(i).getID_Sch_SessionIsNotNull())
				continue;
			result.append(comma);
			result.append(sessions.get(i).getID_Sch_Session());
			comma = ",";
		}
		return result.toString();
	}

	public PatientShort getPatientShort(PatientRefVo patRef) 
	{
		if (patRef == null || !patRef.getID_PatientIsNotNull())
			throw new DomainRuntimeException("Invalid Patient referrence provided");
		DomainFactory factory = getDomainFactory();
		return PatientShortAssembler.create((Patient) factory.getDomainObject(Patient.class, patRef.getID_Patient()));
	}

	public SessionSlotVo getSessionSlot(Session_SlotRefVo slotRef) 
	{
		if (slotRef == null || !slotRef.getID_Session_SlotIsNotNull())
				throw new DomainRuntimeException("Invalid Session Slot reference provided.");
		return SessionSlotVoAssembler.create((Session_Slot) getDomainFactory().getDomainObject(Session_Slot.class, slotRef.getID_Session_Slot()));
		
	}

	//WDEV-12568
	public Booking_AppointmentVo getAppointment(Session_SlotRefVo session)
	{
		if(session == null || !session.getID_Session_SlotIsNotNull())
			throw new DomainRuntimeException("Invalid Session Slot reference provided.");
		
		DomainFactory factory = getDomainFactory();
		String query = "select ss.appointment from Session_Slot as ss where ss.id = :SessionSlotId";
		
		List<?> list = factory.find(query, new String[] {"SessionSlotId"}, new Object[] {session.getID_Session_Slot()});
		
		if(list == null || list.size() == 0)
			return null;
		
		if(list.size() > 1)
			throw new DomainRuntimeException("A session slot can not have associated more than one appointment.");
		
		return Booking_AppointmentVoAssembler.create((Booking_Appointment) list.get(0));
	}

	//WDEV-12568
	public CatsReferralForClinicListVo getCatsReferral(Booking_AppointmentRefVo appt)
	{
		if(appt == null || appt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("Can not get Referral on null Appointment.");
		
		DomainFactory factory = getDomainFactory();
		List<?> cats = factory.find(" select catsref from CatsReferral as catsref left join catsref.appointments as appt where appt.id = :apptID",	new String[]{"apptID"},	new Object[]{appt.getID_Booking_Appointment()});
		if (cats != null && cats.size() > 0)
			return CatsReferralForClinicListVoAssembler.create((CatsReferral)cats.get(0));
		
		return null;
	}

	//WDEV_12568
	public void saveAppointmentForDNA(Booking_AppointmentVo appt, CatsReferralForClinicListVo catsReferral,	SessionSlotClinicListListVo sessionSlot, PatientElectiveListForDNAAppointmentsVo electiveList,	Boolean isFirstApptActivityforDNA) throws StaleObjectException, DomainInterfaceException
	{
		if(appt == null)
			throw new DomainRuntimeException("Invalid Booking to save");
		
		if(!appt.isValidated())
			throw new DomainRuntimeException("Booking Record not validated before save");
		
		if(catsReferral != null && !catsReferral.isValidated())
			throw new DomainRuntimeException("Referral Record not validated before save");
		
		if(sessionSlot != null && !sessionSlot.isValidated())
			throw new CodingRuntimeException("Session Slot is not validated.");
		
		DomainFactory factory = getDomainFactory();
		
		Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, appt);
		
		factory.save(doAppt);
		
		if(ConfigFlag.GEN.ICAB_ENABLED.getValue())
		{
			if(doAppt.getApptStatus() != null && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.DNA)))
			{
				if(doAppt.isIsCABBooking() != null && doAppt.isIsCABBooking().booleanValue())
					CABRequests.sendRequestandUpdateReferences(factory, getDomLookup(ActionRequestType.NOTIFY_DNA), doAppt, "Appt DNA Requested from ClinicListWithIcpActions");	
			}
		}
				
		//WDEV-18524
		CatsReferral doCats = updateCatsReferral(factory, catsReferral, doAppt, isFirstApptActivityforDNA);

		try
		{
			factory.save(doCats);
		}
		catch(StaleObjectException e)
		{
			doCats = updateCatsReferral(factory, catsReferral, doAppt, isFirstApptActivityforDNA);
			factory.save(doCats);
		}
			
		if (doCats != null && isFirstApptActivityforDNA && Boolean.TRUE.equals(doCats.isRTTClockImpact()) && doCats.getJourney() != null)
		{	
			instantiatePatientEvent(doCats);
		}

		if (electiveList != null)
		{
			@SuppressWarnings("rawtypes")
			HashMap domMap = new HashMap(); 
			TCIForPatientElectiveListAppointmentDNAVo currentTCI = electiveList.getTCIDetails();
			TCIForPatientElectiveList domTCIToSave = TCIForPatientElectiveListAppointmentDNAVoAssembler.extractTCIForPatientElectiveList(factory, currentTCI, domMap);
			electiveList.setTCIDetails(null);
			PatientElectiveList domPatientElectiveList = PatientElectiveListForDNAAppointmentsVoAssembler.extractPatientElectiveList(factory, electiveList, domMap);
			
			factory.save(domPatientElectiveList);
			factory.save(domTCIToSave);
		}
				
		if(sessionSlot != null)
		{			
			Session_Slot doSessionSlot = SessionSlotClinicListListVoAssembler.extractSession_Slot(factory, sessionSlot);
			factory.save(doSessionSlot);
		}
	}
	
	private CatsReferral updateCatsReferral(DomainFactory factory, CatsReferralForClinicListVo catsReferral, Booking_Appointment doAppt, Boolean isFirstApptActivityforDNA) throws StaleObjectException
	{
		//WDEV-18524
		CatsReferral doCats = (CatsReferral) factory.getDomainObject(CatsReferral.class, catsReferral.getID_CatsReferral());
		doCats.setHasDNAApptsForReview(catsReferral.getHasDNAApptsForReview());
		
		//	WDEV-12813
		if(doAppt.getApptStatus().equals(getDomLookup(Status_Reason.ARRIVAL)))
		{
			if(doAppt.getSession() != null &&  doAppt.getSession().getService() != null &&  doAppt.getSession().getService().getServiceCategory() != null)
			{
				if(doAppt.getSession().getService().getServiceCategory().equals( getDomLookup(ServiceCategory.CLINICAL)))
				{
					doCats.setLastApptArrivedDate(new Date().getDate());
				}
			}
			
			//WDEV-5711 - generatePatientArrivingEvent 
			OCSExternalEvents impl = (OCSExternalEvents) getDomainImpl(OCSExternalEventsImpl.class); 
			impl.generatePatientArrivingEvent(new Booking_AppointmentRefVo(doAppt.getId(), 0), null);			
		}
		
		//WDEV-17987 when Undo Arrival, if there are no other Arrived or Seen appointments for the Referral, clear last appointment arrived date so the context menus are updated correctly
		else if(doAppt.getApptStatus().equals(getDomLookup(Status_Reason.BOOKED)))
		{
			if(doAppt.getSession() != null &&  doAppt.getSession().getService() != null &&  doAppt.getSession().getService().getServiceCategory() != null)
			{
				if(doAppt.getSession().getService().getServiceCategory().equals( getDomLookup(ServiceCategory.CLINICAL)) && canClearLastPatArrivedDate(doCats))
				{
					doCats.setLastApptArrivedDate(null);
				}
			} 
		}
		
		
		//WDEV-18325
		PathwayRTTStatus rttSTatusDO = null;
		
		if (isFirstApptActivityforDNA && Boolean.TRUE.equals(doCats.isRTTClockImpact()))
		{
			PatientPathwayJourney journeyDO = doCats.getJourney();

			int dnaNatCode = PATIENT_DNA_NAT_CODE;

			rttSTatusDO = createPatientRTTStatus(dnaNatCode);

			if  (journeyDO != null)
			{
				if (journeyDO.getCurrentClock() != null)
				{
					PathwayClock ptwClockDO = journeyDO.getCurrentClock();

					ptwClockDO.setCurrentRTTStatus(rttSTatusDO);

					List<PathwayRTTStatus> ptwClockHistory = ptwClockDO.getRTTStatusHistory();

					if (ptwClockHistory == null)
					{
						ptwClockHistory = new java.util.ArrayList();
					}
					
					ptwClockHistory.add(rttSTatusDO);
				}
			}
			
			doCats.setCurrentRTTStatus(rttSTatusDO);
		}
		
		return doCats;
	}

	private PathwayRTTStatus createPatientRTTStatus(int nationalCode) //WDEV-18325
	{
		PathwayRTTStatus rttSTatusDO = new PathwayRTTStatus();
		
		RTTStatusPoint rttStatusPoint = getRTTStatusPointFromConfig(nationalCode);
		
		rttSTatusDO.setRTTStatus(rttStatusPoint);
		
		Object mos = getMosUser();
		MemberOfStaff doMos = null;
		
		if(mos instanceof MemberOfStaffLiteVo)
		{
			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
		}
		
		rttSTatusDO.setStatusBy(doMos);
		rttSTatusDO.setStatusDateTime(new java.util.Date());
		
		rttSTatusDO.setSetting("O");
		
		return rttSTatusDO;
	}

	private void  instantiatePatientEvent(CatsReferral doCats) throws StaleObjectException, DomainInterfaceException //WDEV-18325
	{
		if (!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return;
		
		if(doCats == null || doCats.getJourney() == null || doCats.getJourney().getCurrentClock() == null)
			return;
		
		RTTStatusEventMapVo rttEventMap = null;

		if (doCats.getJourney().getCurrentClock().getCurrentRTTStatus() != null)
		{
			rttEventMap = getRTTStatusEventMap(doCats.getJourney().getCurrentClock().getCurrentRTTStatus().getRTTStatus());
		}
		
		if (rttEventMap == null || rttEventMap.getEvent() == null)
			return;
		
		PatientEventVo patEvent = new PatientEventVo();
		patEvent.setPatient((PatientRefVo)PatientListVoAssembler.create(doCats.getPatient()));
		patEvent.setEvent(rttEventMap.getEvent());
		patEvent.setEventDateTime(new DateTime());
		patEvent.setEventStatus(EventStatus.ACTIVE);
		patEvent.setJourney(PatientJourneyVoAssembler.create(doCats.getJourney()));
		
		HL7PathwayIf impl = (HL7PathwayIf) getDomainImpl(ims.pathways.domain.impl.HL7PathwayIfImpl.class);
		
		impl.instantiatePatientEvent(patEvent);
	}
		
	private RTTStatusPoint getRTTStatusPointFromConfig(int nationalCode) //WDEV-18325
	{	
		String hql = "from RTTStatusPoint as rttpoint where rttpoint.nationalCode = :natCode";
		DomainFactory fact = getDomainFactory();
		
		List<?> results = fact.find(hql, new String[]{"natCode"}, new Object[] {nationalCode});
		if (results != null && results.size() != 0 && results.get(0) instanceof RTTStatusPoint)
		{	
			return (RTTStatusPoint) results.get(0);
						
		}
		return null;
	}

	private RTTStatusEventMapVo getRTTStatusEventMap(RTTStatusPoint rttStatusPoint) //WDEV-18325 
	{
		if (rttStatusPoint == null || rttStatusPoint.getId() == null)	
			return null;

		String hql = "select event from RTTStatusEventMap as event left join event.currentRTTStatus as rttstat where event.active = 1 and rttstat.nationalCode = :natCode";

		DomainFactory factory = getDomainFactory();

		List<?> events = factory.find(hql, new String[]{"natCode"}, new Object[] {rttStatusPoint.getNationalCode()});

		if (events != null && events.size() != 0 && events.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) events.get(0));
		}
		return null;		
	}
	//WDEV-17987
	private boolean canClearLastPatArrivedDate(CatsReferral doCats)
	{
		if (doCats.getAppointments() == null)
			return true;

		Iterator<?> it1 = doCats.getAppointments().iterator();

		while (it1.hasNext())
		{
			Booking_Appointment doItem = (Booking_Appointment) it1.next();

			if (doItem.getApptStatus() != null && (doItem.getApptStatus().equals(getDomLookup(Status_Reason.ARRIVAL)) || doItem.getApptStatus().equals(getDomLookup(Status_Reason.SEEN))))
			{
				return false;
			}
		}

		return true;
	}

	public Boolean isThereAnyDiagnosticContractsForThisSite(OrganisationRefVo voOrg)
	{
		ReferralStatusList impl = (ReferralStatusList) getDomainImpl(ReferralStatusListImpl.class);
		return impl.isThereAnyDiagnosticContractsForThisSite(voOrg);		
	}

	//WDEV-12842
	public Booking_AppointmentVo getArrivedBookingAppt(CatsReferralListVo catsReferralRefVo)
	{
		if (catsReferralRefVo == null)
			throw new CodingRuntimeException("Invalid catsReferralRefVo");
		
		if (catsReferralRefVo.getLastApptArrivedDate() == null)
			throw new CodingRuntimeException("LastApptArrivedDate can not be null.");

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();

		StringBuffer sb = new StringBuffer();
		String andStr = "";

		String hql = "select bappts from CatsReferral as catsref join catsref.appointments as bappts"; 

		sb.append(" catsref.id = :catsid");
		markers.add("catsid");
		values.add(catsReferralRefVo.getID_CatsReferral());
		andStr = " and ";
			
		sb.append(andStr + " bappts.appointmentDate= :td");
		markers.add("td");
		values.add(catsReferralRefVo.getLastApptArrivedDate().getDate());
		andStr = " and ";

		sb.append(andStr + " bappts.apptStatus = :aStat");
		markers.add("aStat");
		values.add(getDomLookup(Status_Reason.ARRIVAL));
		andStr = " and ";
		
		sb.append(andStr + " bappts.session.sch_Profile.service.serviceCategory = :serCat");
		markers.add("serCat");
		values.add(getDomLookup(ServiceCategory.CLINICAL));
		andStr = " and ";

		sb.append(" and catsref.isRIE is null ");
		sb.append(" order by bappts.apptStartTime asc");
		
		hql += " where ";
		hql += sb.toString();
		
		List<?> list = getDomainFactory().find(hql.toString(), markers, values);	
		
		if (list != null && list.size() > 0)
			return Booking_AppointmentVoAssembler.create((Booking_Appointment)list.get(0));
		
		return null;
	}

	/**
	 * WDEV-12875
	 * Function used to analyse ContractConfiguration records for all Organisations on the branch (up form provided location)
	 * @return <b>true</b> if at least one ContractConfiguration record active and of type Diagnostic, <b>false</b> otherwise
	 * 
	 * <br><b>NOTE</b>It will call the 'hasLocationDiagnosticContract()' method from ReferralStatusList
	 */
	public Boolean hasLocationDiagnosticContract(LocationRefVo location)
	{
		ReferralStatusList impl = (ReferralStatusList) getDomainImpl(ReferralStatusListImpl.class);
		
		return impl.hasLocationDiagnosicContracts(location);
	}

	public Boolean hasTCI(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null)
			return Boolean.FALSE;

		String query = "SELECT COUNT (tci.id) FROM TCIForPatientElectiveList AS tci LEFT JOIN tci.appointment AS appt WHERE appt.id = :APPT_ID and tci.isRIE is null";
		
		long count = getDomainFactory().countWithHQL(query, new String[] {"APPT_ID"}, new Object[] {appointment.getID_Booking_Appointment()});
		
		if (count > 0)
			return Boolean.TRUE;
		
		return Boolean.FALSE;
	}

	public PatientElectiveListForDNAAppointmentsVo getPatientElectiveList(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null)
			return null;
		
		String query = "SELECT electivList FROM PatientElectiveList AS electivList LEFT JOIN electivList.tCIDetails AS tci LEFT JOIN tci.appointment AS appt WHERE appt.id = :APPT_ID ";
		
		return PatientElectiveListForDNAAppointmentsVoAssembler.create((PatientElectiveList) getDomainFactory().findFirst(query, "APPT_ID", appointment.getID_Booking_Appointment()));
	}
}
