//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by John Pearson using IMS Development Environment (version 1.45 build 2259.24726)
// Copyright (C) 1995-2006 IMS MAXIMS plc. All rights reserved.

package ims.ocs_if.domain.impl;

import ims.admin.domain.ResultsPrintingConfig;
import ims.admin.domain.impl.ResultsPrintingConfigImpl;
import ims.admin.helper.Keywords;
import ims.admin.vo.ConfigPropertyVo;
import ims.admin.vo.ConfigPropertyVoCollection;
import ims.admin.vo.PrintLocationConfigVo;
import ims.admin.vo.domain.PrintLocationConfigVoAssembler;
import ims.configuration.ConfigItems;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.ProviderSystem;
import ims.core.admin.vo.ProviderSystemRefVo;
import ims.core.charting.domain.objects.DatasetType;
import ims.core.clinical.domain.objects.PatientNotification;
import ims.core.clinical.domain.objects.PatientOCSNewResults;
import ims.core.clinical.domain.objects.Service;
import ims.core.patient.domain.objects.Patient;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.domain.objects.LocationService;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.ServiceShortVo;
import ims.core.vo.ServiceShortVoCollection;
import ims.core.vo.domain.ServiceShortVoAssembler;
import ims.core.vo.lookups.DataSetCategory;
import ims.core.vo.lookups.LineColourPointIcon;
import ims.core.vo.lookups.LineType;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.MsgEventType;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.core.vo.lookups.QueueType;
import ims.core.vo.lookups.TaxonomyType;
import ims.core.vo.lookups.YesNo;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.domain.lookups.LookupInstance;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.DateTime;
import ims.hl7.utils.HL7Utils;
import ims.ocrr.configuration.domain.objects.Analyte;
import ims.ocrr.configuration.domain.objects.Investigation;
import ims.ocrr.configuration.domain.objects.LocSvcProviderSys;
import ims.ocrr.configuration.domain.objects.Specimen;
import ims.ocrr.orderingresults.domain.objects.CentralBatchPrint;
import ims.ocrr.orderingresults.domain.objects.ClinicalResultDetail;
import ims.ocrr.orderingresults.domain.objects.OcsOrderSession;
import ims.ocrr.orderingresults.domain.objects.OrderChangeResponseQueue;
import ims.ocrr.orderingresults.domain.objects.OrderInvestigation;
import ims.ocrr.orderingresults.domain.objects.OrderResultHistory;
import ims.ocrr.orderingresults.domain.objects.OrderSpecimen;
import ims.ocrr.orderingresults.domain.objects.OrderedInvestigationStatus;
import ims.ocrr.orderingresults.domain.objects.OrderingLocationBatchPrint;
import ims.ocrr.orderingresults.domain.objects.PathResultDetails;
import ims.ocrr.orderingresults.domain.objects.ResultDetails;
import ims.ocrr.orderingresults.vo.OcsOrderSessionRefVo;
import ims.ocrr.orderingresults.vo.OrderInvestigationRefVo;
import ims.ocrr.orderingresults.vo.OrderSpecimenRefVo;
import ims.ocrr.vo.lookups.Category;
import ims.ocrr.vo.lookups.InvEventType;
import ims.ocrr.vo.lookups.InvestigationOrderability;
import ims.ocrr.vo.lookups.MinReorderPeriod;
import ims.ocrr.vo.lookups.OcsDisplayFlag;
import ims.ocrr.vo.lookups.OrderInvStatus;
import ims.ocrr.vo.lookups.ResultSpecimenTypes;
import ims.ocrr.vo.lookups.ResultUnitOfMeasure;
import ims.ocrr.vo.lookups.SpecimenSite;
import ims.ocrr.vo.lookups.SpecimenType;
import ims.ocs_if.domain.base.impl.BaseOcsIfInboundImpl;
import ims.ocs_if.helper.GHGWinPathNumbers;
import ims.ocs_if.vo.IfAnalyteVo;
import ims.ocs_if.vo.IfInvestigationLiteVo;
import ims.ocs_if.vo.IfLocParentVo;
import ims.ocs_if.vo.IfOcsOrderShortVo;
import ims.ocs_if.vo.IfOcsOrderVo;
import ims.ocs_if.vo.IfOcsPathResultVo;
import ims.ocs_if.vo.IfOrdInvResultVo;
import ims.ocs_if.vo.IfOrderInvCurrentStatusVo;
import ims.ocs_if.vo.IfOrderInvestigationVo;
import ims.ocs_if.vo.IfOrderSpecimenVo;
import ims.ocs_if.vo.IfOutOcsOrderVo;
import ims.ocs_if.vo.IfProviderInvSearchVo;
import ims.ocs_if.vo.IfResultDetailsVo;
import ims.ocs_if.vo.IfResultDetailsVoCollection;
import ims.ocs_if.vo.domain.IfAnalyteVoAssembler;
import ims.ocs_if.vo.domain.IfInvestigationLiteVoAssembler;
import ims.ocs_if.vo.domain.IfLocParentVoAssembler;
import ims.ocs_if.vo.domain.IfOcsOrderShortVoAssembler;
import ims.ocs_if.vo.domain.IfOcsOrderVoAssembler;
import ims.ocs_if.vo.domain.IfOcsPathResultVoAssembler;
import ims.ocs_if.vo.domain.IfOrdInvResultVoAssembler;
import ims.ocs_if.vo.domain.IfOrderInvestigationVoAssembler;
import ims.ocs_if.vo.domain.IfOrderSpecimenVoAssembler;
import ims.ocs_if.vo.domain.IfOutOcsOrderVoAssembler;
import ims.ocs_if.vo.domain.IfResultDetailsVoAssembler;
import ims.vo.LookupInstVo;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;

public class OcsIfInboundImpl extends BaseOcsIfInboundImpl
{
	private static final long serialVersionUID = 1L;
	private static final Logger			LOG		= Logger.getLogger(OcsIfInboundImpl.class);
//	private static  boolean throwSOE = true;

	/*++++++++++++++++++++++++++++
	 * Public Interface methods
	 ++++++++++++++++++++++++++++*/
	
	public void saveRadResult(IfOrdInvResultVo ordInvResultVo, String placerNum, String fillerNum, String hl7App) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException 
	{
		if (ordInvResultVo == null)
			throw new DomainInterfaceException("Cannot save null object");
		int invNewSeenChecked=0;
		DomainFactory factory = getDomainFactory();
		OrderInvestigation ordInvBo = null;
		ClinicalResultDetail radRes = null;
		if (ordInvResultVo.getID_OrderInvestigation() != null)
		{
			ordInvBo = (OrderInvestigation)factory.getDomainObject(OrderInvestigation.class, ordInvResultVo.getID_OrderInvestigation());
			if(isSeenOrCheckedDom(ordInvBo))
			{
				invNewSeenChecked++;
			}
			ResultDetails resultDetails = (ResultDetails) ordInvBo.getResultDetails();
			if(resultDetails!=null)
			{
				radRes = resultDetails.getClinicalResultDetails();
			}
		}
		
		if (ordInvResultVo.getRepDateTime() == null)
		{
			ordInvResultVo.setRepDateTime(new DateTime());
			ordInvResultVo.setResultSortDate(new DateTime()); //http://jira/browse/WDEV-18025
			ordInvResultVo.setRepTimeSupplied(Boolean.TRUE);					
			ordInvResultVo.setDisplayDateTime(ordInvResultVo.getRepDateTime());				
			ordInvResultVo.setDisplayFlag(OcsDisplayFlag.REPORTED);
			ordInvResultVo.setDisplayTimeSupplied(ordInvResultVo.getRepTimeSupplied());				
		}

		ordInvBo = 	IfOrdInvResultVoAssembler.extractOrderInvestigation(factory, ordInvResultVo);	
		OrderedInvestigationStatus currStatus = ordInvBo.getOrdInvCurrentStatus();

//		if (ConfigFlag.DOM.OCRR_KEEP_RESULT_HISTORY.getValue())
//		{
			// WDEV-3203 Update RadResultHistory 
			OrderResultHistory hist = new OrderResultHistory();
			hist.setFillerOrdNum(ordInvBo.getFillerOrdNum());
			hist.setHistoryDateTime(new java.util.Date());
			if (radRes != null)
			{
				hist.setOrdInvStatus(getDomLookup(OrderInvStatus.UPDATED_RESULT));
			}
			else
			{
				invNewSeenChecked++;
				hist.setOrdInvStatus(currStatus.getOrdInvStatus());
			}
			ResultDetails resultDetails = (ResultDetails) ordInvBo.getResultDetails();
			hist.setResultDetail(resultDetails);
			hist.setRepDateTime(ordInvBo.getRepDateTime());
			hist.setRepTimeSupplied(ordInvBo.isRepTimeSupplied());
			hist.setResultStatus(ordInvBo.getResultStatus());
			ordInvBo.getResultHistory().add(hist);
//		}
		
		if (radRes != null)
		{
			// wdev-3203 we are not keeping history so ok to delete old result
//			if (!ConfigFlag.DOM.OCRR_KEEP_RESULT_HISTORY.getValue())
//				factory.delete(radRes);
			//JME: 20061024: WDEV-2000
			currStatus.setOrdInvStatus(getDomLookup(OrderInvStatus.UPDATED_RESULT));
			currStatus.setStatusReason("Updated Result Received");
		}
		ordInvBo.getOrdInvStatusHistory().add(currStatus);
		if(ordInvBo!=null
				&&ordInvBo.getOrderDetails()!=null
				&&ordInvBo.getOrderDetails().getPatient()!=null)
		{
			PatientOCSNewResults patientNew = getPatientOCSNewResults(ordInvBo.getOrderDetails().getPatient(),factory);
			int current=patientNew.getNewCount()!=null?patientNew.getNewCount():0;
			patientNew.setNewCount(current+invNewSeenChecked);
			factory.save(patientNew);
		}
		factory.save(ordInvBo);
		return;
	}
	
	public void savePathResult(IfOrderSpecimenVo specimenVo, String placerNumX, String fillerNumX, String hl7AppX,Boolean statusChecked,IfResultDetailsVoCollection historicResultDetails,IfOrderInvestigationVo orderInvestigation) throws DomainInterfaceException , StaleObjectException, ForeignKeyViolationException
	{
		if (specimenVo == null)
			throw new DomainInterfaceException("Cannot save null object");
		
		DomainFactory factory = getDomainFactory();				

		OrderSpecimen ordSpecBo=null;
		HashMap<OrderInvestigation,ResultDetails> res = new HashMap<OrderInvestigation,ResultDetails>();
		int invNewSeenChecked=0;
		
			//JME: Need to do all this to avoid results being orphaned, and to avoid deleting ones not sent in this vo.
		if (specimenVo.getID_OrderSpecimen() != null)
		{
			ordSpecBo = (OrderSpecimen)factory.getDomainObject(OrderSpecimen.class, specimenVo.getID_OrderSpecimen());
			if (ordSpecBo != null)
			{
				for (int i = 0; i < specimenVo.getInvestigations().size(); i++)
				{				
					IfOrderInvestigationVo voInvRes = specimenVo.getInvestigations().get(i);
					if((ConfigFlag.HL7.UNSOLICTED_NEW_SPECIMEN_PER_INVESTIGATION.getValue())
							&&(voInvRes!=null&&voInvRes.getBoId()!=null&&!(voInvRes.getBoId().equals(orderInvestigation.getBoId()))))
					{
						continue;
					}
					if (voInvRes.getID_OrderInvestigation() != null)
					{
						OrderInvestigation ordInv = (OrderInvestigation)factory.getDomainObject(OrderInvestigation.class, voInvRes.getID_OrderInvestigation());

						if (ordInv.getResultDetails() != null    //updated to result if there is already a result for the investigation
								&&voInvRes.getResultDetails()!=null
								&&voInvRes.getResultDetails().getPathologyResultDetails()!=null)
						{
							if(statusChecked!=null &&statusChecked.equals(true))
							{
								voInvRes.getOrdInvCurrentStatus().setOrdInvStatus(OrderInvStatus.CHECKED);
							}
							else
							{
								if(isSeenOrCheckedDom(ordInv))
								{
									invNewSeenChecked++;
								}
								voInvRes.getOrdInvCurrentStatus().setOrdInvStatus(OrderInvStatus.UPDATED_RESULT);
							}
							voInvRes.getOrdInvCurrentStatus().setStatusReason("Updated Result Received");
   						}
						else if  (ordInv.getResultDetails() != null && voInvRes.getResultDetails()==null)
						{
							res.put(ordInv, ordInv.getResultDetails());
							
						}
						if(isNew(voInvRes))
						{
							invNewSeenChecked++;
						}
					}
					else // new inv on old specimen (reflex) 
					{
						invNewSeenChecked++;
					}
				}
			}
		}
		
		OcsOrderSession domOrder = (OcsOrderSession)factory.getDomainObject(OcsOrderSession.class, specimenVo.getOrder().getID_OcsOrderSession());  // wdev-4830
		ordSpecBo = 	IfOrderSpecimenVoAssembler.extractOrderSpecimen(factory, specimenVo);
		
		if(isDFTSpecimen(ordSpecBo))
		{
			OrderInvestigation ordInvx=null;
			Iterator<?> iter = ordSpecBo.getInvestigations().iterator();
			while (iter.hasNext())
			{
				ordInvx = (OrderInvestigation)iter.next();
			}
			
			//Clear the old result
			Set<PathResultDetails> oldPathResults = ordSpecBo.getPathResult();
			for (PathResultDetails pathResultDetails : oldPathResults)
			{
				ordInvx.getResultDetails().getPathologyResultDetails().remove(pathResultDetails);
			}
			
			Set<PathResultDetails> pathResults = IfOcsPathResultVoAssembler.extractPathResultDetailsSet(factory, specimenVo.getPathResult());
			
			ordSpecBo.getPathResult().clear();
			for (PathResultDetails pathResultDetails : pathResults)
			{
				pathResultDetails.setOrderSpecimen(ordSpecBo);
				ordSpecBo.getPathResult().add(pathResultDetails);
				ordInvx.getResultDetails().getPathologyResultDetails().add(pathResultDetails);
			}
		}
		else
		{
			for (IfOrderInvestigationVo invVo : specimenVo.getInvestigations())
			{
				IfOcsPathResultVo  pathResult=null;
				PathResultDetails domPathResult = null;
				if(invVo!=null&&invVo.getResultDetails()!=null&&invVo.getResultDetails().getPathologyResultDetails()!=null
						&&invVo.getResultDetails().getPathologyResultDetails().size()>0)
				{
					pathResult= invVo.getResultDetails().getPathologyResultDetails().get(0);
					domPathResult = IfOcsPathResultVoAssembler.extractPathResultDetails(factory,pathResult);
				}
				
				for (Object object : ordSpecBo.getInvestigations())
				{
					OrderInvestigation domInv = (OrderInvestigation)object;
					if(domInv.getInvestigation().getProviderInvCode().equalsIgnoreCase(invVo.getInvestigation().getProviderInvCode())&&domPathResult!=null)
					{
						domInv.getResultDetails().getPathologyResultDetails().clear();
						domInv.getResultDetails().getPathologyResultDetails().add(domPathResult);
					}
				}
			}
		}
		

		
		
		
		Iterator<?> iter = ordSpecBo.getInvestigations().iterator();
		while (iter.hasNext())
		{
			OrderInvestigation ordInv = (OrderInvestigation)iter.next();
			
			if(ConfigFlag.HL7.UNSOLICTED_NEW_SPECIMEN_PER_INVESTIGATION.getValue()) //if we are looping over all the investigation in the message only update the current one
				{
				if(ordInv!=null&&ordInv.getInvestigation()!=null&&ordInv.getInvestigation().getProviderInvCode()!=null
					&&orderInvestigation!=null&&orderInvestigation.getInvestigation()!=null&&orderInvestigation.getInvestigation().getProviderInvCode()!=null
					&&ordInv.getInvestigation().getProviderInvCode().equals(orderInvestigation.getInvestigation().getProviderInvCode()))	
					{
						ordInv.getOrdInvStatusHistory().add(ordInv.getOrdInvCurrentStatus());
					}
				}
			else
				{
					ordInv.getOrdInvStatusHistory().add(ordInv.getOrdInvCurrentStatus());
				}
			
			if(ordInv.getPlacerOrdNum()==null)
			{
				if(ordInv.getInvestigation().getEventType().equals(getDomLookup(InvEventType.TIME_SERIES)))
				{
//					throw new RuntimeException("Time Series test cannot be reflexed");
				}
				else
				{
					ordInv.setPlacerOrdNum(ordSpecBo.getPlacerOrdNum());
				}
			}
			
				
			//wdev-4830  If neither clinic nor patient location set, set them now
			if (ordInv.getPatientClinic() == null && ordInv.getPatientLocation() == null)  // One or the other would be set
			{ 
				ordInv.setPatientClinic(domOrder.getPatientClinic());
				ordInv.setPatientLocation(domOrder.getPatientLocation());
				
				// WDEV-18165 set ParentLocation dependent on current location
				if (ordInv.getPatientLocation() != null)
					ordInv.setParentLocation(ordInv.getPatientLocation().getParentLocation());
				else if (ordInv.getPatientClinic() != null)
					ordInv.setParentLocation(ordInv.getPatientClinic().getClinicLocation());

				ordInv.setResponsibleClinician(domOrder.getResponsibleClinician());
				ordInv.setResponsibleGp(domOrder.getResponsibleGp());

			}
//			ordSpecBo.getOrder().getInvestigations().add(ordInv);
		}
		
		// this marks the order specimen as complete so the rules can fire. 
		ordSpecBo.setSaveComplete(true);
		if(ordSpecBo.getPlacerOrdNum()==null)
		{
			String token = "Do not use:" + (Double.valueOf(Math.random()*10000).toString().substring(0,4));
			ordSpecBo.setPlacerOrdNum(token);
		}
		factory.save(ordSpecBo);	
		
		if (ConfigFlag.DOM.OCRR_KEEP_RESULT_HISTORY.getValue())
		{
			if(ordSpecBo.getInvestigations() != null)
			{
				Map<String,ResultDetails> histMap = new HashMap<String,ResultDetails>();
				for (IfResultDetailsVo object : historicResultDetails)
				{
					ResultDetails histResultDetails = IfResultDetailsVoAssembler.extractResultDetails(factory, object);
					Set<PathResultDetails> pathResults = IfOcsPathResultVoAssembler.extractPathResultDetailsSet(factory,object.getPathologyResultDetails());
					histResultDetails.getPathologyResultDetails().addAll(pathResults);
					
					histMap.put(object.getInvCode(),histResultDetails);
				} 
					
				Iterator<?> it = ordSpecBo.getInvestigations().iterator();
				while(it.hasNext())
				{
					OrderInvestigation doOrdInv = (OrderInvestigation)it.next();
					OrderResultHistory hist = new OrderResultHistory();
					hist.setFillerOrdNum(ordSpecBo.getFillerOrdNum());
					hist.setHistoryDateTime(new java.util.Date());
					hist.setOrdInvStatus(doOrdInv.getOrdInvCurrentStatus().getOrdInvStatus());
					hist.setResultDetail(histMap.get(doOrdInv.getInvestigation().getProviderInvCode()));
					if(hist.getResultDetail()!=null)
					{	
						Set<?> pathResultDetails = hist.getResultDetail().getPathologyResultDetails();
						for (Object object : pathResultDetails)
						{
							PathResultDetails detail = (PathResultDetails)object;
							detail.setOrderSpecimen(ordSpecBo);
						}
					}
					if(histMap.get(doOrdInv.getInvestigation().getProviderInvCode())!=null)
					{
						if((ConfigFlag.HL7.UNSOLICTED_NEW_SPECIMEN_PER_INVESTIGATION.getValue())
							&&doOrdInv!=null&&doOrdInv.getInvestigation()!=null&&doOrdInv.getInvestigation().getProviderInvCode()!=null
							&&orderInvestigation!=null&&orderInvestigation.getInvestigation()!=null&&orderInvestigation.getInvestigation().getProviderInvCode()!=null
							&&!doOrdInv.getInvestigation().getProviderInvCode().equals(orderInvestigation.getInvestigation().getProviderInvCode()))	
						{
							continue;
						}
						
						doOrdInv.getResultHistory().add(hist);
					}
				}
			}
		}


		//this code goes through the new results only
		Iterator<?> resIter = res.keySet().iterator();
		while (resIter.hasNext())
		{
			OrderInvestigation resInv = (OrderInvestigation)resIter.next();
			ResultDetails resD = (ResultDetails)res.get(resInv);
			resInv.setResultDetails(resD);
			factory.save(resInv);
		}
		if(ordSpecBo.getPlacerOrdNum().startsWith("Do not use:"))
		{
			DecimalFormat myFormatter = new DecimalFormat("000000000");
			myFormatter = new DecimalFormat("000000000");  // Required for placer order number
			ordSpecBo.setPlacerOrdNum(myFormatter.format(ordSpecBo.getId()));
		}
		
		Iterator<?> iterInvs = ordSpecBo.getInvestigations().iterator();
		while (iterInvs.hasNext())
		{
			OrderInvestigation ordInv = (OrderInvestigation)iterInvs.next();
			if(ordInv.getPlacerOrdNum()==null)
			{
				if(ordInv.getInvestigation().getEventType().equals(getDomLookup(InvEventType.TIME_SERIES)))
				{
//					throw new RuntimeException("Time Series test cannot be reflexed");
				}
				else
				{
					ordInv.setPlacerOrdNum(ordSpecBo.getPlacerOrdNum());
				}
			}
		}
		
		
		factory.save(ordSpecBo);
		if(ordSpecBo!=null
				&&ordSpecBo.getOrder()!=null
				&&ordSpecBo.getOrder().getPatient()!=null)
		{
			PatientOCSNewResults patientNew = getPatientOCSNewResults(ordSpecBo.getOrder().getPatient(),factory);
			int current=patientNew.getNewCount()!=null?patientNew.getNewCount():0;
			patientNew.setNewCount(current+invNewSeenChecked);
			factory.save(patientNew);
		}

		
		if(ordSpecBo.getInvestigations() != null)
		{
			Iterator<?> it = ordSpecBo.getInvestigations().iterator();
			while(it.hasNext())
			{
				OrderInvestigation doOrdInv = (OrderInvestigation)it.next();
				ResultDetails resultDetails = (ResultDetails) doOrdInv.getResultDetails();
				if(doOrdInv.getResultDetails() != null && doOrdInv.getResultDetails() != null && resultDetails.getPathologyResultDetails() != null)
				{
					processPrintLocationConfiguration(ordSpecBo);		
					break;
				}
			}
		}
		return;		
	}
	
	private PatientOCSNewResults getPatientOCSNewResults(Patient patient, DomainFactory factory) throws StaleObjectException
	{
		if(patient !=null)
		{
			PatientNotification patNotification=patient.getOCSNotification();
			if (patNotification==null)
			{
				patNotification = new PatientNotification();
				patNotification.setPatient(patient);
				patient.setOCSNotification(patNotification);
			}
			if(patNotification.getNewResults()==null)
			{
				PatientOCSNewResults patientNew = new PatientOCSNewResults();
				patientNew.setPatient(patient);
				patientNew.setNewCount(0);
				patNotification.setNewResults(patientNew);
			}
			return patient.getOCSNotification().getNewResults();
		}
		return null; //No patient
	}
	
	private boolean isSeenOrCheckedDom(OrderInvestigation inv)
	{
		if (inv ==null||inv.getOrdInvCurrentStatus()==null)
			return false;
		if(getDomLookup(OrderInvStatus.SEEN).equals(  inv.getOrdInvCurrentStatus().getOrdInvStatus())
				||getDomLookup(OrderInvStatus.CHECKED).equals(  inv.getOrdInvCurrentStatus().getOrdInvStatus()))
		{
			return true;
		}
		return false;
	}

	
	
	private boolean isNew(IfOrderInvestigationVo inv)
	{
		if (inv ==null||inv.getOrdInvCurrentStatus()==null)
			return false;
		if(OrderInvStatus.NEW_RESULT.equals(  inv.getOrdInvCurrentStatus().getOrdInvStatus()))
		{
			return true;
		}
		return false;
	}
	
	
	//WDEV-12401
	//decide here if records will go to
	//1) Batch Print
	//2) Ordering Location
	//3) None
	private void processPrintLocationConfiguration(OrderSpecimen ordSpecBo) throws StaleObjectException
	{
		if (ordSpecBo == null)
			return;
		
		//get the ordering location
		Location orderingLoc = getOrderingLocation(ordSpecBo);
		
		//WDEV-13355
		if(orderingLoc == null)
		{
			if(ordSpecBo.getOrder() != null && ordSpecBo.getOrder().getPatientClinic() != null &&  ordSpecBo.getOrder().getPatientClinic().getClinicLocation() != null)
				orderingLoc = ordSpecBo.getOrder().getPatientClinic().getClinicLocation();
		}
			 
		//get the hospital for the ordering location
		Location hosp = getHospital( orderingLoc );
		//get the configuration for the hospital
		ims.core.admin.domain.objects.PrintLocationConfig doPrintLocConf =  PrintLocationConfigVoAssembler.extractPrintLocationConfig(getDomainFactory() , getPrintLocationConfiguration(hosp)); 
	
		if(doPrintLocConf != null)
		{
			boolean addToCentralPrint = false;
			boolean addToLocationPrint = false;
			
			if(doPrintLocConf.getPrintToOrderingLocation() != null)
			{
				if(doPrintLocConf.getPrintToOrderingLocation().equals(getDomLookup(YesNo.YES)))
				{
                    if(orderingLoc != null && orderingLoc.getDesignatedPrinterForNewResults() != null)
                        addToLocationPrint = true;
                  else
                        addToCentralPrint = true;
				}
			}
			
			if(doPrintLocConf.getPrintCentral() != null)
			{
				if(doPrintLocConf.getPrintCentral().equals(getDomLookup(YesNo.YES)))
				{
					addToCentralPrint = true;
				}
			}
			
			if(addToLocationPrint)
				checkAndIfNotFoundCreateOrderingLocationBatchPrintEntry(ordSpecBo);	
				
			if(addToCentralPrint)
				checkAndIfNotFoundCreateCentralBatchPrintEntry(ordSpecBo);	
		}
	}

	//WDEV-12401
	private Location getOrderingLocation(OrderSpecimen ordSpecBo)
	{
		if(ordSpecBo == null)
			return null;
		
		if(ordSpecBo.getOrder().getOutpatientDept() != null)
            return ordSpecBo.getOrder().getOutpatientDept();
		else if( ordSpecBo.getOrder().getPatientLocation() != null)
            return ordSpecBo.getOrder().getPatientLocation();
		
		return null;
	}

	//WDEV-12401
	private PrintLocationConfigVo getPrintLocationConfiguration(Location hosp)
	{
		if(hosp != null)
		{
			ResultsPrintingConfig impl = (ResultsPrintingConfig) getDomainImpl(ResultsPrintingConfigImpl.class);
			return impl.getPrintLocationConfigByLocation(new LocationRefVo(hosp.getId(),hosp.getVersion()));
		}
		
		return null;
	}

	//WDEV-12401
	//navigate to a parent hospital to read the configuartion
	private Location getHospital(Location doLocation)
	{
		if(doLocation == null)
			return null;
		
		if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
			return doLocation;
	
		while(doLocation.getParentLocation() != null) 
		{
			doLocation = doLocation.getParentLocation();
			if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
				return doLocation;
		}		
		return null;
	}

	/**
	 * WDEV-12401 supercedes previous functionality removing the config flags which are being replaced by PrintLocationConfig
	 */
	private void checkAndIfNotFoundCreateOrderingLocationBatchPrintEntry(OrderSpecimen orderSpec) throws StaleObjectException
	{
		if (orderSpec == null)
			throw new CodingRuntimeException("investigations is null in method checkAndIfNotFoundCreateResultRequiringNotificationEntry");
	
		List items = getDomainFactory().find("from OrderingLocationBatchPrint nr where nr.resultToBePrinted.id in (" +  " select ordInv.id from OrderSpecimen as ordSpec left join ordSpec.investigations as ordInv where ordSpec.id = " + orderSpec.getId() +  " ) ");
		if(items == null || items.size() == 0)
		{
			OrderingLocationBatchPrint doOrderingLocationBatchItem = new OrderingLocationBatchPrint();
			//get the first investigation in the list as it doesn't matter which one is there as the specimen will be printed
			OrderInvestigation doOrderInv = (OrderInvestigation)orderSpec.getInvestigations().iterator().next();
			doOrderingLocationBatchItem.setResultToBePrinted(doOrderInv);
			doOrderingLocationBatchItem.setWard(getOrderingLocation(orderSpec));
			getDomainFactory().save(doOrderingLocationBatchItem);	
		}	
	}

	/**
	 *  if any of the investigations supplied in method are not already on the to be 
	 *  printed list create a record for one of the investigations for the specimen (WDEV-10969 updated from original issue)
	 */
	private void checkAndIfNotFoundCreateCentralBatchPrintEntry(OrderSpecimen orderSpec) throws StaleObjectException
	{
		if (orderSpec == null)
			throw new CodingRuntimeException("investigations is null in method checkAndIfNotFoundCreateCentralBatchPrintEntry");
	
		List items = getDomainFactory().find("from CentralBatchPrint r where r.resultToBePrinted.id in (" +  " select ordInv.id from OrderSpecimen as ordSpec left join ordSpec.investigations as ordInv where ordSpec.id = " + orderSpec.getId() +  " ) ");
		if(items == null || items.size() == 0)
		{
			CentralBatchPrint doResultToBePrinted = new CentralBatchPrint();
			//get the first investigation in the list as it doesnt matter which one is there as the specimen will be printed
			OrderInvestigation doOrderInv = (OrderInvestigation)orderSpec.getInvestigations().iterator().next();
			doResultToBePrinted.setResultToBePrinted(doOrderInv);
			getDomainFactory().save(doResultToBePrinted);	
		}
	}
	
	public IfOcsOrderVo getOrder(OcsOrderSessionRefVo orderRef) throws DomainInterfaceException 
	{
		DomainFactory factory = getDomainFactory();
		return IfOcsOrderVoAssembler.create((OcsOrderSession)factory.getDomainObject(OcsOrderSession.class, orderRef.getID_OcsOrderSession()));
	}

	public IfOcsOrderVo getOrderByPlacerOrFiller(String placerOrdNum, String fillerOrdNum, Category category) throws DomainInterfaceException
	{
 		// If placerOrdNum is not null, we created it, so it should be found
		if (placerOrdNum != null)
		{
			IfOcsOrderVo orderVo = getOrderByPlacerOrdNum(placerOrdNum, category);
			if (orderVo != null)
				return orderVo;
		}
		
		if (fillerOrdNum == null)
			throw new DomainInterfaceException("Filler Order Number cannot be null as Placer Order Number is null");
		
		if (category != null && category.equals(Category.CLINICALIMAGING))
			return this.getOrderByInvFillerOrdNum(fillerOrdNum);
		else
			return this.getOrderBySpecFillerOrdNum(fillerOrdNum);
			
	}
	
	public IfAnalyteVo getAnalyte(String extCode, String extTxt, IfProviderInvSearchVo search, ResultUnitOfMeasure unitOfMeasure) throws DomainInterfaceException,StaleObjectException 
	{
		if (search == null)
			return null;
		DomainFactory factory = getDomainFactory();
		String hql = " from Analyte a where a.analyteExtCode = '" + extCode + "'";
		
		LocSvcProviderSys locSvcProv = getDomLocProviderSystem(search);
		if (locSvcProv == null)
			throw new DomainInterfaceException("Location Service Provider not found for hl7App " + search.getHl7App());
		
		LocationService locSvc = locSvcProv.getLocationService();
		if (locSvc == null)
			throw new DomainInterfaceException("Location Service not found for Provider " + locSvcProv.getProviderSystem().getSystemName());
		
		ProviderSystem providerSystem = locSvcProv.getProviderSystem();		
	
		//query depends on config flag setting:
		//TODO test flags for non-BHRT application
		String datasetName = extTxt;
		if (ConfigFlag.DOM.ANALYTE_UNIQUENESS.getValue().equals("SVC"))
		{
			 hql += " and a.service = " + locSvc.getService().getId();
			 datasetName += " (" + search.getService().getServiceName() + " - " + extCode + ")";
		}
		else if (ConfigFlag.DOM.ANALYTE_UNIQUENESS.getValue() == "LOC_SVC")
		{
			hql += " and a.locationService = " + locSvc.getId();
			datasetName += " (" + locSvc.getLocation().getName() + " - " + search.getService().getServiceName() + " - " + extCode + ")";
		}
		else if (ConfigFlag.DOM.ANALYTE_UNIQUENESS.getValue() == "PROV_SYS") 
		{
			hql += " and a.providerSystem =  " + providerSystem.getId();
			datasetName += " (" + providerSystem.getSystemName() + " - " + extCode + ")";
		}
		List l = factory.find(hql);
		if (l != null && l.size() != 0)
		{
			if (l.size() > 1 ) //error?
				return null;
			else 
			{
				Analyte analyte = (Analyte) l.get(0);
				if(analyte.getAnalyteExtText()!=null
						&&extTxt!=null
						&&!analyte.getAnalyteExtText().trim().toUpperCase().equals(extTxt.trim().toUpperCase()))
				{
					throw new DomainInterfaceException("Analyte description does not match learned value for: "+extCode);
				}
				return IfAnalyteVoAssembler.create(analyte);
			}
		}
		
		//Doesn't exist - Create 
		Analyte analyteBo = new Analyte();
		analyteBo.setAnalyteExtCode(extCode);
		analyteBo.setAnalyteExtText(extTxt);
		analyteBo.setService(locSvc.getService());
		analyteBo.setProviderSystem(providerSystem);
		analyteBo.setLocationService(locSvc);				
		DatasetType dst = new DatasetType();
		dst.setName(datasetName);
		dst.setCategory(this.getDomLookup(DataSetCategory.PATHOLOGYRESULT));
		dst.setDefaultLineType(this.getDomLookup(LineType.SOLID));
		dst.setDefLineColPtIcon(this.getDomLookup(LineColourPointIcon.RED_SQUARE));
		dst.setIsActive(Boolean.TRUE);
		dst.setUnitOfMeasure(getDomLookup(unitOfMeasure));
		analyteBo.setDatasetType(dst);
		factory.save(analyteBo);
		return IfAnalyteVoAssembler.create(analyteBo);
		
	}

	public IfInvestigationLiteVo getInvestigationByHl7AppInvAndService(IfProviderInvSearchVo searchCriteria)
	{
		DomainFactory factory = getDomainFactory();
		//http://jira/browse/WDEV-14025 Removed some code
			if (searchCriteria == null || !searchCriteria.getHl7AppIsNotNull() || !searchCriteria.getProviderInvCodeIsNotNull())
			{
				throw new DomainRuntimeException("Both hl7App AND providerInvCode must be provided");
			}
		// wdev-3305
		return IfInvestigationLiteVoAssembler.create(this.getDomInvestigationByHl7AppServiceAndSource(factory, searchCriteria));
	}
	
	public IfOcsOrderVo saveOrder(IfOcsOrderVo order) throws StaleObjectException
	{
		if (order == null)
			throw new DomainRuntimeException("Cannot save a null order record!");
		if (!order.isValidated())
			throw new CodingRuntimeException("Order ValueObject has not been validated");
		
		DomainFactory factory = getDomainFactory();
		OcsOrderSession domOrder = IfOcsOrderVoAssembler.extractOcsOrderSession(factory, order);
		
		// Loop through Investigations and Specimens to set order record
		Iterator it = domOrder.getInvestigations().iterator();
		while (it.hasNext())
		{
			OrderInvestigation orderInv = (OrderInvestigation) it.next();
			orderInv.setOrderDetails(domOrder);
			orderInv.getOrdInvStatusHistory().add(orderInv.getOrdInvCurrentStatus());
			
			// wdev-3602 set the Patient location and responsible details
			// at order investigation level too for better response times in new results
			orderInv.setPatientClinic(domOrder.getPatientClinic());
			orderInv.setPatientLocation(domOrder.getPatientLocation());
			
			// WDEV-18165 set ParentLocation dependent on current location
			if (orderInv.getPatientLocation() != null)
				orderInv.setParentLocation(orderInv.getPatientLocation().getParentLocation());
			else if (orderInv.getPatientClinic() != null)
				orderInv.setParentLocation(orderInv.getPatientClinic().getClinicLocation());
			
			orderInv.setResponsibleClinician(domOrder.getResponsibleClinician());
			orderInv.setResponsibleGp(domOrder.getResponsibleGp());
		}
		
		Iterator it2 = domOrder.getSpecimens().iterator();
		while (it2.hasNext())
		{
			OrderSpecimen orderSpec = (OrderSpecimen) it2.next();
			orderSpec.setOrder(domOrder);
			String token = "Do not use:" + (Double.valueOf(Math.random()*10000).toString().substring(0,4));
			orderSpec.setPlacerOrdNum(token);
		}
		
		
		
		
		factory.save(domOrder);
		//WDEV-7493
		Set<?> s =domOrder.getSpecimens();
		DecimalFormat myFormatter = new DecimalFormat("000000000");
		for (Object object : s)
		{
			OrderSpecimen os = (OrderSpecimen)object;
			if(ConfigFlag.DOM.USE_GHG_SPECIMEN_NUMBERING.getValue())
			{
				String placerNumber = new GHGWinPathNumbers().getOCSNumber(os.getId());
				os.setPlacerOrdNum(placerNumber);
			}
			else	
			{
				myFormatter = new DecimalFormat("000000000");  // Required for placer order number
				os.setPlacerOrdNum(myFormatter.format(os.getId()));
			}
			for (Object o2:os.getInvestigations())
			{
				OrderInvestigation oi = (OrderInvestigation)o2;
				if(oi.getInvestigation().getEventType().equals(getDomLookup(InvEventType.TIME_SERIES)))
				{
					DecimalFormat dftFormatter = new DecimalFormat("G00000000");
					os.setPlacerOrdNum(dftFormatter.format(oi.getId()));
					oi.setPlacerOrdNum(dftFormatter.format(oi.getId()));
				}
				else
				{
					oi.setPlacerOrdNum(myFormatter.format(os.getId()));
				}
			}
		}
		//WDEV-16446
		// Iternate over the invs and make sure the placer number is set
		Set<?> invSet =domOrder.getInvestigations();
		for (Object tempInv : invSet) {
			OrderInvestigation ordInv = (OrderInvestigation)tempInv;
			if(ordInv.getPlacerOrdNum()==null)
			{
				ordInv.setPlacerOrdNum(myFormatter.format(ordInv.getId()));
			}
		}
		
		factory.save(domOrder);
		//end WDEV-7493 see change below as well

		
		return IfOcsOrderVoAssembler.create(domOrder);
	}
		
	public ServiceShortVo getServiceByTaxonomy(String externalCode, TaxonomyType taxonomy)
	{
		if (externalCode == null || taxonomy == null)
			throw new DomainRuntimeException("Invalid parameters supplied to getDisciplineServiceByTaxonomy");
		
		DomainFactory factory = getDomainFactory();

		String hql = " from Service s " +
			" join s.taxonomyMap as cm" +
			" where cm.taxonomyName = :taxType " + 
			" and cm.taxonomyCode = :extId ";

		List svcList = factory.find(hql,new String[]{"taxType", "extId"}, new Object[]{getDomLookup(taxonomy),externalCode});

		if (svcList != null && svcList.size() > 1)
		{
			throw new DomainRuntimeException("Duplicate data found for taxonomy type " + taxonomy + " and External Code = " + externalCode);
		}
		else if (svcList != null && svcList.size() == 1)
		{
			return ServiceShortVoAssembler.create((Service) svcList.get(0));
		}
		return null;
	}

	public IfOrderSpecimenVo getSpecimenByPlacerOrFiller(OcsOrderSessionRefVo order, String placerNum, String fillerNum,IfOrderInvestigationVo orderInv)
	{
		DomainFactory factory = getDomainFactory();
		OrderSpecimen spec = null;
		
		if (orderInv.getInvestigation().getEventTypeIsNotNull()&& InvEventType.TIME_SERIES.equals( orderInv.getInvestigation().getEventType())
				&&placerNum!=null&&fillerNum!=null)
		{
			spec = getSpecimenFromPlacerAndFillerNum(placerNum, fillerNum,factory);
		}
		
		else if (placerNum != null)
		{
			//WDEV-7493 replaced code with a new private method 
			spec = getSpecimenFromPlacerNum(placerNum, factory);
			// end WDEV-7493 
			if (spec != null) 
				return IfOrderSpecimenVoAssembler.create(spec);
		}
		
		
		else if (spec == null && fillerNum == null)
		{
			throw new DomainRuntimeException("Either a Placer or a filler number must be supplied.");
		}
		else
		{
			String hql = " from OrderSpecimen s where s.order.id = " +  order.getID_OcsOrderSession() + " and s.fillerOrdNum = '" + fillerNum + "'";
			if(ConfigFlag.HL7.UNSOLICTED_NEW_SPECIMEN_PER_INVESTIGATION.getValue()&&orderInv!=null)
			{
				hql+=" and s.investigations.id ="+orderInv.getID_OrderInvestigation();
			}
			List l = factory.find(hql);
			if (l.size() == 0)
				return null;
			if (l.size() > 1)
				throw new DomainRuntimeException("Non unique hit for OrderSpecimen using filler order num = " + fillerNum);
			else
				spec = (OrderSpecimen)l.get(0);
		}

		return IfOrderSpecimenVoAssembler.create(spec);
	}
	
	
	private IfOrderSpecimenVo getSpecimenByPlacerOrFiller(OcsOrderSessionRefVo order, String placerNum, String fillerNum,IfInvestigationLiteVo investigation)
	{
		DomainFactory factory = getDomainFactory();
		if (investigation==null)
		{
			throw new DomainRuntimeException("Investigation required to get OrderSpecimen");
		}
		OrderSpecimen spec = null;
		
		if (investigation.getEventTypeIsNotNull()&& InvEventType.TIME_SERIES.equals( investigation.getEventType())
				&&placerNum!=null&&fillerNum!=null)
		{
			spec = getSpecimenFromPlacerAndFillerNum(placerNum, fillerNum,factory);
		}
		
		else if (placerNum != null)
		{
			//WDEV-7493 replaced code with a new private method 
			spec = getSpecimenFromPlacerNum(placerNum, factory);
			// end WDEV-7493 
			if (spec != null) 
				return IfOrderSpecimenVoAssembler.create(spec);
		}
		
		else if (spec == null && fillerNum == null)
		{
			throw new DomainRuntimeException("Either a Placer or a filler number must be supplied.");
		}
		else
		{
			String hql = " from OrderSpecimen s where s.order.id = " +  order.getID_OcsOrderSession() + " and s.fillerOrdNum = '" + fillerNum + "'";
			if(ConfigFlag.HL7.UNSOLICTED_NEW_SPECIMEN_PER_INVESTIGATION.getValue()&&investigation!=null)
			{
//				hql+=" and s.investigations.investigation.id ="+investigation.getID_Investigation();
				
				hql="select s from OrderSpecimen s left join s.investigations as ordInv left join ordInv.investigation as inv where s.order.id = " +  order.getID_OcsOrderSession() + " and s.fillerOrdNum = '" + fillerNum + "' and inv.id ="+investigation.getID_Investigation();
				
			}
			List l = factory.find(hql);
			if (l.size() == 0)
				return null;
			if (l.size() > 1)
				throw new DomainRuntimeException("Non unique hit for OrderSpecimen using filler order num = " + fillerNum);
			else
				spec = (OrderSpecimen)l.get(0);
		}
		return IfOrderSpecimenVoAssembler.create(spec);
	}


	// WDEV-7493 new method
	private OrderSpecimen getSpecimenFromPlacerNum(String placerNum, DomainFactory factory)
	{
		OrderSpecimen spec;
//		if(ConfigFlag.DOM.USE_GHG_SPECIMEN_NUMBERING.getValue())
//		{
			List<?> lst = factory.find("select spec from OrderSpecimen spec where spec.placerOrdNum = :placerOrdNum",
					new String[]{"placerOrdNum"},new Object[]{placerNum});
			if (lst == null || lst.size() == 0)
				return null;
//			else if (lst.size() > 1)
//				throw new DomainRuntimeException("Duplicate data found for Placer Order Number = " + placerNum);
			spec = (OrderSpecimen)lst.get(0);
//		}
//		else
//		{
//		 spec = (OrderSpecimen)factory.getDomainObject(OrderSpecimen.class, Integer.parseInt(placerNum));
//		}
		return spec;
	}
	
	private OrderSpecimen getSpecimenFromPlacerAndFillerNum(String placerNum,String fillerNum, DomainFactory factory)
	{
		OrderSpecimen spec=null;
//		if(ConfigFlag.DOM.USE_GHG_SPECIMEN_NUMBERING.getValue())
//		{
			String hql = "from OrderSpecimen spec where spec.placerOrdNum= :placerNum and spec.fillerOrdNum=:fillerNum";	
			spec = (OrderSpecimen)factory.findFirst(hql,new String[]{"placerNum", "fillerNum"}, new Object[]{placerNum,fillerNum});
//		}
//		else
//		{
//			String hql = "from OrderSpecimen spec where spec.id= :id and spec.fillerOrdNum=:fillerNum";	
//			spec = (OrderSpecimen)factory.findFirst(hql,new String[]{"id", "fillerNum"}, new Object[]{Integer.parseInt(placerNum),fillerNum});
//		}
		return spec;
	}
	

	public IfOrderInvestigationVo getOrderInvestigation(OcsOrderSessionRefVo order, IfInvestigationLiteVo investigation, SpecimenSite siteLookup, OrderSpecimenRefVo orderSpecimen,String placerNum, String fillerNum)
	{
		DomainFactory factory = getDomainFactory();
		
		if((orderSpecimen==null||ConfigFlag.HL7.UNSOLICTED_NEW_SPECIMEN_PER_INVESTIGATION.getValue())
				&&investigation.getInvestigationIndexIsNotNull()
				&&investigation.getInvestigationIndex().getCategoryIsNotNull()
				&&investigation.getInvestigationIndex().getCategory().equals(Category.PATHOLOGY)
				&&investigation.getEventTypeIsNotNull()
				&&(!investigation.getEventType().equals(InvEventType.TIME_SERIES)))
		{
			orderSpecimen = getSpecimenByPlacerOrFiller(order,  placerNum,  fillerNum, investigation);
			if(orderSpecimen==null)
			{
				return null; //No OrderSpecimen => No OrderInvestigation for pathology
			}
		}
		
		
		ArrayList<String> names = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		StringBuffer hql = new StringBuffer();
		hql.append("from OrderInvestigation c where ");
		hql.append(" c.investigation.id = :investigation ");
		names.add("investigation");
		values.add(investigation.getID_Investigation());		
		hql.append(" and "); 
		hql.append(" c.orderDetails.id = :orderDetails ");
		names.add("orderDetails");
		values.add(order.getID_OcsOrderSession());		
		
		// wdev-3597 If the orderSpecimen is supplied, we want to include this in the query
		if (orderSpecimen != null)
		{
			hql.append(" and c.specimen.id = :specimenId");
			names.add("specimenId");
			values.add(orderSpecimen.getID_OrderSpecimen());
		}
		
		// wdev-2618 If siteLookup is not null, then we need to link back to the specimen
		// object to select where they equal
		if (siteLookup != null)
		{
			hql.append(" and c.specimen.siteCd = :siteCd ");
			names.add("siteCd");
			values.add(getDomLookup(siteLookup));
		}
		
		java.util.List l = factory.find(hql.toString(), names, values);
		if (l == null || l.size() == 0) return null;
		if (l.size() > 1) throw new ims.domain.exceptions.DomainRuntimeException("Non-unique get call. " + hql + " returned " + l.size() + " records. " );
		return IfOrderInvestigationVoAssembler.create((OrderInvestigation)l.get(0));
	}

	/*++++++++++++++++++++++++++++
	 * Private methods
	 ++++++++++++++++++++++++++++*/

	private LocSvcProviderSys getDomLocProviderSystem(IfProviderInvSearchVo searchCriteria)
	{
		if (searchCriteria == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		ProviderSystem ps = ProviderSystem.getProviderSystemFromHl7Application(factory, searchCriteria.getHl7App());
		if (ps == null)
			return null;
		

		//Investigation domInv = this.getDomInvestigationByHl7AppInvAndService(factory, searchCriteria);
		Investigation domInv = this.getDomInvestigationByHl7AppServiceAndSource(factory, searchCriteria);
		
		if (domInv == null)
		{
			throw new DomainRuntimeException("Can't find Investigation for ProviderSystem = " + ps.getHl7Application() + " and inv code = " + searchCriteria.getProviderInvCode() + " and service = " + searchCriteria.getService().getServiceName());
		}
		return domInv.getProviderService();
	}

	/**
	 * getDomInvestigationByHl7AppServiceAndSource
	 * WDEV-3305
	 * List off all investigations that match invcode, hl7App and are active.  If only one found, then we can
	 * assume that it will be either an Add-On, or an investigation without SiteSpecifier set.  If not an addon
	 * it will verify the SpecimenType against that passed within the message.
	 * If more than one found it will assume that the investigation is marked as requiring siteSpecifier
	 * we can get the local lookup based on SpecimenSite, and get the correct investigation.
	 * @param factory
	 * @param searchCriteria
	 * @return Investigation matching search criteria
	 */
	private Investigation getDomInvestigationByHl7AppServiceAndSource(DomainFactory factory, IfProviderInvSearchVo searchCriteria)
	{
		if (searchCriteria == null)
			return null;
		
		ArrayList<String> names= new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		String hql = "select i From Investigation i left join i.pathInvDetails path join i.investigationIndex inv left join inv.sites sites " +
		" where i.providerService.providerSystem.hl7Application = :hl7App " +
		" and i.activeStatus = :activeStatus";
		 

		
		
		if(null!=searchCriteria.getProviderInvCode())
		{
			hql+=" and i.providerInvCode = :invCode ";
			names.add("invCode");
			values.add(searchCriteria.getProviderInvCode());
		} 
		
		names.add("hl7App");
		values.add(searchCriteria.getHl7App());
		names.add("activeStatus");
		values.add(this.getDomLookup(PreActiveActiveInactiveStatus.ACTIVE));
		
		if (searchCriteria.getServiceIsNotNull())
		{
			hql += " and i.providerService.locationService.service.id = :serviceId "; 			
			names.add("serviceId");
			values.add(searchCriteria.getService().getID_Service());
		}
		
		List domInvList = factory.find(hql, names, values);

		if (domInvList == null || domInvList.size() == 0)
		{
			return null;
		}
		
		// From the list of invesigations returned, check the siteSpecifier and AddOn flags to determine how to get to the exact one
		Investigation domInv = (Investigation) domInvList.get(0);
		
		// For Radiology, nothing below should be checked, so we simply return one if found and
		// throw an error if > 1 found
		if (domInv.getInvestigationIndex().getCategory().getId() == Category.CLINICALIMAGING.getId())
		{
			if (domInvList.size() > 1)
				throw new DomainRuntimeException("More than one Investigation found for provider system = " + searchCriteria.getHl7App() + " and inv code " + searchCriteria.getProviderInvCode() + " and status of Active");
			return domInv;
		}
		
		
		if (domInv.getInvestigationIndex().isRequiresSiteSpecifier() == null || domInv.getInvestigationIndex().isRequiresSiteSpecifier().booleanValue() == false)
			
		{
			// Verify the specimenType is correct before returning (AddOns will not have path details)
			if (domInv.isIsAddon().booleanValue() == true)
				return domInv;
				
			LookupInstVo msgSpecimenTypeVo = null;
			msgSpecimenTypeVo= getLookupService().getLocalLookup(LookupInstVo.class, SpecimenType.TYPE_ID, searchCriteria.getProvider().getCodeSystem().getText(), searchCriteria.getSpecimenSource().trim());
			if(msgSpecimenTypeVo==null)
			{
				msgSpecimenTypeVo= getLookupService().getLocalLookup(LookupInstVo.class, ims.ocrr.vo.lookups.ResultSpecimenTypes.TYPE_ID, searchCriteria.getProvider().getCodeSystem().getText(), searchCriteria.getSpecimenSource().trim());
			}
			
			for (int i=0; i<domInvList.size(); i++)
			{
				domInv = (Investigation) domInvList.get(i);
				Specimen specimen = (Specimen) domInv.getPathInvDetails().getSpecimens().get(0);
				LookupInstance domSpcType = specimen.getType();
				// The SpecimenType from this investigation should equal that from the message
				if (/*domSpcType == null || msgSpecimenTypeVo == null || */isValidSpecimenType(domSpcType,msgSpecimenTypeVo))
					return domInv;

			}
			
			// Do not match - return null
			return null;
		}
		
		// We have reached here, so assume site required, we
		// now need to loop through the investigations to see which match the specimenSite
		// and return the correct one found
		
		
		String useSiteAndSource = HL7Utils.getConfigItem(toConfigItemArray(searchCriteria.getProvider().getConfigItems()), ConfigItems.useSiteAndSource);
		String siteFromMessage=null;
		if (useSiteAndSource!=null&&(useSiteAndSource.equalsIgnoreCase("TRUE")||useSiteAndSource.equalsIgnoreCase("YES"))
				&&searchCriteria.getSpecimenSiteIsNotNull())
		{
			siteFromMessage=searchCriteria.getSpecimenSite().trim();
		}
		else
		{
			siteFromMessage=searchCriteria.getSpecimenSource().trim();
		}
		LookupInstVo specimenSiteVo = getLookupService().getLocalLookup(SpecimenSite.class, SpecimenSite.TYPE_ID, searchCriteria.getProvider().getCodeSystem().getText(), siteFromMessage);
		// wdev-3384
		if (specimenSiteVo == null)
			throw new DomainRuntimeException("Local Lookup not found for Specimen Site " + searchCriteria.getSpecimenSource().trim());
		
		for (int i=0; i<domInvList.size(); i++)
		{
			domInv = (Investigation) domInvList.get(i);
			if (domInv.getInvestigationIndex().getSites() != null)
			{
				Iterator it = domInv.getInvestigationIndex().getSites().iterator();
				while (it.hasNext())
				{
					LookupInstance specSite = (LookupInstance) it.next();
					if (specSite.getId() == specimenSiteVo.getId())
						return domInv;
				}
			}
		}


		return null;
	}
	
	//returns true if its the specimen type from the investigation or one of the associated result types 
	private boolean isValidSpecimenType( LookupInstance typeFromInvConfig,LookupInstVo msgSpecimenTypeVo)
	{
		if(typeFromInvConfig==null)
			throw new CodingRuntimeException("typeFromInvConfig is null in method isValidSpecimenType");
		if(msgSpecimenTypeVo==null)
			throw new CodingRuntimeException("msgSpecimenTypeVo is null in method isValidSpecimenType");
		DomainFactory factory=getDomainFactory();
		LookupInstance typeFromMessage = getDomLookup(msgSpecimenTypeVo);
		if(typeFromMessage.equals(typeFromInvConfig))
			return true;
		
		ArrayList<String> names = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		names.add("typeID");
		values.add(typeFromInvConfig.getId());
		
		List<?> items = factory.find  ("select  AT.id from ResultSpecimenTypes as RST left join RST.alternateSpecimenTypes as AST left join AST.instance as AT left join RST.specimenType as ST where (ST.id = :typeID)", names,values);
		if (items.contains(typeFromMessage.getId()))
			return true;
		return false;
	}
	
	
	private Investigation getDomInvestigationByHl7AppInvAndService(DomainFactory factory, IfProviderInvSearchVo searchCriteria)
	{
		if (searchCriteria == null)
			return null;
		
		ArrayList<String> names = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		String hql = "select i From Investigation i left join i.pathInvDetails path join i.investigationIndex inv left join inv.sites sites " +
		" where i.providerInvCode = :invCode " + 
		" and i.providerService.providerSystem.hl7Application = :hl7App " +
		" and i.activeStatus = :activeStatus";
		
		names.add("invCode");
		values.add(searchCriteria.getProviderInvCode());
		names.add("hl7App");
		values.add(searchCriteria.getHl7App());
		names.add("activeStatus");
		values.add(this.getDomLookup(PreActiveActiveInactiveStatus.ACTIVE));
		
		if (searchCriteria.getServiceIsNotNull())
		{
			hql += " and i.providerService.locationService.service.id = :serviceId "; 			
			names.add("serviceId");
			values.add(searchCriteria.getService().getID_Service());
		}
		
		// There are 3 scenarios that we need to cover when finding the investigation
		// 1. Search by invCode and specimen Source as normal
		// 2. If this is an addOn investigation, pathinvdetails will be null
		// 3. If this investigation requires site, specimenType will not be received correctly,but specimenSite will
//		if (searchCriteria.getSpecimenSourceIsNotNull())
//		{
//			hql += " and (path.specimenType = :specimenType or path is null) and inv.requiresSiteSpecifier is false ";
//			names.add("specimenType");
//			values.add(getDomLookup(searchCriteria.getSpecimenSource()));
//		}
//		else if (searchCriteria.getSpecimenSiteIsNotNull())
//		{
//			hql += " and inv.requiresSiteSpecifier = true and sites.instance = :specimenSite";
//			names.add("specimenSite");
//			values.add(getDomLookup(searchCriteria.getSpecimenSite()));
//		}
//		else
//		{
//			hql += " and path is null ";
//		}
//		
		List l = factory.find(hql, names, values);

		if (l == null || l.size() == 0)
		{
			return null;
		}
		
		if (l.size() > 1)
			throw new DomainRuntimeException("More than one Investigation found for provider system = " + searchCriteria.getHl7App() + " and inv code " + searchCriteria.getProviderInvCode() + " and status of Active");
		
		return (Investigation)l.get(0);
	}

	private IfOcsOrderVo getOrderByPlacerOrdNum(String placerOrdNum, Category category)
	{
		DomainFactory factory = getDomainFactory();
		OcsOrderSession order;
		OrderInvestigation ordInv=null;
		if( placerOrdNum!=null&&placerOrdNum.length()==9&&placerOrdNum.startsWith("G"))//  G00000015) DFT
		{
			ordInv = (OrderInvestigation)factory.getDomainObject(OrderInvestigation.class, Integer.parseInt(placerOrdNum.substring(1)));
			order = ordInv.getOrderDetails();
		}
		else if (category.equals(Category.PATHOLOGY))
		{
			//WDEV-7493  replaced code with a method call
			OrderSpecimen ordSpec=getSpecimenFromPlacerNum(placerOrdNum, factory);
			if (ordSpec == null)
				return null;
			order = ordSpec.getOrder();
		}
		else
		{
			ordInv = (OrderInvestigation)factory.getDomainObject(OrderInvestigation.class, Integer.parseInt(placerOrdNum));
			if (ordInv == null)
				return null;
			order = ordInv.getOrderDetails();			
		}
		if (order == null)
			return null;
		return IfOcsOrderVoAssembler.create(order);
	}
	
	private IfOcsOrderVo getOrderByInvFillerOrdNum(String fillerOrdNum)
	{
		if (fillerOrdNum == null)
			throw new CodingRuntimeException("FillerOrdNum cannot be null");
		
		DomainFactory factory = getDomainFactory();
		String hql = " select ord from OcsOrderSession ord join ord.investigations inv where inv.fillerOrdNum = :fillerOrderNum";
		List lst = factory.find(hql, new String[]{"fillerOrderNum"}, new Object[]{fillerOrdNum});
		if (lst == null || lst.size() == 0)
			return null;
		else if (lst.size() > 1)
			throw new DomainRuntimeException("Duplicate data found for Filler Order Number = " + fillerOrdNum);
		
		return IfOcsOrderVoAssembler.create((OcsOrderSession) lst.get(0));
	} 

	private IfOcsOrderVo getOrderBySpecFillerOrdNum(String fillerOrderNumber)
	{
		if (fillerOrderNumber == null)
			throw new CodingRuntimeException("FillerOrdNumber cannot be null");
		
		DomainFactory factory = getDomainFactory();
		String hql = " select ord from OcsOrderSession ord join ord.specimens spc where spc.fillerOrdNum = :fillerOrderNum";
		List lst = factory.find(hql, new String[]{"fillerOrderNum"}, new Object[]{fillerOrderNumber});
		if (lst == null || lst.size() == 0)
			return null;
		else if (lst.size() > 1&&!ConfigFlag.HL7.UNSOLICTED_NEW_SPECIMEN_PER_INVESTIGATION.getValue())
			throw new DomainRuntimeException("Duplicate data found for Filler Order Number = " + fillerOrderNumber);
		
		return IfOcsOrderVoAssembler.create((OcsOrderSession) lst.get(0));
		
	}
	
	public ServiceShortVoCollection listServicesWithAlternateCode(String alternateCode)
	{
		DomainFactory factory = getDomainFactory();
		
		String hql = "from Service s where s.alternateServiceCode = :alternateCode";
		List lst = factory.find(hql, new String[]{"alternateCode"}, new Object[]{alternateCode});
		return ServiceShortVoAssembler.createServiceShortVoCollectionFromService(lst);
	}

	public void updateInvestigationStatus(OrderInvestigationRefVo invRef, IfOrderInvCurrentStatusVo newStatus) throws StaleObjectException
	{
		if(invRef == null)
			throw new DomainRuntimeException("Investigation must be specified to update status.");
		
		if(newStatus == null)
			throw new DomainRuntimeException("New Status value must be provided in order to update investigation status.");
		
		DomainFactory factory = getDomainFactory();
		OrderInvestigation ordInv = (OrderInvestigation)factory.getDomainObject(OrderInvestigation.class, invRef.getID_OrderInvestigation());

		OrderedInvestigationStatus currStatus = ordInv.getOrdInvCurrentStatus();
		currStatus.setOrdInvStatus(getDomLookup(newStatus.getOrdInvStatus()));
		currStatus.setChangeDateTime(newStatus.getChangeDateTime().getJavaDate());
		currStatus.setChangeUser(newStatus.getChangeUser());
		currStatus.setStatusReason(newStatus.getStatusReason());
		ordInv.getOrdInvStatusHistory().add(currStatus);
		
		factory.save(ordInv);
	}
	
	//http://jira/browse/WDEV-12032
	public IfOrderInvestigationVo saveOrderInvestigation(IfOrderInvestigationVo ordInv, Boolean isChangeInv,ProviderSystemRefVo providerSystem) throws StaleObjectException {
		if (ordInv == null)
			throw new DomainRuntimeException("Cannot save a null order investigation record!");
		if (!ordInv.isValidated())
			throw new CodingRuntimeException("Order Investigation ValueObject has not been validated");
		
		DomainFactory factory = getDomainFactory();
		OrderInvestigation domOrdInv = IfOrderInvestigationVoAssembler.extractOrderInvestigation(factory, ordInv);

		OrderedInvestigationStatus currStatus = domOrdInv.getOrdInvCurrentStatus();
		domOrdInv.getOrdInvStatusHistory().add(currStatus);
		if(isChangeInv!=null&&isChangeInv&&providerSystem!=null)
		{
			domOrdInv.getOrdInvXOStatusHistory().add(currStatus);
			OrderChangeResponseQueue response = new OrderChangeResponseQueue();
			response.setStatusReason(currStatus.getStatusReason());
			response.setCausingStatus(currStatus.getOrdInvStatus());
			response.setInvestigation(domOrdInv);
			response.setQueueType(getDomLookup(QueueType.ORDERCHANGERESPONSE));
			response.setProviderSystem((ProviderSystem)factory.getDomainObject(ProviderSystem.class, providerSystem.getID_ProviderSystem()));
			response.setMsgType(getDomLookup(MsgEventType.O20));
			factory.save(response);
		}

		
		factory.save(domOrdInv);		
		return IfOrderInvestigationVoAssembler.create(domOrdInv);
	}

	public IfOrderInvestigationVo saveOrderInvestigation(IfOrderInvestigationVo ordInv) throws StaleObjectException
	{
		return saveOrderInvestigation(ordInv,null,null);
	}
	//http://jira/browse/WDEV-12032
	
	public void saveOrderSpecimen(IfOrderSpecimenVo ordSpec) throws StaleObjectException
	{
		if (ordSpec == null)
			throw new DomainRuntimeException("Cannot save a null order specimen record!");
/*		if (!ordSpec.isValidated())
			throw new CodingRuntimeException("Order Specimen ValueObject has not been validated");
*/		
		DomainFactory factory = getDomainFactory();
		OrderSpecimen domOrdSpec = IfOrderSpecimenVoAssembler.extractOrderSpecimen(factory, ordSpec);
		if(ordSpec.getPlacerOrdNum()==null)
		{
			String token = "Do not use:" + (Double.valueOf(Math.random()*10000).toString().substring(0,4));
			domOrdSpec.setPlacerOrdNum(token);
			factory.save(domOrdSpec);
			DecimalFormat myFormatter = new DecimalFormat("000000000");
			myFormatter = new DecimalFormat("000000000");  // Required for placer order number
			domOrdSpec.setPlacerOrdNum(myFormatter.format(domOrdSpec.getId()));
		}
		
		
		
		Iterator iter = domOrdSpec.getInvestigations().iterator();
		while (iter.hasNext())
		{
			OrderInvestigation ordInv = (OrderInvestigation)iter.next();
			if(ordInv.getSpecimen().contains(domOrdSpec))
			{
				ordInv.getSpecimen().remove(domOrdSpec); //remove and add the latest
				ordInv.getSpecimen().add(domOrdSpec);
			}
				
			else
			{
				ordInv.getSpecimen().add(domOrdSpec);
			}
			
			
			if(ordInv.getPlacerOrdNum()==null)
			{
				if(ordInv.getInvestigation().getEventType().equals(getDomLookup(InvEventType.TIME_SERIES)))
				{
					DecimalFormat dftFormatter = new DecimalFormat("G00000000");
					domOrdSpec.setPlacerOrdNum(dftFormatter.format(ordInv.getId()));
					ordInv.setPlacerOrdNum(dftFormatter.format(ordInv.getId()));
				}
				else
				{
					ordInv.setPlacerOrdNum(domOrdSpec.getPlacerOrdNum());
				}
			}

			
			
//			ordInv.setSpecimen(domOrdSpec);
			ordInv.setOrderDetails(domOrdSpec.getOrder());
			ordInv.getOrdInvStatusHistory().add(ordInv.getOrdInvCurrentStatus());
			domOrdSpec.getOrder().getInvestigations().add(ordInv);
			
			
			//http://jira/browse/WDEV-16899
//			if (ordInv.getOrdInvCurrentStatus().getOrdInvStatus().getId() == OrderInvStatus.CANCELLED.getId() 
//					|| ordInv.getOrdInvCurrentStatus().getOrdInvStatus().getId() == OrderInvStatus.CANCEL_REQUEST.getId())
//			{
//			// if it is a DFT cancel the collection item	
//				if(ordInv.getInvestigation().getEventType().equals(getDomLookup(InvEventType.TIME_SERIES)))
//				{
//					String hql = "from SpecimenWorkListItem wl where wl.dFTOrderInvestigation= :inv and wl.collectionStatus!= :collected";
//					SpecimenWorkListItem wli = (SpecimenWorkListItem)factory.findFirst(hql,new String[]{"inv","collected"}, new Object[]{ordInv,getDomLookup(ims.ocrr.vo.lookups.SpecimenCollectionStatus.COLLECTIONCOMPLETE)});
//					if (wli!=null)
//					{
//						wli.setCollectionStatus(getDomLookup(ims.ocrr.vo.lookups.SpecimenCollectionStatus.CANCELLED));
//						factory.save(wli);
//					}
//				}
//			}
			
			// wdev-3152 When saving order specimen, if there are any non-resultable investigations, we may want to set them to accepted
			if (ordInv.getOrdInvCurrentStatus().getOrdInvStatus().getId() == OrderInvStatus.SENT.getId() && 
					ordInv.getInvestigation().getInvestigationIndex().getOrderability().getId() ==  InvestigationOrderability.ORDERONLY.getId())
			{
				OrderedInvestigationStatus newStat = new OrderedInvestigationStatus();
				newStat.setChangeDateTime(new java.util.Date());
				newStat.setChangeUser("HL7InboundEngine");
				newStat.setOrdInvStatus(getDomLookup(OrderInvStatus.ACCEPTED));
				newStat.setStatusReason("Non-Resultable, set to accepted from related investigations");
				ordInv.setOrdInvCurrentStatus(newStat);
				if (domOrdSpec.getCollDateTimeFiller() != null)
					ordInv.setDisplayDateTime(domOrdSpec.getCollDateTimeFiller());
				else
					ordInv.setDisplayDateTime(domOrdSpec.getCollDateTimePlacer());
				ordInv.setDisplayFlag(getDomLookup(OcsDisplayFlag.SPEC_COLL));
			}
			
			
			
		}
		factory.save(domOrdSpec);		
		
	}

	public IfLocParentVo getLocParentByTaxType(String extId, TaxonomyType taxType)
	{
		if (extId == null || taxType == null)
			return null;

		DomainFactory factory = getDomainFactory();
		String hql = " from Location l " +
		" join l.codeMappings as cm" +
		" where cm.taxonomyName = :taxType " + 
		" and cm.taxonomyCode = :extId ";

		List locList = factory.find(hql,new String[]{"taxType", "extId"}, new Object[]{getDomLookup(taxType),extId});

		if (locList != null && locList.size() == 1)
		{
			return IfLocParentVoAssembler.create((Location)locList.get(0));
		}
		else if (locList != null && locList.size() > 1)
		{
			throw new DomainRuntimeException("Non unique hit on Location by TaxonomyType " + taxType.getText() + " and code " + extId);
		}
		else
			return null;
	}

	public void saveLocation(IfLocParentVo location) throws StaleObjectException, UniqueKeyViolationException
	{
		if (!location.isValidated())
			throw new DomainRuntimeException("Location not Validated.");

		DomainFactory factory = getDomainFactory();

		Location doLocation = IfLocParentVoAssembler.extractLocation(factory, location);

		try
		{
			factory.save(doLocation);
		}
		catch (UnqViolationUncheckedException e)
		{
			String dupMessage = Keywords.checkDuplicateTaxonomy(factory, doLocation, "codeMappings", location.getCodeMappings(), "getName");
			if(dupMessage != null)
				throw new UniqueKeyViolationException(dupMessage);

			throw new UniqueKeyViolationException("An Location with this name already exists, Please change", e);			
		}
		return;		
	}

	public IfOcsOrderVo saveOrderLevelItems(IfOcsOrderShortVo order) throws StaleObjectException
	{
		if (order == null)
			throw new DomainRuntimeException("Cannot save a null order record!");
		if (!order.isValidated())
			throw new CodingRuntimeException("Order ValueObject has not been validated");
		
		DomainFactory factory = getDomainFactory();
		OcsOrderSession domOrder = IfOcsOrderShortVoAssembler.extractOcsOrderSession(factory, order);
		
		factory.save(domOrder);
		return IfOcsOrderVoAssembler.create(domOrder);
	}

	public IfOrderSpecimenVo updateInvDisplayDateTime(IfOrderSpecimenVo specimen) throws StaleObjectException
	{
		if (specimen == null)
			throw new DomainRuntimeException("Cannot save a null specimen record!");
		if (!specimen.isValidated())
			throw new CodingRuntimeException("Specimen ValueObject has not been validated");
		
		DomainFactory factory = getDomainFactory();
		
		OrderSpecimen domSpc = IfOrderSpecimenVoAssembler.extractOrderSpecimen(factory, specimen);
		
		factory.save(domSpc);
		return IfOrderSpecimenVoAssembler.create(domSpc);
	}
	
	public IfOrderSpecimenVo updateNonResultableInvestigations(OrderSpecimenRefVo spc) throws StaleObjectException
	{
	
		// wdev-2748 27/03/2007
		// For each investigation within the specimen, check whether it is
		// non resultable.  If so, set the status to accepted (if it is currently sent)
		// and set the display datetime values
		DomainFactory factory = getDomainFactory();
		
		OrderSpecimen domSpc = (OrderSpecimen)factory.getDomainObject(OrderSpecimen.class, spc.getID_OrderSpecimen().intValue());
		
		Iterator it = domSpc.getInvestigations().iterator();
		while (it.hasNext())
		{
			OrderInvestigation ordInv = (OrderInvestigation) it.next();
			if (ordInv.getOrdInvCurrentStatus().getOrdInvStatus().getId() == OrderInvStatus.SENT.getId() && 
					ordInv.getInvestigation().getInvestigationIndex().getOrderability().getId() ==  InvestigationOrderability.ORDERONLY.getId())
			{
				OrderedInvestigationStatus newStat = new OrderedInvestigationStatus();
				newStat.setChangeDateTime(new java.util.Date());
				newStat.setChangeUser("HL7InboundEngine");
				newStat.setOrdInvStatus(getDomLookup(OrderInvStatus.ACCEPTED));
				newStat.setStatusReason("Non-Resultable, set to accepted from related investigations");
				ordInv.setOrdInvCurrentStatus(newStat);
				if (domSpc.getCollDateTimeFiller() != null)
					ordInv.setDisplayDateTime(domSpc.getCollDateTimeFiller());
				else
					ordInv.setDisplayDateTime(domSpc.getCollDateTimePlacer());
				ordInv.setDisplayFlag(getDomLookup(OcsDisplayFlag.SPEC_COLL));
			}
		}
		factory.save(domSpc);
		
		return IfOrderSpecimenVoAssembler.create(domSpc);
	}

	public static ConfigItems[] toConfigItemArray(ConfigPropertyVoCollection properties)
	{
		if (properties == null || properties.size() == 0)
			return null;
		
		ConfigItems[] items = new ConfigItems[properties.size()];
		for (int i=0; i<properties.size(); i++)
		{
			ConfigPropertyVo prop= properties.get(i);
			ConfigItems item = new ConfigItems(prop.getPropertyName(), prop.getPropertyValue());
			items[i] = item;
		}
		return items;
	}
	public IfOutOcsOrderVo getOrderFromInv(OrderInvestigationRefVo inv) throws DomainInterfaceException
	{
		if(null==inv)
		{
			throw new DomainInterfaceException("Investigation should not be null");
		}
		DomainFactory factory = getDomainFactory();
		OrderInvestigation domOrderInv = (OrderInvestigation)factory.getDomainObject(OrderInvestigation.class,inv.getBoId());
		OcsOrderSession order = domOrderInv.getOrderDetails();
		return IfOutOcsOrderVoAssembler.create(order);
	}

	public SpecimenType getFirstSpecimenTypeForResultSpecimenType(ResultSpecimenTypes resultSpecimenType)
	{
		if (resultSpecimenType==null)
			return null;
		DomainFactory factory = getDomainFactory();
		
		String query = "select rst.specimenType from ResultSpecimenTypes as rst left join rst.alternateSpecimenTypes as ast left join ast.instance as ins left join rst.specimenType as l3_1";
		query+=" where ins.id = :type"; 
		
		List<?> list =factory.find(query,new String[]{"type"},new Object[]{resultSpecimenType.getID()});
		if (list!=null && list.size()>0)
		{
			LookupInstance li=(LookupInstance)list.get(0);
			return new SpecimenType(li.getId(),li.getText(),li.isActive());
		}
	return null;	
	}
	
	/**
	 *  WDEV-16384
	 *  Calculate the expected datetime of the result based on configured turnaround values
	 */
	public ims.framework.utils.DateTime calculateExpectedDateTime(ims.ocrr.configuration.vo.InvestigationRefVo investigation, ims.framework.utils.DateTime dateTimeReceived)
	{
		DomainFactory factory = getDomainFactory();
		
		// First check if any configured turnaround date for the investigation
		Investigation domInv = (Investigation) factory.getDomainObject(Investigation.class, investigation.getID_Investigation());
		if (domInv != null)
		{
			// Configured value set to zero means that this investigation does not want expected values calculated
			if (domInv.getExpectedTurnaround() != null && domInv.getExpectedTurnaround() == 0)
				return null;
			
			if (domInv.getExpectedTurnaround() != null && domInv.getTurnaroundMeasure() != null)
			{
				return (calculateTurnaround(domInv.getExpectedTurnaround(), domInv.getTurnaroundMeasure(), dateTimeReceived));
			}
			
			// No configuration at investigation level, check the service level
			Service domService = domInv.getProviderService().getLocationService().getService();
			if (domService != null && domService.getExpectedTurnaround() != null && domService.getTurnaroundMeasure() != null)
			{
				return (calculateTurnaround(domService.getExpectedTurnaround(), domService.getTurnaroundMeasure(), dateTimeReceived));
			}
		}
		return null;
	}

	private DateTime calculateTurnaround(Integer expectedTurnaround, LookupInstance turnaroundMeasure, DateTime dateTimeReceived)
	{
		if (expectedTurnaround == null || turnaroundMeasure == null || dateTimeReceived == null)
			return null;
		
		if (turnaroundMeasure.getId() == MinReorderPeriod.MINUTES.getID() )
			return (dateTimeReceived.addMinutes(expectedTurnaround));
		if (turnaroundMeasure.getId() == MinReorderPeriod.HOURS.getID())
			return (dateTimeReceived.addHours(expectedTurnaround));
		if (turnaroundMeasure.getId() == MinReorderPeriod.DAYS.getID())
			return (dateTimeReceived.addDays(expectedTurnaround));
		if (turnaroundMeasure.getId() == MinReorderPeriod.WEEKS.getID() )
			return (dateTimeReceived.addDays(expectedTurnaround*7));
		if (turnaroundMeasure.getId() == MinReorderPeriod.MONTHS.getID() )
			return (dateTimeReceived.addMonth(expectedTurnaround));
		
		return null;
	}

	//WDEV-17048 new method
	public IfOcsOrderVo saveOrderAsUnprocessed(OcsOrderSessionRefVo orderSession) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		OcsOrderSession order = (OcsOrderSession) factory.getDomainObject(OcsOrderSession.class, orderSession.getID_OcsOrderSession());
		if(order!=null)
		{
			order.setWasProcessed(false);
			order.setSendNumber(Boolean.TRUE);
			factory.save(order);
			return IfOcsOrderVoAssembler.create(order);
		}
		return null;
	}
	
	private boolean isDFTSpecimen(OrderSpecimen ordSpecBo)
	{
		Iterator<?> iter = ordSpecBo.getInvestigations().iterator();
		while (iter.hasNext())
		{
			OrderInvestigation ordInv = (OrderInvestigation)iter.next();
			if(ordInv.getInvestigation()!=null
					&&ordInv.getInvestigation().getEventType()!=null
					&&ordInv.getInvestigation().getEventType().equals(getDomLookup(InvEventType.TIME_SERIES)))
				return true;
		}
		return false;
	}
}	

