//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Cristian Belciug using IMS Development Environment (version 1.62 build 3100.30141)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.core.domain.impl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import ims.admin.domain.MosAdmin;
import ims.admin.domain.impl.MosAdminImpl;
import ims.core.domain.base.impl.BaseMOSQueryImpl;
import ims.core.resource.people.domain.objects.Hcp;
import ims.core.resource.people.domain.objects.Medic;
import ims.core.resource.people.domain.objects.Nurse;
import ims.core.resource.people.domain.objects.Therapist;
import ims.core.vo.HcpCollection;
import ims.core.vo.HcpLocationVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.MemberOfStaffVo;
import ims.core.vo.domain.HcpAssembler;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.MedicLiteVoAssembler;
import ims.core.vo.domain.MedicVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.NurseVoAssembler;
import ims.core.vo.domain.TherapistVoAssembler;
import ims.core.vo.enums.MosType;
import ims.core.vo.lookups.HcpDisType;
import ims.core.vo.lookups.MedicGrade;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.framework.enumerations.SortOrder;
import ims.vo.interfaces.IMos;
public class MOSQueryImpl extends BaseMOSQueryImpl
{

	private static final long serialVersionUID = 1L;
	private static String MEDIC = "Medic";

	//WDEV-15544 //WDEV-15194
	public IMos[] listMOS(String name, MosType mosType, HcpDisType mosDiscipline, Integer mosLocation, Boolean canReferPatient,Boolean isALocalConsultant,Boolean isResponsibleHcp) 
	{
		if(name == null || (name != null && name.length() == 0))
			throw new DomainRuntimeException("Can not search on null name.");
		
		if(mosType == null)
			mosType = MosType.ALL;
		
		if(mosType.equals(MosType.HCP))
		{
			return listHCP(name, null, mosDiscipline, mosLocation, canReferPatient,isALocalConsultant,isResponsibleHcp);//WDEV-15544 //WDEV-15194
		}
		if(mosType.equals(MosType.MEDIC))
		{
			return listHCP(name, MEDIC, null, mosLocation, canReferPatient,isALocalConsultant,isResponsibleHcp);//WDEV-15544 //WDEV-15194
		}
		
		return listAllMOS(name);
	}

	//WDEV-15544 //WDEV-15194
	private IMos[] listHCP(String name, String subClass, HcpDisType mosDiscipline, Integer mosLocation, Boolean canReferPatient,Boolean isALocalConsultant,Boolean isResponsibleHcp) 
	{
		List hcps = listHCPList(name, subClass, mosDiscipline, mosLocation, canReferPatient,isALocalConsultant,isResponsibleHcp);//WDEV-15544	//WDEV-15194
		
		if(mosDiscipline != null || subClass != null)
		{
			return listByDiscipline(hcps, name, mosDiscipline);
		}
		
		/*if(mosLocation!=null){
			HcpCollection collHcps = listMOSByPrimaryLocation(HcpAssembler.createHcpCollectionFromHcp(hcps), mosLocation);
			DomainFactory factory = getDomainFactory();
			hcps = HcpAssembler.extractHcpList(factory, collHcps);
		}
		*/
	
		return (HcpLiteVoAssembler.createHcpLiteVoCollectionFromHcp(hcps)).sort().toIMosArray();
	}
	
	private HcpCollection listMOSByPrimaryLocation(HcpCollection collHCPs, LocationLiteVo mosLocation) {
		
		HcpCollection collHCPsForLocation = new HcpCollection();
		MosAdmin impl = (MosAdmin)getDomainImpl(MosAdminImpl.class);
		for (int i = 0; i < collHCPs.size(); i++)
		{
			MemberOfStaffVo mos = impl.getMemberOfStaff(collHCPs.get(i).getMos());
			for (int j = 0; j < mos.getLocations().size(); j++)
			{
				HcpLocationVo hcpLocation = mos.getLocations().get(j);
				if(hcpLocation.getIsPrimaryIsNotNull() && hcpLocation.getIsPrimary()){
					
					if(mosLocation.getID_Location().equals(hcpLocation.getLocation().getID_Location()))
						collHCPsForLocation.add(collHCPs.get(i));
				}
			}
		}
		
		return collHCPsForLocation;
	}
	
	private IMos[] listAllMOS(String name) 
	{
		if(name == null || (name != null && name.length() == 0))
			throw new DomainRuntimeException("Can not search on null name.");
		
		DomainFactory factory = getDomainFactory();
		
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		
		String hql = " from MemberOfStaff mos where mos.isActive = :isActive and (mos.name.upperSurname like :mosSname or mos.name.upperForename like :mosFname)";
		
		markers.add("isActive");
		values.add(Boolean.TRUE);
		markers.add("mosSname");
		values.add(name.toUpperCase() + "%");
		markers.add("mosFname");
		values.add(name.toUpperCase() + "%");
		
		hql += " order by mos.name.upperSurname,mos.name.upperForename";
		
		List mosColl = factory.find(hql, markers, values, 400); //WDEV-11656
		
		return MemberOfStaffLiteVoAssembler.createMemberOfStaffLiteVoCollectionFromMemberOfStaff(mosColl).toIMosArray();
	}
	
	//WDEV-15544  //WDEV-15194 
	private List listHCPList(String name, String subClass, HcpDisType mosDiscipline, Integer mosLocation, Boolean canReferPatient,Boolean isALocalConsultant,Boolean isResponsibleHcp) 
	{
		if(name == null || (name != null && name.length() == 0))
			throw new DomainRuntimeException("Can not search on null name.");
		
		DomainFactory factory = getDomainFactory();
		
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
		
		String hql = "select h from Hcp h ";
		
		if(mosLocation != null)
		{
			hql += "left join h.mos as m left join m.locations as hcpLocation left join hcpLocation.location as loc "; 
		}
		
		hql += "where h.isActive = :isActive and (h.mos.name.upperSurname like :hcpSname or h.mos.name.upperForename like :hcpFname)";
		
		markers.add("isActive");
		values.add(Boolean.TRUE);
		markers.add("hcpSname");
		values.add(name.toUpperCase() + "%");
		markers.add("hcpFname");
		values.add(name.toUpperCase() + "%");
		
		StringBuilder condStr = new StringBuilder();
		
		if (subClass != null)
		{
			condStr.append(" and h.class = " + subClass);
		}
		else
		{
			if (mosDiscipline != null)
			{
				//If the hcpType = HcpDisType.OTHER we must allow for that field being null or it's parent == OTHER
				if (mosDiscipline.equals(HcpDisType.OTHER))
				{
					condStr.append(" and ( h.hcpType is null or h.hcpType.parent.id = :hcpType) ");														
				}
				else
				{
					condStr.append(" and h.hcpType.id = :hcpType");									
				}
				markers.add("hcpType");
				values.add(mosDiscipline.getID());
				
			}
		}
		
		if(mosLocation != null)
		{
			condStr.append(" and loc.id = :locationId");
			markers.add("locationId");
			values.add(mosLocation);
		}
		
		//WDEV-12587
		if(canReferPatient != null)
		{
			if(canReferPatient)
			{
				condStr.append(" and h.mos.canReferPatient = :canReferPatient");
			}
			else
			{
				condStr.append(" and (h.mos.canReferPatient is null or h.mos.canReferPatient = :canReferPatient)");
			}
			
			markers.add("canReferPatient");
			values.add(canReferPatient);
		}
		
		//WDEV-15544
		if(isALocalConsultant != null)
		{
			if(isALocalConsultant)
			{
				condStr.append(" and h.isALocalConsultant = :isALocalConsultant");
			}
			else
			{
				condStr.append(" and (h.isALocalConsultant is null or h.isALocalConsultant = :isALocalConsultant)");
			}
			
			markers.add("isALocalConsultant");
			values.add(isALocalConsultant);
		}
		
		//WDEV-15194 
		if(isResponsibleHcp != null)
		{
			if(isResponsibleHcp)
			{
				condStr.append(" and h.isHCPaResponsibleHCP = :isResponsibleHcp");
			}
			else
			{
				condStr.append(" and (h.isHCPaResponsibleHCP is null or h.isHCPaResponsibleHCP = :isResponsibleHcp)");
			}
			
			markers.add("isResponsibleHcp");
			values.add(isResponsibleHcp);
		}
		
		hql += condStr.toString();
		
		hql += " order by h.mos.name.upperSurname,h.mos.name.upperForename";
		
		List hcps = factory.find(hql, markers, values, 400); //WDEV-11656

		return hcps;
	}
	
	private IMos[] listByDiscipline(List hcps, String name, HcpDisType mosDiscipline) 
	{
		List<IMos> hcpList = new ArrayList<IMos>();
		
		if(hcps != null)
		{			
			for(int i=0;i<hcps.size();i++)
			{
				Hcp hcp = (Hcp) hcps.get(i);
				if (Medic.class.isAssignableFrom(hcp.getClass()))
					hcpList.add(MedicVoAssembler.create((Medic)hcp));				
				else if (Therapist.class.isAssignableFrom(hcp.getClass()))
					hcpList.add(TherapistVoAssembler.create((Therapist)hcps.get(i)));
				else if (Nurse.class.isAssignableFrom(hcp.getClass()))
					hcpList.add(NurseVoAssembler.create((Nurse)hcps.get(i)));
				else
					hcpList.add(HcpAssembler.create((Hcp)hcps.get(i)));				
			}
		}
		Collections.sort(hcpList, new HcpAdminComparator(SortOrder.ASCENDING));		
		
		IMos[] iMosArray = new IMos[hcpList.size()];
		for(int i=0; i < hcpList.size(); i++)
			iMosArray[i] = hcpList.get(i);
			
		return iMosArray;	
	}
	
	private class HcpAdminComparator implements Comparator
	{
		private int direction = 1;
		public HcpAdminComparator()
		{
			this(SortOrder.ASCENDING);
		}
		public HcpAdminComparator(SortOrder order)
		{
			if (order == SortOrder.DESCENDING)
			{
				direction = -1;
			}
		}
		public int compare(Object obj1, Object obj2)
		{
			ims.core.vo.Hcp voObj1 = (ims.core.vo.Hcp)obj1;
			ims.core.vo.Hcp voObj2 = (ims.core.vo.Hcp)obj2;
			return direction*(voObj1.getName().compareTo(voObj2.getName()));
		}
	}

	public IMos[] listMedics(String name,HcpDisType medicType, MedicGrade medicGrade, Boolean isResponsibleHcp)
	{
		if(name == null || (name != null && name.length() == 0))
			throw new DomainRuntimeException("Can not search on null name.");
		
		StringBuffer hqlConditions = new StringBuffer();

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		String andStr = "";

		String hql = "select medic from Medic as medic where medic.isActive = 1 and (medic.mos.name.upperSurname like :hcpSname or medic.mos.name.upperForename like :hcpFname)";
		markers.add("hcpSname");
		values.add(name.toUpperCase() + "%");
		markers.add("hcpFname");
		values.add(name.toUpperCase() + "%");
		andStr = " and ";
		
		if (medicGrade!=null)
		{
			hqlConditions.append(andStr+ " medic.grade.id =:idMedicGrade");
			markers.add("idMedicGrade");
			values.add(getDomLookup(medicGrade).getId());
			andStr = " and ";
		}
		
		if( medicType != null)
		{
			hqlConditions.append(andStr + " medic.medicType.id =:idMedicType");
			markers.add("idMedicType");
			values.add(getDomLookup(medicType).getId());
			andStr = " and ";
		}
		
		//WDEV-17096
		if(isResponsibleHcp != null)
		{
			if(isResponsibleHcp)
			{
				hqlConditions.append(" and medic.isHCPaResponsibleHCP = :isRespHcp");
			}
			else
			{
				hqlConditions.append(" and (medic.isHCPaResponsibleHCP is null or medic.isHCPaResponsibleHCP = :isRespHcp)");
			}
			
			markers.add("isRespHcp");
			values.add(isResponsibleHcp);
		}
		
		DomainFactory factory = getDomainFactory();
		List<?> list = factory.find((hql + hqlConditions.toString() + " order by medic.mos.name.upperSurname , medic.mos.name.upperForename asc").toString(), markers, values,400);
		 
		if (list != null && list.size() > 0)
			return (MedicLiteVoAssembler.createMedicLiteVoCollectionFromMedic(list)).toIMosArray(); //wdev-15687
			
		return null;
	}


	/*
	private HcpLiteVo convertHcpToHcpLiteVo(ims.core.vo.Hcp hcp)
	{
		HcpLiteVo voHcpLite = new HcpLiteVo();
		voHcpLite.setID_Hcp(hcp.getID_Hcp());
		voHcpLite.setMos(hcp.getMos());
		return voHcpLite;
	}

	private MedicLiteVo convertHcpToMedicLiteVo(ims.core.vo.Hcp hcp)
	{
		MedicLiteVo voMedicLite = new MedicLiteVo();
		voMedicLite.setID_Hcp(hcp.getID_Hcp());
		voMedicLite.setMos(hcp.getMos());
		return voMedicLite;
	}
	 */
}
