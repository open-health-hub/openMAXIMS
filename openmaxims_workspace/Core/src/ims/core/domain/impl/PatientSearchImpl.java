//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by John MacEnri using IMS Development Environment (version 1.17 build 40512.1200)
// Copyright (C) 1995-2004 IMS MAXIMS plc. All rights reserved.

package ims.core.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.configuration.InitConfig;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.pas.domain.objects.PASEvent;
import ims.core.patient.domain.objects.MergeRequest;
import ims.core.patient.domain.objects.Patient;
import ims.core.vo.MergeRequestVo;
import ims.core.vo.PasEventVo;
import ims.core.vo.PatientFilter;
import ims.core.vo.PatientShort;
import ims.core.vo.PatientShortCollection;
import ims.core.vo.PersonAddress;
import ims.core.vo.domain.MergeRequestVoAssembler;
import ims.core.vo.domain.PasEventVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.NameType;
import ims.core.vo.lookups.PatIdType;
import ims.core.vo.lookups.Sex;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.hibernate3.IMSCriteria;
import ims.domain.impl.Transactional;
import ims.dto.DTODomainImplementation;
import ims.dto.DtoErrorCode;
import ims.dto.Result;
import ims.dto.client.Demographics;
import ims.dto.client.Demographics.DemographicsRecord;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateFormat;
import ims.framework.utils.PartialDate;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;

public class PatientSearchImpl extends DTODomainImplementation implements ims.core.domain.PatientSearch, Transactional
{
	private static final long	serialVersionUID	= 1L;

	public boolean dtoOnly() 
	{
		return InitConfig.getConfigType().equals("DTO");
	}

	public Class getLookupServiceClass()
	{
		return ims.domain.lookups.impl.LookupServiceImpl.class;
	}
	
	public PatientShortCollection searchPatients(PatientFilter filter) throws ims.domain.exceptions.DomainInterfaceException 
	{
		if(ConfigFlag.DOM.PATIENT_SEARCH_TYPE.getValue().equals("LOCAL"))   
			return searchPatientsLocal(filter, true);
		else if(ConfigFlag.DOM.PATIENT_SEARCH_TYPE.getValue().equals("DTO"))
			return searchPatientsDTO(filter, Boolean.FALSE);
			
		return new PatientShortCollection();
	}
	
	private PatientShortCollection searchPatientsDTO(PatientFilter filter, Boolean remote) throws ims.domain.exceptions.DomainInterfaceException 
	{
		String extSystem = ConfigFlag.DOM.DEMOGRAPHICS_EXT_SYSTEM.getValue();
		int maxPats = ConfigFlag.DOM.PAT_SEARCH_MAX_SIZE.getValue();
		boolean addWildcard = ConfigFlag.DTO.PAT_SEARCH_ADD_WILDCARD.getValue();  // wdev-4219
		
		PatientShortCollection psColl = new PatientShortCollection();
		PatientShort ps;
		Result result = null;
		
		Demographics patients = (Demographics)getDTOInstance(Demographics.class);		
		patients.Filter.clear();
		
		if (remote.booleanValue()){
			patients.Filter.Remote = "Y";
		}else {
			patients.Filter.Remote = "N";			
		}

		if (filter.getPersId() != null)
		{
			if (filter.getPersId().getType().equals(PatIdType.HOSPNUM))
			{
				patients.Filter.Hospnum = filter.getPersId().getValue();
			}
			else if (filter.getPersId().getType().equals(PatIdType.PKEY))
			{
				patients.Filter.Pkey = filter.getPersId().getValue();
			}
			else if (filter.getPersId().getType().equals(PatIdType.NHSN))
			{
				patients.Filter.Nhsn = filter.getPersId().getValue();
				if (filter.getPersId().getType().equals(PatIdType.NHSN))
					patients.Filter.Nhsn = filter.getPersId().getValue().replace(" ", "");//wdev-7305
			}
			else if (filter.getPersId().getType().equals(PatIdType.CHARTNUM))
			{
				patients.Filter.Chartnum = filter.getPersId().getValue().toUpperCase();
			}
			else if (filter.getPersId().getType().equals(PatIdType.PPSN))
			{
				patients.Filter.Ppsn = filter.getPersId().getValue();
			}
			else
			{
				patients.Filter.Oidtype = "" + filter.getPersId().getType().getID();
				patients.Filter.Oidval = filter.getPersId().getValue();
			}
			result = patients.get();
		}
		else
		{
			patients.Connection.setListSize(20);
			if (filter.getSurname() != null)
			{
				String strSurname = removeWildCards(filter.getSurname().trim());
				if (addWildcard) // wdev-4219
					strSurname += "?";
				patients.Filter.Snm  = strSurname;
			}
			if (filter.getForename() != null)
			{
				String strForename = removeWildCards(filter.getForename().trim());
				if (addWildcard)  // wdev-4219
					strForename += "?";
				patients.Filter.Fnm1  = strForename;
			}
			if (filter.getDob() != null && !filter.getDob().toString().equals("__/__/____"))		//wdev-12350
			{
				Integer[] range = filter.getDob().toSearchRange();
				if(range[0] % 100 == 0)				//if days are 00
					range[0] += 1;
				int temp = range[0];
				temp /= 100;
				if(temp % 100 == 0)					//if months are 00
					range[0] += 100;
				String dobfrom = range[0].toString();
				String dobto = range[1].toString();
				if(dobfrom.equals(dobto))//WDEV-13514
					patients.Filter.Dob = dobfrom;
				else
					patients.Filter.Dob = dobfrom + "|" + dobto;
			}
			if (filter.getSex() != null){
				patients.Filter.Sex = getLookupService().getRemoteLookup(filter.getSex().getID(), extSystem);
			}
			result = patients.list(maxPats + 1);
		}
		
		if (result != null)
		{
			String errMessage = "";
			switch (result.getId())
			{
			case DtoErrorCode.GENERIC_ERROR:
				errMessage = "This functionality is currently unavailable. Error Message returned from PAS is : " + result.getMessage();
				break;
			case DtoErrorCode.NO_DATA_FOUND:
				errMessage = "No Patient records were found for your search criteria.";
				break;				
			case DtoErrorCode.NO_MORE_DATA:
				errMessage = "No Patient records were found for your search criteria.";
				break;				
			case DtoErrorCode.DUP_KEY_ERROR:
				errMessage = "Duplicate records were found for your search criteria.";
				break;				
			case DtoErrorCode.INVALID_DATA:
				errMessage = "The search criteria provided was invalid : " + result.getMessage();
				break;				
			case DtoErrorCode.UID_NOT_SENT:
				errMessage = "No unique identifier was found to query on.";
				break;				
			case DtoErrorCode.MERGED_PATIENT:
				errMessage = "Merged Patient error : " + result.getMessage();
				break;				
			default :
				throw new DomainRuntimeException(result.getMessage());
			}
			
			throw new DomainInterfaceException(errMessage);	
		}
		
		if (patients.DataCollection.count() > maxPats)
		{
			throw new DomainInterfaceException("Search returned more than the configured max size of " + maxPats + ". Please refine the search criteria.");
		}
		
		PersonAddress pa;
		DemographicsRecord patient;
		for (int i = 0; i < patients.DataCollection.count(); i++)
		{
			patient = patients.DataCollection.get(i);
			ps = new PatientShort();
			pa = new PersonAddress();
			
			//name
			ps.setName(patient.Snm, patient.Fnm1, patient.Fnm2);	
			
			//sex
			ps.setSex((Sex)getLookupService().getLocalLookup(Sex.class, Sex.TYPE_ID, extSystem, patient.Sex));
			
			//dob
			if(patient.Dob != null && !patient.Dob.equals("")) //WDEV-10984
				ps.setDob(new PartialDate(patient.Dob));			

			//dod
			try {
				ps.setDod(new Date(patient.Dod, DateFormat.ISO));
			}catch(ParseException pe){}
			
			//address
			pa.setLine1(patient.Adr1);
			pa.setLine2(patient.Adr2);
			pa.setLine3(patient.Adr3);
			pa.setLine4(patient.Adr4);			
			ps.setAddress(pa);

			ps.addId(PatIdType.NHSN, patient.Nhsn);						
			ps.addId(PatIdType.PKEY, patient.Pkey);						
			ps.addId(PatIdType.HOSPNUM, patient.Hospnum);						
			ps.addId(PatIdType.PPSN, patient.Ppsn);						
			ps.addId(PatIdType.CHARTNUM, patient.Chartnum);						
						
			//age
			if (ps.getDobIsNotNull())
			{
				if ( ! (ps.getDob().getDay() == null
						&& ps.getDob().getMonth() == null
						&& ps.getDob().getYear() == 0))
					ps.calculateAge();
			}
			
			//Ward
			OrganisationAndLocation locImpl = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
			ps.setWard(locImpl.getLocationByLocalCode(patient.Ploc, LocationType.WARD));

			psColl.add(ps);
		}
		
		return psColl.sort();
	}

	private String removeWildCards(String strToBeFormated)
	{
		if (strToBeFormated != null)
		{
			strToBeFormated = strToBeFormated.toUpperCase();
			strToBeFormated = strToBeFormated.replace("%","");
			strToBeFormated = strToBeFormated.replace("?","");
		}
		return strToBeFormated;

	}

	private PatientShortCollection searchPatientsLocal(PatientFilter filter, boolean bReturnMergedPatients)  
	{
		int maxPats = ConfigFlag.DOM.PAT_SEARCH_MAX_SIZE.getValue();
		DomainFactory factory = getDomainFactory();

		PatientShort ps;
		StringBuffer filterString = new StringBuffer();
		ArrayList markerNames = new ArrayList();
		ArrayList markerValues = new ArrayList();
		String andStr="";
		java.util.List patients = null;
		if (filter.getPersId() != null && filter.getPersId().getValue() != null && !filter.getPersId().getType().equals(PatIdType.NHSN))
		{
			//TODO dlaffan - when NTPF.Demographics is merged to Core.Demographics we 
			//can call the getPatient and add the result to the collection and return it 
			//here instead of this duplicated code

			StringBuffer hql = new StringBuffer(" from Patient p " +
					" join p.identifiers as ids" +
					" where ids.type = :idType ");// +
					//" and p.isActive = true ");
			
			String idVal = filter.getPersId().getValue().trim();			
			if (filter.getPersId().getType().equals(PatIdType.NHSN))
				idVal = filter.getPersId().getValue().replace(" ", "");//wdev-7305
			
			if(!ConfigFlag.DOM.CASE_SENSITIVE_PATID.getValue())
			{
				idVal = idVal.toUpperCase();
			}

			if (filter.getPersId().getType().equals(PatIdType.NHSN))
			{
				hql.append(" and ids.value like :idValue ");
				idVal += "%";
			}
			else
				hql.append(" and ids.value = :idValue");

			if(bReturnMergedPatients == true)
				hql.append(andStr + " and (p.isActive = :isActive or p.associatedPatient is not null)");
			else
				hql.append(andStr + " and p.isActive = :isActive and p.associatedPatient is null");
			
			//WDEV-17167
			if (Boolean.TRUE.equals(filter.getExcludeQuickRegistrationPatients()))
			{
				hql.append(andStr + " and ((p.isQuickRegistrationPatient is null) OR (p.isQuickRegistrationPatient = 0)) ");
			}
			
			patients = factory.find(hql.toString(), new String[]{"idValue", "idType", "isActive"}, new Object[]{idVal, getDomLookup(filter.getPersId().getType()),Boolean.TRUE});
		}
		else
		{
			//WDEV-13293 allow all search field values to be used in conjunction with NHSNumber
			if (filter.getPersId() != null && filter.getPersId().getValue() != null && filter.getPersId().getType().equals(PatIdType.NHSN))
			{
				filterString = new StringBuffer(" from Patient p ");
				
				if(ConfigFlag.DOM.USE_ALIAS_SURNAME_FUNCTIONALITY.getValue())//WDEV-15180
				{
					filterString.append(" left join p.otherNames as oths ");
				}

				filterString.append(" join p.identifiers as ids where ids.type = :idType ");
				
				String idVal = filter.getPersId().getValue().trim();			
				if (filter.getPersId().getType().equals(PatIdType.NHSN))
					idVal = filter.getPersId().getValue().replace(" ", "");//wdev-7305
				
				if(!ConfigFlag.DOM.CASE_SENSITIVE_PATID.getValue())
				{
					idVal = idVal.toUpperCase();
				}

				if (filter.getPersId().getType().equals(PatIdType.NHSN))
				{
					filterString.append(" and ids.value like :idValue ");
					idVal += "%";
				}
				else
					filterString.append(" and ids.value = :idValue");
				//WDEV-18285 -  this part was added twice to the query
				//if(bReturnMergedPatients == true)
					//filterString.append(andStr + " and (p.isActive = :isActive or p.associatedPatient is not null)");
				//else
				//	filterString.append(andStr + " and p.isActive = :isActive and p.associatedPatient is null");
				
				markerNames.add("idType");
				markerValues.add(getDomLookup(filter.getPersId().getType()));	
				markerNames.add("idValue");
				markerValues.add(idVal);	
				
				filterString.append(" and ");
			}
			String strSearchSurname = "";
			String strSearchForename = "";
			
			if (filter.getSurname() != null)
			{
				if (ConfigFlag.DOM.USE_ALIAS_SURNAME_FUNCTIONALITY.getValue())
				{
					filterString.append(" ( (oths.upperSurname like :aliassurname and oths.nameType = :nameType) or ( ");

					markerNames.add("nameType");
					markerValues.add(getDomLookup(NameType.ALIAS));
				}

				filterString.append(andStr + " p.name.upperSurname like :surname");

				markerNames.add("surname");

				strSearchSurname = filter.getSurname().toUpperCase().trim();
				strSearchSurname = strSearchSurname.replaceAll("[^a-zA-Z]", "");

				if(strSearchSurname.length() >= 40)
				{
					strSearchSurname = strSearchSurname.substring(0,40);
					strSearchSurname += '%';
				}
				else
				{
					strSearchSurname += '%';
				}

				markerValues.add(strSearchSurname);
				if (ConfigFlag.DOM.USE_ALIAS_SURNAME_FUNCTIONALITY.getValue())
				{
					markerNames.add("aliassurname");
					markerValues.add(strSearchSurname);
					
					filterString.append(" ) ) ");
				}
				
				andStr = " and ";
			}
			
			//WDEV-8149 if Forename consists only of "%" characters ignore
			String ret = "";
			if(filter!=null &&  filter.getForenameIsNotNull())
				ret = filter.getForename().replaceAll("%", "");
			

			if (filter.getForename() != null && ret.length()!=0)
			{
				filterString.append(andStr + " p.name.upperForename like :forename");
				markerNames.add("forename");

				filter.setForename(filter.getForename().replaceAll("[^a-zA-Z]", ""));
				strSearchForename = filter.getForename().toUpperCase().trim();
				
				if(strSearchForename.length() >= 9)
				{
					strSearchForename = strSearchForename.substring(0,9);
					strSearchForename += '%';
				}
				else
				{
					strSearchForename += '%';
				}

				markerValues.add(strSearchForename);					
				andStr = " and ";
			}
			if (filter.getDob() != null && !filter.getDob().toString().equals("__/__/____"))
			{
				filterString.append(andStr + " p.dob  between :dobFrom and :dobTo");
				markerNames.add("dobFrom");
				markerNames.add("dobTo");
				Integer[] range = filter.getDob().toSearchRange();
		        markerValues.add(range[0]);
		        markerValues.add(range[1]);
				andStr = " and ";
			}
			if (filter.getSex() != null)
			{
				filterString.append(andStr + " p.sex = :sex");
				markerNames.add("sex");
				markerValues.add(getDomLookup(filter.getSex()));
				andStr = " and ";
			}
			
			if (filter.getAddressIsNotNull())
			{
				filterString.append(andStr + " (upper(p.address.line1) like :partialAddress ");
				filterString.append(" or upper(p.address.line2) like :partialAddress");
				filterString.append(" or upper(p.address.line3) like :partialAddress");
				filterString.append(" or upper(p.address.line4) like :partialAddress");
				filterString.append(" or upper(p.address.line5) like :partialAddress )");

				markerNames.add("partialAddress");
				markerValues.add(filter.getAddress().toUpperCase() + "%");
				andStr = " and ";
			}
			
			//WDEV-18576
			if (filter.getPostCode() != null)
			{
				filterString.append(andStr + " (upper(REPLACE(p.address.postCode,' ','')) = :postCode )");

				markerNames.add("postCode");
				markerValues.add(filter.getPostCode().replace(" ","").toUpperCase());
				andStr = " and ";
			}
			
			if (filter.getCounty() != null)
			{
				filterString.append(andStr + " p.address.county = :county");
				markerNames.add("county");
				markerValues.add(getDomLookup(filter.getCounty()));
				andStr = " and ";
			}
            
			if(bReturnMergedPatients == true)
				filterString.append(andStr + " (p.isActive = :isActive or p.associatedPatient is not null)");
			else
				filterString.append(andStr + " p.isActive = :isActive and p.associatedPatient is null");
			
			markerNames.add("isActive");
			markerValues.add(Boolean.TRUE);
			
			if (Boolean.TRUE.equals(filter.getExcludeQuickRegistrationPatients()))
			{
				if (andStr.length() == 0)
				{	
					andStr = " and ";
				}
				filterString.append(andStr + " ((p.isQuickRegistrationPatient is null) OR (p.isQuickRegistrationPatient = 0)) ");
			}
			
			if (filter.getPersId() != null && filter.getPersId().getValue() != null && filter.getPersId().getType().equals(PatIdType.NHSN))
				patients = factory.find(filterString.toString(), markerNames, markerValues, maxPats);
			else if (ConfigFlag.DOM.USE_ALIAS_SURNAME_FUNCTIONALITY.getValue() && filter.getSurname() != null) 
				patients = factory.find("from ims.core.patient.domain.objects.Patient p left join p.otherNames as oths where " + filterString.toString() + " order by p.name.upperSurname asc , p.name.upperForename asc", markerNames, markerValues, maxPats);
			else
				patients = factory.find("from ims.core.patient.domain.objects.Patient p where " + filterString.toString() + " order by p.name.upperSurname asc , p.name.upperForename asc", markerNames, markerValues, maxPats);
		}
		
		if (patients != null)
		{
			//TODO dlaffan - when NTPF.Demographics is merged to Core.Demographics we 
			//can call the getPatient and add the result to the collection and return it 
			//here instead of this duplicated code
			
			//if only one returned check it is not a merged patient
			if(patients.size() == 1)
			{
				//recurse to get master patient if this patient was merged
				Patient domPatient = (Patient) patients.get(0);
				boolean isMergedPatient = false;
				while(domPatient.getAssociatedPatient() != null)
				{
					domPatient = domPatient.getAssociatedPatient();
					isMergedPatient = true;
				}
					
				if(isMergedPatient)
				{
					raiseAlert(domPatient.getMergedMessage((ims.core.patient.domain.objects.Patient)patients.get(0)));
					patients.set(0, domPatient);
				}
			}
							
			PatientShortCollection coll = (PatientShortAssembler.createPatientShortCollectionFromPatient(patients)).sort();
				
			for(int i = 0; i < coll.size(); i++)
			{
				ps = coll.get(i);
				if(ps.getAge() == null)
						ps.calculateAge();
			}
			
			return coll;
		}
		return null;
	}
	
	public PatientShortCollection getPatient(PatientFilter filter, Boolean remote) throws DomainInterfaceException 
	{		
		if(InitConfig.getConfigType().equals("HIB")) 
			return searchPatientsLocal(filter,true);
		else if(InitConfig.getConfigType().equals("DTO"))
			return searchPatientsDTO(filter, remote);	
			
		return new PatientShortCollection();
	}	
	public void saveMergeRequest(MergeRequestVo mergeRequest) throws DomainInterfaceException, StaleObjectException  
	{
		if(!mergeRequest.isValidated())
			throw new DomainRuntimeException("MergeRequestVo not validated");
		
		DomainFactory factory = getDomainFactory();
		
		if(!validateMergeRequest(mergeRequest))
			throw new DomainInterfaceException("A pending Merge Request involving a selected patient exists");
		
		MergeRequest doMergeRequest = MergeRequestVoAssembler.extractMergeRequest(factory, mergeRequest);
		factory.save(doMergeRequest);
	}


	public Boolean validateMergeRequest(MergeRequestVo mergeRequest) 
	{
		DomainFactory factory = getDomainFactory();
		
		//if any of the patients from the current attempted save are involved in pending merges(status set to false)
		List merges = factory.find("from MergeRequest m where m.status = :status and (m.sourcePatId = :sourcePatId or m.sourcePatId = :destPatId) and (m.destinationPatId = :sourcePatId or m.destinationPatId = :destPatId)", 
				new String[]{"status","sourcePatId","destPatId"},new Object[]{mergeRequest.getStatus(),mergeRequest.getSourcePatId(),mergeRequest.getDestinationPatId()});
		
		if(merges.size() > 0)
			return false;
		
		return true;
	}

	public PatientShortCollection listActivePatients(PatientFilter filter) throws DomainInterfaceException
	{
		return searchPatientsLocal(filter, false);
	}
	public PasEventVo getPasEvent(String pasEpisodeId,ims.core.vo.Patient patient, String visitID)
	{
		if(pasEpisodeId == null || patient == null)
			throw new CodingRuntimeException("pasEpisodeId and/or patient parameters are null in method existsPasEvent");
		
		DomainFactory factory=getDomainFactory();
		
		IMSCriteria imsc=new IMSCriteria(PASEvent.class, factory);
		ArrayList <String> objects = new ArrayList <String>();
		objects.add("patient");
		imsc.equal("patient.id", patient.getID_Patient());
		imsc.equal("this.pasEpisodeId", pasEpisodeId);
		List pasEvents=imsc.find();
		
		if (pasEvents.size()==0)
			return null;
		else
		{
			for (int i=0;i<pasEvents.size();i++)
			{
				PASEvent pas=(PASEvent)pasEvents.get(i);
				if (pas.getPasEventId().equals(visitID))
					return PasEventVoAssembler.create((PASEvent)pasEvents.get(i));
			}
		}
		return PasEventVoAssembler.create((PASEvent)pasEvents.get(0));
	}

	public ims.dto.client.Patient getCCODTOPatient(String pkey) throws DomainInterfaceException
	{
		if(pkey == null)
			throw new DomainRuntimeException("Cannot get Patient for null pkey");
		
		ims.dto.client.Patient patient = (ims.dto.client.Patient)getDTOInstance(ims.dto.client.Patient.class);
		patient.Filter.clear();
		patient.Filter.Pkey = pkey;
		
		Result result = patient.get();
		if (result != null)
		{
			if(result.getId() == -2)
				throw new DomainInterfaceException("Error Getting Patient Details for pkey = " + pkey);

			throw new DomainInterfaceException(result.getMessage());
		}

		if (patient.DataCollection.count()!= 1)
			throw new DomainInterfaceException("Failed to get patient record.");
		
		return patient;
	}
	
}
