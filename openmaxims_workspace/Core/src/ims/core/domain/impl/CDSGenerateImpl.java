//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Barbara Worwood using IMS Development Environment (version 1.71 build 3607.26880)
// Copyright (C) 1995-2009 IMS MAXIMS. All rights reserved.

package ims.core.domain.impl;

import ims.RefMan.domain.objects.CATSReferralStatus;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.DischargeSummaryPacuAndWard;
import ims.RefMan.domain.objects.ReferralCoding;
import ims.RefMan.domain.objects.ReferralCodingItem;
import ims.RefMan.domain.objects.SuitableForSurgeryAssessment;
import ims.RefMan.vo.lookups.ReferralApptStatus;
import ims.configuration.EnvironmentConfig;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.domain.objects.HrgConfig;
import ims.core.admin.pas.domain.objects.AdmissionDetail;
import ims.core.admin.pas.domain.objects.DischargedEpisode;
import ims.core.admin.pas.domain.objects.PASEvent;
import ims.core.cds.domain.objects.CDSDiagnosisDetails;
import ims.core.cds.domain.objects.CDSHistory;
import ims.core.cds.domain.objects.CDSInpatient;
import ims.core.cds.domain.objects.CDSInpatientLocationGroup;
import ims.core.cds.domain.objects.CDSOutpatient;
import ims.core.cds.domain.objects.CDSProcedureDetails;
import ims.core.clinical.domain.objects.Diagnosis;
import ims.core.clinical.domain.objects.IntraOperativeCareRecord;
import ims.core.clinical.domain.objects.PatientProcedure;
import ims.core.clinical.domain.objects.ReferralLetterDetails;
import ims.core.clinical.domain.objects.Service;
import ims.core.clinical.domain.objects.TaxonomyMap;
import ims.core.domain.base.impl.BaseCDSGenerateImpl;
import ims.core.patient.domain.objects.Patient;
import ims.core.patient.domain.objects.PatientId;
import ims.core.resource.people.domain.objects.Gp;
import ims.core.resource.people.domain.objects.Hcp;
import ims.core.resource.people.domain.objects.Medic;
import ims.core.resource.place.domain.objects.Activity;
import ims.core.resource.place.domain.objects.LocSite;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.domain.objects.Organisation;
import ims.core.resource.place.domain.objects.OrganisationPCTLinkConfig;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.CDSDiagnosisDetailsVo;
import ims.core.vo.CDSHistoryVo;
import ims.core.vo.CDSInpatientLocationGroupVo;
import ims.core.vo.CDSInpatientVo;
import ims.core.vo.CDSOutpatientVo;
import ims.core.vo.CDSProcedureDetailsVo;
import ims.core.vo.CDSResultVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.domain.CDSHistoryVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.lookups.CDSReportType;
import ims.core.vo.lookups.PasEventType;
import ims.core.vo.lookups.PatIdType;
import ims.core.vo.lookups.SourceOfReferral;
import ims.core.vo.lookups.TaxonomyType;
import ims.domain.DomainFactory;
import ims.domain.DomainObject;
import ims.domain.Transaction;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.impl.DomainImplFlyweightFactory;
import ims.domain.lookups.LookupInstance;
import ims.domain.lookups.LookupMapping;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.DateFormat;
import ims.framework.utils.DateTime;
import ims.framework.utils.PartialDate;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.Session_ListOwner;
import ims.scheduling.domain.objects.Session_Slot;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.utils.Logging;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.RandomAccessFile;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.zip.Deflater;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import org.apache.log4j.Logger;
import org.quartz.JobDetail;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.quartz.StatefulJob;

import com.ims.query.builder.client.QueryBuilderClient;
import com.ims.query.builder.client.SeedValue;
import com.ims.query.builder.client.exceptions.QueryBuilderClientException;

public class CDSGenerateImpl extends BaseCDSGenerateImpl implements StatefulJob
{

	private static final long serialVersionUID = 1L;
	private static final String CONTRACT_CODE="E01";  // Contract Code for UKSH
	private static final String UNKNOWN_CONSULTANT="C9999998";
	private static final String UNKNOWN_GP="G9999998";
	//private static final String UNKNOWN_REFERRER="X9999998";  wdev-9484
	private static final String UNKNOWN_PRACTICE="V81999";
	private static final String NO_PROCEDURE=" ";  // wdev-9720 changed from X999 to blank as requested
	private static final Logger	LOG					= Logging.getLogger(CDSGenerateImpl.class);
	private static final int DIAGNOSIS_TYPE=1;
	private static final int PROCEDURE_TYPE=2;
	private static boolean	 running = false;
	private static final int ADMISSION=1;
	private static final int DAY_CASE=2;
	
	//the next 3 definitions should be declared identically in CDSgenerate logic java file
	private static final String	INPATIENT_REPORT_TYPE	= "INPATIENT_REPORT";
	private static final String	OUTPATIENT_REPORT_TYPE	= "OUTPATIENT_REPORT";
	private static final String	HRG_REPORT_TYPE	= "HRG_REPORT";
	
	//WDEV-15012: max number of lines in buffer before flushing to disk
	private static final int	BUFFER_LINES	= 2000; 
	private static final int	MAX_RECORDS_LOG	= 10000;

	private static String		INPATIENT_REPORT		= "CDS Inpatient";
	private static String		OUTPATIENT_REPORT		= "CDS Outpatient";	
	private static String		HRG_GROUPER_REPORT		= "HRG Output";
	
	private static final int	INPATIENT_REPORT_ID		= 215;
	private static final int	OUTPATIENT_REPORT_ID	= 216;
	private static final int	HRG_GROUPER_REPORT_ID	= 246;
		
	private static final String HTML = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\r\n" + 
	"\r\n" + 
	"<style type=\"text/css\">\r\n" + 
	"<!-- \r\n" + 
	".line {background: #CCFFCC}\r\n" + 
	".body {font-family: monospace; font-size:14px;}\r\n" + 
	"-->\r\n" + 
	"</style>\r\n" + 
	"\r\n" + 
	"<html>\r\n" + 
	"<head>\r\n" + 
	"<title>CDS Report</title>\r\n" + 
	"</head>\r\n" + 
	"\r\n" + 
	"<script type=\"text/javascript\">\r\n" + 
	"<!--\r\n" + 
	"    function setupHeader() \r\n" + 
	"    {\r\n" + 
	"        if(document.getElementById) \r\n" + 
	"    		{\r\n" + 
	"            var div3 = document.getElementById('L3');\r\n" + 
	"						\r\n" + 
	"						document.getElementById('L1').innerHTML = \"<SPAN style=\\\"background-color:#FFFFCC\\\">\" + addHeaderChars(MAXLINE, 100) + \"</SPAN>\";\r\n" + 
	"						document.getElementById('L2').innerHTML = \"<SPAN style=\\\"background-color:#FFFFCC\\\">\" + addHeaderChars(MAXLINE, 10) + \"</SPAN>\";\r\n" + 
	"						document.getElementById('L3').innerHTML = \"<SPAN style=\\\"background-color:#FFFFCC\\\">\" + \"<u>\" + addHeaderChars(MAXLINE, 1) + \"</u>\" + \"</SPAN>\";\r\n" + 
	"						\r\n" + 
	"            return true;\r\n" + 
	"        }\r\n" + 
	"    		\r\n" + 
	"        return false;\r\n" + 
	"    }\r\n" + 
	"		\r\n" + 
	"		function addHeaderChars(len, step)\r\n" + 
	"		{\r\n" + 
	"		 	 var ret = \"\";\r\n" + 
	"			 \r\n" + 
	"			 for(var i = 1; i <= len; i++)\r\n" + 
	"			 {\r\n" + 
	"			 	   if(step == 1)\r\n" + 
	"					 {\r\n" + 
	" 					    ret = ret + i%10;\r\n" + 
	"					 }\r\n" + 
	"			 	   else\r\n" + 
	"					 {\r\n" + 
	"    			 	   ret = ret + (i%step == 0 ? (i/step)%step : \"&nbsp;\");\r\n" + 
	"					 }\r\n" + 
	"			 }\r\n" + 
	"			 \r\n" + 
	"			 return ret;\r\n" + 
	"		}\r\n" + 
	"    \r\n" + 
	"    window.onload = setupHeader;\r\n" + 
	"// -->\r\n" + 
	" </script>\r\n" + 
	"\r\n" + 
	"<body class=\"body\">\r\n" + 
	"<DIV id=\"L1\"></DIV>\r\n" + 
	"<DIV id=\"L2\"></DIV>\r\n" + 
	"<DIV id=\"L3\"></DIV>";
	

	public void execute(JobExecutionContext ctx) throws JobExecutionException
	{
		try 
		{
			JobDetail job = ctx.getJobDetail();
			Date last = ctx.getPreviousFireTime();
			Calendar cal = Calendar.getInstance();
			Date curr = cal.getTime();
			
			System.out.println();
			System.out.println( job.getFullName() + " executes. Last run: " + last + " current: " + curr);
			
			System.out.println("Check if another job of this type is running");
			while(true) 
			{				
				if (!running)
				{
					running = true;
					System.out.println("No CDS job running! Proceed with doExecute()");
					doExecute(ctx, last, curr);
					break;
				}
				else
				{
					System.out.println("Another CDS job is running!");
					ims.core.domain.CDSGenerate impl = (ims.core.domain.CDSGenerate)DomainImplFlyweightFactory.getInstance().create(CDSGenerateImpl.class, ims.domain.DomainSession.getSession());
					impl.createSystemLogEntry(SystemLogType.QUARTZ_JOB, SystemLogLevel.ERROR, "Attempt to start a job when another is still executing, this job is going to be deleted - " + ctx.getJobDetail().getFullName());
					running = false;
					return;
				}
			}
			running = false;
		}
		catch (Exception e)
		{
			running = false;
			ims.core.domain.CDSGenerate impl;
			try 
			{
				impl = (ims.core.domain.CDSGenerate)DomainImplFlyweightFactory.getInstance().create(CDSGenerateImpl.class, ims.domain.DomainSession.getSession());
				impl.createSystemLogEntry(SystemLogType.QUARTZ_JOB, SystemLogLevel.ERROR, "Exception in execute method - " + e.getMessage());
			}
			catch (Exception e1) 
			{
				e1.printStackTrace();
			} 
		
			System.out.println("Exception in execute method - " + e.getMessage());
		} 	   
	}	
	

	public synchronized void doExecute(JobExecutionContext ctx, Date last, Date curr) throws Exception 
	{
		String hostname = "";
		String ipAddress = "";
		try 
		{ 
			InetAddress addr 	 = InetAddress.getLocalHost();   
			hostname = addr.getHostName();											
		    ipAddress = addr.getHostAddress();		      
		} 
		catch (UnknownHostException err) 
		{ 
			throw new DomainRuntimeException(err.getMessage());			
		} 
		System.out.println("Executing " + ctx.getTrigger().getJobName() + " at: " + Calendar.getInstance().getTime() + " triggered by: hostname: " + hostname + "(" + ipAddress + ")");		


		try 
		{
			ims.core.domain.CDSGenerate impl = (ims.core.domain.CDSGenerate)DomainImplFlyweightFactory.getInstance().create(CDSGenerateImpl.class, ims.domain.DomainSession.getSession());
			
			JobDetail jb = ctx.getJobDetail();
			if (jb != null )
			{
				String jbType = (String) jb.getJobDataMap().get("JOB_TYPE");
				ims.framework.utils.Date dateFrom = (ims.framework.utils.Date) jb.getJobDataMap().get("DATE_FROM");
				ims.framework.utils.Date dateTo = (ims.framework.utils.Date) jb.getJobDataMap().get("DATE_TO");
				
				java.util.Date startTime = new java.util.Date();
				if (jbType != null && jbType.equals("INPATIENT"))
				{
						impl.createSystemLogEntry(SystemLogType.QUARTZ_JOB, SystemLogLevel.INFORMATION, "Inpatient CDS Data Generate Started for Date Range (" + dateFrom + " to " + dateTo + ") ");

						int numRecords = impl.generateInpatCDSData(dateFrom, dateTo);
						java.util.Date stopTime = new java.util.Date();
						long totalTime=stopTime.getTime() - startTime.getTime();
						impl.createSystemLogEntry(SystemLogType.QUARTZ_JOB, SystemLogLevel.INFORMATION, "Inpatient CDS Data Generated Successfully for Date Range (" + dateFrom + " to " + dateTo + ") " + numRecords + " records generated - took " + formatTimeTaken(totalTime));

				}
				else if (jbType != null && jbType.equals("OUTPATIENT"))
				{
					impl.createSystemLogEntry(SystemLogType.QUARTZ_JOB, SystemLogLevel.INFORMATION, "Outpatient CDS Data Generate Started for Date Range (" + dateFrom + " to " + dateTo + ") ");

					int numRecords=impl.generateOutpatCDSData(dateFrom, dateTo);
					java.util.Date stopTime = new java.util.Date();
					long totalTime=stopTime.getTime() - startTime.getTime();
					impl.createSystemLogEntry(SystemLogType.QUARTZ_JOB, SystemLogLevel.INFORMATION, "Outpatient CDS Data Generated Successfully for Date Range (" + dateFrom + " to " + dateTo + ") " + numRecords + " records generated - took " +  formatTimeTaken(totalTime));

				}
				else if (jbType != null && (jbType.equals(OUTPATIENT_REPORT_TYPE) || jbType.equals(INPATIENT_REPORT_TYPE) || jbType.equals(HRG_REPORT_TYPE)))
				{
					String nlc = (String) jb.getJobDataMap().get("NLC");
					String requestUrl = (String) jb.getJobDataMap().get("REQURL");
					String rep = "";
					int repId = 0;
					
					if(jbType.equals(OUTPATIENT_REPORT_TYPE))
					{
						rep = "Outpatient";
						repId = OUTPATIENT_REPORT_ID;
					}
					else if(jbType.equals(INPATIENT_REPORT_TYPE))
					{
						rep = "Inpatient";
						repId = INPATIENT_REPORT_ID;
					}
					else if(jbType.equals(HRG_REPORT_TYPE))
					{
						rep = "HRG Grouper";
						repId = HRG_GROUPER_REPORT_ID;
					}

					impl.createSystemLogEntry(SystemLogType.QUARTZ_JOB, SystemLogLevel.INFORMATION, rep + " CDS Report Started for Date Range (" + dateFrom + " to " + dateTo + "), Location = '" + nlc + "'");

					CDSResultVo res = impl.buildCDSReport(dateFrom, dateTo, nlc, repId, null, requestUrl);

					if(Boolean.TRUE.equals(res.getSuccessful()))
					{					
						java.util.Date stopTime = new java.util.Date();
						long totalTime = stopTime.getTime() - startTime.getTime();
						impl.createSystemLogEntry(SystemLogType.QUARTZ_JOB, SystemLogLevel.INFORMATION, rep + " CDS Report Generated Successfully for Date Range (" + dateFrom + " to " + dateTo + "), Location = '" + nlc + "' - took " + formatTimeTaken(totalTime));
					}
					else
					{
						impl.createSystemLogEntry(SystemLogType.QUARTZ_JOB, SystemLogLevel.ERROR, rep + " CDS Report Failed to execute for Date Range (" + dateFrom + " to " + dateTo + "), Location = '" + nlc + "', Error was:" + res.getErrorMessage());
					}
				}
				
			}
		} 
		catch (InstantiationException err) 
		{
			LOG.error(err.getMessage(), err);
			throw new Exception(err.getMessage());
		} 
		catch (IllegalAccessException err) 
		{		
			LOG.error(err.getMessage(), err);
			throw new Exception(err.getMessage());
		} 
		catch (StaleObjectException err) 
		{
			LOG.error(err.getMessage(), err);
			throw new Exception(err.getMessage());
		}				
	} 
	 
	private String formatTimeTaken(long millis)
	{
		int seconds = (int) ((millis / 1000) % 60);
		int minutes = (int) ((millis / 1000) / 60);
		if (minutes > 60)
			minutes %= 60;
		int hours = (int) (((millis / 1000) / 60) / 60);
		
		StringBuffer returnValue = new StringBuffer();
		if (hours > 0)
			returnValue.append(hours).append(" hour(s) and ");
		if (minutes  > 0)
			returnValue.append(minutes).append(" minute(s) and ");
		if (seconds > 0)
			returnValue.append(seconds).append(" second(s) and ");
		returnValue.append(millis % 1000).append(" milliseconds.");
		return returnValue.toString();
	}
		

	@SuppressWarnings("rawtypes")
	public Integer generateOutpatCDSData(ims.framework.utils.Date fromDate, ims.framework.utils.Date toDate) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		// WDEV-12877
		String defaultSiteCode = ConfigFlag.DOM.CDS_DEFAULT_SITE_CODE.getValue();
		if (defaultSiteCode == null || defaultSiteCode.equals(""))
			defaultSiteCode="NA";
		defaultSiteCode = formatStr(defaultSiteCode, 5); // Max Length allowed
		
		DomainFactory factory = getDomainFactory();
		
		String deleteOutpatientSql = "delete from core_cdsoutpatient where core_cdsoutpatient.apptdate between ? and ?";//WDEV-13368
		deleteFromTable(deleteOutpatientSql, fromDate, toDate);//	WDEV-13368

		// List all appointments who's appointment dates are within the given date range
		StringBuffer hql = new StringBuffer();
		hql.append(" from CatsReferral ref  join ref.appointments as appt join ref.careContext as cc where ((appt.isRIE is null or appt.isRIE = 0) and (appt.session.isTheatreSession is null or appt.session.isTheatreSession is false) ");
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		ArrayList<Integer> appts = new ArrayList<Integer>();
		
		if (fromDate != null && toDate != null)
		{
			hql.append(" and appt.appointmentDate between :fromDate and :toDate");
			markers.add("fromDate");
			markers.add("toDate");
			values.add(fromDate.getDate());
			values.add(toDate.getDate());
		}
		else if (fromDate != null && toDate == null)
		{
			hql.append(" and appt.appointmentDate >= :fromDate");
			markers.add("fromDate");
			values.add(fromDate.getDate());
		}
		else if (fromDate == null && toDate != null)
		{
			hql.append(" and appt.appointmentDate <= :toDate");
			markers.add("toDate");
			values.add(toDate.getDate());
		}
		
		hql.append(")");
		

		// Exclude Theatre Sessions
		List lst = factory.find(hql.toString(), markers, values);
		if (lst == null || lst.size() == 0)
			return 0;
			
		Map<String,CDSOutpatient> outpatMap = new HashMap<String,CDSOutpatient>();
		String errors[] = new String[lst.size()];
		int errorCounter=0;
		// Loop through each result and process for CDS extract
		for (int i=0; i<lst.size(); i++)
		{
			

			Object[] items = (Object[]) lst.get(i);
			CatsReferral domRef = (CatsReferral) items[0];
			Booking_Appointment domAppt = (Booking_Appointment) items[1];
			CareContext domCC = (CareContext) items[2];

			if (appts.contains(domAppt.getId()))
			{
				LOG.debug("Skip Record " + domAppt.getId());
				continue;
			}
			appts.add(domAppt.getId());
			LOG.debug("Record " + i + " Appt " + domAppt.getId());
			CDSOutpatient cds = CDSOutpatient.getCDSOutpatientFromAppointmentId(factory, domAppt.getId());
			if (cds == null)
				cds = new CDSOutpatient();

			cds.setAppointmentId(domAppt.getId());
			if (domAppt.getSystemInformation() != null)
			{
				if (domAppt.getSystemInformation().getLastUpdateDateTime() != null)
					cds.setCDSApplicableDate(domAppt.getSystemInformation().getLastUpdateDateTime());
				else
					cds.setCDSApplicableDate(domAppt.getSystemInformation().getCreationDateTime());
			}

			// WDEV-13201 - Patient Location not null, then retrieve it's value, otherwise use location only
			if (domAppt.getSession().getSchLocation().getParentLocation() != null)
				cds.setCDSSenderOrgCode(formatStr(getNationalLocCode(domAppt.getSession().getSchLocation().getParentLocation(), defaultSiteCode), CDSOutpatientVo.getCDSSenderOrgCodeMaxLength()));
			else
				cds.setCDSSenderOrgCode(formatStr(getNationalLocCode(domAppt.getSession().getSchLocation(), defaultSiteCode), CDSOutpatientVo.getCDSSenderOrgCodeMaxLength()));
			
			String nhsNum="";
			PatientId domPatId = getNHSNumber(domAppt.getPatient());  // Get NHS Number to output as part of system logs
			if (domPatId != null)
				nhsNum = domPatId.getValue();

			
			//CatsReferral domRef = getCatsReferralFromAppt(factory, domAppt);
			if (domRef == null || (domRef.getIsRIE() != null && domRef.getIsRIE() == true))
			{
				factory.evict(cds);
				errors[errorCounter++] = "No Referral Found for Appt " + domAppt.getId() + " (" + nhsNum + ")";
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "No Referral Found for Appt " + domAppt.getId() + " (" + nhsNum + ")");
				continue;
			}
			ReferralLetterDetails domRefLet = domRef.getReferralDetails();
			if (domRefLet == null)
			{
				factory.evict(cds);
				errors[errorCounter++] = "No Referral Letter Details Found for Referral " + domRef.getId() + " (" + nhsNum + ")";
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "No Referral Letter Details Found for Referral " + domRef.getId() + " (" + nhsNum + ")");
				continue;
			}
			
			if (domCC == null)
			{
				factory.evict(cds);
				errors[errorCounter++] = "CareContext not found for referral " + domRef.getId() + " (" + nhsNum + ")";
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "CareContext not found for referral " + domRef.getId() + " (" + nhsNum + ")");
				continue;
			}
			
			// wdev-9484
			// Exclude nursing clinics
			if (isNursingClinic(domRefLet.getService()))
			{
				factory.evict(cds);
				errors[errorCounter++] = "Nursing Clinic ignored for appointment " + domAppt.getId() + " (" + nhsNum + ")";
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "Nursing Clinic ignored for appointment " + domAppt.getId() + " (" + nhsNum + ")");
				continue;
			}
			
			// wdev-9720
			// Exclude Radiology clinics
			if (isRadiologyClinic(domRefLet.getService()))
			{
				factory.evict(cds);
				errors[errorCounter++] = "Radiology Clinic ignored for appointment " + domAppt.getId() + " (" + nhsNum + ")";
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "Radiology Clinic ignored for appointment " + domAppt.getId() + " (" + nhsNum + ")");
				continue;
			}
			
			// WDEV-13478
			// Exclude Inpatient non-suitable for surgery clinics from outpatient CDS
			if (isInpatientNonSuitableForSurgeryClinic(domRefLet.getService()))
			{
				factory.evict(cds);
				errors[errorCounter++] = "Inpatient Non Suitable for Surgery Clinic ignored for appointment " + domAppt.getId() + " (" + nhsNum + ")";
				continue;
			}
			
			
			IntraOperativeCareRecord domIntraCare = getIntraCareRecord(factory, domCC, domAppt.getAppointmentDate());
			
			cds.setPathwayIdentifier(CONTRACT_CODE + formatDec(domRef.getId(), CDSOutpatientVo.getPathwayIdentifierMaxLength()- CONTRACT_CODE.length()));
			cds.setPathwayOrgCode(formatStr(cds.getCDSSenderOrgCode(), CDSOutpatientVo.getPathwayOrgCodeMaxLength())); // wdev-9077 same as senderOrgCode
			cds.setRTTStartDate(domRefLet.getDateOfReferral());
			cds.setLeadCareActInd(" ");
			cds.setReferralToTreatmentStatus(formatStr("30", CDSOutpatientVo.getReferralToTreatmentStatusMaxLength()));  // Not Yet Known
			
			if (domRef.getICABReferral() != null && domRef.getICABReferral().getUBRN() != null)
				cds.setUBRN(formatStr(domRef.getICABReferral().getUBRN(), CDSOutpatientVo.getUBRNMaxLength()));
			else
				cds.setUBRN(formatStr(" ", CDSOutpatientVo.getUBRNMaxLength()));

			
			if (domIntraCare != null && domIntraCare.getProcedureDate() != null)
			{
				cds.setRTTEndDate(domIntraCare.getProcedureDate());
			}
			else
			{  // wdev-9720
				if (domRef.getProviderCancellation() != null)
					cds.setRTTEndDate(domRef.getProviderCancellation().getCancellationDateTime());
			}
			
			Patient domPatient = domRef.getPatient();
			// If this is a dummy patient - we do not want to include it.
			if (domPatient != null && domPatient.getName() != null && domPatient.getName().getSurname().equals("DummyICABSurname"))
			{
				factory.evict(cds);
				errors[errorCounter++] = "DummyICAB Patient Found - will be ignored - " + domPatient.getId() + " (" + nhsNum + ")";
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "DummyICAB Patient Found - will be ignored - " + domPatient.getId() + " (" + nhsNum + ")");
				continue;
			}
			
			cds.setLocalPatientIdentifier(formatStr(domPatient.getId(), CDSOutpatientVo.getLocalPatientIdentifierMaxLength()));
			cds.setPatIdOrgCode(formatStr(cds.getCDSSenderOrgCode(), CDSOutpatientVo.getPatIdOrgCodeMaxLength()));   
			if (domPatId != null)
			{
				cds.setNHSNumber(domPatId.getValue());
				if (domPatId.isVerified())
					cds.setNHSNumberStatusInd("01");
				else
					cds.setNHSNumberStatusInd("02");
				cds.setPatientName(formatStr(" ", CDSOutpatientVo.getPatientNameMaxLength()));
				cds.setPatientAddress(formatStr(" ", CDSOutpatientVo.getPatientAddressMaxLength()));			
			}
			else
			{
				cds.setNHSNumber(formatStr(" ", CDSOutpatientVo.getNHSNumberMaxLength()));
				cds.setNHSNumberStatusInd("09");  // Not Present
				cds.setPatientName(formatStr(domPatient.getName() == null ? " " : domPatient.getName().toString(), CDSOutpatientVo.getPatientNameMaxLength()));
				cds.setPatientAddress(formatStr(domPatient.getAddress() == null ? " " :domPatient.getAddress().toString(), CDSOutpatientVo.getPatientAddressMaxLength()));			
			}

			cds.setPostCode(formatStr(domPatient.getAddress() == null ? "":domPatient.getAddress().getPostCode(), CDSOutpatientVo.getPostCodeMaxLength()));
			if (domPatient.getGpSurgery() != null && domPatient.getGpSurgery().getParentOrganisation() != null 
					&& domPatient.getGpSurgery().getParentOrganisation().getPctCode() != null)
			{
				cds.setPCTOrgCode(formatStr(domPatient.getGpSurgery().getParentOrganisation().getPctCode(), CDSOutpatientVo.getPCTOrgCodeMaxLength()));
			}
			else
				cds.setPCTOrgCode(formatStr(domRefLet.getPCT(), CDSOutpatientVo.getPCTOrgCodeMaxLength()));
			
			cds.setDateOfBirth(fromPartialDate(domPatient.getDob()));
			String gender =  getExternalMapping(domPatient.getSex());
			if (gender == null)
			{
				if (domPatient.getSex() != null)
				{
					errors[errorCounter++] = "Lookup Mapping of type CDS not found for patient sex = " + domPatient.getSex().getText();
					//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "Lookup Mapping of type CDS not found for patient sex = " + domPatient.getSex().getText());
				}
				gender="9";
			}
			cds.setPersonGender(formatStr(gender, CDSOutpatientVo.getPersonGenderMaxLength()));

			String ethnicOrigin="99";  // Unknown
			if (domPatient.getEthnicOrigin() != null)
			{
				ethnicOrigin = getExternalMapping(domPatient.getEthnicOrigin());
				if (ethnicOrigin == null)
					ethnicOrigin="99";
			}
			cds.setEthnicCategory(formatStr(ethnicOrigin, CDSOutpatientVo.getEthnicCategoryMaxLength()));

			cds.setTreatmentFuncCode(formatStr(getNatSpecialtyCode(domRefLet.getService()), CDSOutpatientVo.getTreatmentFuncCodeMaxLength()));
			cds.setSpecialtyCode(formatStr(cds.getTreatmentFuncCode(), CDSOutpatientVo.getSpecialtyCodeMaxLength()));
			// WDEV-13201 - Consultant should be retrieved from the sessionList owners firs and foremost
			String consultantCode=null;
			// Take First Listowner for the clinic
			if (domAppt.getSession().getListOwners() != null)
			{
				while (domAppt.getSession().getListOwners().iterator().hasNext())
				{
					Session_ListOwner domLo = (Session_ListOwner) domAppt.getSession().getListOwners().iterator().next();
					consultantCode = getNatConsultantCode(domLo.getHcp());
					//mainSpecCode = getConsMainSpecialty(factory, domLo.getHcp());
					break;
				}
			}
			if (consultantCode == null)
				// revert to use Appt SeenBy as no other value available
				consultantCode = getNatConsultantCode(domAppt.getSeenBy());
			
			if (consultantCode ==  null && domIntraCare != null)
			{
				consultantCode = getNatConsultantCode(domIntraCare.getPlannedProcedure().getPeformedBy());
				// Get consultant's main specialty
				//mainSpecCode = getConsMainSpecialty(factory, domIntraCare.getPlannedProcedure().getPeformedBy());
			}

			cds.setConsultantCode(formatStr(consultantCode, CDSOutpatientVo.getConsultantCodeMaxLength(),UNKNOWN_CONSULTANT)); // wdev-10825	
			// Set above wdev-9484cds.setSpecialtyCode(formatStr(mainSpecCode, CDSOutpatientVo.getSpecialtyCodeMaxLength()));
			
	

			cds.setAttendanceIdentifier(formatStr(domAppt.getId(), CDSOutpatientVo.getAttendanceIdentifierMaxLength()));
			
			cds.setAdminCategory("01");  // Default NHS
			// WDEV-15790 - AdminCategory to be retrieved from ReferralCategory associated with referral
			if (domRef != null && domRef.getReferralCategory() != null)
			{
				cds.setAdminCategory(formatStr(getExternalMapping(domRef.getReferralCategory(), "01"),CDSOutpatientVo.getAdminCategoryMaxLength()));
			}


			String attendStat=null;
			if (domAppt.getAppointmentDate().after(new Date()))
				attendStat = "0";  // Future
			else
			{
				attendStat = getExternalMapping(domAppt.getApptStatus());
				if (attendStat == null)
					attendStat = getExternalMapping(domAppt.getApptStatusReas());
			}
			
			cds.setAttendedOrDNA(formatStr(attendStat, CDSOutpatientVo.getAttendedOrDNAMaxLength()));
			
			
			// WDEV-9484 - Get activity from slot and get code mapping from here.
			Session_Slot domSlot = domAppt.getSessionSlot();
			String firstAttendance ="1";
			if (domSlot != null && domSlot.getActivity() != null)
			{
				firstAttendance = getFirstAttendanceValue(domSlot.getActivity(), "1");  // Default
			}
			else if (domAppt.getActivity() != null)  // WDEV-13327 - Check Appt's activity if slot is null
			{
				firstAttendance = getFirstAttendanceValue(domAppt.getActivity(), "1");  // Default
			}
			cds.setFirstAttendance(formatStr(firstAttendance, CDSOutpatientVo.getFirstAttendanceMaxLength()));

			cds.setMedStaffType(formatStr("03", CDSOutpatientVo.getMedStaffTypeMaxLength()));
			
			// 1 One or more operative procedure carried out 
			// 9 Not known i.e. finished episode/out-patient attendance but no data entered or the episode is unfinished and no data needs to be present. This would be a validation error only for a finished episode
			if (domIntraCare != null && domIntraCare.getActualProcedure() != null)
				cds.setOperationStatus(formatStr("1", CDSOutpatientVo.getOperationStatusMaxLength()));
			else
				cds.setOperationStatus(formatStr("9", CDSOutpatientVo.getOperationStatusMaxLength()));
			
			
			// wdev-9484
			// Value 1 if ReferralApptStatus is discharged or referral cancelled by provider
			// Value 2 if another appointment for patient after this appts date
			// Value 3 if no future appointment and not discharged
			cds.setAttendOutcome(formatStr(getAttendanceOutcome(factory,domAppt, domRef), CDSOutpatientVo.getAttendOutcomeMaxLength()));
			cds.setCarerSupportInd(formatStr(" ", CDSOutpatientVo.getCarerSupportIndMaxLength()));
			cds.setApptDate(domAppt.getAppointmentDate());
			cds.setAge(calculateAge(domAppt.getAppointmentDate(), domPatient.getDob()));
			cds.setEarliestOfferDate(domAppt.getEarliestOfferedDate());
			
			cds.setSerialNumber(formatStr(" ", CDSOutpatientVo.getSerialNumberMaxLength()));
			cds.setNHSServiceAgreeNum(formatStr(" ", CDSOutpatientVo.getNHSServiceAgreeNumMaxLength()));
			cds.setProviderRefNum(formatStr(" ",CDSOutpatientVo.getProviderRefNumMaxLength()));
			cds.setOrgCodeProvider(formatStr(defaultSiteCode, CDSOutpatientVo.getOrgCodeProviderMaxLength()));
			
			// WDEV-18159
			// ORGANISATION CODE (CODE OF COMMISSIONER) to be determined on the basis of registered GP practice or, where a patient is not registered, their place of residence".
			// If it is then still null, use the referral letter PCT value
			if (domPatient.getGpSurgery() != null && domPatient.getGpSurgery().getParentOrganisation() != null && 
					domPatient.getGpSurgery().getParentOrganisation().getPctCode() != null)
			{
				cds.setOrgCodeCommissioner(formatStr(domPatient.getGpSurgery().getParentOrganisation().getPctCode(), CDSOutpatientVo.getOrgCodeCommissionerMaxLength()));
			}
			else if (domPatient.getAddress() != null && domPatient.getAddress().getPCT() != null)
			{
				cds.setOrgCodeCommissioner(formatStr(domPatient.getAddress().getPCT(), CDSOutpatientVo.getOrgCodeCommissionerMaxLength()));
			}
			else if (domRefLet != null)
			{
				cds.setOrgCodeCommissioner(formatStr(domRefLet.getPCT(), CDSOutpatientVo.getOrgCodeCommissionerMaxLength()));
			}
			else
			{
				cds.setOrgCodeCommissioner(formatStr(" ", CDSOutpatientVo.getOrgCodeCommissionerMaxLength()));
			}
			
			cds.setCommissionerRefNum(formatStr(" ", CDSOutpatientVo.getCommissionerRefNumMaxLength()));
			cds.setResourceGrpCode(formatStr(" ", CDSOutpatientVo.getResourceGrpCodeMaxLength()));
			cds.setResourceGPVersion(formatStr(" ", CDSOutpatientVo.getResourceGPVersionMaxLength()));
			cds.setProcedureScheme(formatStr("02", CDSOutpatientVo.getProcedureSchemeMaxLength()));
			cds.setHrgDominantGrouping(formatStr("3.5", CDSOutpatientVo.getHrgDominantGroupingMaxLength()));

			// WDEV-13777  Check if we need to replace organisation code dependant on the OrgCodeCommissioner value
			String replacement = getOrgCodeReplacement(factory, cds.getOrgCodeCommissioner());
			if (replacement != null)
			{
				cds.setOrgCodeProvider(formatStr(replacement, CDSOutpatientVo.getOrgCodeProviderMaxLength()));
				cds.setPatIdOrgCode(formatStr(replacement, CDSOutpatientVo.getPatIdOrgCodeMaxLength()));
				// This needs to stay as it is cds.setPathwayOrgCode(formatStr(replacement, CDSOutpatientVo.getPathwayOrgCodeMaxLength()));
			}
			
			cds.setLocationClass(formatStr("01", CDSOutpatientVo.getLocationClassMaxLength()));  // TODO - this is general occurrence, but need to be specific
			String siteCode = defaultSiteCode; 
//			if (domIntraCare != null && domIntraCare.getTheatre().getParentLocation() != null)
//			{
//				siteCode = getNationalLocCode(domIntraCare.getTheatre().getParentLocation(), defaultSiteCode);
//			}
//			else if (domIntraCare != null && domIntraCare.getTheatre() != null)
//			{
//				siteCode = getNationalLocCode(domIntraCare.getTheatre(), defaultSiteCode);
//			}
//			cds.setSiteCodeTreatment(formatStr(siteCode, (CDSOutpatientVo.getSiteCodeTreatmentMaxLength())));  

			// WDEV-13201  Site code of treatment is retrieved from the appointment's session location
			// i.e. same as senderOrgCode
			cds.setSiteCodeTreatment(formatStr(cds.getCDSSenderOrgCode(), (CDSOutpatientVo.getSiteCodeTreatmentMaxLength())));
			
			cds.setGPCode(formatStr(getGPCode(domPatient.getGp()), CDSOutpatientVo.getGPCodeMaxLength()));
			cds.setPracticeCode(formatStr(getPracticeCode(domPatient.getGpSurgery()), CDSOutpatientVo.getPracticeCodeMaxLength()));
			cds.setPriorityType(formatStr(getExternalMapping(domAppt.getPriority(), "1"), CDSOutpatientVo.getPriorityTypeMaxLength()));  // wdev-9720
			cds.setServiceTypeReq(formatStr("1",CDSOutpatientVo.getServiceTypeReqMaxLength()));  // wdev-9720
			// cds.setServiceTypeReq(formatStr(getNatSpecialtyCode(domRefLet.getService()),CDSOutpatientVo.getServiceTypeReqMaxLength()));
			cds.setReferralSource(formatStr(getExternalMapping(domRefLet.getReferrerType()), CDSOutpatientVo.getReferralSourceMaxLength()));
			cds.setReferralReceivedDate(domRefLet.getDateReferralReceived());
			
			String referrerCode =UNKNOWN_GP;
			if (domRefLet.getReferrerType() != null && domRefLet.getReferrerType().getId() == SourceOfReferral.GP.getId())
				referrerCode = getGPCode(domRefLet.getGPName(), UNKNOWN_GP);
			else
				referrerCode = UNKNOWN_CONSULTANT;
			cds.setReferrerCode(formatStr(referrerCode, CDSOutpatientVo.getReferrerCodeMaxLength()));
			cds.setOrgCodeReferrer(formatStr(getPracticeCode(domRefLet.getPractice()), CDSOutpatientVo.getOrgCodeReferrerMaxLength()));
			
			// Get the Last DNA or Patient Cancelled Date
			cds.setLastDNACancelDate(getDNACancelledDate(factory, domRef));
			
			outpatMap.put(String.valueOf(cds.getAppointmentId()), cds);
		}

		// Now work through the list to save items
		Transaction transaction = factory.beginTransaction();
		int insertCounter=0;
		for (String cds: outpatMap.keySet())
		{
			try
			{
				factory.saveNoFlush((DomainObject) outpatMap.get(cds));
				insertCounter++; 
				if (insertCounter %100 == 0)
				{
					transaction.commit();
					transaction = factory.beginTransaction();
				}
			}
			catch (Exception e) 
			{
				createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.ERROR, "Exception occurred saving CDS record (" + cds + ") - " + e.getMessage());
			}
		}

	
		// Create system log entries
		for (int i=0; i<errorCounter; i++)
		{
			if (errors[i] != null)
				createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, errors[i]);
		}
		
		transaction.commit();
		factory.setTransaction(null); // This will prevent DomainImplProxyHandler attempting to commit again

		LOG.debug("Returning " + insertCounter);
		return insertCounter;
	}

	
	/**
	 * WDEV-13777
	 * Check the OrganisationPCTLinkConfig to see if their is a configured organisation code to be used
	 * if not, return null so that no replacement will take place
	 * @param factory
	 * @param orgCodeCommissioner
	 * @return null for no change, or the configured org code replacement
	 */
	@SuppressWarnings("rawtypes")
	private String getOrgCodeReplacement(DomainFactory factory,	String orgCodeCommissioner) 
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		StringBuffer hql = new StringBuffer();
		hql.append(" from OrganisationPCTLinkConfig cfg where cfg.pctCode = :commissionerCode");
		markers.add("commissionerCode");
		values.add(orgCodeCommissioner);
		
		List lst = factory.find(hql.toString(), markers, values);
		if (lst == null || lst.size() == 0)
			return null;

		return ((OrganisationPCTLinkConfig)lst.get(0)).getOrganisationCode();
	}


	/**
	 * wdev-9484
	 * If this is a nursing clinic i.e. there is a CDS mapping starting with NURSE
	 * return true. Otherwise return false.
	 * @param factory
	 * @param service
	 * @return
	 */
	private boolean isNursingClinic(Service service)
	{
		if (service == null || service.getTaxonomyMap() == null)
			return false;
		
		for (int i=0; i<service.getTaxonomyMap().size(); i++)
		{
			TaxonomyMap map = (TaxonomyMap) service.getTaxonomyMap().get(i);
			if (map.getTaxonomyName().getId() == TaxonomyType.CDS.getID() &&
					map.getTaxonomyCode().startsWith("NURSE"))
			{
				return true;
			}
		}
		
		return false;
	}
	
	
	/**
	 * WDEV-13478 
	 * If this clinic/service is mapped with 'INPATIENT_NO_SFS' , it indicates that it is an inpatient record
	 * without a suitable for surgery record.  It needs to be omitted from Outpatient CDS, and duration of elective
	 * wait etc.. need to be retrieved from elsewhere - e.g. Endoscopy
	 * return true. Otherwise return false.
	 * @param factory
	 * @param service
	 * @return
	 */
	private boolean isInpatientNonSuitableForSurgeryClinic(Service service)
	{
		if (service == null || service.getTaxonomyMap() == null)
			return false;
		
		for (int i=0; i<service.getTaxonomyMap().size(); i++)
		{
			TaxonomyMap map = (TaxonomyMap) service.getTaxonomyMap().get(i);
			if (map.getTaxonomyName().getId() == TaxonomyType.CDS.getID() &&
					map.getTaxonomyCode().startsWith("INPATIENT_NO_SFS"))
			{
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * wdev-9720
	 * If this is a radiology clinic i.e. there is a CDS mapping starting with RADIOLOGY
	 * return true. Otherwise return false.
	 * @param factory
	 * @param service
	 * @return
	 */
	private boolean isRadiologyClinic(Service service)
	{
		if (service == null || service.getTaxonomyMap() == null)
			return false;
		
		for (int i=0; i<service.getTaxonomyMap().size(); i++)
		{
			TaxonomyMap map = (TaxonomyMap) service.getTaxonomyMap().get(i);
			if (map.getTaxonomyName().getId() == TaxonomyType.CDS.getID() &&
					map.getTaxonomyCode().startsWith("RADIOLOGY"))
			{
				return true;
			}
		}
		
		return false;
	}

	// wdev-9484
	// Value 1 if ReferralApptStatus is discharged or referral cancelled by provider
	// Value 2 if another appointment for patient after this appts date
	// Value 3 if no future appointment and not discharged

	private String getAttendanceOutcome(DomainFactory factory,
			Booking_Appointment domAppt, CatsReferral domRef)
	{
		CATSReferralStatus domStat = domRef.getCurrentStatus();
		if (domStat != null && domStat.getReferralStatus() != null &&
				(domStat.getReferralStatus().getId() == ReferralApptStatus.DISCHARGED.getID() ||
				 domStat.getReferralStatus().getId() == ReferralApptStatus.REFERRAL_CANCELLED_BY_PROVIDER.getID()))
		 {
			return "1";
		 }
		
		// Are there other appointments for this patient at a future date
		if (isFutureAppt(factory, domAppt, domRef))
			return "2";
						
		return "3";
	}

	@SuppressWarnings({"unchecked", "rawtypes"})
	private boolean isFutureAppt(DomainFactory factory, Booking_Appointment domAppt, CatsReferral domRef) 
	{

		String hql = " select appts from CatsReferral ref join ref.appointments as appts where appts.appointmentDate > :thisDate and ref = :thisReferral";
		ArrayList<String> paramNames = new ArrayList();
		ArrayList<Object> paramValues = new ArrayList();
		paramNames.add("thisDate");
		paramNames.add("thisReferral");
		paramValues.add(domAppt.getAppointmentDate());
		paramValues.add(domRef);
		
		List<Booking_Appointment> lst = factory.find(hql, paramNames, paramValues);
		if (lst != null && lst.size() > 0)
			return true;  // Future appointment found 
		
		return false;
	}

	// wdev-9484
	private String getFirstAttendanceValue(Activity activity, String defaultVal)
	{
		if (activity == null || activity.getCodeMappings() == null)
			return defaultVal; 
		
		for (int i=0; i<activity.getCodeMappings().size(); i++)
		{
			TaxonomyMap domMap = (TaxonomyMap) activity.getCodeMappings().get(i);
			if (domMap.getTaxonomyName().getId() == TaxonomyType.CDS.getID())
				return domMap.getTaxonomyCode();
		}
		return defaultVal;
	}

	private Date fromPartialDate(Integer val)  
	{
		if (val == null)
			return null;
		
		PartialDate dt = new PartialDate(val);
		if (dt.isDate())
			return dt.toDate().getDate();
		else
		{
			StringBuffer retVal= new StringBuffer();
			if (dt.getYear() != null)
				retVal.append(dt.getYear());
			if (dt.getMonth() != null)
				retVal.append(dt.getMonth());
			else
				retVal.append("1");
			if (dt.getDay() != null)
				retVal.append(dt.getDay());
			else
				retVal.append("1");
			
			try 
			{
				return new ims.framework.utils.Date(retVal.toString(),DateFormat.ISO).getDate();
			} catch (ParseException e)
			{
				super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.ERROR, "ParseException building Date from PartialDate - " + e.getMessage());
				return null;
				
			}
		}
	}

	/**
	 * Looks for a Cancelled or DNA Appointment within the referral
	 * and returns the latest one
	 * @param factory
	 * @param domRef
	 * @return
	 */
	@SuppressWarnings({"rawtypes"})
	private Date getDNACancelledDate(DomainFactory factory, CatsReferral domRef)
	{

		String hql = " select appt from CatsReferral ref join ref.appointments as appt where ref.id = :refId and appt.apptStatus.id in (:dna, :cancelPat) order by appt.appointmentDate desc";
		
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		markers.add("refId");
		markers.add("dna");
		markers.add("cancelPat");
		values.add(domRef.getId());
		values.add(Status_Reason.DNA.getId());
		values.add(Status_Reason.CANCELLED.getId());
		
		List lst = factory.find(hql, markers, values);
		if (lst != null && lst.size() > 0)
		{
			Booking_Appointment domAppt= (Booking_Appointment) lst.get(0);
			return domAppt.getAppointmentDate();
		}
		return null;
	}

	private String getPracticeCode(LocSite gpSurgery)
	{
		if (gpSurgery != null && gpSurgery.getParentOrganisation() != null)
			return this.getPracticeCode(gpSurgery.getParentOrganisation());
		return UNKNOWN_PRACTICE;
	}
	
	private String getPracticeCode(Organisation practice) 
	{
   	    // Practice is parent of surgery
		if (practice != null && practice.getCodeMappings() != null)
		{
			for (int i=0; i<practice.getCodeMappings().size(); i++)
			{
				TaxonomyMap mp = (TaxonomyMap) practice.getCodeMappings().get(i);
				if (mp.getTaxonomyName().getId() == TaxonomyType.NAT_LOC_CODE.getId())
					return mp.getTaxonomyCode();
			}
		}
		return UNKNOWN_PRACTICE;
	}

	private String getGPCode(Gp gp)
	{
		return this.getGPCode(gp, UNKNOWN_GP);
	}
	private String getGPCode(Gp gp, String defaultVal) 
	{
		if (gp != null && gp.getCodeMappings() != null && gp.getCodeMappings().size() > 0)
		{
			for (int i=0; i<gp.getCodeMappings().size(); i++)
			{
				TaxonomyMap mp = (TaxonomyMap) gp.getCodeMappings().get(i);
				if (mp.getTaxonomyName().getId() == TaxonomyType.NAT_GP_CODE.getId())
					return mp.getTaxonomyCode();
			}
		}
		return defaultVal;
	}

	private String getNationalLocCode(Location loc, String defaultSiteCode) 
	{
		if (loc == null || loc.getCodeMappings() == null || loc.getCodeMappings().size() == 0)
			return defaultSiteCode;
		
		for (int i=0; i<loc.getCodeMappings().size(); i++)
		{
			TaxonomyMap mp = (TaxonomyMap) loc.getCodeMappings().get(i);
			if (mp.getTaxonomyName().getId() == TaxonomyType.NAT_LOC_CODE.getId())
				return mp.getTaxonomyCode();
		}
		
		return defaultSiteCode;
	}

	private String getICDCode(Diagnosis primaryDiagnosis) 
	{
		for (int i=0; i<primaryDiagnosis.getTaxonomyMap().size(); i++)
		{
			TaxonomyMap map = (TaxonomyMap) primaryDiagnosis.getTaxonomyMap().get(i);
			if (map.getTaxonomyName().getId() == TaxonomyType.ICD10.getId())
				return map.getTaxonomyCode();
		}
			
		return null;
	}
	
	
	private String getConsMainSpecialty(DomainFactory factory, Hcp hcp)
	{
		if (hcp == null)
			return null;
		Medic domMed = (Medic) factory.getDomainObject(Medic.class, hcp.getId());
		if (domMed != null)
		{
			return getExternalMapping(domMed.getSpecialty(), TaxonomyType.NAT_SPEC_CODE);
		}
		return null;
	}

	private String getNatConsultantCode(Hcp peformedBy) 
	{
		if (peformedBy == null)
			return UNKNOWN_CONSULTANT;
		
		for (int i=0; i<peformedBy.getMos().getCodeMappings().size(); i++)
		{
			TaxonomyMap map = (TaxonomyMap) peformedBy.getMos().getCodeMappings().get(i);
			if (map.getTaxonomyName().getId() == TaxonomyType.NAT_CONS_CODE.getId())
				return map.getTaxonomyCode();
		}

		return UNKNOWN_CONSULTANT;
	}

	private Integer calculateAge(Date appointmentDate, Integer dob)
	{
		if (dob != null)
		{		
			int patAge = 0;
			ims.framework.utils.Date toDt = new ims.framework.utils.Date(appointmentDate);
			if (toDt != null)
			{
				patAge = toDt.yearDiff(new PartialDate(dob));
			}
			return patAge;
		}
		
		return 0;
	}

	private String getNatSpecialtyCode(Service service) 
	{
		if (service == null)
		{
			super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "No Service found for referral");
			return null;
		}
				
		if (service.getTaxonomyMap() == null || service.getTaxonomyMap().size() == 0)
		{
			super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "No TaxonomyTypes found for this service - " + service.getServiceName());
			return null;
		}
		
		for (int i=0; i<service.getTaxonomyMap().size(); i++)
		{
			TaxonomyMap taxMap = (TaxonomyMap) service.getTaxonomyMap().get(i);
			if (taxMap.getTaxonomyName().getId() == TaxonomyType.NAT_SPEC_CODE.getId())
				return taxMap.getTaxonomyCode();
		}
		
		super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "TaxonomyType NAT_SPEC_CODE not found for this service - " + service.getServiceName());
		return null;
	}

	private String getExternalMapping(LookupInstance instance)
	{
		return this.getExternalMapping(instance, TaxonomyType.CDS, " ");
	}
	// Get the external mapping of type CDS for the given LookupInstance
	private String getExternalMapping(LookupInstance instance, String defaultVal)
	{
		return this.getExternalMapping(instance, TaxonomyType.CDS, defaultVal);
	}
	
	private String getExternalMapping(LookupInstance instance, TaxonomyType type)
	{
		return this.getExternalMapping(instance, type, " ");
	}
	
	
	private String getExternalMapping(LookupInstance instance, TaxonomyType type, String defaultVal)
	{
		if (instance == null)
			return defaultVal;
		
		LookupMapping map = instance.getMapping(type.getText());
		if (map != null)
			return map.getExtCode();
		
		return defaultVal;
	}

	private PatientId getNHSNumber(Patient domPatient)
	{
		for (int i=0; i<domPatient.getIdentifiers().size(); i++)
		{
			PatientId id = (PatientId) domPatient.getIdentifiers().get(i);
			if (id.getType().getId() == PatIdType.NHSN.getId())
				return id;
		}
		return null;
	}

	@SuppressWarnings("rawtypes")
	private IntraOperativeCareRecord getIntraCareRecord(DomainFactory factory, CareContext careContext, Date procDate) 
	{
		// Get the first IntraOperative record for the care context
		StringBuffer hql = new StringBuffer(); 
		
		hql.append(" from IntraOperativeCareRecord rec where rec.careContext = :careContext and rec.procedureDate = :procDate");
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		markers.add("careContext");
		markers.add("procDate");
		values.add(careContext);
		values.add(procDate);

		hql.append(" order by rec.procedureDate ");		
		List lst = factory.find(hql.toString(), markers, values);
		if (lst != null && lst.size() > 0)
		{
			for (int i=0; i<lst.size(); i++)
			{
				IntraOperativeCareRecord intraRec =(IntraOperativeCareRecord) lst.get(i);
				if (intraRec.getIsRIE() == null || intraRec.getIsRIE() == false)
					return intraRec;
			}
		}
		
		// Just in case procedure wasn't performed, so date not set, but still want to get access to the record
		hql = new StringBuffer(); 
		hql.append(" from IntraOperativeCareRecord rec where rec.careContext = :careContext");
		markers = new ArrayList<String>();
		values = new ArrayList<Object>();
		markers.add("careContext");
		values.add(careContext);
		
		hql.append(" order by rec.procedureDate ");		
		lst = factory.find(hql.toString(), markers, values);
		if (lst != null && lst.size() > 0)
		{
			for (int i=0; i<lst.size(); i++)
			{
				IntraOperativeCareRecord intraRec =(IntraOperativeCareRecord) lst.get(i);
				if (intraRec.getIsRIE() == null || intraRec.getIsRIE() == false)
					return intraRec;
			}
		}
		return null;
	}

	@SuppressWarnings({"rawtypes"})
	private CatsReferral getCatsReferralFromAppt(DomainFactory factory, Booking_Appointment domAppt)
	{
		String hql = " select ref from CatsReferral ref join ref.appointments as appts where appts.id = :appt";
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		markers.add("appt");
		values.add(domAppt.getId());
		
		List lst = factory.find(hql, markers, values);
		if (lst != null && lst.size() > 0)
			return (CatsReferral) lst.get(0);
		return null;
	}

	
	/**
	* Returns the number of records output
	*/
	public Integer outputCDSData(ims.framework.utils.Date fromDate, ims.framework.utils.Date toDate)
	{
		// TODO: Add your code here and change the return value.
		return null;
	}
	
	private String formatStr(String value, int len)
	{
		return this.formatStr(value, len, " ");
	}
	
	private String formatStr(Integer value, int len)
	{
		return this.formatStr(String.valueOf(value), len, " ");
	}
	
	// wdev-10825 - defaultValue should be specified
	private String formatStr(String value, int len, String defaultValue)  
	{
		 if (value == null)
			 value=defaultValue;
		 
		 // It is already at the correct length
		  if (value.length() == len)
	          return value;

	      // Value is too long, get substring
	      if (value.length() > len)
			  return(value.substring(0, len));

		  // Value is too short, pad with spaces
		  for (int i=value.length(); i<len; i++)
		     value += " ";
		  
		  return value;
	}
	
	private String formatDec(Integer value, int len)
	{
		StringBuffer formatStr = new StringBuffer();
		for (int i=0; i<len; i++)
		{
			formatStr.append("0");
		}
		
		return new java.text.DecimalFormat(formatStr.toString()).format(value);
	}

	@SuppressWarnings({"unchecked", "rawtypes"})
	public Integer generateInpatCDSData(ims.framework.utils.Date fromDate, ims.framework.utils.Date toDate) throws DomainInterfaceException, StaleObjectException 
	{
		DomainFactory factory = getDomainFactory();
		
		String deleteInpatientSql = "delete from core_cdsinpatient where core_cdsinpatient.startdate between ? and ?";//WDEV-13368
		deleteFromTable(deleteInpatientSql, fromDate, toDate);//	WDEV-13368
		
		// WDEV-12877
		String defaultSiteCode = ConfigFlag.DOM.CDS_DEFAULT_SITE_CODE.getValue();
		if (defaultSiteCode == null || defaultSiteCode.equals(""))
			defaultSiteCode="NA";
		defaultSiteCode = formatStr(defaultSiteCode, 5); // Max Length allowed
		
		// wdev-9922 
		// List from ReferralCoding level as won't be progressing without this anyway
		// and it cuts down on any unrequired items.
		
		// List all appointments who's appointment dates are within the given date range
		StringBuffer hql = new StringBuffer();
		hql.append(" select ref from ReferralCoding ref join ref.pasEvent pe where pe.eventType.id = :Inpatient and (pe.isRIE is null or pe.isRIE = 0) and (ref.isRIE is null or ref.isRIE = 0) ");
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		markers.add("Inpatient");
		values.add(PasEventType.INPATIENT.getId());
		
		if (fromDate != null && toDate != null)
		{
			hql.append(" and pe.eventDateTime between :fromDate and :toDate");
			markers.add("fromDate");
			markers.add("toDate");
			values.add(fromDate.getDate());
			values.add(toDate.getDate());
		}
		else if (fromDate != null && toDate == null)
		{
			hql.append(" and pe.eventDateTime >= :fromDate");
			markers.add("fromDate");
			values.add(fromDate.getDate());
		}
		else if (fromDate == null && toDate != null)
		{
			hql.append(" and pe.eventDateTime <= :toDate");
			markers.add("toDate");
			values.add(toDate.getDate());
		}
		
		List lst = factory.find(hql.toString(), markers, values);
		if (lst == null || lst.size() == 0)
			return 0;
		

		Map<String,CDSInpatient> inpatMap = new HashMap<String,CDSInpatient>();
		String[] errors = new String[lst.size()];
		int errorCounter=0;
		// Loop through each result and process for CDS extract
		for (int i=0; i<lst.size(); i++)
		{

			ReferralCoding domRefCode = (ReferralCoding) lst.get(i);
			PASEvent domEvent = domRefCode.getPasEvent();
			
			LOG.debug("Record " + i + " Event " + domEvent.getId());

			// Check if the cds already exists for the unique identifier
			// if it does, update the record
			CDSInpatient cds = CDSInpatient.getCDSInpatientFromPasEventId(factory, domEvent.getId());
			if (cds == null)
				cds= new CDSInpatient();

			cds.setPasEventId(domEvent.getId());
			cds.setCDSSenderOrgCode(defaultSiteCode); // Will be set further down, this is to get over mandatory on intermediate saves
			if (domEvent.getSystemInformation() != null)
			{
				if (domEvent.getSystemInformation().getLastUpdateDateTime() != null)
					cds.setCDSApplicableDate(domEvent.getSystemInformation().getLastUpdateDateTime());
				else
					cds.setCDSApplicableDate(domEvent.getSystemInformation().getCreationDateTime());
			}
			
			String nhsNum="";
			PatientId domPatId = getNHSNumber(domEvent.getPatient());  // Get NHS Number to output as part of system logs
			if (domPatId != null)
				nhsNum = domPatId.getValue();
					
			// Get the CatsReferral 
			CatsReferral domRef = domRefCode.getCatsReferral();
			if (domRef == null)
			{
				factory.evict(cds);
				errors[errorCounter++] ="No Referral Found for ReferralCoding " + domRefCode.getId() + " (" + nhsNum + ")"; 
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "No Referral Found for ReferralCoding " + domRefCode.getId() + " (" + nhsNum + ")");
				continue;
			}
			ReferralLetterDetails domRefLet = domRef.getReferralDetails();
			if (domRefLet == null)
			{
				factory.evict(cds);
				errors[errorCounter++]="No Referral Letter Details Found for Referral " + domRef.getId() + " (" + nhsNum + ")";
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "No Referral Letter Details Found for Referral " + domRef.getId() + " (" + nhsNum + ")");
				continue;
			}
			
			// wdev-9720
			// Exclude Radiology clinics
			if (isRadiologyClinic(domRefLet.getService()))
			{
				factory.evict(cds);
				errors[errorCounter++] ="Radiology Clinic ignored for Referral " + domRef.getId() + " (" + nhsNum + ")"; 
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "Radiology Clinic ignored for Referral " + domRef.getId() + " (" + nhsNum + ")");
				continue;
			}

			AdmissionDetail domAdmission = getAdmissionRecord(factory, domEvent);
			
			// wdev-9720 Reject record if no admission found
			if (domAdmission == null)
			{
				factory.evict(cds);
				errors[errorCounter++] = "No Admission Record found for Referral " + domRef.getId() + " (" + nhsNum + ")";
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "No Admission Record found for Referral " + domRef.getId() + " (" + nhsNum + ")");
				continue;
			}
			
			DischargedEpisode domDisEpis = getDischargeEpisode(factory, domEvent);
			if (domDisEpis == null)
			{
				factory.evict(cds);
				errors[errorCounter++] = "No Discharged Record found for PAS Event" + domEvent.getId() + " (" + nhsNum + ")";
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "No Discharged Record found for PAS Event" + domEvent.getId() + " (" + nhsNum + ")");
				continue;
			}
			
			DischargeSummaryPacuAndWard domDischarge = getDischargeSummaryRecord(factory, domDisEpis);
			if (domDischarge == null)
			{
				factory.evict(cds);
				errors[errorCounter++] = "No Discharged Summary Record found for Discharged Episode " + domDisEpis.getId() + " (" + nhsNum + ")";
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "No Discharged Summary Record found for Discharged Episode " + domDisEpis.getId() + " (" + nhsNum + ")");
				continue;
			}

			IntraOperativeCareRecord domIntraCare = getIntraCareRecordFromRefCode(factory, domRefCode, domAdmission.getAdmissionDateTime(), domDischarge.getDischargeDate());
			// Warning if Intracare not found
			if (domIntraCare == null)
			{
				errors[errorCounter++] ="IntraCareRecord not found for ReferralCoding " + 	domRefCode.getId() + " (" + nhsNum + ")"; 
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "IntraCareRecord not found for ReferralCoding " + 	domRefCode.getId() + " (" + nhsNum + ")");
			}

			// Cross verify that CatsReferral in DischargeSummary is same as that for ReferralCoding
			if (domDischarge.getCatsReferral().getId() != domRefCode.getCatsReferral().getId())
			{
				factory.evict(cds);
				super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.ERROR, "Cross Reference Failure for Event " + domEvent.getId() + " - CatsReferral mismatch between Discharge Summary (" + domDischarge.getId() + ") and ReferralCoding (" + domRefCode.getId() + ")" + " (" + nhsNum + ")");
				continue;
			}
			
			// wdev-11242 - set CareContext from the First Procedure
			cds.setCareContextId(domRef.getCareContext().getId());
			
			if (domRef.getICABReferral() != null && domRef.getICABReferral().getUBRN() != null)
				cds.setUBRN(formatStr(domRef.getICABReferral().getUBRN(), CDSInpatientVo.getUBRNMaxLength()));
			else
				cds.setUBRN(formatStr(" ", CDSInpatientVo.getUBRNMaxLength()));
			cds.setPathwayIdentifier(CONTRACT_CODE + formatDec(domRef.getId(), CDSInpatientVo.getPathwayIdentifierMaxLength()- CONTRACT_CODE.length()));
			cds.setRTTStartDate(domRefLet.getDateOfReferral());
			cds.setLeadCareActInd(" ");
			cds.setReferralToTreatmentStatus(formatStr("30", CDSInpatientVo.getReferralToTreatmentStatusMaxLength())); // Not yet known

			
			// If no IntraOperativeCareRecord, check the referral and use the dischargeDate
			if (domIntraCare != null && domIntraCare.isWasPlannedProcedure() && domIntraCare.getReadmissionType() == null)
			{
				cds.setRTTEndDate(domIntraCare.getProcedureDate());
			}
			else
			{
				if (domDischarge != null && domDischarge.getDischargeDate() != null) 
					cds.setRTTEndDate(domDischarge.getDischargeDate());  // wdev-9720  discharge date from discharge record
			}
			
			Patient domPatient = domRef.getPatient();
			// If this is a dummy patient - we do not want to include it.
			if (domPatient != null && domPatient.getName() != null && domPatient.getName().getSurname().equals("DummyICABSurname"))
			{
				factory.evict(cds);
				errors[errorCounter++] = "DummyICAB Patient Found - will be ignored - " + domPatient.getId() + " (" + nhsNum + ")";
				//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "DummyICAB Patient Found - will be ignored - " + domPatient.getId() + " (" + nhsNum + ")");
				continue;
			}
		
			cds.setLocalPatientIdentifier(formatStr(domPatient.getId(), CDSInpatientVo.getLocalPatientIdentifierMaxLength()));

			if (domPatId != null)
			{
				cds.setNHSNumber(domPatId.getValue());
				if (domPatId.isVerified())
					cds.setNHSNumberStatusInd("01");
				else
					cds.setNHSNumberStatusInd("02");
				cds.setPatientName(formatStr(" ", CDSInpatientVo.getPatientNameMaxLength()));
				cds.setPatientAddress(formatStr(" ", CDSInpatientVo.getPatientAddressMaxLength()));
			}
			else
			{
				cds.setNHSNumber(formatStr(" ", CDSInpatientVo.getNHSNumberMaxLength()));
				cds.setNHSNumberStatusInd("09");  // Not Present
				cds.setPatientName(formatStr(domPatient.getName() == null ? " " : domPatient.getName().toString(), CDSInpatientVo.getPatientNameMaxLength()));
				cds.setPatientAddress(formatStr(domPatient.getAddress() == null ? " " :domPatient.getAddress().toString(), CDSInpatientVo.getPatientAddressMaxLength()));
			}

			cds.setPostCode(formatStr(domPatient.getAddress() == null ? "":domPatient.getAddress().getPostCode(), CDSInpatientVo.getPostCodeMaxLength()));
			if (domPatient.getGpSurgery() != null && domPatient.getGpSurgery().getParentOrganisation() != null 
					&& domPatient.getGpSurgery().getParentOrganisation().getPctCode() != null)
			{
				cds.setPCTOrgCode(formatStr(domPatient.getGpSurgery().getParentOrganisation().getPctCode(), CDSInpatientVo.getPCTOrgCodeMaxLength()));
			}
			else
				cds.setPCTOrgCode(formatStr(domRefLet.getPCT(), CDSInpatientVo.getPCTOrgCodeMaxLength()));
			cds.setDateOfBirth(fromPartialDate(domPatient.getDob()));
			
			String gender =  getExternalMapping(domPatient.getSex());
			if (gender == null)
			{
				if (domPatient.getSex() != null)
				{
					errors[errorCounter++] = "Lookup Mapping of type CDS not found for patient sex = " + domPatient.getSex().getText() + " (" + nhsNum + ")";
					//super.createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, "Lookup Mapping of type CDS not found for patient sex = " + domPatient.getSex().getText() + " (" + nhsNum + ")");
				}
				else
					gender="9";
					
			}
			cds.setPersonGender(formatStr(gender, CDSInpatientVo.getPersonGenderMaxLength()));

			String ethnicOrigin="99";  // Unknown
			if (domPatient.getEthnicOrigin() != null)
			{
				ethnicOrigin = getExternalMapping(domPatient.getEthnicOrigin());
				if (ethnicOrigin == null)
					ethnicOrigin="99";
			}
			cds.setEthnicCategory(formatStr(ethnicOrigin, CDSInpatientVo.getEthnicCategoryMaxLength()));
			cds.setMaritalStatus(formatStr("8", CDSInpatientVo.getMaritalStatusMaxLength()));  // wdev-9720
			
			cds.setAdminCategoryADT(formatStr("01", CDSInpatientVo.getAdminCategoryADTMaxLength()));  // NHS
			// WDEV-15790 - AdminCategory to be retrieved from ReferralCategory associated with referral
			if (domRef != null && domRef.getReferralCategory() != null)
			{
				cds.setAdminCategoryADT(formatStr(getExternalMapping(domRef.getReferralCategory(), "01"),CDSInpatientVo.getAdminCategoryADTMaxLength()));
			}
			
			if (domDischarge.getDischargeDate() != null)
				cds.setPatientClassification(formatStr(getPatientClass(domAdmission.getAdmissionDateTime(), domDischarge.getDischargeDate()), CDSInpatientVo.getPatientClassificationMaxLength()));  
			else
				cds.setPatientClassification(formatStr(getPatientClass(domAdmission.getAdmissionDateTime(), cds.getRTTEndDate()), CDSInpatientVo.getPatientClassificationMaxLength())); 
			cds.setAdminCategoryEPIS(formatStr("01", CDSInpatientVo.getAdminCategoryEPISMaxLength()));  // NHS
			// WDEV-15790 - AdminCategory to be retrieved from ReferralCategory associated with referral
			if (domRef != null && domRef.getReferralCategory() != null)
			{
				cds.setAdminCategoryEPIS(formatStr(getExternalMapping(domRef.getReferralCategory(), "01"),CDSInpatientVo.getAdminCategoryEPISMaxLength()));
			}
			
			if (domAdmission != null)
			{
				cds.setStartDate(domAdmission.getAdmissionDateTime());
				cds.setAge(calculateAge(domAdmission.getAdmissionDateTime(), domPatient.getDob()));
				cds.setProviderSpellNo(formatStr(domAdmission.getId(), CDSInpatientVo.getProviderSpellNoMaxLength()));
				cds.setAdmissionMethod(formatStr(getExternalMapping(domAdmission.getMethodOfAdmission(), "11"), CDSInpatientVo.getAdmissionMethodMaxLength()));  //WDEV-12290  default val was 13 // Booked
				cds.setSourceOfAdmission(formatStr(getExternalMapping(domAdmission.getSourceOfAdmission(), "19"), CDSInpatientVo.getSourceOfAdmissionMaxLength()));
			}
			else
			{
				cds.setStartDate(domEvent.getEventDateTime());
				cds.setAge(calculateAge(domEvent.getEventDateTime(), domPatient.getDob()));
				cds.setProviderSpellNo(formatStr(domEvent.getId(), CDSInpatientVo.getProviderSpellNoMaxLength()));
				cds.setAdmissionMethod(formatStr("28", CDSInpatientVo.getAdmissionMethodMaxLength()));  // Other i.e. unknown in this case  
				cds.setSourceOfAdmission(formatStr("19", CDSInpatientVo.getSourceOfAdmissionMaxLength()));

			}
			cds.setCarerSupportInd(formatStr(" ", CDSInpatientVo.getCarerSupportIndMaxLength()));

			cds.setDischargeDestination(formatStr(" ", CDSInpatientVo.getDischargeDestinationMaxLength()));
			
			if (domDischarge != null)
			{
				cds.setDischargeDate(domDischarge.getDischargeDate());
				cds.setDischargeDestination(formatStr(getExternalMapping(domDischarge.getDischargeType()),CDSInpatientVo.getDischargeDestinationMaxLength()));
				cds.setEpisodeEndDate(domDischarge.getDischargeDate());
			}
			
			// wdev-11242 - calculate the length of stay
			ims.framework.utils.Date stDate = new ims.framework.utils.Date(cds.getStartDate());
			ims.framework.utils.Date dischargeDate=null;
			if (cds.getDischargeDate() != null)
				dischargeDate= new ims.framework.utils.Date(cds.getDischargeDate());
			else
				dischargeDate= new ims.framework.utils.Date(cds.getRTTEndDate());
			long stayDays = ims.framework.utils.Date.daysBetween(stDate, dischargeDate);
			cds.setLengthOfStay(Long.valueOf(stayDays).intValue());
			
			
			
			// wdev-9484
			if (cds.getDischargeMethod() == null || cds.getDischargeMethod().trim().equals(""))
			{
				cds.setDischargeMethod(formatStr("1", CDSInpatientVo.getDischargeMethodMaxLength()));
				// If patient died before discharge, dischargemethod = 4
				if (domPatient.getDod() != null && cds.getEpisodeEndDate() != null &&
												domPatient.getDod().before(cds.getEpisodeEndDate()))
				{
					cds.setDischargeMethod(formatStr("4", CDSInpatientVo.getDischargeMethodMaxLength()));
				}
			}
			
			//cds.setEpisodeNumber(formatStr(domEvent.getId(), CDSInpatientVo.getEpisodeNumberMaxLength()));
			// wdev-10386 - EpisodeNumber should be 01
			cds.setEpisodeNumber(formatStr("01", CDSInpatientVo.getEpisodeNumberMaxLength()));
			cds.setLastEpisodeInd(formatStr("1", CDSInpatientVo.getLastEpisodeIndMaxLength()));
			// Episode Start Date should be take from the admission date
			cds.setEpisodeStartDate(domAdmission.getAdmissionDateTime());

			// 1 One or more operative procedure carried out 
			// 9 Not known i.e. finished episode/out-patient attendance but no data entered or the episode is unfinished and no data needs to be present. This would be a validation error only for a finished episode
			if (domIntraCare != null && domIntraCare.getActualProcedure() != null)
				cds.setOperationStatus(formatStr("1", CDSInpatientVo.getOperationStatusMaxLength()));
			else
				cds.setOperationStatus(formatStr("9", CDSInpatientVo.getOperationStatusMaxLength()));
			
			cds.setNeonatalCareLevel(formatStr(" ", CDSInpatientVo.getNeonatalCareLevelMaxLength()));
			cds.setFirstAdmission(formatStr(" ", CDSInpatientVo.getFirstAdmissionMaxLength()));
			cds.setPsychPatientStatus(formatStr(" ", CDSInpatientVo.getPsychPatientStatusMaxLength()));
			cds.setLegalStatus(formatStr("98", CDSInpatientVo.getLegalStatusMaxLength()));  // wdev-9077 hardcode 98
			cds.setAgeAtCDSActivity(999); //  wdev-9720 default value
			// WDEV-13200 - Age to be calculated from admission date not procedure date
			cds.setAgeAtCDSActivity(calculateAge(cds.getStartDate(), domPatient.getDob()));

			cds.setCCAdmissionSource(formatStr(" ", CDSInpatientVo.getCCAdmissionSourceMaxLength()));
			cds.setCCAdmissionType(formatStr(" ", CDSInpatientVo.getCCAdmissionTypeMaxLength()));
			cds.setCCDischargeDest(formatStr(" ", CDSInpatientVo.getCCDischargeDestMaxLength()));
			cds.setCCDischargeLocation(formatStr(" ", CDSInpatientVo.getCCDischargeLocationMaxLength()));
			cds.setCCDischargeStatus(formatStr(" ", CDSInpatientVo.getCCDischargeStatusMaxLength()));
			cds.setCCLevel2Days(formatStr(" ", CDSInpatientVo.getCCLevel2DaysMaxLength()));
			cds.setCCLevel3Days(formatStr(" ", CDSInpatientVo.getCCLevel3DaysMaxLength()));
			cds.setCCSourceLocation(formatStr(" ", CDSInpatientVo.getCCSourceLocationMaxLength()));
			cds.setCCUnitBedConfiguration(formatStr(" ", CDSInpatientVo.getCCUnitBedConfigurationMaxLength()));
			cds.setProcedureScheme(formatStr("02", CDSInpatientVo.getProcedureSchemeMaxLength()));
			cds.setHrgDominantGrouping(formatStr("3.5", CDSInpatientVo.getHrgDominantGroupingMaxLength()));
			
			
			cds.setAdvRespiratorySupDays(formatStr(" ", CDSInpatientVo.getAdvRespiratorySupDaysMaxLength()));
			cds.setBscRespiratorySupDays(formatStr(" ", CDSInpatientVo.getBscRespiratorySupDaysMaxLength()));
			cds.setAdvCardioSupDays(formatStr(" ", CDSInpatientVo.getAdvCardioSupDaysMaxLength()));
			cds.setBscCardioSupDays(formatStr(" ", CDSInpatientVo.getBscCardioSupDaysMaxLength()));
			cds.setRenalSupportDays(formatStr(" ", CDSInpatientVo.getRenalSupportDaysMaxLength()));
			cds.setNeuroSupportDays(formatStr(" ", CDSInpatientVo.getNeuroSupportDaysMaxLength()));
			cds.setGastroSupportDays(formatStr(" ", CDSInpatientVo.getGastroSupportDaysMaxLength()));
			cds.setDermaSupportDays(formatStr(" ", CDSInpatientVo.getDermaSupportDaysMaxLength()));
			cds.setLiverSupportDays(formatStr(" ", CDSInpatientVo.getLiverSupportDaysMaxLength()));
			cds.setOrganSupportMax(formatStr(" ", CDSInpatientVo.getOrganSupportMaxMaxLength()));
			cds.setDurElectiveWait(formatStr("9998", CDSInpatientVo.getDurElectiveWaitMaxLength()));
			cds.setIntendedManagement(formatStr("8", CDSInpatientVo.getIntendedManagementMaxLength()));
			
			cds.setSerialNumber(formatStr(" ", CDSInpatientVo.getSerialNumberMaxLength()));
			cds.setNHSServiceAgreeNum(formatStr(" ", CDSInpatientVo.getNHSServiceAgreeNumMaxLength()));
			cds.setProviderRefNum(formatStr(" ",CDSInpatientVo.getProviderRefNumMaxLength()));
			cds.setOrgCodeProvider(formatStr(defaultSiteCode, CDSInpatientVo.getOrgCodeProviderMaxLength()));
			
			
			// WDEV-18159
			// ORGANISATION CODE (CODE OF COMMISSIONER) to be determined on the basis of registered GP practice or, where a patient is not registered, their place of residence".
			// If it is then still null, use the referral letter PCT value
			if (domPatient.getGpSurgery() != null && domPatient.getGpSurgery().getParentOrganisation() != null && 
					domPatient.getGpSurgery().getParentOrganisation().getPctCode() != null)
			{
				cds.setOrgCodeCommissioner(formatStr(domPatient.getGpSurgery().getParentOrganisation().getPctCode(), CDSInpatientVo.getOrgCodeCommissionerMaxLength()));
			}
			else if (domPatient.getAddress() != null && domPatient.getAddress().getPCT() != null)
			{
				cds.setOrgCodeCommissioner(formatStr(domPatient.getAddress().getPCT(), CDSInpatientVo.getOrgCodeCommissionerMaxLength()));
			}
			else if (domRefLet != null)
			{
				cds.setOrgCodeCommissioner(formatStr(domRefLet.getPCT(), CDSInpatientVo.getOrgCodeCommissionerMaxLength()));
			}
			else
			{
				cds.setOrgCodeCommissioner(formatStr(" ", CDSInpatientVo.getOrgCodeCommissionerMaxLength()));
			}
			cds.setCommissionerRefNum(formatStr(" ", CDSInpatientVo.getCommissionerRefNumMaxLength()));
			
			cds.setResourceGrpCode(formatStr(" ", CDSInpatientVo.getResourceGrpCodeMaxLength()));
			cds.setResourceGPVersion(formatStr(" ", CDSInpatientVo.getResourceGPVersionMaxLength()));

			String consultantCode=null;
			String mainSpecCode =null;
			if (domAdmission != null)
			{
				consultantCode = getNatConsultantCode(domAdmission.getConsultant());
				// Get consultant's main specialty
				mainSpecCode = getConsMainSpecialty(factory, domAdmission.getConsultant());
			}

			cds.setConsultantCode(formatStr(consultantCode, CDSInpatientVo.getConsultantCodeMaxLength(), UNKNOWN_CONSULTANT));  // wdev-10825	
			cds.setSpecialtyCode(formatStr(mainSpecCode, CDSInpatientVo.getSpecialtyCodeMaxLength()));
			//  WDEV-12292 changed to use referral specialty -- cds.setTreatmentFuncCode(formatStr(getExternalMapping(domAdmission.getSpecialty(), TaxonomyType.NAT_SPEC_CODE), CDSInpatientVo.getTreatmentFuncCodeMaxLength()));
			cds.setTreatmentFuncCode(formatStr(getNatSpecialtyCode(domRefLet.getService()), CDSInpatientVo.getTreatmentFuncCodeMaxLength()));


			// wdev-9077 Get OPCS information from coding items
			PatientProcedure firstProc = null;
			cds.setOPCSProcedureGroup(new java.util.ArrayList());
			cds.setICDDiagnosisGroup(new java.util.ArrayList());
			if (domRefCode == null)
			{
				// Output unknown
				CDSProcedureDetails domProcDet = new CDSProcedureDetails();
				domProcDet.setProcedureScheme("02");  // OPCS-4
				domProcDet.setProcedure(formatStr(NO_PROCEDURE, CDSProcedureDetailsVo.getProcedureMaxLength()));
				cds.getOPCSProcedureGroup().add(domProcDet);
				
			}
			else
			{
				//factory.save(cds);  // Required as for some reason, getSurgeryAssessment was flushing CDS and causing StaleObjectException
				SuitableForSurgeryAssessment domSurgery =null;
				int lastType=0;
				List codeItems = domRefCode.getCodingItems();
				if (codeItems != null && codeItems.size() > 0)
				{
					Date lastProcDate=null;
					for (int x=0; x<codeItems.size(); x++)
					{
						ReferralCodingItem refItem = (ReferralCodingItem) codeItems.get(x);
						if (refItem.getPatientProcedure() != null || (lastType == PROCEDURE_TYPE && refItem.getOPCS4() != null))
						{
							lastType=PROCEDURE_TYPE;
							if (firstProc == null && refItem.getPatientProcedure() != null)
							{
								firstProc = refItem.getPatientProcedure();
								domSurgery= getSurgeryAssessment(factory, firstProc, domAdmission.getAdmissionDateTime());
								cds.setHRGCode(getHrgCode(factory, refItem));  // wdev-11242
							}
							CDSProcedureDetails domProcDet = new CDSProcedureDetails();
							domProcDet.setProcedureScheme("02");  // OPCS-4
							domProcDet.setProcedure(formatStr(refItem.getOPCS4(), CDSProcedureDetailsVo.getProcedureMaxLength()));
							
							if (refItem.getPatientProcedure() != null)
								lastProcDate=fromPartialDate(refItem.getPatientProcedure().getProcDate());
							
							domProcDet.setProcedureDate(lastProcDate);  // wdev-9720
							domProcDet.setLaterality(formatStr(getExternalMapping(refItem.getProcLaterality()), CDSProcedureDetailsVo.getLateralityMaxLength()));
							cds.getOPCSProcedureGroup().add(domProcDet);
						}
						if (refItem.getPatientDiagnosis() != null || (lastType == DIAGNOSIS_TYPE && refItem.getICD10() != null))
						{
							lastType=DIAGNOSIS_TYPE;
							CDSDiagnosisDetails domDiagDet = new CDSDiagnosisDetails();
							domDiagDet.setDiagScheme(formatStr("02", CDSDiagnosisDetailsVo.getDiagSchemeMaxLength()));  // 02=ICD
						
							domDiagDet.setPrimaryDiagnosis(formatStr(refItem.getICD10(), CDSDiagnosisDetailsVo.getPrimaryDiagnosisMaxLength()));
							domDiagDet.setSecondaryDiagnosis(formatStr(" ", CDSDiagnosisDetailsVo.getSecondaryDiagnosisMaxLength()));
						
							cds.getICDDiagnosisGroup().add(domDiagDet);
						}
					}
				}

				if (domSurgery != null)
				{
					// wdev-11317 - Use SuitableForSurgeryDate if value exists
					if (domSurgery.getSuitableForSurgeryDate() != null)
						cds.setDecidedToAdmitDate(domSurgery.getSuitableForSurgeryDate());
					else if (domSurgery.getAuthoringInformation() != null)
						cds.setDecidedToAdmitDate(domSurgery.getAuthoringInformation().getAuthoringDateTime());
					
					cds.setIntendedManagement(formatStr(getExternalMapping(domSurgery.getTheatreType(), "8"), CDSInpatientVo.getIntendedManagementMaxLength()));
					// Difference between decided to admit date and admission date time
					if (cds.getDecidedToAdmitDate() != null && cds.getStartDate() != null)
					{
						ims.framework.utils.Date decideDate = new ims.framework.utils.Date(cds.getDecidedToAdmitDate());
						ims.framework.utils.Date startDate = new ims.framework.utils.Date(cds.getStartDate());
						long dayDiff = ims.framework.utils.Date.daysBetween(decideDate,startDate);
						cds.setDurElectiveWait(formatStr(new Long(dayDiff).intValue(), CDSInpatientVo.getDurElectiveWaitMaxLength()));
						if (dayDiff < 0)  /// wdev-10825
							cds.setDurElectiveWait("9999");
					}
				}
				
				if (firstProc == null && cds.getOPCSProcedureGroup().size() == 0)  // Diagnosis only, output no procedure
				{
					// 	Output unknown
					CDSProcedureDetails domProcDet = new CDSProcedureDetails();
					domProcDet.setProcedureScheme("02");  // OPCS-4
					domProcDet.setProcedure(formatStr(NO_PROCEDURE, CDSProcedureDetailsVo.getProcedureMaxLength()));
					cds.getOPCSProcedureGroup().add(domProcDet);
				}
			}
			
			// WDEV-13478
			// Decided To Admit Date,Duration Of Elective Wait, Intended Management calculated from referral received date
			// for Inpatient non-suitable for surgery clinics
			if (isInpatientNonSuitableForSurgeryClinic(domRefLet.getService()))
			{
				cds.setDecidedToAdmitDate(domRefLet.getDateReferralReceived());
				cds.setIntendedManagement(formatStr(DAY_CASE, CDSInpatientVo.getIntendedManagementMaxLength()));  // Intended Management should always be day case
				// Difference between decided to admit date and admission date time
				if (cds.getDecidedToAdmitDate() != null && cds.getStartDate() != null)
				{
					ims.framework.utils.Date decideDate = new ims.framework.utils.Date(cds.getDecidedToAdmitDate());
					ims.framework.utils.Date startDate = new ims.framework.utils.Date(cds.getStartDate());
					long dayDiff = ims.framework.utils.Date.daysBetween(decideDate,startDate);
					cds.setDurElectiveWait(formatStr(new Long(dayDiff).intValue(), CDSInpatientVo.getDurElectiveWaitMaxLength()));
					if (dayDiff < 0)  /// wdev-10825
						cds.setDurElectiveWait("9999");
				}
			}
			
			// wdev-9077 senderOrgCode is taken from intraoperativeCareRecord from the first procedure
			String orgCode=null;
			if (firstProc != null)
			{
				IntraOperativeCareRecord domIntra =firstProc.getIntraOperativeRecord();
				if (domIntra == null)
					domIntra = getIntraFromProcedure(factory, firstProc, domAdmission.getAdmissionDateTime(), domDischarge.getDischargeDate());
				if (domIntra != null && domIntra.getTheatre() != null)
					orgCode = getNationalLocCode(domIntra.getTheatre().getParentLocation(), defaultSiteCode);
				
				if (domIntra != null && cds.getAgeAtCDSActivity() == 999)
					cds.setAgeAtCDSActivity(calculateAge(domIntraCare.getProcedureDate(), domPatient.getDob()));
				
			}
			
			
			if (orgCode == null) // Null, try the main Intraoperative record for the CareContext
			{
				if (domIntraCare != null && domIntraCare.getTheatre() != null)
					orgCode = getNationalLocCode(domIntraCare.getTheatre().getParentLocation(), defaultSiteCode);
				
			}
			if (orgCode== null)
				orgCode = defaultSiteCode;
			cds.setCDSSenderOrgCode(formatStr(orgCode, CDSInpatientVo.getCDSSenderOrgCodeMaxLength()));
			cds.setPathwayOrgCode(formatStr(cds.getCDSSenderOrgCode(), CDSInpatientVo.getPathwayOrgCodeMaxLength())); // wdev-9077 same as senderOrgCode
			cds.setPatIdOrgCode(formatStr(cds.getCDSSenderOrgCode(), CDSInpatientVo.getCDSSenderOrgCodeMaxLength()));   

			CDSInpatientLocationGroup locGrpStartEpis = new CDSInpatientLocationGroup();
			locGrpStartEpis.setLocationClass(formatStr("01", CDSInpatientLocationGroupVo.getLocationClassMaxLength()));  
			String siteCode = defaultSiteCode; 
			if (domIntraCare != null && domIntraCare.getTheatre().getParentLocation() != null)
			{
				siteCode = getNationalLocCode(domIntraCare.getTheatre().getParentLocation(), defaultSiteCode);
			}
			else if (domIntraCare != null && domIntraCare.getTheatre() != null)
			{
				siteCode = getNationalLocCode(domIntraCare.getTheatre(), defaultSiteCode);
			}
			locGrpStartEpis.setSiteCodeTreatment(formatStr(siteCode, CDSInpatientLocationGroupVo.getSiteCodeTreatmentMaxLength())); 
			cds.setLocationGroupStartEpis(locGrpStartEpis);

			
			cds.setGPCode(formatStr(getGPCode(domPatient.getGp()), CDSInpatientVo.getGPCodeMaxLength()));
			cds.setPracticeCode(formatStr(getPracticeCode(domPatient.getGpSurgery()), CDSInpatientVo.getPracticeCodeMaxLength()));
			
			String referrerCode =UNKNOWN_GP;
			if (domRefLet.getReferrerType().getId() == SourceOfReferral.GP.getId())
				referrerCode = getGPCode(domRefLet.getGPName(), UNKNOWN_GP);
			else
				referrerCode = UNKNOWN_CONSULTANT;
			cds.setReferrerCode(formatStr(referrerCode, CDSInpatientVo.getReferrerCodeMaxLength()));
			cds.setOrgCodeReferrer(formatStr(getPracticeCode(domRefLet.getPractice()), CDSInpatientVo.getOrgCodeReferrerMaxLength()));

			// WDEV-13777  Check if we need to replace organisation code dependant on the OrgCodeCommissioner value
			String replacement = getOrgCodeReplacement(factory, cds.getOrgCodeCommissioner());
			if (replacement != null)
			{
				cds.setOrgCodeProvider(formatStr(replacement, CDSInpatientVo.getOrgCodeProviderMaxLength()));
				cds.setPatIdOrgCode(formatStr(replacement, CDSInpatientVo.getPatIdOrgCodeMaxLength()));
				// This needs to stay as it is 	cds.setPathwayOrgCode(formatStr(replacement, CDSInpatientVo.getPathwayOrgCodeMaxLength())); 
			}
			
			inpatMap.put(String.valueOf(domEvent.getId()), cds);
		}
		
		int insertCounter=0;
		Transaction transaction = factory.beginTransaction();

		// Now work through the list to save items
		for (String cds: inpatMap.keySet())
		{
			try
			{
				factory.saveNoFlush((DomainObject) inpatMap.get(cds));
				insertCounter++;
				if (insertCounter %100 == 0)
				{
					transaction.commit();
					transaction = factory.beginTransaction();
				}

			}
			catch (Exception e) 
			{
				createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.ERROR, "Exception occurred saving CDS record (" + cds + ") - " + e.getMessage());
			}
		}
	
		// Save the errors
		for (int i=0; i<errorCounter; i++)
		{
			if (errors[i] != null)
				createSystemLogEntry(SystemLogType.CDS, SystemLogLevel.WARNING, errors[i]);			
		}
	
		transaction.commit();

		// Remove orphaned detail records
		try 
		{
			transaction = factory.beginTransaction();
			Connection conn = factory.getJdbcConnection();

			Statement stmt = conn.createStatement();
			StringBuffer sqlStr = new StringBuffer();
			sqlStr.append("delete from core_cdsinpatloc where id not in (select locationgr from core_cdsinpatient)");
			stmt.executeUpdate(sqlStr.toString());
			
			stmt.executeUpdate("delete from core_cdsdiagdetail where core_cdsinpatient_icddiagnos is null and core_cdsoutpatient_icddiaggro is null");
			
			stmt.executeUpdate("delete from core_cdsprocdetail where core_cdsinpatient_opcsproced is null and core_cdsoutpatient_opcsproced is null");
			stmt.close();
		
		} 
		catch (SQLException e) 
		{
			e.printStackTrace();
			LOG.error("SQLException occurred deleting orphaned data - " + e.getMessage());
		}
		
		transaction.commit();
		factory.setTransaction(null); // This will prevent DomainImplProxyHandler attempting to commit again
	
		
		// would need to remove orphaned sub records at this point
		LOG.debug("Returning " + insertCounter);
		return insertCounter;
	}

	//	WDEV-13368
	private void deleteFromTable(String deleteSql, ims.framework.utils.Date fromDate, ims.framework.utils.Date toDate) 
	{
		if(deleteSql == null || fromDate == null || toDate == null)
		{
			LOG.error("Cannot delete. Delete SQL is null or From Date is null or To Date is null." );
			return;
		}
		
		try 
		{
			Connection conn = getDomainFactory().getJdbcConnection();
	
			PreparedStatement stmt = conn.prepareStatement(deleteSql);
			stmt.setDate(1, new java.sql.Date(fromDate.getDate().getTime()));
			stmt.setDate(2, new java.sql.Date(toDate.getDate().getTime()));
			stmt.executeUpdate();
			
			stmt.close();
			conn.close();
		} 
		catch (SQLException e) 
		{
			e.printStackTrace();
			LOG.error("SQLException occurred deleting - " + e.getMessage());
		}
	}


	/**
	 * wdev-11242
	 * Get the Configured HRG Code for the given referral coded item
	 * @param factory
	 * @param refItem
	 * @return String hrgCode or null
	 */
	@SuppressWarnings("rawtypes")
	private String getHrgCode(DomainFactory factory, ReferralCodingItem refItem) 
	{
		if (refItem == null || refItem.getOPCS4() == null)
			return null;
		
		String hql = " select hrg from HrgConfig hrg join hrg.mappings mp where mp.taxonomyCode = :opcs and mp.taxonomyName = :taxType";
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		markers.add("opcs");
		values.add(refItem.getOPCS4());
		markers.add("taxType");
		values.add(getDomLookup(TaxonomyType.OPCS4));

		List lst = factory.find(hql, markers, values);
		if (lst != null && lst.size() > 0)
		{
			HrgConfig domHrg = (HrgConfig) lst.get(0);
			return domHrg.getHRGCode();
		}
		
		return null;
	}


	/**
	 * wdev-10370
	 * Return Patient Classification based on the start date and end date - i.e. DayCase or Inpatient
	 * @param startDate
	 * @param endDate
	 * @return
	 */
	private Integer getPatientClass(Date startDate,	Date endDate) 
	{
		if (startDate == null || endDate == null)
			return 1;  // Default
		
		ims.framework.utils.Date fromDt = new ims.framework.utils.Date(startDate);
		ims.framework.utils.Date toDt = new ims.framework.utils.Date(endDate);

		long numDays = ims.framework.utils.Date.daysBetween(fromDt, toDt);
		if (numDays == 0)
			return DAY_CASE;  // Day Case
		
		return ADMISSION;  // Ordinary Admission
	}


	@SuppressWarnings("rawtypes")
	private IntraOperativeCareRecord getIntraCareRecordFromRefCode(DomainFactory factory, ReferralCoding domRefCode, Date admitDate, Date dischargeDate) 
	{
		List lst = domRefCode.getCodingItems();
		if (lst != null && lst.size() > 0)
		{
			for (int i=0; i<lst.size(); i++)
			{
				ReferralCodingItem item = (ReferralCodingItem) lst.get(i);
				if (item != null && item.getPatientProcedure() != null && item.getPatientProcedure().getIntraOperativeRecord() != null)
					return item.getPatientProcedure().getIntraOperativeRecord();
				
				// If intraoperative is null, then see if we can get it the other way around i.e. actual procedure from intraoperative
				if (item != null && item.getPatientProcedure() != null)
				{
					IntraOperativeCareRecord domIntra = getIntraFromProcedure(factory, item.getPatientProcedure(), admitDate, dischargeDate);
					if (domIntra != null)
						return domIntra;
				}
			}
		}
		return null;
	}

	@SuppressWarnings("rawtypes")
	private IntraOperativeCareRecord getIntraFromProcedure(DomainFactory factory, PatientProcedure patientProcedure, Date admitDate, Date dischargeDate)
	{
		StringBuffer hql = new StringBuffer(); 
		
		hql.append(" from IntraOperativeCareRecord rec where (rec.actualProcedure.procedure = :patientProc  or rec.plannedProcedure.procedure = :patientProc ) and (rec.isRIE is null or rec.isRIE = 0)");
		hql.append(" and rec.careContext = :careContext");
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		markers.add("patientProc");
		markers.add("careContext");
		values.add(patientProcedure.getProcedure());
		values.add(patientProcedure.getCareContext());
		
		if (admitDate != null && dischargeDate != null)
		{
			hql.append(" and rec.procedureDate between :dateFrom and :dateTo");
			markers.add("dateFrom");
			markers.add("dateTo");
			values.add(admitDate);
			values.add(dischargeDate);
		}
		
		hql.append(" order by rec.procedureDate ");		
		List lst = factory.find(hql.toString(), markers, values);
		if (lst != null && lst.size() > 0)
			return (IntraOperativeCareRecord) lst.get(0);
		return null;
	}

	@SuppressWarnings("rawtypes")
	private DischargedEpisode getDischargeEpisode(DomainFactory factory, PASEvent domEvent) 
	{
		String hql = " from DischargedEpisode discharge where discharge.pasEvent.id = :domEvent and (discharge.isRIE is null or discharge.isRIE = 0) "; 
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		markers.add("domEvent");
		values.add(domEvent.getId());
		
		List lst = factory.find(hql, markers, values);
		if (lst != null && lst.size() > 0)
			return (DischargedEpisode) lst.get(0);
		return null;
	}

	@SuppressWarnings({"rawtypes"})
	private SuitableForSurgeryAssessment getSurgeryAssessment(DomainFactory factory, PatientProcedure firstProc, Date admissionDateTime) 
	{
		// WDEV-13306, exclude the check for configured procedure not null
		String hql = " select surgery from SuitableForSurgeryAssessment surgery where surgery.careContext = :careContext and surgery.procedure = :firstProc and (surgery.isRIE is null or surgery.isRIE = 0)" +
		   " and surgery.authoringInformation.authoringDateTime < :admissionDT";  // wdev-10682 
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		markers.add("firstProc");

		// WDEV-13200
		// If the firstProc has a planned procedure, match against it, otherwise
		// just match against the firstProc itself.  This is because the suitable for surgery
		// record always has the initial planned procedure.  If this changes, the patient procedure
		// creates a planned procedure and attaches it to the actual one.
		if (firstProc.getPlannedProc() != null)
			values.add(firstProc.getPlannedProc());
		else 
			values.add(firstProc);
		markers.add("careContext");
		values.add(firstProc.getCareContext());
		markers.add("admissionDT");   // wdev-10682
		values.add(admissionDateTime);
		
		List lst = factory.find(hql, markers, values);
		if (lst != null && lst.size() > 0)
			return (SuitableForSurgeryAssessment) lst.get(0);
		return null;
	}

	@SuppressWarnings({"rawtypes"})
	private DischargeSummaryPacuAndWard getDischargeSummaryRecord(DomainFactory factory, DischargedEpisode domDisEpis) 
	{
		String hql = " select discharge from DischargeSummaryPacuAndWard discharge where discharge.dischargeEpisode.id = :dischargeEpisode and discharge.dischargeDate is not null and (discharge.isRIE is null or discharge.isRIE = 0) "; 
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		markers.add("dischargeEpisode");
		values.add(domDisEpis.getId());
		
		List lst = factory.find(hql, markers, values);
		if (lst != null && lst.size() > 0)
			return (DischargeSummaryPacuAndWard) lst.get(0);
		return null;
	}

	@SuppressWarnings({"rawtypes"})
	private AdmissionDetail getAdmissionRecord(DomainFactory factory,PASEvent domEvent) 
	{
		List lst = AdmissionDetail.listAdmissionDetailByPasEvent(factory, domEvent);
		if (lst == null || lst.size() == 0)
			return null;
		return (AdmissionDetail)lst.get(0);
	}

	@SuppressWarnings({"rawtypes"})
	public String[] getSystemReportAndTemplate(Integer imsId)
	{
		String[] result = null;
		
		DomainFactory factory = getDomainFactory();
		
		List lst = factory.find("select r1_1.reportXml, t1_1.templateXml, r1_1.reportName, r1_1.reportDescription, t1_1.name, t1_1.description from ReportBo as r1_1 left join r1_1.templates as t1_1 where (r1_1.imsId= :imsid) order by t1_1.name", new String[] {"imsid"}, new Object[] {imsId});
		
		if(lst.iterator().hasNext())
		{
			Object[] obj = (Object[])lst.iterator().next();
			
			result = new String[] {(String)obj[0], (String)obj[1], (String)obj[2], (String)obj[3], (String)obj[4], (String)obj[5]};
		}
		
		return result;
	}


	@SuppressWarnings({"rawtypes"})
	public String getNationalLocationCode(LocationRefVo refLocation)
	{
		if(refLocation == null || refLocation.getID_Location() == null)
			throw new CodingRuntimeException("NULL value for refLocation param passed down !");

		DomainFactory factory = getDomainFactory();
		
		List lst = factory.find("select t1_1.taxonomyCode from Location as l1_1 left join l1_1.codeMappings as t1_1 left join t1_1.taxonomyName as l2_1	where (l2_1.id = -828 and l1_1.id = (:ID))", new String[] {"ID"}, new Object[] {refLocation.getID_Location()});
		
		if(lst == null || lst.size() == 0)
			return null;
		
		return (String)lst.get(0);
	}


	@SuppressWarnings({"rawtypes"})
	public LocationLiteVoCollection listLocation(String name)
	{
		if(name == null)
			throw new CodingRuntimeException("Can't search for a null string !");
		
		String tmp = name;
		
		if(!tmp.endsWith("%"))
			tmp += "%";
		if(!tmp.startsWith("%"))
			tmp = "%" + tmp;
		
		DomainFactory factory = getDomainFactory();
		
		List lst = factory.find("from Location loc where loc.isActive = 1 and loc.name like :NAME and loc.type.id <> -853 order by loc.name", new String[] {"NAME"}, new Object[] {tmp});

		return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(lst);
	}

	public CDSResultVo buildCDSReport(ims.framework.utils.Date fromDate, ims.framework.utils.Date toDate, String nlc, Integer imsReportId, String sessionId, String requestUrl) throws DomainInterfaceException, StaleObjectException
	{
		StringBuilder sbLog = new StringBuilder(HTML);
		MaxLine maxline = new MaxLine(0);
		int splitDays = ConfigFlag.UI.CDS_REPORTS_SPLIT_INTERVAL_DAYS.getValue();
		ims.framework.utils.DateTime start = new ims.framework.utils.DateTime(fromDate);
		ims.framework.utils.DateTime end;
		boolean overflow = false;
		CDSHistoryVo histVo = new CDSHistoryVo();
		
		CDSResultVo result = new CDSResultVo();
		
		result.setSuccessful(Boolean.FALSE);
		
		sbLog.append("\r\n");
		
		long mili1 = System.currentTimeMillis();
		ims.framework.utils.DateTime date1 = new ims.framework.utils.DateTime();
		
		histVo.setStartDate(fromDate);
		histVo.setEndDate(toDate);
		histVo.setLocation(nlc);
		histVo.setJobStartTime(date1);
		
		if(INPATIENT_REPORT_ID == imsReportId)
			histVo.setReportType(CDSReportType.INPATIENT);
		else if(OUTPATIENT_REPORT_ID == imsReportId)
			histVo.setReportType(CDSReportType.OUTPATIENT);
		else if(HRG_GROUPER_REPORT_ID == imsReportId)
			histVo.setReportType(CDSReportType.HRGGROUPER);
		
		String[] obj = getSystemReportAndTemplate(new Integer(imsReportId));		
		
		if(obj == null || obj.length < 2)
		{
			result.setErrorMessage("I could not get the report and template for imsReportId = " + imsReportId + " !");
			
			saveErrorHistoryEntry(histVo, result);
			
			return result;
		}
		
		if(obj[0] == null || obj[1] == null)
		{
			result.setErrorMessage("The report has not been deployed !");
			
			saveErrorHistoryEntry(histVo, result);
			
			return result;
		}
		
		String urlQueryServer = ConfigFlag.GEN.QUERY_SERVER_URL.getValue();
		String urlReportServer = ConfigFlag.GEN.REPORT_SERVER_URL.getValue();

		QueryBuilderClient client = new QueryBuilderClient(urlQueryServer, sessionId);

		SimpleDateFormat df = new SimpleDateFormat("yyyyMMddHHmmss");
		String folderName = null;
		try
		{
			folderName = getOutputFolder();
		}
		catch (DomainInterfaceException e1)
		{
			e1.printStackTrace();
			result.setErrorMessage(e1.toString());
			
			saveErrorHistoryEntry(histVo, result);
			
			return result;
		}

		int records = 0;
		String info = "";
		Date now = new Date();
		
		String fileName = folderName + (String)obj[4] + "_" + df.format(now) + ".csv"; 
		String zipFileName = folderName + (String)obj[4] + "_" + df.format(now) + ".zip";
		String logFileName = folderName + (String)obj[4] + "_" + df.format(now) + "_log.html";
	
		if(imsReportId == INPATIENT_REPORT_ID)
			info = INPATIENT_REPORT;
		else if(imsReportId == OUTPATIENT_REPORT_ID)
			info = OUTPATIENT_REPORT;
		else if (imsReportId == HRG_GROUPER_REPORT_ID)
			info = HRG_GROUPER_REPORT;
		
		StringBuilder sbOutput = null;
		while(overflow == false)
		{
			end = new ims.framework.utils.DateTime(start.getJavaDate());
			end.addDays(splitDays);
			
			if(end.getDate().isGreaterOrEqualThan(toDate))
			{
				end = new ims.framework.utils.DateTime(toDate);
				overflow = true;
			}
			
			end = end.addSeconds(24*60*60 - 1);
			//
			System.out.print(info + "...processing split [ " + start.toString() + ", " + end.toString() + " ]");
			client.getSeeds().clear();
			
			client.addSeed(new SeedValue("START_DATE", fromDate.getDate(), java.sql.Date.class));
			client.addSeed(new SeedValue("END_DATE", toDate.getDate(), java.sql.Date.class));
			client.addSeed(new SeedValue("NLC", nlc, String.class));
			client.addSeed(new SeedValue("START_SPLIT", start.getJavaDate(), java.util.Date.class));
			client.addSeed(new SeedValue("END_SPLIT", end.getJavaDate(), java.util.Date.class));
			client.addSeed(new SeedValue("TIMESTAMP", df.format(now), String.class));
			
			byte[] reportResult = null;
			try
			{
				long t1 = System.currentTimeMillis(); 
				reportResult = client.buildReport((String)obj[0], (String)obj[1], urlReportServer, "CSV", "", 1);
				long t2 = System.currentTimeMillis();
				
				System.out.print("...buildReport() took " + (t2-t1) + " ms ");
			}
			catch (QueryBuilderClientException e1)
			{
				result.setErrorMessage("Error building the report: " + e1.toString());
				
				saveErrorHistoryEntry(histVo, result);
				
				return result;
			}
			
			try
			{
				if(sbOutput == null)
					sbOutput = new StringBuilder(reportResult.length);
				
				long t1 = System.currentTimeMillis();
				int rec = processCsvFile(info, reportResult, fileName, logFileName, sbOutput, sbLog, maxline, result);
				long t2 = System.currentTimeMillis();
				records += rec;
				
				if(result.getErrorMessageIsNotNull() && result.getErrorMessage().length() > 0)
					return result;
				
				System.out.print("...processCsvFile() took " + (t2-t1) + " ms ");
				
				System.out.println("..." + rec + " record(s)");
			}
			catch (Exception e)
			{
				e.printStackTrace();
				result.setErrorMessage(e.toString());
				
				saveErrorHistoryEntry(histVo, result);
				
				return result;
			}	
			
			//
			
			start = new ims.framework.utils.DateTime(end.getDate());
			start.addDays(1);
			if(start.getDate().isGreaterThan(toDate))
			{
				overflow = true;
			}
		}
		
		if(records > 0)
		{
			try
			{
				byte[] buffer = new byte[1024*64];
				int len;
				FileInputStream in = new FileInputStream(fileName);
				
				ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFileName));
				out.setLevel(Deflater.DEFAULT_COMPRESSION);
				out.putNextEntry(new ZipEntry((String)obj[4] + "_" + df.format(now) + ".csv"));
				
				while ((len = in.read(buffer)) > 0)
				{
					out.write(buffer, 0, len);
				}
				//out.write(sbOutput.toString().getBytes(), 0, sbOutput.length());
				out.closeEntry();
				out.close();
				in.close();
			}
			catch (Exception ioe)
			{
				ioe.printStackTrace();
				result.setErrorMessage("Error creating zip file :" + ioe.toString());
			      
				saveErrorHistoryEntry(histVo, result);
			      
				return result;
			}

			//long mili2 = System.currentTimeMillis();
			
			try
			{
				if(maxline.getRecords() > MAX_RECORDS_LOG)
				{
					appendToFile(logFileName, "<br>");
					appendToFile(logFileName, "Only the first " + MAX_RECORDS_LOG + " records have been displayed in the result window (out of " + maxline.getRecords() + ").");
				}

				/*
				appendToFile(logFileName, "<br>");
				appendToFile(logFileName, "The " + info + " report took " + (mili2 - mili1) + " miliseconds to execute.");
				
				String header = HTML;
				String ml = String.format("%7s", maxline.getMaxline());
				header = header.replaceAll("MAXLINE", ml);
				overWriteTopFile(logFileName, header);
				
				appendToFile(logFileName, "\r\n</body></html>");
				*/
			}
			catch (IOException ioe)
			{
				ioe.printStackTrace();
				result.setErrorMessage("Error writting to log file :" + ioe.toString());
				
				saveErrorHistoryEntry(histVo, result);
				
				return result;
			}
			
			try
			{
				File f = new File(fileName);
				
				if(f.exists())
					f.delete();
			}
			catch(Exception e)
			{
				e.printStackTrace();
			}
			finally
			{
				
			}
			//System.out.println(fileName);
			//System.out.println(engine.getRequestUrl());
			//System.out.println(EnvironmentConfig.getBaseUri());

			result.setResultUrl(requestUrl + "/download/" + (String)obj[4] + "_" + df.format(now) + ".zip");
			//form.htmDownload().setHTML("<b><a style=\"float: right\" href='" + engine.getRequestUrl() + "/download/" + (String)obj[4] + "_" + df.format(now) + ".zip" + "'><font color='blue'>" + (String)obj[4] + "_" + df.format(now) + ".zip" + "</font></a><span style=\"float: right\">Download file:  &nbsp;</span></b>");
			//form.htmDownload().setEnabled(true);
		}
		
		long mili2 = System.currentTimeMillis();
		ims.framework.utils.DateTime date2 = new ims.framework.utils.DateTime();

		try
		{
			if(records == 0)
			{
				appendToFile(logFileName, "<br>");
				appendToFile(logFileName, "The report didn't return any records.");
			}
			else
			{
				appendToFile(logFileName, "<br>");
				appendToFile(logFileName, records + " record(s) returned.");
			}
			
			appendToFile(logFileName, "<br>");
			appendToFile(logFileName, "The " + info + " report took " + (mili2 - mili1) + " miliseconds to execute.");
			
			String header = HTML;
			String ml = String.format("%7s", maxline.getMaxline());
			header = header.replaceAll("MAXLINE", ml);
			overWriteTopFile(logFileName, header);
			
			appendToFile(logFileName, "\r\n</body></html>");
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
			result.setErrorMessage("Error writting to log file :" + ioe.toString());
			
			saveErrorHistoryEntry(histVo, result);
			
			return result;
		}

		result.setLogUrl(requestUrl + "/download/" + (String)obj[4] + "_" + df.format(now) + "_log.html");
		//form.htmResult().setHTML("<IFRAME id=\"ResultFrame123\" name=\"PostFrame\" width=\"100%\" height=\"100%\" frameborder=0 src='" + engine.getRequestUrl() + "/download/" + (String)obj[4] + "_" + df.format(now) + "_log.html" + "'></IFRAME>");
		
		histVo.setFileUrl(result.getResultUrl());
		histVo.setLogUrl(result.getLogUrl());
		histVo.setJobSuccessful(Boolean.TRUE);
		
		saveHistory(histVo);
		
		result.setSuccessful(Boolean.TRUE);
		
		System.out.print(info + "...finished processing.");
		
		return result;
	}


	private void saveErrorHistoryEntry(CDSHistoryVo histVo, CDSResultVo result) throws StaleObjectException
	{
		histVo.setErrorMessage(result.getErrorMessage());
		histVo.setJobSuccessful(Boolean.FALSE);
		saveHistory(histVo);
	}

	
	private int processCsvFile(String info, byte[] doc, String fileName, String fileNameLog, StringBuilder sbOutput, StringBuilder sbLog, MaxLine maxLine, CDSResultVo result) throws IOException
	{
	    String strLine;
	
	    ByteArrayInputStream fstream = new ByteArrayInputStream(doc);
	    DataInputStream in = new DataInputStream(fstream);
	    BufferedReader br = new BufferedReader(new InputStreamReader(in));
	    
	    int recCount = 0;
	    int maxl = maxLine.getMaxline();
	    
	    // Read File Line By Line
	    while ((strLine = br.readLine()) != null)
	    {
	        // Process current line from file
	        if (strLine != null && strLine.trim().length() > 0)
	        {
	        	strLine = strLine.trim();
	        	
	        	if(!(strLine.startsWith("\"") && strLine.endsWith("\"")))
	        	{
	        		appendToFile(fileNameLog, "<br>The line below is not enclosed between double quotes ! Processing aborted.");
	        		appendToFile(fileNameLog, "<br>" + strLine);
	        		
	        		result.setErrorMessage("The input line doesn't have the correct format, see the log file. Processing aborted.");
	        		
	        		return 0;
	        	}
	        	
	        	strLine = strLine.substring(1, strLine.length() - 1);
	        	
	        	if(strLine.length() > maxl)
	        		maxl = strLine.length();
	            
	        	/*
	    		if(sbLog.length() > 0)
	    			sbLog.append("\r\n");
	    		
	    		if(sbOutput.length() > 0)
	    			sbOutput.append("\r\n");
	    			*/
	    		sbOutput.append(strLine);
	    		sbOutput.append("\r\n"); //WDEV-9893
	    		
	    		if(maxLine.getRecords() < MAX_RECORDS_LOG)
	    		{
	        		sbLog.append("<SPAN style=\"background-color:#CCFFCC\">");
	        		sbLog.append(strLine.replaceAll(" ", "&nbsp;"));
	        		sbLog.append("</SPAN><BR>\r\n");
	    		}
	    		
	    		recCount++;
	    		maxLine.incRecords();        		
	    		
	    		if(recCount % BUFFER_LINES == 0)
	    		{
	        		appendToFile(fileNameLog, sbLog.toString());
	        		appendToFile(fileName, sbOutput.toString());
	    			
	        		sbLog.setLength(0);
	        		sbOutput.setLength(0);
	    		}
	        }
	    }
	    
		if(sbLog.length() > 0)
		{
			appendToFile(fileNameLog, sbLog.toString());
			sbLog.setLength(0);			
		}
	
		if(sbOutput.length() > 0)
		{
			appendToFile(fileName, sbOutput.toString());
			sbOutput.setLength(0);
		}
		
		maxLine.setMaxline(maxl);
		
		return recCount;
	}

	private void appendToFile(String fileName, String buffer) throws IOException
	{
		FileOutputStream fos = new FileOutputStream(fileName, true);
		fos.write(buffer.getBytes());
		fos.flush();
		fos.close();
	}
	
	private void overWriteTopFile(String filename, String str) throws IOException
	{
		RandomAccessFile file = new RandomAccessFile(filename, "rw");
		file.seek(0);
		file.write(str.getBytes());
		file.close();		
	}
	
	private String getOutputFolder() throws DomainInterfaceException 
	{
		if ( EnvironmentConfig.getBaseUri() == null || EnvironmentConfig.getBaseUri().length() == 0)
		{
			throw new DomainInterfaceException("EnvironmentConfig.getBaseUri() returned null !");				
		}
		
		String folderName = EnvironmentConfig.getBaseUri() + "download/";				
		File folder = new File(folderName);
		
		if(folder.exists() == false)
		{
			boolean bSuccess = folder.mkdir();
			
			if(bSuccess == false)
				throw new DomainInterfaceException("I could not create the folder '" + folder.getAbsolutePath() + "' !");
		}
		
		return folderName;
	}
	
	private void saveHistory(CDSHistoryVo histVo) throws StaleObjectException
	{
		histVo.setJobEndTime(new DateTime());
		
		if(histVo.getErrorMessageIsNotNull() && histVo.getErrorMessage().length() > histVo.getErrorMessageMaxLength())
		{
			histVo.setErrorMessage(histVo.getErrorMessage().substring(0, histVo.getErrorMessageMaxLength() - 1));	
		}
		
		histVo.validate();
		
		DomainFactory domainFactory = getDomainFactory();
		
		CDSHistory hist = CDSHistoryVoAssembler.extractCDSHistory(domainFactory, histVo);
		
		domainFactory.save(hist);
	}

	private class MaxLine
	{
		private int maxline;
		private int records;
	
		public void incRecords()
		{
			this.records++;
		}
		
		public int getMaxline()
		{
			return maxline;
		}
		
		public int getRecords()
		{
			return records;
		}
	
		public void setMaxline(int maxline)
		{
			this.maxline = maxline;
		}
	
		public MaxLine(int maxline)
		{
			super();
			this.maxline = maxline;
			this.records = 0;
		}
	}
	
}
