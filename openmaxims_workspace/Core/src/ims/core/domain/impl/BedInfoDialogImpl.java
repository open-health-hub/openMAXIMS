//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.66 build 3271.26979)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.core.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.ReferralEROD;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.domain.objects.TCIOutcomeForPatientElectiveList;
import ims.RefMan.vo.PatientElectiveListBedAdmissionVo;
import ims.RefMan.vo.PatientElectiveListBedAdmissionVoCollection;
import ims.RefMan.vo.PatientElectiveListRefVo;
import ims.RefMan.vo.domain.PatientElectiveListBedAdmissionVoAssembler;
import ims.RefMan.vo.lookups.AdmissionOfferOutcome;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.clinical.vo.InpatientEpisodeForVTERiskAsessmentVo;
import ims.clinical.vo.VTERiskAssessmentShortVo;
import ims.clinical.vo.VTERiskAssessmentShortVoCollection;
import ims.clinical.vo.domain.InpatientEpisodeForVTERiskAsessmentVoAssembler;
import ims.clinical.vo.domain.VTERiskAssessmentShortVoAssembler;
import ims.configuration.InitConfig;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.domain.objects.CareContextStatusHistory;
import ims.core.admin.pas.domain.objects.AdmissionDetail;
import ims.core.admin.pas.domain.objects.BedSpaceState;
import ims.core.admin.pas.domain.objects.BedSpaceStateStatus;
import ims.core.admin.pas.domain.objects.ConsultantStay;
import ims.core.admin.pas.domain.objects.DischargedEpisode;
import ims.core.admin.pas.domain.objects.HomeLeave;
import ims.core.admin.pas.domain.objects.InpatientEpisode;
import ims.core.admin.pas.domain.objects.PASEvent;
import ims.core.admin.pas.domain.objects.PendingTransfers;
import ims.core.admin.pas.domain.objects.TransferHistory;
import ims.core.admin.pas.domain.objects.WardStay;
import ims.core.admin.pas.vo.BedSpaceStateRefVo;
import ims.core.admin.pas.vo.BedSpaceStateStatusRefVo;
import ims.core.admin.pas.vo.DischargedEpisodeRefVo;
import ims.core.admin.pas.vo.InpatientEpisodeRefVo;
import ims.core.admin.pas.vo.PASEventRefVo;
import ims.core.admin.pas.vo.PendingTransfersRefVo;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.admin.vo.EpisodeOfCareRefVo;
import ims.core.clinical.domain.objects.TaxonomyMap;
import ims.core.clinical.domain.objects.VTERiskAssessment;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.clinical.vo.VTERiskAssessmentRefVo;
import ims.core.configuration.domain.objects.AppUser;
import ims.core.configuration.vo.AppUserRefVo;
import ims.core.domain.Alerts;
import ims.core.domain.BedAdmissionComponent;
import ims.core.domain.BedInfoDialog;
import ims.core.domain.WardView;
import ims.core.helper.DTOHelper;
import ims.core.helper.IPathwayPatientEventHelper;
import ims.core.patient.domain.objects.Patient;
import ims.core.patient.domain.objects.PatientId;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.Medic;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.AdmissionDetailVo;
import ims.core.vo.BedSpaceStateLiteVo;
import ims.core.vo.BedSpaceStateStatusVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.DischargedEpisodeADTVo;
import ims.core.vo.DischargedEpisodeADTVoCollection;
import ims.core.vo.DischargedEpisodeForVTERiskAssessmentWorklistVo;
import ims.core.vo.HomeLeaveVo;
import ims.core.vo.InPatientEpisodeADTVo;
import ims.core.vo.InpatConsultantTransferVo;
import ims.core.vo.InpatientEpisodeLiteVo;
import ims.core.vo.InpatientEpisodeLiteVoCollection;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.MemberOfStaffShortVo;
import ims.core.vo.PatientShortCollection;
import ims.core.vo.PendingTransfersLiteVo;
import ims.core.vo.VTERiskAssessmentWorklistVo;
import ims.core.vo.domain.BedSpaceStateLiteVoAssembler;
import ims.core.vo.domain.BedSpaceStateStatusVoAssembler;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.DischargedEpisodeADTVoAssembler;
import ims.core.vo.domain.DischargedEpisodeForVTERiskAssessmentWorklistVoAssembler;
import ims.core.vo.domain.HomeLeaveVoAssembler;
import ims.core.vo.domain.InPatientEpisodeADTVoAssembler;
import ims.core.vo.domain.InpatConsultantTransferVoAssembler;
import ims.core.vo.domain.InpatientEpisodeLiteVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffShortVoAssembler;
import ims.core.vo.domain.PatientAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.domain.PendingTransfersLiteVoAssembler;
import ims.core.vo.domain.VTERiskAssessmentWorklistVoAssembler;
import ims.core.vo.lookups.BedStatus;
import ims.core.vo.lookups.CareContextStatus;
import ims.core.vo.lookups.ContextType;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.PASSpecialty;
import ims.core.vo.lookups.PASSpecialtyCollection;
import ims.core.vo.lookups.PatIdType;
import ims.core.vo.lookups.ReasonForBedClosure;
import ims.core.vo.lookups.Sex;
import ims.core.vo.lookups.Specialty;
import ims.core.vo.lookups.SpecialtyCollection;
import ims.core.vo.lookups.TaxonomyType;
import ims.core.vo.lookups.WaitingListStatus;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DTODomainInterfaceException;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.dto.DTODomainImplementation;
import ims.dto.Result;
import ims.dto.ResultException;
import ims.dto.client.Homeleave;
import ims.dto.client.Inpat;
import ims.dto.client.Homeleave.HomeleaveRecord;
import ims.dto.client.Inpat.InpatRecord;
import ims.emergency.vo.lookups.ElectiveListReason;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.ILocation;
import ims.framework.utils.DateTime;
import ims.framework.utils.DateTimeFormat;
import ims.framework.utils.TimeFormat;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.domain.objects.PathwayRTTStatus;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.scheduling.domain.objects.Appointment_Status;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.vo.interfaces.IMos;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

import org.apache.log4j.Logger;

public class BedInfoDialogImpl extends DTODomainImplementation implements BedInfoDialog
{
	private static final Object	PATIENTDIED	= "4";
	private static final String	STILLBIRTH	= "5";
	
	private static final int TRANSFERIN = 1;
	private static final int TRANSFEROUT = 2;
	private static final int TRANSFERCANCEL = 3;
	private static final int START_OF_FIRST_DEFINITIVE_TREATMENT = 30;
	
	
	private static final Logger LOG	= Logger.getLogger(BedInfoDialogImpl.class);
	private static final long serialVersionUID = 1L;

	public boolean dtoOnly()
	{
		return InitConfig.getConfigType().equals("DTO");
	}

	public Class getLookupServiceClass()
	{
		return ims.domain.lookups.impl.LookupServiceImpl.class;
	}
	/**
	* getPatient
	*/
	public ims.core.vo.Patient getPatient(ims.core.patient.vo.PatientRefVo patient)
	{
		if(patient == null || patient.getID_Patient() == null)
			throw new CodingRuntimeException("patient os null or id not provided for method getPatient");
		
		return PatientAssembler.create((Patient) getDomainFactory().getDomainObject(patient)); 
	}

	/**
	 * 1)send ADT Transfer
	 * 2)Get Current Bed and set to Available and null Inpatient Episode
	 * 3)save InpatientEpisode record with new ward stay record and referncing new bed & status
	 * 4)delete PendingTransfer record
	 */
	public CareContextShortVo saveTransferIn(BedSpaceStateLiteVo voOldBedSpaceStateLite, InPatientEpisodeADTVo inpatientEpisode, PendingTransfersLiteVo voTransfer, HomeLeaveVo voHL) throws DomainInterfaceException, StaleObjectException 
	{
		if(inpatientEpisode == null)
			throw new CodingRuntimeException("inpatientEpisode is null in method saveTransfer");
		if(!inpatientEpisode.isValidated())
			throw new CodingRuntimeException("inpatientEpisode has not been validated in method saveTransfer");
		
		if(voTransfer == null || voTransfer.getID_PendingTransfers() == null)
			throw new CodingRuntimeException("voTransfer is null or id not provide for delete in method saveTransferIn");
		
		
		DomainFactory factory = getDomainFactory();
		
		//1)
		Inpat inpatRec = null;
		Result res = null;
		if (Boolean.FALSE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
		{
			inpatRec = (Inpat)getDTOInstance(Inpat.class);
			inpatRec.DataCollection.add();
		}
		
		//WDEV-8164 - Consultant Transfers - if the consultant has changed
		InpatientEpisode doInpat = addConsultantStayIfNeeded(inpatientEpisode);
		
		//WDEV-8403 update the patient's ward
		if(doInpat.getPasEvent() != null && doInpat.getPasEvent().getPatient() != null)
		{
			doInpat.getPasEvent().getPatient().setWard(doInpat.getPasEvent().getLocation());
			// WDEV-17867 - Set Current Responsible Clinician to Patient record
			doInpat.getPasEvent().getPatient().setCurrentResponsibleConsultant(doInpat.getPasEvent().getConsultant());
		}
		

		if (Boolean.FALSE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
		{
			if (inpatientEpisode.getUpdateCaseFolderIsNotNull()
					&& inpatientEpisode.getUpdateCaseFolder())
				copyInpatEpisodeToDtoForTransfer(inpatRec, doInpat, false, true, inpatientEpisode.getCaseFolderComments());
			else
				copyInpatEpisodeToDtoForTransfer(inpatRec, doInpat, false, false, null);

			res = inpatRec.executeAction("TRANSFER");
			if (res != null && res.getId() != 0)
				throw new DTODomainInterfaceException(res.getId(), "Error occurred Transferring Patient on PAS " + res.getMessage());
		}
	
		//2)
		if(voOldBedSpaceStateLite != null)
		{
			BedSpaceState doBed = BedSpaceStateLiteVoAssembler.extractBedSpaceState(factory, voOldBedSpaceStateLite);
			factory.save(doBed);
		}
		//wdev-13509
		doInpat.setIsOnHomeLeave(false);
		doInpat.setDateOnHomeLeave(null);
		doInpat.setTimeOnHomeLeave(null);
		doInpat.setExpectedDateOfReturn(null);
		doInpat.setExpectedTimeOfReturn(null);
		doInpat.setVacatedBedNumber(null);
		
		//3)
		factory.save(doInpat);

		Location destWard = null;
		AdmissionDetail doAdmissionDetail = null;
		try
		{
			PendingTransfers doPending = (PendingTransfers) factory.getDomainObject(voTransfer);	
			
			if (doPending != null)
			{
				//WDEV-10421 - get the admission detail record and update its history for transfers
				doAdmissionDetail = populateTransferHistory(doPending, TRANSFERIN, null);
				
				destWard = doPending.getDestinationWard();
				//4
				factory.delete(doPending);
			}
			else
				throw new StaleObjectException(doPending, ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue());
		}
		catch (ForeignKeyViolationException e)
		{
			throw new DomainInterfaceException("Data Constraint : PendingTransfers record could not be deleted", e);
		}
		
		//wdev-13509
		if (voHL != null
			&& Boolean.FALSE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
		{
			//UPDATE PAS THAT NO LONGER ON HOME LEAVE 
			Homeleave hlRec = (Homeleave)getDTOInstance(Homeleave.class);
			hlRec.DataCollection.add();

			copyHomeLeaveToDto(hlRec, doAdmissionDetail, voHL);
			
			res = hlRec.update();
			if (res != null && res.getId() < 0 )
			{
				if (res.getId() == -5)
					throw new DomainInterfaceException("Error occurred saving Home Leave record to PAS " + res.getMessage());
				else 
					throw new DTODomainInterfaceException(res.getId(), "Error occurred saving Home Leave record to PAS " + res.getMessage());	
			}
		}

		//WDEV-8315,WDEV-10421
		if(doAdmissionDetail != null)
		{
			if(destWard != null)
				doAdmissionDetail.setWard(destWard);
			if(doInpat.getBed() != null)
				doAdmissionDetail.setBed(doInpat.getBed().getBedSpace());
			factory.save(doAdmissionDetail);
		}
		
		//WDEV-11438 - update the CareContext with the EDD
		WardView impl = (WardView) getDomainImpl(WardViewImpl.class);
		CareContextShortVo voCareContext = impl.getCareContextForPasEvent(inpatientEpisode.getPasEvent());
		if(voCareContext != null)
		{
			voCareContext.setEstimatedDischargeDate(inpatientEpisode.getEstDischargeDate());
			CareContext doCareContext = CareContextShortVoAssembler.extractCareContext(factory, voCareContext);
			//WDEV-11479
			if(doInpat != null && doInpat.getPasEvent() != null && doCareContext.getEpisodeOfCare() != null) 
			{
				doCareContext.setResponsibleHCP(doInpat.getPasEvent().getConsultant());
				if(!ConfigFlag.DOM.ADT_LINK_ADMISSION_TO_EPISODE.getValue()) //wdev-14309
				{
					doCareContext.getEpisodeOfCare().setResponsibleHCP(doInpat.getPasEvent().getConsultant());
					doCareContext.getEpisodeOfCare().setSpecialty(doInpat.getPasEvent().getSpecialty());	//	WDEV-12771
				}
			}				
		
			factory.save(doCareContext);
			return CareContextShortVoAssembler.create(doCareContext);
		}
		
		return null;
	}

	/**
	 * @method addConsultantStayIfNeeded
	 * @comment does InpatientAssembler call also - MUST BE CALLED
	 * 
	 */
	private InpatientEpisode addConsultantStayIfNeeded(InPatientEpisodeADTVo inpatientEpisode)
	{
		if(inpatientEpisode == null)
			throw new CodingRuntimeException("inpatientEpisode is null in method addConsultantStayIfNeeded"); 
			
		DomainFactory factory = getDomainFactory();
		Medic doExistingCons = null;
		if(inpatientEpisode.getPasEventIsNotNull() && inpatientEpisode.getPasEvent().getBoId() != null)
		{
			PASEvent doExistingPe = (PASEvent)factory.getDomainObject(PASEvent.class, inpatientEpisode.getPasEvent().getBoId());
			doExistingCons = doExistingPe != null ? doExistingPe.getConsultant() : null;
		}
		
		InpatientEpisode doInpat = InPatientEpisodeADTVoAssembler.extractInpatientEpisode(factory, inpatientEpisode);
		
		if(inpatientEpisode.getPasEventIsNotNull() && inpatientEpisode.getPasEvent().getConsultantIsNotNull())
		{
			if(doExistingCons != null)
			{
				if(!doInpat.getPasEvent().getConsultant().equals(doExistingCons))
				{
					ConsultantStay doConsStay = new ConsultantStay();
					doConsStay.setConsultant(doInpat.getPasEvent().getConsultant());
					doConsStay.setTransferDateTime(getMostRecentWardStayTransferDate(doInpat));
					doInpat.getConsultantStays().add(doConsStay);
				}
			}	
		}
		return doInpat;
	}

	private void copyInpatEpisodeToDtoForTransfer(Inpat inpatRec, InpatientEpisode inpatientEpisode, boolean isConsultantTransfer, boolean isUpdateFolder, String szCaseFolderComment)
	{
		InpatRecord rec = inpatRec.DataCollection.get(0);
		
		//WDEV-8238
		inpatRec.EditFilter.excludeAll();
		inpatRec.EditFilter.IncludeHospnum = true;
		inpatRec.EditFilter.IncludeHcpcode = true;
		inpatRec.EditFilter.IncludeSpcd = true;
		inpatRec.EditFilter.IncludeRescode = true;
		inpatRec.EditFilter.IncludeMors = true;
		inpatRec.EditFilter.IncludeLtdt = true;
		inpatRec.EditFilter.IncludeLttm = true;
		inpatRec.EditFilter.IncludeEddt = true;
		inpatRec.EditFilter.IncludeCflup = true;
		inpatRec.EditFilter.IncludeWebadt = true;
		inpatRec.EditFilter.IncludeBtyp = true; //WDEV-10965
		
		rec.Hospnum = getPatientIdValue(inpatientEpisode, PatIdType.HOSPNUM);
		if(inpatientEpisode.getPasEvent() != null)
			rec.Hcpcode = getPasMapping(inpatientEpisode.getPasEvent().getConsultant());
		if(inpatientEpisode.getPasEvent() != null)
			rec.Spcd = DTOHelper.getPasMapping(inpatientEpisode.getPasEvent().getSpecialty());
		
		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO")
			&& inpatientEpisode.getPasEvent() != null
			&& inpatientEpisode.getPasEvent().getPASSpecialty() != null)
			rec.Spcd = DTOHelper.getPasMapping(inpatientEpisode.getPasEvent().getPASSpecialty());

		rec.Rescode = inpatientEpisode.getPasEvent() != null && inpatientEpisode.getPasEvent().getLocation() != null ? inpatientEpisode.getPasEvent().getLocation().getExtCode(TaxonomyType.PAS.getID()) : null;
		rec.Mors = DTOHelper.getPasMapping(inpatientEpisode.getWardType());
		
		if(isConsultantTransfer)
		{
			Date consDate = getMostRecentConsultantStayTransferDate(inpatientEpisode);
			if(consDate != null)
			{
				rec.Ltdt = DTOHelper.convertToDtoDate(consDate);
				rec.Lttm = DTOHelper.convertToDtoTime(consDate);	
			}
		}
		else
		{
			Date transDate = getMostRecentWardStayTransferDate(inpatientEpisode);
			if(transDate != null)
			{
				rec.Ltdt = DTOHelper.convertToDtoDate(transDate);
				rec.Lttm = DTOHelper.convertToDtoTime(transDate);
			}
		}
		
		if(inpatientEpisode.getEstDischargeDate() != null)
			rec.Eddt = DTOHelper.convertToDtoDate(inpatientEpisode.getEstDischargeDate());
	
		rec.Cflup = "N";	
		//WDEV-12957/wdev-13402
		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO") && isUpdateFolder)
		{
			rec.Cflup = "Y"; 
			
			inpatRec.EditFilter.IncludeCfl = true;
			inpatRec.EditFilter.IncludeCflcomm = true;
			
			rec.Cfl = rec.Rescode;
			rec.Cflcomm = szCaseFolderComment;
		}

		//WDEV-10965 - interim solution
		if(rec.Mors != null)
		{
			if(rec.Mors.equals("M"))
			{
				if(inpatientEpisode.getPasEvent().getPatient().getSex() != null)
				{
					if(inpatientEpisode.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.MALE)))
						rec.Btyp = "M";
					else if(inpatientEpisode.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.FEMALE)))
						rec.Btyp = "F";
					else
						//defaulting Male for unknown sex
						rec.Btyp = "M";
				}
				else
					//defaulting Male for unknown sex
					rec.Btyp = "M";	
			}
			else if(rec.Mors.equals("S"))
				rec.Btyp = "S";
		}
		
		//WDEV-7827
		rec.Webadt = "Y";				
	}
	


	private Date getMostRecentConsultantStayTransferDate(InpatientEpisode inpatientEpisode)
	{
		if(inpatientEpisode == null)
			throw new CodingRuntimeException("inpatientEpisode is null in method getMostRecentConsultantStayTransferDate");
		
		Date transferDate = null;
		if(inpatientEpisode.getConsultantStays() != null && inpatientEpisode.getConsultantStays().size() > 0)
		{
			Iterator it = inpatientEpisode.getConsultantStays().iterator();
			while(it.hasNext())
			{	
				ConsultantStay consStay = (ConsultantStay)it.next();
				if(consStay.getTransferDateTime() != null)
				{
					if(transferDate == null || transferDate.before(consStay.getTransferDateTime()))
						transferDate = consStay.getTransferDateTime();
				}
			}
		}			
			
		return transferDate;
	}

	private void copyToDtoForDischarge(Inpat inpatRec, InpatientEpisode inpatientEpisode, DischargedEpisode doDisch)
	{
		//WDEV-9644
		inpatRec.EditFilter.excludeAll();
		inpatRec.EditFilter.IncludeHospnum = true;
		inpatRec.EditFilter.IncludeRescode = true;
		inpatRec.EditFilter.IncludeMors = true;
		inpatRec.EditFilter.IncludeLttm = true;
		inpatRec.EditFilter.IncludeWebadt = true;
		inpatRec.EditFilter.IncludeDsmt = true;
		inpatRec.EditFilter.IncludeDsds = true;
		inpatRec.EditFilter.IncludeRrea = true;
		
		InpatRecord rec = inpatRec.DataCollection.get(0); 
		
		rec.Hospnum = getPatientIdValue(inpatientEpisode, PatIdType.HOSPNUM);
		if(inpatientEpisode.getPasEvent() != null)
		{
			inpatRec.EditFilter.IncludeHcpcode = true;
			rec.Hcpcode = getPasMapping(inpatientEpisode.getPasEvent().getConsultant());
		}
		if(inpatientEpisode.getPasEvent() != null)
		{
			inpatRec.EditFilter.IncludeSpcd = true;
			rec.Spcd = DTOHelper.getPasMapping(inpatientEpisode.getPasEvent().getSpecialty());
			if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO")
				&& inpatientEpisode.getPasEvent() != null
				&& inpatientEpisode.getPasEvent().getPASSpecialty() != null)
				rec.Spcd = DTOHelper.getPasMapping(inpatientEpisode.getPasEvent().getPASSpecialty()); //wdev-15724
		}

		rec.Rescode = inpatientEpisode.getPasEvent() != null && inpatientEpisode.getPasEvent().getLocation() != null ? inpatientEpisode.getPasEvent().getLocation().getExtCode(TaxonomyType.PAS.getID()) : null;
		rec.Mors = DTOHelper.getPasMapping(inpatientEpisode.getWardType());
		Date recentDt = getMostRecentWardStayTransferDate(inpatientEpisode);
		if(recentDt != null)
		{
			inpatRec.EditFilter.IncludeLtdt = true;
			rec.Ltdt = DTOHelper.convertToDtoDate(recentDt);
		}
		if(inpatientEpisode.getAdmissionDateTime() != null)
		{
			inpatRec.EditFilter.IncludeLttm = true;
			rec.Lttm = DTOHelper.convertToDtoTime(inpatientEpisode.getAdmissionDateTime());
		}
		//WDEV-7827
		rec.Webadt = "Y";				
	
		rec.Dsmt = DTOHelper.getPasMapping(doDisch.getMethodOfDischarge());
		rec.Dsds = DTOHelper.getPasMapping(doDisch.getDischargeDestination());
		
		//WDEV
		if(doDisch.getDischargeDateTime() != null)
		{
			inpatRec.EditFilter.IncludeEpen = true;
			inpatRec.EditFilter.IncludeEetm = true;
			
			rec.Epen = DTOHelper.convertToDtoDate(doDisch.getDischargeDateTime());
			rec.Eetm = DTOHelper.convertToDtoTime(doDisch.getDischargeDateTime());
		}
		
		rec.Rrea = DTOHelper.getPasMapping(doDisch.getTreatmentDeferredReason());
		
		if(doDisch.isEighteenWeekClockStopped() != null)
		{
			inpatRec.EditFilter.IncludeRttstop = true;
			rec.Rttstop = doDisch.isEighteenWeekClockStopped() ? "Y" : "N";
		}
	}
	
	private Date getMostRecentWardStayTransferDate(InpatientEpisode inpatientEpisode)
	{
		if(inpatientEpisode == null)
			throw new CodingRuntimeException("inpatientEpisode is null in method getMostRecentWardStayTransferDate");

		Date transferDate = null;
		if(inpatientEpisode.getWardStays() != null && inpatientEpisode.getWardStays().size() > 0)
		{
			Iterator it = inpatientEpisode.getWardStays().iterator();
			while(it.hasNext())
			{	
				WardStay wardStay = (WardStay)it.next();
				//**********************************************
				if(wardStay == null || wardStay.getTransferDateTime()== null)
				   continue;
				//**********************************************
				if(transferDate == null || transferDate.before(wardStay.getTransferDateTime()))
					transferDate = wardStay.getTransferDateTime();
			}
		}			
			
		return transferDate;
	}

	private String getPasMapping(Medic consultant) 
	{
		if(consultant == null || consultant.getMos() == null || consultant.getMos().getCodeMappings() == null || consultant.getMos().getCodeMappings().size() == 0)
			return null;
		
		Iterator it = consultant.getMos().getCodeMappings().iterator();
		while(it.hasNext())
		{
			TaxonomyMap map = (TaxonomyMap) it.next();
			if(map.getTaxonomyName().equals(getDomLookup(TaxonomyType.PAS)))
				return map.getTaxonomyCode();
		}
		
		return null;
	}

	private String getPatientIdValue(InpatientEpisode doInpatientEpisode, PatIdType type) 
	{
		if(doInpatientEpisode == null)
			return null;
		
		if(doInpatientEpisode.getPasEvent() != null && doInpatientEpisode.getPasEvent().getPatient() != null && doInpatientEpisode.getPasEvent().getPatient().getIdentifiers() != null)
		{
			Iterator it = doInpatientEpisode.getPasEvent().getPatient().getIdentifiers().iterator();
			while(it.hasNext())
			{
				PatientId patId = (PatientId) it.next();
				if(patId.getType().equals( getDomLookup(type)))
					return patId.getValue();
			}
		}
		
		return null;
	}

	public InPatientEpisodeADTVo getInpatientEpisode(InpatientEpisodeRefVo inpatientEpisode)
	{
		if(inpatientEpisode == null || inpatientEpisode.getID_InpatientEpisode() == null)
			throw new CodingRuntimeException("inpatientEpisode is null or id not provided for getInpatientEpisode");
		
		return InPatientEpisodeADTVoAssembler.create( (InpatientEpisode) getDomainFactory().getDomainObject(inpatientEpisode));
	}

	public LocationLiteVoCollection listActiveHospitalsLite()
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveHospitalsLite();
	}

	public LocationLiteVoCollection listActiveWardsForHospitalLite(LocationRefVo hospital)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveWardsForHospitalLite(hospital);
	}

	public void saveTransferOut(PendingTransfersLiteVo pendingTransfer) throws StaleObjectException, DomainInterfaceException
	{
		if(pendingTransfer == null)
			throw new CodingRuntimeException("pendingTransfer is null in method saveTransferOut");
		if(!pendingTransfer.isValidated())
			throw new CodingRuntimeException("pendingTransfer has not been validated in method saveTransferOut");
		
		//WDEV-9192
		if(pendingTransfer.getInpatientEpisodeIsNotNull())
		{
			String currentTransfer = "";
			if(pendingTransfer.getID_PendingTransfers() != null)
				currentTransfer = " and pt.id <> '" +  pendingTransfer.getID_PendingTransfers() + "'";
			
			List existingPTs = getDomainFactory().find("from PendingTransfers pt where pt.inpatientEpisode.id = '" + pendingTransfer.getInpatientEpisode().getID_InpatientEpisode() + "'" + currentTransfer);
			if(existingPTs != null && existingPTs.size() > 0)
				throw new DomainInterfaceException("Patient already has a transfer pending, the screen will be refreshed");
		}
		
		//WDEV-10421
		PendingTransfers doTransfer = PendingTransfersLiteVoAssembler.extractPendingTransfers(getDomainFactory(), pendingTransfer);
		//get the admission detail record and update its history for transfers
		AdmissionDetail doAdmissionDetail = populateTransferHistory(doTransfer, TRANSFEROUT, null);
			
		try
		{
			getDomainFactory().save(doTransfer);	
			if(doAdmissionDetail != null)
				getDomainFactory().save(doAdmissionDetail);	
		}
		catch (IllegalArgumentException e)
		{
			//where object has been deleted - this happens when a transfer in has been deleted (transfer complete) and this user has the old pending transfer record and is trying to update it
			throw new DomainInterfaceException("Patient's transfer has already been processed, the screen will be refreshed");
		}
	}

	public AdmissionDetail populateTransferHistory(PendingTransfers doTransfer, int transferType, LocationRefVo voCancellingfromWard)
	{
		AdmissionDetail doAdmissionDetail = null;
		if (doTransfer != null && doTransfer.getInpatientEpisode() != null && doTransfer.getInpatientEpisode().getPasEvent() != null)
		{
			List admList = getDomainFactory().find("from AdmissionDetail adm where adm.pasEvent.id = " + doTransfer.getInpatientEpisode().getPasEvent().getId());
			if(admList != null && admList.size() > 0)
			{
				doAdmissionDetail =  (AdmissionDetail) admList.get(0);
				
				//create a new or get the latest and check if its being transferred
				TransferHistory doTransferHistory = null;
				if(doAdmissionDetail.getTransferHistory().size() == 0)
					doTransferHistory = new TransferHistory();
				else
				{
					//populate last record
					doTransferHistory = (TransferHistory) doAdmissionDetail.getTransferHistory().get(doAdmissionDetail.getTransferHistory().size() - 1);
				}	
			
				//depending on the operation
				if(transferType != 0)
				{
					if(transferType == TRANSFEROUT)
					{
						//get the last pending if any and update it with rejected - this is when user 
						//changes their mind on a pending transfer and updates it - whether or not they change ward
						if(doAdmissionDetail.getTransferHistory() != null && doAdmissionDetail.getTransferHistory().size() > 0)
						{
							TransferHistory doPrevTransferHistory = (TransferHistory) doAdmissionDetail.getTransferHistory().get(doAdmissionDetail.getTransferHistory().size() - 1);
							
							//WDEV-10589 - if it has already been accepted no need to reject it
							if(doPrevTransferHistory.getAcceptTransferDateTime() == null)
							{
								doPrevTransferHistory.setRejectTransferDateTime(new Date());
								
								if(getLoggedInUser() != null)
									doPrevTransferHistory.setRejectTransferUser((AppUser) getDomainFactory().getDomainObject((AppUserRefVo) getLoggedInUser()));
							}
						}
						
						doTransferHistory = new TransferHistory();
						doTransferHistory.setAcceptingOrRejectingWard(doTransfer.getDestinationWard());
						doTransferHistory.setTransferringFromWard(doTransfer.getInpatientEpisode().getPasEvent().getLocation());
						doTransferHistory.setMarkedForTransferOutDateTime(new DateTime().getJavaDate()); //WDEV-10593
						if(getLoggedInUser() != null)
							doTransferHistory.setTransferOutUser((AppUser) getDomainFactory().getDomainObject((AppUserRefVo) getLoggedInUser()));
						
						doAdmissionDetail.getTransferHistory().add(doTransferHistory);
					}
					else if(transferType == TRANSFERIN)
					{
						doTransferHistory.setAcceptingOrRejectingWard(doTransfer.getDestinationWard());
						if(getLoggedInUser() != null)
							doTransferHistory.setAcceptingTransferUser((AppUser) getDomainFactory().getDomainObject((AppUserRefVo) getLoggedInUser()));
						
						doTransferHistory.setAcceptTransferDateTime(new Date());
					}
					else if(transferType == TRANSFERCANCEL)
					{
						// WDEV-11139
						// For patients in WaitingArea there is no ward to be set - leave it to null
						if (voCancellingfromWard != null)
							doTransferHistory.setAcceptingOrRejectingWard((Location) getDomainFactory().getDomainObject(voCancellingfromWard));
						
						doTransferHistory.setRejectTransferDateTime(new Date());
						if(getLoggedInUser() != null)
							doTransferHistory.setRejectTransferUser((AppUser) getDomainFactory().getDomainObject((AppUserRefVo) getLoggedInUser()));
					}
				}
			}
		}
		return doAdmissionDetail;
	}

	public ims.core.vo.DischargedEpisodeADTVo saveDischarge(DischargedEpisodeADTVo dischargedEpisode, BedSpaceStateLiteVo voBedSpacState) throws StaleObjectException, DomainInterfaceException, ForeignKeyViolationException
	{	
		if(dischargedEpisode.getPasEventIsNotNull() && dischargedEpisode.getPasEvent().getPatientIsNotNull())
			return dischargePatient(dischargedEpisode.getPasEvent().getPatient(), dischargedEpisode, voBedSpacState, false, null);
		
		return null;
	}
	
	public DischargedEpisodeADTVo saveDischargeElectiveList(DischargedEpisodeADTVo dischargedEpisode, BedSpaceStateLiteVo voBedSpacState, PatientElectiveListBedAdmissionVo electiveList, PatientElectiveListBedAdmissionVoCollection cancelledElectiveListToBeRemoved) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException
	{
		Boolean hasElectiveList = false;
		PatientElectiveList domElectiveList=null;
		
		HashMap domMap = new HashMap();
		
		
		if (electiveList != null)
		{
			domElectiveList = PatientElectiveListBedAdmissionVoAssembler.extractPatientElectiveList(getDomainFactory(), electiveList, domMap);
			
			if (WaitingListStatus.REQUIRES_TCI.equals(electiveList.getElectiveListStatus().getElectiveListStatus()))
			{
				TCIForPatientElectiveList tci = domElectiveList.getTCIDetails();
				domElectiveList.getTCIHistory().add(tci);
				domElectiveList.setTCIDetails(null);
				
				ReferralEROD erod = domElectiveList.getEROD();
				domElectiveList.getERODHistory().add(erod);
				domElectiveList.setEROD(null);
			}
			
			getDomainFactory().save(domElectiveList);
			hasElectiveList = true;
		}
		
		if (cancelledElectiveListToBeRemoved != null)
		{
			MemberOfStaff domainMOS = null;
			Object mosUser = getMosUser();

			DomainFactory factory = getDomainFactory();
			ims.framework.utils.Date currentDate = new ims.framework.utils.Date();

			if (mosUser instanceof MemberOfStaffShortVo)
			{
				domainMOS = MemberOfStaffShortVoAssembler.extractMemberOfStaff(factory, ((MemberOfStaffShortVo) getMosUser()));
			}

			for (PatientElectiveListBedAdmissionVo patientElectiveListToCancel : cancelledElectiveListToBeRemoved)
			{
				PatientElectiveList domPatientElectiveListToCancel = PatientElectiveListBedAdmissionVoAssembler.extractPatientElectiveList(getDomainFactory(), patientElectiveListToCancel, domMap);

				// check if Elective List has an active TCI
				if (domPatientElectiveListToCancel.getTCIDetails() != null && Boolean.TRUE.equals(domPatientElectiveListToCancel.getTCIDetails().isIsActive()))
				{
					TCIOutcomeForPatientElectiveList outcome = new TCIOutcomeForPatientElectiveList();

					outcome.setOutcome(getDomLookup(AdmissionOfferOutcome.NOT_APPLICABLE_OR_REMOVED_ETC_9));
					outcome.setChangeBy(domainMOS);
					outcome.setStatusDateTime(new Date());

					domPatientElectiveListToCancel.getTCIDetails().setCurrentOutcome(outcome);

					if (domPatientElectiveListToCancel.getTCIDetails().getOutcomeHistory() == null)
						domPatientElectiveListToCancel.getTCIDetails().setOutcomeHistory(new ArrayList());

					domPatientElectiveListToCancel.getTCIDetails().getOutcomeHistory().add(outcome);
					domPatientElectiveListToCancel.getTCIDetails().setIsActive(false);

					// check if the TCI has a linked future Booked Theatre
					// Appointment
					Booking_Appointment doBookAppt = domPatientElectiveListToCancel.getTCIDetails().getAppointment();

					if (doBookAppt != null && doBookAppt.getTheatreBooking() != null && getDomLookup(Status_Reason.BOOKED).equals(doBookAppt.getApptStatus()) && currentDate.getDate().compareTo(doBookAppt.getAppointmentDate()) <= 0)
					{
						doBookAppt.setApptStatus(getDomLookup(Status_Reason.CANCELLED));

						Appointment_Status appStatus = new Appointment_Status();

						appStatus.setStatus(getDomLookup(Status_Reason.CANCELLED));
						appStatus.setStatusReason(getDomLookup(Status_Reason.SLOTOPENED));
						appStatus.setStatusChangeDateTime(new Date());

						doBookAppt.setCurrentStatusRecord(appStatus);

						if (doBookAppt.getApptStatusHistory() == null)
							doBookAppt.setApptStatusHistory(new HashSet());

						doBookAppt.getApptStatusHistory().add(appStatus);

						if (doBookAppt.getSessionSlot() != null)
						{
							doBookAppt.getSessionSlot().setStatus(getDomLookup(Status_Reason.SLOTOPENED));
						}

						Booking_AppointmentVo bookingApptVo = Booking_AppointmentVoAssembler.create(doBookAppt);

						try
						{
							Class<?> implClass = Class.forName("ims.scheduling.domain.impl.SessionAdminImpl");
							ims.core.helper.IElectiveListCancelAppt sessionAdminImp = (ims.core.helper.IElectiveListCancelAppt) getDomainImpl(implClass);
							sessionAdminImp.cancelAppt(bookingApptVo, ActionRequestType.NOTIFY_APPT_CANCEL, "Cancel Appt requested from Bed Info Dialog Discharge");
						}
						catch (ClassNotFoundException e)
						{
							// log the exception in system log - but it should
							// be fine
							createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Cast exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
						}
					}
				}
				
				//WDEV-18680
				if (domPatientElectiveListToCancel.getPathwayClock() != null &&domPatientElectiveListToCancel.getPathwayClock().getStopDate() == null )
				{
					domPatientElectiveListToCancel.getPathwayClock().setStopDate(new Date());
					updateRTTStatus(domPatientElectiveListToCancel.getReferral());
				}

				getDomainFactory().save(domPatientElectiveListToCancel);
			}
		}
		
		if(dischargedEpisode.getPasEventIsNotNull() && dischargedEpisode.getPasEvent().getPatientIsNotNull())
			return dischargePatient(dischargedEpisode.getPasEvent().getPatient(), dischargedEpisode, voBedSpacState, hasElectiveList, domElectiveList);
		
		return null;
	}
	
	private RTTStatusPoint updateRTTStatus(CatsReferral doCats) throws DomainInterfaceException, StaleObjectException
	{
		if(!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return null;
		
		if(doCats == null)
			return null;
		
		if(doCats.isRTTClockImpact() == null || Boolean.FALSE.equals(doCats.isRTTClockImpact()))
			return null;
		
		PathwayRTTStatus rttStatus = createPathwayRTTStatus(doCats);
		
		doCats.setCurrentRTTStatus(rttStatus);
		
		RTTStatusEventMapVo rttMap = getRTTStatusEventMap(rttStatus.getRTTStatus());

		if (rttMap != null && rttMap.getEvent() != null)
		{
			PatientEventVo patEvent = new PatientEventVo();
			patEvent.setPatient(PatientListVoAssembler.create(doCats.getPatient()));
			patEvent.setEvent(rttMap.getEvent());
			patEvent.setEventDateTime(new DateTime());
			patEvent.setEventStatus(EventStatus.ACTIVE);
			patEvent.setJourney(PatientJourneyVoAssembler.create(doCats.getJourney()));

			try
			{
				Class<?> implClass = Class.forName("ims.pathways.domain.impl.HL7PathwayIfImpl");
				IPathwayPatientEventHelper pathwayImp = (IPathwayPatientEventHelper) getDomainImpl(implClass);
				pathwayImp.instantiatePatientEvent(patEvent);
			}
			catch (ClassNotFoundException e)
			{
				//Log the exception in system, should be fine
				e.printStackTrace();
			}
		}
		
		return rttStatus.getRTTStatus();
	}

	private RTTStatusEventMapVo getRTTStatusEventMap(RTTStatusPoint rttStatusPoint)
	{
		if(rttStatusPoint == null)
			return null;
		
		String query = "select rttMap from RTTStatusEventMap as rttMap left join rttMap.currentRTTStatus as rtt where rtt.id = :RTTStatusPoint and rttMap.event is not null and rttMap.active = 1";
		List<?> listRTTMap = getDomainFactory().find(query, new String[] {"RTTStatusPoint"}, new Object[] {rttStatusPoint.getId()});
		
		if(listRTTMap != null && listRTTMap.size() > 0 && listRTTMap.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) listRTTMap.get(0));
		}
		
		return null;
	}

	private PathwayRTTStatus createPathwayRTTStatus(CatsReferral doCats)
	{
		if(doCats == null)
			return null;
		
		RTTStatusPoint rttStatusPoint = getRTTStatusPoint(START_OF_FIRST_DEFINITIVE_TREATMENT);
		Object mos = getMosUser();
		MemberOfStaff doMos = null;
		
		if(mos instanceof MemberOfStaffLiteVo)
		{
			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
		}
		
		PathwayRTTStatus pathwayRTTStatus = new PathwayRTTStatus();
		pathwayRTTStatus.setRTTStatus(rttStatusPoint);
		pathwayRTTStatus.setStatusBy(doMos);
		pathwayRTTStatus.setStatusDateTime(new java.util.Date());
		
		if(doCats.getJourney() != null && doCats.getJourney().getCurrentClock() != null)
    	{
			doCats.getJourney().getCurrentClock().setCurrentRTTStatus(pathwayRTTStatus);
    			
    		if(doCats.getJourney().getCurrentClock().getRTTStatusHistory() == null)
    			doCats.getJourney().getCurrentClock().setRTTStatusHistory(new java.util.ArrayList());
    			
    		doCats.getJourney().getCurrentClock().getRTTStatusHistory().add(pathwayRTTStatus);
    	}
		
		return pathwayRTTStatus;
	}
	
	private RTTStatusPoint getRTTStatusPoint(int nationalCode)
	{
		String query = "select rtt from RTTStatusPoint as rtt where rtt.nationalCode = :NationalCode";
		
		List<?> rttList = getDomainFactory().find(query, new String[] {"NationalCode"}, new Object[] {nationalCode});
		
		if(rttList != null && rttList.size() > 0 && rttList.get(0) instanceof RTTStatusPoint)
		{
			return (RTTStatusPoint) rttList.get(0);
		}
		
		return null;
	}
	
	private ims.core.vo.DischargedEpisodeADTVo dischargePatient(ims.core.vo.PatientShort voPatient, ims.core.vo.DischargedEpisodeADTVo voDischEpis, BedSpaceStateLiteVo voBedSpacState, Boolean hasElectiveList, PatientElectiveList domElectiveList) throws ForeignKeyViolationException, DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		if(voDischEpis == null)
			throw new CodingRuntimeException("dischargedEpisode is null in method dischargePatient");
		if (!voDischEpis.isValidated())
			throw new CodingRuntimeException("voDischEpis has not been validated!");
		if(voPatient == null)
			throw new CodingRuntimeException("voPatient is null in method dischargePatient");
		
		DomainFactory factory = getDomainFactory();		
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, voPatient.getID_Patient().intValue());
		DischargedEpisode disDo = DischargedEpisodeADTVoAssembler.extractDischargedEpisode(factory, voDischEpis);
	
		BedSpaceState doBed = null;
		if(voBedSpacState != null)
			doBed = BedSpaceStateLiteVoAssembler.extractBedSpaceState(factory, voBedSpacState); 
	
		PASEvent peDo = disDo.getPasEvent();
		
		InpatientEpisode ipDo = getCurrentAdmission(factory, voPatient);
		
		// Patient was discharged already
		if (ipDo == null)
		{
			throw new StaleObjectException(ipDo);
		}
		
		if (ipDo != null)
		{			
			if (Boolean.FALSE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			{
				Inpat inpatRec = (Inpat)getDTOInstance(Inpat.class);
				inpatRec.DataCollection.add();
				
				copyToDtoForDischarge(inpatRec, ipDo, disDo);
				Result res = inpatRec.executeAction("DISCHARGE");
				if (res != null)
				{
					if(res.getId() == -2)
					{
						//specifically ignore this error see WDEV-8158 - patient is not an inpatient
						String error = "Inpatient not found on Hearts - Maxims proceeding with Discharge";
						LOG.error(error);
						createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, error);
					}
					else if(res.getId() != 0)
						throw new DTODomainInterfaceException(res.getId(), "Error occurred Discharging Patient on PAS " + res.getMessage());
				}
			}
			
			//Dod implementation here - if the reason is mapped to PATIENTDIED(4) or STILLBIRTH(5)
			if(disDo.getMethodOfDischarge() != null)
			{
				String mapping = getLookupService().getRemoteLookup(disDo.getMethodOfDischarge().getId(), TaxonomyType.PAS.getIItemText());
				if(mapping != null && (mapping.equals(PATIENTDIED) || mapping.equals(STILLBIRTH)))
				{
					Date dischDT = disDo.getDischargeDateTime();
					domPatient.setDod(dischDT);
				}	
			}

			//Want to re-use the one that was created for the Admission. No need for a new one on Discharge.
			peDo = ipDo.getPasEvent();
			factory.initialize(peDo);
			
			//WDEV-8312
			List admList = factory.find("from AdmissionDetail adm where adm.pasEvent.id = " + peDo.getId());
			if(admList != null && admList.size() > 0)
			{
				AdmissionDetail doAdmissionDetail =  (AdmissionDetail) admList.get(0);
				doAdmissionDetail.setWard(null);
				doAdmissionDetail.setBed(null);
				factory.save(doAdmissionDetail);
			}
			 
			//WDEV-18450 
			if (Boolean.TRUE.equals(ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue()) && Boolean.TRUE.equals(voDischEpis.getWasTreatmentDeferred()))  
			{
				// WDEV-18617
				if (domElectiveList != null && domElectiveList.getElectiveListReason().getId() == ElectiveListReason.DIAGNOSTIC.getId())
				{
					// Need to stop the lock clock as patient was treated during diagnostics
					if (domElectiveList.getReferral() != null && domElectiveList.getReferral().getJourney() != null && domElectiveList.getReferral().getJourney().getCurrentClock() != null)
					{
						domElectiveList.getReferral().getJourney().getCurrentClock().setStopDate(ipDo != null ? ipDo.getAdmissionDateTime() : new Date());
						factory.save(domElectiveList);
					}
				}
				else
				{
					List catsList = factory.find("from CatsReferral cats where cats.careContext.pasEvent.id = " + peDo.getId());
					if (catsList != null && catsList.size() > 0)
				{
					CatsReferral doCatsDetails = (CatsReferral) catsList.get(0);
					
					if (doCatsDetails != null && Boolean.TRUE.equals(doCatsDetails.isRTTClockImpact()) && doCatsDetails.getJourney() != null && 
						doCatsDetails.getJourney().getCurrentClock() != null && 
						(doCatsDetails.getJourney().getCurrentClock().getStopDate() != null || Boolean.TRUE.equals(hasElectiveList))&& 
						doCatsDetails.getJourney().getCurrentClock().getRTTStatusHistory() != null)
					{
						PathwayRTTStatus doPreviousCurrentPathwayRttStatus = getStatusPreviousTheClockStop(doCatsDetails.getJourney().getCurrentClock().getRTTStatusHistory());
						PathwayRTTStatus doNewPathwayRttStatus = createNewStausBasedOnThePreviousStatus(doPreviousCurrentPathwayRttStatus);
						if (doNewPathwayRttStatus != null)
						{
							doCatsDetails.setCurrentRTTStatus(doNewPathwayRttStatus);
							doCatsDetails.getJourney().getCurrentClock().setCurrentRTTStatus(doNewPathwayRttStatus);
							doCatsDetails.getJourney().getCurrentClock().setStopDate(null);
							doCatsDetails.getJourney().getCurrentClock().getRTTStatusHistory().add(doNewPathwayRttStatus);
							factory.save(doCatsDetails);
						}
					}
				}
				}
			}
			
				
			
			//WDEV-8403
			if(peDo.getPatient() != null)
			{
				peDo.getPatient().setWard(null);
				// WDEV-17867 - Clear Current Responsible Consultant from Patient record
				peDo.getPatient().setCurrentResponsibleConsultant(null);
			}
			
			disDo.setPasEvent(peDo);
			if(doBed != null)
			{
				doBed.setInpatientEpisode(null);
				factory.save(doBed);
			}
			
			if(ipDo != null)
			{
				PendingTransfers doTransfer = PendingTransfers.getPendingTransfersFromInpatientEpisode(factory, ipDo.getId());
				if(doTransfer != null)
					getDomainFactory().delete(doTransfer);
			}
				
			//copy over home Leaves
			for (int i = 0 ; i < ipDo.getHomeLeaves().size() ; i++)
			{
				if(ipDo.getHomeLeaves().get(i) == null)
					continue;

				disDo.getHomeLeaves().add((HomeLeave)ipDo.getHomeLeaves().get(i));
				
				ipDo.getHomeLeaves().remove(i);
			}
			factory.delete(ipDo);
		}
		factory.save(peDo);
		factory.save(disDo);
		
		//Clear the ward field in Patient record. No longer an inpatient.
		domPatient.setWard(null);
		// WDEV-17867 - Clear Current Responsible Consultant from Patient record
		domPatient.setCurrentResponsibleConsultant(null);
		
		factory.save(domPatient);
		
		//WDEV-12732 - have set other fields other than issue has requested - same as what happens in ADTImpl
		if(ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()
			|| ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue()
			|| ConfigFlag.DOM.ADT_LINK_ADMISSION_TO_EPISODE.getValue())//wdev-14358
		{
			CareContext doCareContext = (CareContext) getDomainFactory().findFirst("from CareContext cc where cc.pasEvent.id = " + peDo.getId());
			//WDEV-13121
			if(doCareContext != null)
			{
				doCareContext.setBedNumber(null);
				doCareContext.setContext(getDomLookup(ContextType.INPATIENT));
				doCareContext.setCurrentStatus(new CareContextStatusHistory());
				doCareContext.getCurrentStatus().setStatusDateTime(new Date());
				if (doCareContext.getEndDateTime() == null && disDo != null)
					doCareContext.setEndDateTime(disDo.getDischargeDateTime());
				doCareContext.getCurrentStatus().setStatus(getDomLookup(CareContextStatus.OPEN));
				doCareContext.getStatusHistory().add(doCareContext.getCurrentStatus());
				factory.save(doCareContext);
			}
		}
		
		return DischargedEpisodeADTVoAssembler.create(disDo);
	}
	
	private PathwayRTTStatus createNewStausBasedOnThePreviousStatus(PathwayRTTStatus doPreviousCurrentPathwayRttStatus)
	{
		if(doPreviousCurrentPathwayRttStatus != null)
		{
    		PathwayRTTStatus rttStatusDO = new PathwayRTTStatus();
    		
    		rttStatusDO.setRTTStatus(doPreviousCurrentPathwayRttStatus.getRTTStatus());
    		
    		Object mos = getMosUser();
    		MemberOfStaff doMos = null;
    		
    		if(mos instanceof MemberOfStaffLiteVo)
    		{
    			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
    		}
    		
    		rttStatusDO.setStatusBy(doMos);
    		rttStatusDO.setStatusDateTime(new java.util.Date());
    		rttStatusDO.setSetting("I");
    		
    		return rttStatusDO;
		}
		return null;
	}

	private PathwayRTTStatus getStatusPreviousTheClockStop(List listCatsReferralRttHistory)
	{
		List<Integer> statusToBeRemoved =statusToBeRemovedList();
		
		if (listCatsReferralRttHistory.size() > 0)
		{
			PathwayRTTStatus doPathwayRttStatus = null;
			for (int i = listCatsReferralRttHistory.size() -1 ; i >=0 ; i-- )
			{
				doPathwayRttStatus = (PathwayRTTStatus) listCatsReferralRttHistory.get(i);
				Integer nationalCode = doPathwayRttStatus.getRTTStatus() != null ? doPathwayRttStatus.getRTTStatus().getNationalCode() : null;
				
				if(nationalCode != null && !statusToBeRemoved.contains(nationalCode))
				{
					return doPathwayRttStatus;
				}						
			}			
		}		
		return null;
	}

	private List<Integer> statusToBeRemovedList()
	{
		List<Integer> listOfStatusesToBeRemoved = new ArrayList<Integer>();
		listOfStatusesToBeRemoved.add(30);
		listOfStatusesToBeRemoved.add(31);
		listOfStatusesToBeRemoved.add(32);
		listOfStatusesToBeRemoved.add(33);
		listOfStatusesToBeRemoved.add(34);
		listOfStatusesToBeRemoved.add(35);
		listOfStatusesToBeRemoved.add(36);
		return listOfStatusesToBeRemoved;
	}

	private InpatientEpisode getCurrentAdmission(DomainFactory factory, PatientRefVo patVo) 
	{
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());
		
		String hql = "from InpatientEpisode ip where ip.pasEvent.patient.id = :pat";
		List<?> l = factory.find(hql, new String[] {"pat"}, new Object[] {domPatient.getId()});		
		if (l != null && l.size() > 0)
		{
			return (InpatientEpisode)l.get(0);
		}
		return null;
	}

	public InpatConsultantTransferVo getInpatConsultantTransfer(InpatientEpisodeRefVo inpat)
	{
		if(inpat == null || inpat.getID_InpatientEpisode() == null)
			throw new CodingRuntimeException("inpatientEpisode is null or id not provided for getInpatConsultantTransfer");
		
		return InpatConsultantTransferVoAssembler.create( (InpatientEpisode) getDomainFactory().getDomainObject(inpat));
	}

	public CareContextShortVo saveInpatConsultantTransfer(InpatConsultantTransferVo inpatConsTransfer) throws DomainInterfaceException, StaleObjectException
	{
		if(inpatConsTransfer == null)
			throw new CodingRuntimeException("inpatConsTransfer is null in method saveInpatConsultantTransfer");
		if(!inpatConsTransfer.isValidated())
			throw new CodingRuntimeException("inpatConsTransfer has not been validated in method saveInpatConsultantTransfer");

		Inpat inpatRec = null;
		if (Boolean.FALSE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
		{
			inpatRec = (Inpat)getDTOInstance(Inpat.class);
			inpatRec.DataCollection.add();
		}
		
		InpatientEpisode doInpat = InpatConsultantTransferVoAssembler.extractInpatientEpisode(getDomainFactory(), inpatConsTransfer);
		
		if (inpatRec != null)
		{
			copyInpatEpisodeToDtoForTransfer(inpatRec, doInpat, true, false, null);
			Result res = inpatRec.executeAction("TRANSFER");
			if (res != null && res.getId() != 0)
				throw new DTODomainInterfaceException(res.getId(), "Error occurred Transferring Patient on PAS " + res.getMessage());
		}
		
		getDomainFactory().save(doInpat);
		
		//WDEV-11479 - update the CareContext with the ResponsibleHcp
		WardView impl = (WardView) getDomainImpl(WardViewImpl.class);
		CareContextShortVo voCareContext = impl.getCareContextForPasEvent(inpatConsTransfer.getPasEvent());
		if(voCareContext != null)
		{
			CareContext doCareContext = CareContextShortVoAssembler.extractCareContext(getDomainFactory(), voCareContext);			
			if(doInpat != null && doInpat.getPasEvent() != null && doCareContext.getEpisodeOfCare() != null) 
			{
				doCareContext.setResponsibleHCP(doInpat.getPasEvent().getConsultant());
				if(!ConfigFlag.DOM.ADT_LINK_ADMISSION_TO_EPISODE.getValue()) //wdev-14309
				{
					doCareContext.getEpisodeOfCare().setSpecialty(doInpat.getPasEvent().getSpecialty());	//	WDEV-12764
					doCareContext.getEpisodeOfCare().setResponsibleHCP(doInpat.getPasEvent().getConsultant());
				}
			}
					
			getDomainFactory().save(doCareContext);	
			return CareContextShortVoAssembler.create(doCareContext);
		}
		
		return null;	
	}

	public LocationLiteVo getParentLocation(LocationRefVo childLoc)
	{
		if(childLoc == null || childLoc.getID_Location() == null )
			throw new CodingRuntimeException("childLoc is null or id not provided in method getParentLocation");
		
		Location doLocation = (Location) getDomainFactory().getDomainObject(childLoc);
		return LocationLiteVoAssembler.create(doLocation.getParentLocation());
	}

	public BedSpaceStateLiteVo saveCloseBed(BedSpaceStateLiteVo bedSpaceState, String user, ReasonForBedClosure reason, DateTime estReOpen) throws StaleObjectException
	{
		if(bedSpaceState == null)
			throw new CodingRuntimeException("bedSpaceState is null in method saveCloseBed");
		
		BedSpaceState doBedSpace = BedSpaceStateLiteVoAssembler.extractBedSpaceState(getDomainFactory(), bedSpaceState);
		doBedSpace.getCurrentBedStatus().setEstReopeningDateTime(estReOpen != null ? estReOpen.getJavaDate() : null);
		doBedSpace.getCurrentBedStatus().setReasonForClosure(getDomLookup(reason));
		doBedSpace.getCurrentBedStatus().getSystemInformation().setCreationUser(user);
		
		getDomainFactory().save(doBedSpace);
		return BedSpaceStateLiteVoAssembler.create(doBedSpace);
	}

	public BedSpaceStateStatusVo getBedSpaceStateStatus(BedSpaceStateStatusRefVo bedSpaceStateStatus)
	{
		if(bedSpaceStateStatus == null || bedSpaceStateStatus.getID_BedSpaceStateStatus() == null)
			throw new CodingRuntimeException("bedSpaceStateStatus is null or id not provided in method getBedSpaceStateStatus");
		
		return BedSpaceStateStatusVoAssembler.create((BedSpaceStateStatus) getDomainFactory().getDomainObject(bedSpaceStateStatus));
	}

	public void saveReOpenOrAssignBed(BedSpaceStateLiteVo bedSpaceState) throws StaleObjectException
	{
		if(bedSpaceState == null)
			throw new CodingRuntimeException("bedSpaceState is null in method saveReOpenOrAssignBed");
		
		//WDEV-8507
		bedSpaceState.setInpatientEpisode(null);
		
		getDomainFactory().save(BedSpaceStateLiteVoAssembler.extractBedSpaceState(getDomainFactory(), bedSpaceState));	
	}

	public void cancelTransfer(PendingTransfersRefVo voTransfer, LocationRefVo voCancellingFromWard) throws StaleObjectException, ForeignKeyViolationException
	{		
		if (voTransfer == null || voTransfer.getID_PendingTransfers() == null)
			throw new CodingRuntimeException("voTransfer is null or id not provided in method cancelTransfer");
		
		//WDEV-10421 - get the admission detail record and update its history for transfers
		PendingTransfers doPending = (PendingTransfers) getDomainFactory().getDomainObject(voTransfer);
		AdmissionDetail doAdmissionDetail = populateTransferHistory(doPending, TRANSFERCANCEL, voCancellingFromWard);
	
		getDomainFactory().delete("from PendingTransfers p where p.id = '" + voTransfer.getID_PendingTransfers() + "'");
		
		//WDEV-10421
		if(doAdmissionDetail != null)
			getDomainFactory().save(doAdmissionDetail);
	}

	public CareContextShortVo saveEstimatedDischarge(InpatientEpisodeLiteVo inpatEpisode) throws StaleObjectException, DomainInterfaceException
	{
		if (inpatEpisode == null)
			throw new CodingRuntimeException("inpatEpisode is null in method saveEstimatedDischarge");
		if (!inpatEpisode.isValidated())
			throw new CodingRuntimeException("inpatEpisode has not been validated in method saveEstimatedDischarge");
		
		Inpat inpatRec = null;
		if (Boolean.FALSE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
		{
			try
			{
				inpatRec = (Inpat) getDTOInstance(Inpat.class);	
			}
			catch(ResultException e)
			{
				throw new DomainInterfaceException("Failed to Connect to PAS - Please check Configuration", e);
			}
		}
		
		if(inpatEpisode.getEstDischargeDateIsNotNull())
		{
			if (inpatRec != null)
				inpatRec.Filter.clear();

			Result result = null;
			if (inpatEpisode.getPasEventIsNotNull() && inpatEpisode.getPasEvent().getPatientIsNotNull())
			{
				ims.core.vo.PatientId intfId = inpatEpisode.getPasEvent().getPatient().getHospnum();
				if (inpatRec != null)
				{
					inpatRec.Filter.Hospnum = intfId.getValue();
					result = inpatRec.get();
					if(inpatRec.DataCollection.count() == 0)
					{
						if(result != null)
							throw new DomainInterfaceException("Failed to get Inpat record on Pas " + result.getMessage());
					}
					
				InpatRecord inpatRecord = inpatRec.DataCollection.get(0);
				
				inpatRec.EditFilter.excludeAll();
				inpatRec.EditFilter.IncludeEddt = true;
				inpatRec.EditFilter.IncludeHospnum = true;

				//WDEV-12957
				if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO"))
				{
					inpatRec.EditFilter.IncludeStay = true;
					inpatRec.EditFilter.IncludeDrdt = true;
					if(inpatRec.DataCollection.get(0).Addt != null && inpatEpisode.getEstDischargeDateIsNotNull())
					{
						try
						{
							inpatRecord.Stay = String.valueOf(ims.framework.utils.Date.daysBetween( new ims.framework.utils.DateTime(inpatRec.DataCollection.get(0).Addt).getDate(), inpatEpisode.getEstDischargeDate()));
						}
						catch (ParseException e)
						{
							throw new DomainRuntimeException("Error in Admission Date", e);
						}
					}
					if(inpatEpisode.getDischargeReadyDateIsNotNull())
						inpatRecord.Drdt = DTOHelper.convertToDtoDate(inpatEpisode.getDischargeReadyDate().getDate());
				}
				
				inpatRecord.Eddt = DTOHelper.convertToDtoDate(inpatEpisode.getEstDischargeDate().getDate());
				result = inpatRec.update();
				
				if(result != null && result.getId() < 0)
					throw new DomainInterfaceException("Attempt to save to Pas failed " + result.getMessage());
				}				

			}
		}	
		getDomainFactory().save(InpatientEpisodeLiteVoAssembler.extractInpatientEpisode(getDomainFactory(), inpatEpisode));
		
		//WDEV-11438 - update the CareContext with the EDD
		WardView impl = (WardView) getDomainImpl(WardViewImpl.class);
		CareContextShortVo voCareContext = impl.getCareContextForPasEvent(inpatEpisode.getPasEvent());
		if(voCareContext != null)
		{
			voCareContext.setEstimatedDischargeDate(inpatEpisode.getEstDischargeDate());
			CareContext doCareContext = CareContextShortVoAssembler.extractCareContext(getDomainFactory(), voCareContext);			
			getDomainFactory().save(doCareContext);	
			return CareContextShortVoAssembler.create(doCareContext);
		}

		return null;
	}

	public String[] getRtpStatAndPlBlk(ims.core.vo.PatientId intfId)
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;
		
		Inpat inpatRec = (Inpat) getDTOInstance(Inpat.class);
		inpatRec.Filter.clear();
		
		if (intfId == null)
		{
			throw new DomainRuntimeException("Patient Get call must contain valid interface identifier");
		}

		if (intfId.getType().equals(PatIdType.PKEY))
		{
			inpatRec.Filter.Pkey = intfId.getValue();
		}
		else if (intfId.getType().equals(PatIdType.HOSPNUM))
		{
			inpatRec.Filter.Hospnum = intfId.getValue();
		}
		else
		{
			throw new DomainRuntimeException("No valid Interface Patient Identifier supplied.");
		}

		Result result = inpatRec.get();
		if (result == null)
		{
			return new String[] {inpatRec.DataCollection.get(0).Rtpstat, inpatRec.DataCollection.get(0).Plbk};
		}
		
		return null;
	}

	public InpatientEpisodeLiteVoCollection listInpatientEpisodeByWard(LocationRefVo ward)
	{
		WardView impl = (WardView) getDomainImpl(WardViewImpl.class);
		return impl.listInpatientEpisodeByWard(ward);
	}

	public void saveInternalTransfer(InpatientEpisodeLiteVo inpatEpis, BedSpaceStateLiteVo bedSpaceState) throws StaleObjectException
	{
		if (bedSpaceState == null)
			throw new CodingRuntimeException("bedSpaceState is null in method saveInternalTransfer");
		if (inpatEpis == null)
			throw new CodingRuntimeException("inpatEpis is null in method saveInternalTransfer");
		
		BedSpaceState doBedSpaceState = BedSpaceStateLiteVoAssembler.extractBedSpaceState(getDomainFactory(), bedSpaceState);
		InpatientEpisode doInpatEpis = InpatientEpisodeLiteVoAssembler.extractInpatientEpisode(getDomainFactory(), inpatEpis);
		doInpatEpis.getBed().getCurrentBedStatus().setBedStatus(getDomLookup(BedStatus.AVAILABLE));
		doInpatEpis.getBed().setInpatientEpisode(null);
		getDomainFactory().save(doInpatEpis);
		
		doBedSpaceState.setInpatientEpisode(doInpatEpis);
		doBedSpaceState.getCurrentBedStatus().setBedStatus(getDomLookup(BedStatus.OCCUPIED));
		doInpatEpis.setBed(doBedSpaceState);
		
		getDomainFactory().save(doInpatEpis);
	}

	public InpatientEpisodeLiteVoCollection listInfantsForSelectedPatient(PatientRefVo patient)
	{
		if (patient == null || patient.getID_Patient() == null)
			throw new CodingRuntimeException("patient is null or id not provided in method countInfants");
		
		String hql = "select inpatEpis from InpatientEpisode as inpatEpis left join inpatEpis.pasEvent as pE where (pE.patient.id in (select pat.id from Patient as pat where (pat.clientParent.id = " + patient.getID_Patient() + ")))";
		List lstEpisodes = getDomainFactory().find(hql);
		if(lstEpisodes != null)
			return InpatientEpisodeLiteVoAssembler.createInpatientEpisodeLiteVoCollectionFromInpatientEpisode(lstEpisodes);
		
		return null;
	}

	public BedSpaceStateLiteVo getBedSpaceStateByInpatientEpisode(InpatientEpisodeRefVo inpat)
	{
		if (inpat == null || inpat.getID_InpatientEpisode() == null)
			throw new CodingRuntimeException("inpat is null or id not provided in method getBedSpaceStateByInpatientEpisode");
		
		String hql = "from BedSpaceState as bed where bed.inpatientEpisode.id = " + inpat.getID_InpatientEpisode();
		List lstBeds = getDomainFactory().find(hql);
		if(lstBeds != null && lstBeds.size() == 1)
			return BedSpaceStateLiteVoAssembler.create((BedSpaceState) lstBeds.get(0));
		
		return null;
	}
	
	public String getPasMappingFromConsultant(IMos mos)
	{
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		return impl.getPasMappingFromConsultant(mos);
	}

//	public SpecialtyCollection listSpecialtiesFromConSpc(String consultantMapping) throws DomainInterfaceException
//	{
//		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
//		return impl.listSpecialtiesFromConSpc(consultantMapping);
//	}

	public PendingTransfersLiteVo getPendingTransferForInpatient(InpatientEpisodeRefVo inpatEpis)
	{
		if (inpatEpis == null || inpatEpis.getID_InpatientEpisode() == null)
			throw new CodingRuntimeException("inpatEpis is null or id not provided in method getPendingTransferForInpatient");

		List transfers = getDomainFactory().find("from PendingTransfers pTrans where pTrans.inpatientEpisode.id = " + inpatEpis.getID_InpatientEpisode());
		if(transfers != null && transfers.size() == 1)
			return PendingTransfersLiteVoAssembler.create((PendingTransfers) transfers.get(0));
			
		return null;
	}

	public AdmissionDetailVo getAdmissionDetailByPasEvent(PASEventRefVo pasEvent)
	{
		if (pasEvent == null || pasEvent.getID_PASEvent() == null)
			throw new CodingRuntimeException("pasEvent is null or id not provided in method getAdmissionDetailByPasEvent");
		
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		return impl.getAdmissionDetailByPasEvent(pasEvent);
	}

	public SpecialtyCollection listSpecialtiesFromConSpc(String consultantMapping) throws DomainInterfaceException 
	{
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		return impl.listSpecialtiesFromConSpc(consultantMapping);
	}

	public Specialty getCCOSpecialtyMappingFromPASSpecialty(PASSpecialty pasSpecialty)
	{
		if (pasSpecialty == null)
			return null;
		
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		String szMapping = null;
		for (int i = 0 ; i < pasSpecialty.getMappings().size() ; i++)
		{
			if (pasSpecialty.getMappings().get(i).getExtSystem().equals("PAS"))
				szMapping = pasSpecialty.getMappings().get(i).getExtCode();
		}
		if (szMapping != null)
			return impl.getSpecialtyMappingFromPASSpecialty(szMapping);
		else
			return null;
	}

	public PASSpecialtyCollection listCCOSpecialtiesFromConSpc(String consultantMapping) throws DomainInterfaceException 
	{
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		return impl.listCCOSpecialtiesFromConSpc(consultantMapping);
	}

	public Specialty getSpecialtyMappingFromPASSpecialty(String szMapping) 
	{
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		return impl.getSpecialtyMappingFromPASSpecialty(szMapping);
	}

	public PASSpecialty getPASSpecialtyMappingFromSpecialty(String szMapping) 
	{
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		return impl.getPASSpecialtyMappingFromSpecialty(szMapping);
	}

	public PASSpecialty getPASSpecialtyMappingFromSpecialty(Specialty specialty) {
		// TODO Auto-generated method stub
		return null;
	}

	public CareContextShortVo saveHomeLeave(BedSpaceStateLiteVo voBedSpaceStateLite, InPatientEpisodeADTVo inpatientEpisode, HomeLeaveVo homeLeaveVo) throws DomainInterfaceException, StaleObjectException 
	{
		if(inpatientEpisode == null)
			throw new CodingRuntimeException("inpatientEpisode is null in method saveTransfer");
		if(!inpatientEpisode.isValidated())
			throw new CodingRuntimeException("inpatientEpisode has not been validated in method saveTransfer");
		
		if(homeLeaveVo == null)
			throw new CodingRuntimeException("homeLeaveVo is null in method saveHomeLeave");
	
		DomainFactory factory = getDomainFactory();
		
		if (Boolean.FALSE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
		{
			Homeleave hlRec = (Homeleave)getDTOInstance(Homeleave.class);
			hlRec.DataCollection.add();
			
			copyHomeleaveToDto(hlRec, homeLeaveVo, inpatientEpisode);
			
			//Update Home Leave on PAS 
			Result res = hlRec.insert();
			if (res != null && res.getId() < 0 )
			{
				if (res.getId() == -5)
					throw new DomainInterfaceException("Error occurred saving Home Leave record to PAS " + res.getMessage());
				else 
					throw new DTODomainInterfaceException(res.getId(), "Error occurred saving Home Leave record to PAS " + res.getMessage());	
			}
		}		
		//Save MAXIMS HomeLeave
		HomeLeave doHL = HomeLeaveVoAssembler.extractHomeLeave(factory, homeLeaveVo);
		
		//Save IP details
		InpatientEpisode doInpatEpis = InPatientEpisodeADTVoAssembler.extractInpatientEpisode(getDomainFactory(), inpatientEpisode);
		doInpatEpis.getHomeLeaves().add(doHL);
		
		doInpatEpis.setIsOnHomeLeave(true);
		doInpatEpis.setDateOnHomeLeave(homeLeaveVo.getDateOnHomeLeaveIsNotNull() ? homeLeaveVo.getDateOnHomeLeave().getDate() : null);
		doInpatEpis.setTimeOnHomeLeave(homeLeaveVo.getTimeOnHomeLeaveIsNotNull() ? homeLeaveVo.getTimeOnHomeLeave().toString() : null);
		doInpatEpis.setExpectedDateOfReturn(homeLeaveVo.getExpectedDateOfReturnIsNotNull() ? homeLeaveVo.getExpectedDateOfReturn().getDate() : null);
		doInpatEpis.setExpectedTimeOfReturn(homeLeaveVo.getExpectedTimeOfReturnIsNotNull() ? homeLeaveVo.getExpectedTimeOfReturn().toString() : null);
		doInpatEpis.setVacatedBedNumber(homeLeaveVo.getVacatedBedNumberIsNotNull() ? homeLeaveVo.getVacatedBedNumber() : "");
		
		factory.save(doInpatEpis);

		//Vacate the bed.
		if(voBedSpaceStateLite != null)
		{
			BedSpaceState doBed = BedSpaceStateLiteVoAssembler.extractBedSpaceState(factory, voBedSpaceStateLite);
			factory.save(doBed);
		}
		return null;
	}

	private String getPatientIdValue(AdmissionDetail doAdmissionDetail, PatIdType type) 
	{
		if(doAdmissionDetail == null)
			return null;
		
		if(doAdmissionDetail.getPasEvent() != null && doAdmissionDetail.getPasEvent().getPatient() != null && doAdmissionDetail.getPasEvent().getPatient().getIdentifiers() != null)
		{
			Iterator it = doAdmissionDetail.getPasEvent().getPatient().getIdentifiers().iterator();
			while(it.hasNext())
			{
				PatientId patId = (PatientId) it.next();
				if(patId.getType().equals( getDomLookup(type)))
					return patId.getValue();
			}
		}
		
		return null;
	}

	private void copyHomeLeaveToDto(Homeleave homeLeaveRec, AdmissionDetail doAdmissionDetail, HomeLeaveVo voHomeLeave) 
	{		
		HomeleaveRecord hlRec = homeLeaveRec.DataCollection.get(0);
	 	
		hlRec.Pkey = getPatientIdValue(doAdmissionDetail, PatIdType.PKEY);
		hlRec.Hospnum = getPatientIdValue(doAdmissionDetail, PatIdType.HOSPNUM);

		hlRec.Leavedt = voHomeLeave.getDateOnHomeLeaveIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getDateOnHomeLeave().getDate()) : "";
		hlRec.Leavetm =  voHomeLeave.getTimeOnHomeLeaveIsNotNull() ? voHomeLeave.getTimeOnHomeLeave().toString(TimeFormat.FLAT4) : "";

		hlRec.Exdt = voHomeLeave.getExpectedDateOfReturnIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getExpectedDateOfReturn().getDate()) : "";
		hlRec.Extm = voHomeLeave.getExpectedTimeOfReturnIsNotNull() ? voHomeLeave.getExpectedTimeOfReturn().toString(TimeFormat.FLAT4) : "";

		hlRec.Rescode = doAdmissionDetail.getWard() != null ? doAdmissionDetail.getWard().getExtCode(TaxonomyType.PAS.getID()) : null;
		hlRec.Mors = DTOHelper.getPasMapping(doAdmissionDetail.getWardType());
		if(doAdmissionDetail.getPasEvent().getPatient().getSex() != null)
		{
			if(doAdmissionDetail.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.MALE)))
				hlRec.Btyp = "M";
			else if(doAdmissionDetail.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.FEMALE)))
				hlRec.Btyp = "F";
			else
				//defaulting Male for unknown sex
				hlRec.Btyp = "M";
		}
		else
			//defaulting Male for unknown sex
			hlRec.Btyp = "M";	

		hlRec.Returndt = voHomeLeave.getDateReturnedFromHomeLeaveIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getDateReturnedFromHomeLeave().getDate()) : "";
		hlRec.Returntm = voHomeLeave.getTimeReturnedFromHomeLeaveIsNotNull() ? voHomeLeave.getTimeReturnedFromHomeLeave().toString(TimeFormat.FLAT4) : "";
		
//		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO"))
//			hlRec.Cflup = rec.Rescode;
		
		if (voHomeLeave.getID_HomeLeaveIsNotNull())
			hlRec.Hlfl = "N"; //"N" on an update
		else
			hlRec.Hlfl = "Y"; //"Y" on an insert
		
		hlRec.Webadt = "Y";				
	}

	private void copyHomeleaveToDto(Homeleave homeLeaveRec, HomeLeaveVo voHomeLeave, InPatientEpisodeADTVo inpatientEpisode)
	{
		HomeleaveRecord hlRec = homeLeaveRec.DataCollection.get(0);
	 	
		hlRec.Pkey = getPatientIdValue(inpatientEpisode, PatIdType.PKEY);
		hlRec.Hospnum = getPatientIdValue(inpatientEpisode, PatIdType.HOSPNUM);

		InpatientEpisode doInpat = InPatientEpisodeADTVoAssembler.extractInpatientEpisode(getDomainFactory(), inpatientEpisode);
		hlRec.Rescode = doInpat.getPasEvent() != null && doInpat.getPasEvent().getLocation() != null ? doInpat.getPasEvent().getLocation().getExtCode(TaxonomyType.PAS.getID()) : null;
		hlRec.Mors = DTOHelper.getPasMapping(doInpat.getWardType());

		hlRec.Leavedt = voHomeLeave.getDateOnHomeLeaveIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getDateOnHomeLeave().getDate()) : "";
		hlRec.Leavetm =  voHomeLeave.getTimeOnHomeLeaveIsNotNull() ? voHomeLeave.getTimeOnHomeLeave().toString(TimeFormat.FLAT4) : "";

		hlRec.Exdt = voHomeLeave.getExpectedDateOfReturnIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getExpectedDateOfReturn().getDate()) : "";
		hlRec.Extm = voHomeLeave.getExpectedTimeOfReturnIsNotNull() ? voHomeLeave.getExpectedTimeOfReturn().toString(TimeFormat.FLAT4) : "";
		if(hlRec.Mors.equals("M"))
		{
			if(doInpat.getPasEvent().getPatient().getSex() != null)
			{
				if(doInpat.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.MALE)))
					hlRec.Btyp = "M";
				else if(doInpat.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.FEMALE)))
					hlRec.Btyp = "F";
				else
					//defaulting Male for unknown sex
					hlRec.Btyp = "M";
			}
			else
				//defaulting Male for unknown sex
				hlRec.Btyp = "M";	
		}
		else if(hlRec.Mors.equals("S"))
			hlRec.Btyp = "S";
	

		hlRec.Hlfl = "Y"; //"Y" on an insert
		
		hlRec.Webadt = "Y";				
	}

	private String getPatientIdValue(InPatientEpisodeADTVo inpatientEpisode, PatIdType type) 
	{
		if(inpatientEpisode == null)
			return null;
		
		if(inpatientEpisode.getPasEvent() != null && inpatientEpisode.getPasEvent().getPatient() != null && inpatientEpisode.getPasEvent().getPatient().getIdentifiers() != null)
		{
			Iterator it = inpatientEpisode.getPasEvent().getPatient().getIdentifiers().iterator();
			while(it.hasNext())
			{
				ims.core.vo.PatientId patId = (ims.core.vo.PatientId) it.next();
				if(patId.getType().getId() == getDomLookup(type).getId())
					return patId.getValue();
			}
		}
		
		return null;
	}

	//wdev-14858
	public VTERiskAssessmentWorklistVo getVTERiskAssessmentWorklistById(InpatientEpisodeRefVo inpatEpRef) 
	{
		if(	inpatEpRef == null )
			return null;
		
		DomainFactory factory = getDomainFactory();
		InpatientEpisode doInpatientEpisode  =(InpatientEpisode) factory.getDomainObject(InpatientEpisode.class, inpatEpRef.getID_InpatientEpisode());
		return VTERiskAssessmentWorklistVoAssembler.create(doInpatientEpisode);
	}

	//wdev-14858
	public InpatientEpisodeForVTERiskAsessmentVo getInpatEpisodeForVTERiskAssessment( InpatientEpisodeRefVo inpatEpRef) 
	{
		if(	inpatEpRef == null )
			return null;
		
		DomainFactory factory = getDomainFactory();
		InpatientEpisode doInpatientEpisode  =(InpatientEpisode) factory.getDomainObject(InpatientEpisode.class, inpatEpRef.getID_InpatientEpisode());
		return InpatientEpisodeForVTERiskAsessmentVoAssembler.create(doInpatientEpisode);
	}

	//wdev-14858
	public VTERiskAssessmentShortVo getVTERiskAssessmentShortVoBYId( VTERiskAssessmentRefVo vTERef) 
	{

		if(vTERef == null || vTERef.getID_VTERiskAssessment() == null) //wdev-14944
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		VTERiskAssessment doVTERiskAssessment  =(VTERiskAssessment) factory.getDomainObject(VTERiskAssessment.class, vTERef.getID_VTERiskAssessment());
		return VTERiskAssessmentShortVoAssembler.create(doVTERiskAssessment);
		
	}
	//wdev-15042
	public InpatientEpisodeLiteVo geInpatientEpisodeLiteVoById(	InpatientEpisodeRefVo inparEpRef) 
	{
		if( inparEpRef == null || inparEpRef.getID_InpatientEpisode() == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		InpatientEpisode doInpatientEpisode = (InpatientEpisode) factory.getDomainObject(InpatientEpisode.class, inparEpRef.getID_InpatientEpisode());
				
		return InpatientEpisodeLiteVoAssembler.create(doInpatientEpisode);
	}

	//WDEV-15043
	public String getPIDDiagnosisInfo(CareContextRefVo careContextRefV, EpisodeOfCareRefVo episodeRefVo)
	{
		Alerts impl = (Alerts) getDomainImpl(AlertsImpl.class);
		return impl.getPIDDiagnosisInfo(careContextRefV, episodeRefVo);
	}

	//WDEV-15990
	public VTERiskAssessmentShortVoCollection getVTEByCareContext(CareContextRefVo careContextRef)
	{
		if (careContextRef == null)
			throw new CodingRuntimeException("Cannot get VTEs on null careContextRef");

		DomainFactory factory = getDomainFactory();
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		String query = "SELECT vte FROM VTERiskAssessment AS vte LEFT JOIN vte.careContext AS cc WHERE cc.id = :ID_CC";
		
		paramNames.add("ID_CC");
		paramValues.add(careContextRef.getID_CareContext());
		
		return VTERiskAssessmentShortVoAssembler.createVTERiskAssessmentShortVoCollectionFromVTERiskAssessment(factory.find(query.toString(), paramNames, paramValues));
	}

	public DischargedEpisodeADTVo getDischargedEpisodeADT(PASEventRefVo pasEventRef)
	{
		if (pasEventRef == null)
			throw new CodingRuntimeException("Cannot get DischargeEpisode on null PASEventRef");

		DomainFactory factory = getDomainFactory();
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		String query = "SELECT dis FROM DischargedEpisode AS dis LEFT JOIN dis.pasEvent AS pasev WHERE pasev.id = :ID_PASEV";
		
		paramNames.add("ID_PASEV");
		paramValues.add(pasEventRef.getID_PASEvent());
		
		DischargedEpisodeADTVoCollection dischargeEpisode = DischargedEpisodeADTVoAssembler.createDischargedEpisodeADTVoCollectionFromDischargedEpisode(factory.find(query.toString(), paramNames, paramValues));
		
		if (dischargeEpisode != null && dischargeEpisode.size() > 0)
		{
			return dischargeEpisode.get(0);
		}
		
		return null;
	}

	//WDEV-16030
	public BedSpaceStateLiteVo getBedSpaceStateStatusByBedId(BedSpaceStateRefVo bedSpaceRef)
	{
		if(bedSpaceRef == null || bedSpaceRef.getID_BedSpaceState() == null)
			throw new CodingRuntimeException("Cannot get BedSpaceState on null Id.");
		
		return BedSpaceStateLiteVoAssembler.create(	(BedSpaceState)		getDomainFactory().getDomainObject(BedSpaceState.class, bedSpaceRef.getID_BedSpaceState()));
	}

	//wdev-15414
	public DischargedEpisodeForVTERiskAssessmentWorklistVo getDischargedEpisodeForVTERiskAssessmentWorklistVo(DischargedEpisodeRefVo dischargeepisodeRef)
	{
		if( dischargeepisodeRef == null)
			throw new CodingRuntimeException("DischargeEpisode cannot be null");
		
		DomainFactory factory = getDomainFactory();
		DischargedEpisode doDischargedEpisode = (DischargedEpisode) factory.getDomainObject(DischargedEpisode.class, dischargeepisodeRef.getID_DischargedEpisode());
				
		return DischargedEpisodeForVTERiskAssessmentWorklistVoAssembler.create(doDischargedEpisode);
	}

	public LocationLiteVo getCurrentHospital(ILocation currentLocation) // 	WDEV-18012
	{
		if(currentLocation == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		Location currentHospital = getHospital((Location) factory.getDomainObject(Location.class, currentLocation.getID()));
		
		if(currentHospital instanceof Location)
			return LocationLiteVoAssembler.create((Location) currentHospital);
		
		return null;
	}
	
	private Location getHospital(Location doLocation)
	{
		if(doLocation == null)
			return null;
		
		if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
			return doLocation;
	
		while(doLocation.getParentLocation() != null) 
		{
			doLocation = doLocation.getParentLocation();
			if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
				return doLocation;
		}
		
		return null;
	}

	public Boolean hasCancelledElectiveListsToRemove(PatientRefVo patient, PatientElectiveListRefVo electiveList, ServiceRefVo service)
	{
		if (patient == null || patient.getID_Patient() == null)
			return Boolean.FALSE;
		
		if (service == null || service.getID_Service() == null)
			return Boolean.FALSE;
		
		StringBuilder query = new StringBuilder("SELECT COUNT(pel.id) FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service LEFT JOIN pel.patient AS patient LEFT JOIN pel.tCIDetails AS tci");
		query.append(" WHERE pel.id <> :PEL_ID AND patient.id = :PAT_ID AND service.id = :SERVICE_ID AND tci.isActive = 0");
		
		ArrayList<String> paramNames = new ArrayList<String>();							ArrayList<Object> paramValues = new ArrayList<Object>();
		paramNames.add("PEL_ID");														paramValues.add(electiveList.getID_PatientElectiveList());
		paramNames.add("PAT_ID");														paramValues.add(patient.getID_Patient());
		paramNames.add("SERVICE_ID");													paramValues.add(service.getID_Service());
		
		long count = getDomainFactory().countWithHQL(query.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray(new Object[paramValues.size()]));
		
		if (count > 0)
			return Boolean.TRUE;
		
		return Boolean.FALSE;
	}

	public PatientElectiveListBedAdmissionVo getPatientElectiveListForDischarge(PASEventRefVo pasEvent)
	{
		if (pasEvent == null || pasEvent.getID_PASEvent() == null)
			return null;
		
		// WDEV-18617  - For some reason only one pasevent being created so have to get the most recent
		StringBuilder query = new StringBuilder("SELECT adm from AdmissionDetail adm LEFT JOIN adm.pasEvent AS pas ");
		
		//StringBuilder query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.referral AS cats LEFT JOIN cats.careContext AS context LEFT JOIN context.pasEvent AS pas ");
		query.append(" WHERE pas.id = :PAS_ID");
		query.append(" order by adm.admissionDateTime desc ");
		
		ArrayList<String> paramNames = new ArrayList<String>();		
		ArrayList<Object> paramValues = new ArrayList<Object>();
		paramNames.add("PAS_ID");														
		paramValues.add(pasEvent.getID_PASEvent());
		
		AdmissionDetail domAdmission = (AdmissionDetail) getDomainFactory().findFirst(query.toString(), paramNames, paramValues);
		
		// WDEV-18617  - Get the ELE for this pas event - not the first one for the Referral!!!
		query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.tCIDetails AS tci LEFT JOIN tci.admissionDetail AS adm ");
		
		//StringBuilder query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.referral AS cats LEFT JOIN cats.careContext AS context LEFT JOIN context.pasEvent AS pas ");
		query.append(" WHERE adm.id = :ADM_ID");
		
		
		paramNames = new ArrayList<String>();
		paramValues = new ArrayList<Object>();
		paramNames.add("ADM_ID");				
		paramValues.add(domAdmission.getId());
		
		return PatientElectiveListBedAdmissionVoAssembler.create((PatientElectiveList) getDomainFactory().findFirst(query.toString(), paramNames, paramValues));
	}

	public PatientElectiveListBedAdmissionVoCollection getCancelledElectiveListsToRemove(PatientRefVo patient, PatientElectiveListRefVo electiveList, ServiceRefVo service)
	{
		if (patient == null || patient.getID_Patient() == null)
			return null;
		
		if (service == null || service.getID_Service() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service LEFT JOIN pel.patient AS pat LEFT JOIN pel.tCIDetails AS tci");
		query.append(" WHERE pel.id <> :PEL_ID AND patient.id = :PAT_ID AND service.id = :SERVICE_ID AND tci.isActive = 0");
		
		ArrayList<String> paramNames = new ArrayList<String>();							ArrayList<Object> paramValues = new ArrayList<Object>();
		paramNames.add("PEL_ID");														paramValues.add(electiveList.getID_PatientElectiveList());
		paramNames.add("PAT_ID");														paramValues.add(patient.getID_Patient());
		paramNames.add("SERVICE_ID");													paramValues.add(service.getID_Service());
		
		return PatientElectiveListBedAdmissionVoAssembler.createPatientElectiveListBedAdmissionVoCollectionFromPatientElectiveList(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	//WDEV-18454
	public Boolean hasElectiveListsToRemove(PatientRefVo patientRef, PatientElectiveListRefVo electiveListRef, Specialty specialty)
	{
		if (patientRef == null || patientRef.getID_Patient() == null)
			return Boolean.FALSE;
		
		if (specialty == null)
			return Boolean.FALSE;
		
		StringBuilder query = new StringBuilder("SELECT COUNT(pel.id) FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service LEFT JOIN service.specialty AS specialty LEFT JOIN pel.patient AS patient LEFT JOIN pel.electiveListStatus AS elStatus LEFT JOIN elStatus.electiveListStatus as eleListStatus");
		query.append(" WHERE patient.id = :PAT_ID AND specialty.id = :SPECIALTY_ID AND eleListStatus.id <> :STATUS_ID ");
		
		if (electiveListRef != null)
			query.append(" AND pel.id <> :PEL_ID ");
		
		ArrayList<String> paramNames = new ArrayList<String>();	
		ArrayList<Object> paramValues = new ArrayList<Object>();
																
		paramNames.add("PAT_ID");	
		paramValues.add(patientRef.getID_Patient());
		paramNames.add("SPECIALTY_ID");		
		paramValues.add(specialty.getID());
		paramNames.add("STATUS_ID");		
		paramValues.add(WaitingListStatus.REMOVED.getID());
		
		if (electiveListRef != null)
		{
			paramNames.add("PEL_ID");
			paramValues.add(electiveListRef.getID_PatientElectiveList());
		}
		long count = getDomainFactory().countWithHQL(query.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray(new Object[paramValues.size()]));
		
		if (count > 0)
			return Boolean.TRUE;
		
		return Boolean.FALSE;
	}

	public PatientElectiveListBedAdmissionVoCollection getElectiveListsToRemove(PatientRefVo patientRef, PatientElectiveListRefVo electiveListRef, Specialty specialty)
	{
		if (patientRef == null || patientRef.getID_Patient() == null)
			return null;
		
		if (specialty == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		StringBuilder query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service LEFT JOIN service.specialty AS specialty LEFT JOIN pel.patient AS patient LEFT JOIN pel.electiveListStatus AS elStatus LEFT JOIN elStatus.electiveListStatus as eleListStatus");
		query.append(" WHERE patient.id = :PAT_ID AND specialty.id = :SPECIALTY_ID AND eleListStatus.id <> :STATUS_ID ");
		
		if (electiveListRef != null)
			query.append(" AND pel.id <> :PEL_ID ");
		
		ArrayList<String> paramNames = new ArrayList<String>();	
		ArrayList<Object> paramValues = new ArrayList<Object>();
																
		paramNames.add("PAT_ID");	
		paramValues.add(patientRef.getID_Patient());
		paramNames.add("SPECIALTY_ID");		
		paramValues.add(specialty.getID());
		paramNames.add("STATUS_ID");		
		paramValues.add(WaitingListStatus.REMOVED.getID());
		
		if (electiveListRef != null)
		{
			paramNames.add("PEL_ID");
			paramValues.add(electiveListRef.getID_PatientElectiveList());
		}
		
		return PatientElectiveListBedAdmissionVoAssembler.createPatientElectiveListBedAdmissionVoCollectionFromPatientElectiveList(factory.find(query.toString(), paramNames, paramValues));
	}

	public PatientShortCollection getPatientsForCurrentBay(LocationRefVo currentBay)
	{
		StringBuilder query = new StringBuilder();
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
 
		query.append("SELECT patients FROM InpatientEpisode AS inpEp LEFT JOIN inpEp.pasEvent AS pasEv ");
		query.append("LEFT JOIN pasEv.patient AS patients ");
		query.append("LEFT JOIN inpEp.bed AS bed ");
		query.append("LEFT JOIN bed.bay AS patientBay ");
		
		query.append("WHERE patientBay.id = :bay ");
		paramNames.add("bay");
		paramValues.add(currentBay.getID_Location());
		
		return PatientShortAssembler.createPatientShortCollectionFromPatient(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

}
