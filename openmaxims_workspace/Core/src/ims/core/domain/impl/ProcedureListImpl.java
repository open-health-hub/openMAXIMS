//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Rory Fitzpatrick using IMS Development Environment (version 1.20 build 40902.1730)
// Copyright (C) 1995-2004 IMS MAXIMS plc. All rights reserved.

package ims.core.domain.impl;

import ims.admin.helper.Keywords;
import ims.configuration.gen.ConfigFlag;
import ims.core.clinical.domain.objects.Procedure;
import ims.core.clinical.domain.objects.TaxonomyMap;
import ims.core.clinical.vo.ProcedureRefVo;
import ims.core.resource.domain.objects.ServiceActivityExport;
import ims.core.resource.place.vo.ActivityRefVo;
import ims.core.vo.ActivityVo;
import ims.core.vo.LocationServiceActivityVoCollection;
import ims.core.vo.ProcedureLiteVo;
import ims.core.vo.ProcedureLiteVoCollection;
import ims.core.vo.ProcedureVo;
import ims.core.vo.ProcedureVoCollection;
import ims.core.vo.ServiceActivityVo;
import ims.core.vo.ServiceActivityVoCollection;
import ims.core.vo.domain.LocationServiceActivityVoAssembler;
import ims.core.vo.domain.ProcedureLiteVoAssembler;
import ims.core.vo.domain.ProcedureVoAssembler;
import ims.core.vo.domain.ServiceActivityVoAssembler;
import ims.core.vo.domain.TaxonomyMapAssembler;
import ims.core.vo.lookups.TaxonomyType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.domain.impl.DomainImpl;
import ims.ntpf.vo.ServiceActivityExportVoCollection;
import ims.ntpf.vo.domain.ServiceActivityExportVoAssembler;

import java.util.ArrayList;
import java.util.List;

public class ProcedureListImpl extends DomainImpl implements ims.core.domain.ProcedureList, ims.domain.impl.Transactional
{
	private static final long serialVersionUID = 1L;
	
	public ProcedureVo saveProcedureLite(ProcedureLiteVo procVo) throws StaleObjectException, UniqueKeyViolationException, DomainInterfaceException
	{
		ProcedureVo proc = new ProcedureVo(procVo.getID_Procedure(), procVo.getVersion_Procedure());
		proc.setIsActive(procVo.getIsActive());
		proc.setProcedureName(procVo.getProcedureName().trim());//wdev-1336
		proc.setProcedureStatus(procVo.getProcedureStatus());
		String[] arrErrors = proc.validate();
		if( arrErrors != null)
		{
			throw new DomainRuntimeException("Error saving Procedure - Procedure not validated correctly");
		}
		return saveProcedureVo(proc, false);
	}

	
	public ServiceActivityVo checkForServiceActivityUsingChangedProcedure(ActivityRefVo activityRefVo)
	{
		DomainFactory factory = getDomainFactory();	
		
		if( activityRefVo == null )
			throw new DomainRuntimeException("checkForServiceActivityUsingChangedProcedure : activityRefVo is Null.");
		
		//wdev3999 - ignore inactive records in this check
		java.util.List servactList = factory.find("from ServiceActivity servact join servact.taxonomyMap tax where servact.activity.id = :activityid and tax.taxonomyName = :taxname and servact.isActive = :isActive", new String[]{"activityid", "taxname", "isActive"}, new Object[]{activityRefVo.getID_Activity(), getDomLookup(TaxonomyType.EXCH), Boolean.TRUE});
		ServiceActivityVoCollection coll = ServiceActivityVoAssembler.createServiceActivityVoCollectionFromServiceActivity(servactList).sort();

		if(coll != null && coll.size() > 0)
			return coll.get(0);
		
		return null;
	}

	public ProcedureVo saveProcedureVo(ProcedureVo voProcedureVo, Boolean bNoLocationServiceActivityChecks) throws DomainInterfaceException, StaleObjectException, UniqueKeyViolationException
	{
		if (!voProcedureVo.isValidated())
		{
			throw new DomainRuntimeException("This ProcedureVo has not been validated");
		}
		
		DomainFactory factory = getDomainFactory();		

		// We need to ensure that the taxonomy map is not duplicated - based on Taxonomy and map
		voProcedureVo.setProcedureName(voProcedureVo.getProcedureName().trim());//wdev-1336
		
		// Bug Fix - WDEV-1896 
		if (!voProcedureVo.getID_ProcedureIsNotNull())
		{
			List l = factory.find("from Procedure p where upper(p.procedureName) = :procName", new String[]{"procName"}, new Object[]{voProcedureVo.getProcedureName().toUpperCase()});
			if (l.size() > 0)
				throw new UniqueKeyViolationException("Procedure record called \"" + voProcedureVo.getProcedureName() + "\" already exists. Duplicates not allowed.");
		}
		
		//Check to see if the Procedure has been already save and if the Name is changed.....
		//....if so confirm the throw an Exception if it is already saved against a Procedure 
		if (voProcedureVo.getID_ProcedureIsNotNull() 
			&& ! ConfigFlag.DOM.ENABLE_EXCHEQUER_CODES_VALIDATION.getValue())
		{
			Procedure doProc = (Procedure) factory.getDomainObject(Procedure.class, voProcedureVo.getID_Procedure());
			if ( ! doProc.getProcedureName().equals(voProcedureVo.getProcedureName()))
			{
				if (checkForServiceActivityUsingChangedProcedure(voProcedureVo.getActivity()) != null)
					throw new DomainRuntimeException("Error saving Procedure name change - Procedure is already saved against a Specialty with an Exchequer code.");
			}
		}

		//Check to see if a changed EXCH code for a procedure that is already linked to specialty
		if (voProcedureVo.getID_ProcedureIsNotNull() 
			&& ConfigFlag.DOM.ENABLE_EXCHEQUER_CODES_VALIDATION.getValue()
			&& bNoLocationServiceActivityChecks == false)
		{
			Procedure doProc = (Procedure) factory.getDomainObject(Procedure.class, voProcedureVo.getID_Procedure());
			
			for(int i = 0 ; i < voProcedureVo.getTaxonomyMap().size() ; i++)
			{
				//Has an EXCH code in the data to save
				if (voProcedureVo.getTaxonomyMap().get(i).getTaxonomyName().equals(TaxonomyType.EXCH)) 
				{
					//Check the DOM object EXCH code is different
					for(int j = 0 ; j < doProc.getTaxonomyMap().size() ; j++)
					{
						if (((TaxonomyMap)doProc.getTaxonomyMap().get(j)).getTaxonomyName().equals(getDomLookup(TaxonomyType.EXCH))
								&& ! ((TaxonomyMap)doProc.getTaxonomyMap().get(j)).getTaxonomyCode().equals(voProcedureVo.getTaxonomyMap().get(i).getTaxonomyCode()))
						{
							// If diff then check to see if it is used in a Specialty link.....if so fail.
							if (checkForServiceActivityUsingChangedProcedure(voProcedureVo.getActivity()) != null)
								throw new DomainRuntimeException("Error saving Procedure Exchequer Code change - Procedure is already saved against a Specialty.");
						}
						
					}
				}
			}
		}

		Procedure domProcedure = ProcedureVoAssembler.extractProcedure(factory, voProcedureVo);
		domProcedure.setKeywords(Keywords.setupKeyWords(domProcedure.getKeywords(), domProcedure.getProcedureName()));
		
		try
		{
			domProcedure.getTaxonomyMap().clear();
			domProcedure.setTaxonomyMap(TaxonomyMapAssembler.extractTaxonomyMapList(factory, voProcedureVo.getTaxonomyMap()));

			factory.save(domProcedure);
		}
		catch(UnqViolationUncheckedException e)
		{
			//check which constraint was violated (name/taxononmy map)
			
			///name
			Procedure proc = Procedure.getProcedureFromProcedureName(factory, voProcedureVo.getProcedureName());
			if (proc != null && proc.getId() != null && !(proc.getId().equals(voProcedureVo.getID_Procedure())))
			{
				throw new UniqueKeyViolationException("Procedure record called \"" + voProcedureVo.getProcedureName() + "\" already exists. Duplicates not allowed.", e);	
			}
							
			//taxonomy map
			String dupMessage = Keywords.checkDuplicateTaxonomy(factory, domProcedure, voProcedureVo.getTaxonomyMap(), "getProcedureName");
			if(dupMessage != null)
				throw new UniqueKeyViolationException(dupMessage);
						
			throw (e);
		}
		
		return ProcedureVoAssembler.create(domProcedure);
	}
	
	public ProcedureVo getProcedureVo(ProcedureRefVo voProcedureVo) 
	{
		DomainFactory factory = getDomainFactory();
		Procedure doProc = (Procedure) factory.getDomainObject(Procedure.class, voProcedureVo.getID_Procedure());
		return (ProcedureVoAssembler.create(doProc));
	}
	
	public LocationServiceActivityVoCollection listProcedureinLocationServiceActivity(ActivityVo voActivity)
	{
		DomainFactory factory = getDomainFactory();
		
		String hql = " from LocationServiceActivity locServiceActivity "; 
		StringBuffer condStr = new StringBuffer();
		String andStr = " ";
	
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
	
		if(voActivity != null)
		{	
			if(voActivity.getIsActiveIsNotNull())
			{
				condStr.append(andStr + " locServiceActivity.serviceActivity.activity.isActive = :isActive"); 
				markers.add("isActive");
				values.add(voActivity.getIsActive());
				andStr = " and ";
			}
			if(voActivity.getNameIsNotNull() && !voActivity.getID_ActivityIsNotNull())
			{
				condStr.append(andStr + " upper(locServiceActivity.serviceActivity.activity.name) like :activityName"); 
				markers.add("activityName");
				values.add("%" + voActivity.getName().toUpperCase() + "%");
				andStr = " and ";
			}
			else if(voActivity.getID_ActivityIsNotNull())
			{
				condStr.append(andStr + "locServiceActivity.serviceActivity.activity.id = :activityId"); 
				markers.add("activityId");
				values.add(voActivity.getID_Activity());
				andStr = " and ";
			}
		}
		
		if (andStr.equals(" and "))
			hql += " where ";

		hql += condStr.toString();
		return LocationServiceActivityVoAssembler.createLocationServiceActivityVoCollectionFromLocationServiceActivity(factory.find(hql, markers, values)).sort();
	}
		
	public ProcedureLiteVoCollection listAllProcedures(String filter) throws DomainInterfaceException
	{
		return ProcedureLiteVoAssembler.createProcedureLiteVoCollectionFromProcedure(listDomProcedures(filter,false)).sort();
	}

	public ProcedureLiteVoCollection listActiveProcedures(String filter) throws DomainInterfaceException
	{
		return ProcedureLiteVoAssembler.createProcedureLiteVoCollectionFromProcedure(listDomProcedures(filter,true)).sort();
	}

	private List listDomProcedures(String filter, boolean activeOnly) throws DomainInterfaceException 
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer(" from Procedure proc join proc.keywords as kw "); 
		ArrayList names = new ArrayList();
		ArrayList values = new ArrayList();
		
		if (activeOnly)
		{
			hql.append(" where proc.isActive = :isActive");
			names.add("isActive");
			values.add(Boolean.TRUE);	
		}
		return Keywords.searchByKeywords(factory, filter, hql.toString(), names, values);		
	}

	public ProcedureVoCollection listActiveFullProcedures(String filter) throws DomainInterfaceException 
	{
		return ProcedureVoAssembler.createProcedureVoCollectionFromProcedure(listDomProcedures(filter,true)).sort();
	}


	public Boolean isProcedureExported(ProcedureVo procVo)
	{
		DomainFactory factory = getDomainFactory();
		
//		String hql = "select from ServiceActivity sa where sa.activity = X and sa.id in (select serviceact from ServiceActivityExport)"; 
		String hql = "from ServiceActivity sa where"; 
		StringBuffer condStr = new StringBuffer();
		String andStr = " ";
	
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
	
		condStr.append(andStr + " sa.activity.id = :procid"); 
		markers.add("procid");
		values.add(procVo.getActivity().getID_Activity());
		condStr.append(" and sa.id in (select serviceActivity from ServiceActivityExport)"); 

		hql += condStr.toString();
		if (factory.find(hql, markers, values).size() > 0)
			return true;
		else
			return false;
	}

	public Boolean updateServiceActivityExportRecords(ProcedureVo procVo) throws StaleObjectException, ForeignKeyViolationException
	{
		DomainFactory factory = getDomainFactory();

		ServiceActivityExportVoCollection collSERACT = ServiceActivityExportVoAssembler.
			createServiceActivityExportVoCollectionFromServiceActivityExport(factory.find("from ServiceActivityExport sax where sax.serviceActivity in (select sa.id from ServiceActivity sa where sa.activity.id = :actID )", new String[]{"actID"}, new Object[]{procVo.getActivity().getID_Activity()}));
		
		for (int i = 0 ; i < collSERACT.size() ; i++)
		{
			ServiceActivityExport doSerActExport = ServiceActivityExportVoAssembler.extractServiceActivityExport(factory, collSERACT.get(i));

			doSerActExport.setReadyForExport(true);
	//		doSerActExport.setDateLastExported(null);
			
			factory.save(doSerActExport);
		}
		
		return true;

	}


	public ServiceActivityExportVoCollection listServiceActivityExports() throws DomainInterfaceException
	{
		// TODO Auto-generated method stub
		return null;
	}


	public ServiceActivityVoCollection listProcedureinServiceActivity(ActivityVo activityVo)
	{
		DomainFactory factory = getDomainFactory();
		
		String hql = " from ServiceActivity serActivity "; 
		StringBuffer condStr = new StringBuffer();
		String andStr = " ";
	
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
	
		if(activityVo != null)
		{	
			if(activityVo.getIsActiveIsNotNull())
			{
				condStr.append(andStr + " serActivity.isActive = :isActive"); 
				markers.add("isActive");
				values.add(activityVo.getIsActive());
				andStr = " and ";
			}
			if(activityVo.getNameIsNotNull() && !activityVo.getID_ActivityIsNotNull())
			{
				condStr.append(andStr + " upper(serActivity.activity.name) like :activityName"); 
				markers.add("activityName");
				values.add("%" + activityVo.getName().toUpperCase() + "%");
				andStr = " and ";
			}
			else if(activityVo.getID_ActivityIsNotNull())
			{
				condStr.append(andStr + "serActivity.activity.id = :activityId"); 
				markers.add("activityId");
				values.add(activityVo.getID_Activity());
				andStr = " and ";
			}
		}
		
		if (andStr.equals(" and "))
			hql += " where ";

		hql += condStr.toString();
		return ServiceActivityVoAssembler.createServiceActivityVoCollectionFromServiceActivity(factory.find(hql, markers, values)).sort();
	}

}
