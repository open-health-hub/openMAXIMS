//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Cristian Belciug using IMS Development Environment (version 1.71 build 3896.19006)
// Copyright (C) 1995-2010 IMS MAXIMS. All rights reserved.

package ims.core.domain.impl;

import java.util.ArrayList;
import java.util.List;

import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.ProviderSystem;
import ims.core.admin.vo.ProviderSystemRefVo;
import ims.core.domain.base.impl.BaseHL7QueryImpl;
import ims.core.vo.PatientId;
import ims.core.vo.lookups.PatIdType;
import ims.domain.DomainFactory;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.DateTime;
import ims.hl7.domain.objects.HL7Inbound;
import ims.hl7.domain.objects.HL7Outbound;
import ims.hl7.vo.HL7InboundSaveVo;
import ims.hl7.vo.domain.HL7InboundSaveVoAssembler;
import ims.hl7.vo.domain.HL7InboundVoAssembler;
import ims.hl7.vo.domain.HL7OutboundSaveVoAssembler;
import ims.hl7.vo.domain.HL7OutboundVoAssembler;
import ims.hl7.vo.lookups.MessageType;
import ims.ocrr.vo.ProviderSystemLiteVoCollection;
import ims.ocrr.vo.domain.ProviderSystemLiteVoAssembler;
import ims.vo.interfaces.IHL7Query;

public class HL7QueryImpl extends BaseHL7QueryImpl
{

	private static final long serialVersionUID = 1L;

	public HL7InboundSaveVo saveInboundHL7Message(ims.hl7.vo.HL7InboundSaveVo inboundMessage) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		if(inboundMessage == null)
			throw new CodingRuntimeException("Can not save a null HL7Inbound.");
		
		if(!inboundMessage.isValidated())
			throw new CodingRuntimeException("HL7InboundVo is not validate.");
		
		DomainFactory factory = getDomainFactory();
		
		HL7Inbound doInboundMessage = HL7InboundSaveVoAssembler.extractHL7Inbound(factory, inboundMessage);
		factory.save(doInboundMessage);
		
		return HL7InboundSaveVoAssembler.create(doInboundMessage);
	}

	public ims.hl7.vo.HL7OutboundSaveVo saveOutboundHL7Message(ims.hl7.vo.HL7OutboundSaveVo outboundMessage) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		if(outboundMessage == null)
			throw new CodingRuntimeException("Can not save a null HL7Outbound.");
		
		if(!outboundMessage.isValidated())
			throw new CodingRuntimeException("HL7OutboundSaveVo is not validate.");
		
		DomainFactory factory = getDomainFactory();
		
		HL7Outbound doOutboundMessage = HL7OutboundSaveVoAssembler.extractHL7Outbound(factory, outboundMessage);
		factory.save(doOutboundMessage);
		
		return HL7OutboundSaveVoAssembler.create(doOutboundMessage);
	}

	public ProviderSystemLiteVoCollection listProviderSystems()
	{
		DomainFactory factory = getDomainFactory();
		return ProviderSystemLiteVoAssembler.createProviderSystemLiteVoCollectionFromProviderSystem(factory.listDomainObjects(ProviderSystem.class)).sort();
	}

	public IHL7Query[] listInboundMessages(DateTime startDate, DateTime endDate, PatientId patientId, MessageType messageType, ProviderSystemRefVo provider, Boolean viewFailedMessagesOnly, Boolean viewFailedByProviderSystem)
	{
		DomainFactory factory = getDomainFactory();
		
		StringBuffer hql = new StringBuffer();
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		String query = "select hli from HL7Inbound as hli";
		
		if(startDate != null)
		{
			if(markers.size() > 0)
				hql.append(" and ");
			
			hql.append("hli.messageDateTime >= :starDate");
			markers.add("starDate");
			values.add(startDate.getJavaDate());
		}
		
		if(endDate != null)
		{
			if(markers.size() > 0)
				hql.append(" and ");
			
			hql.append("hli.messageDateTime <= :endDate");
			markers.add("endDate");
			values.add(endDate.getJavaDate());
		}
		
		if(patientId != null && patientId.getTypeIsNotNull() && patientId.getValueIsNotNull())
		{
			query += " left join hli.patient as p left join p.identifiers as i left join i.type as t";
			
			if(markers.size() > 0)
				hql.append(" and ");
			
			hql.append("t.id = :pidType");
			markers.add("pidType");
			values.add(patientId.getType().getID());
			
			String idVal = patientId.getValue().trim();			
			if(!ConfigFlag.DOM.CASE_SENSITIVE_PATID.getValue())
			{
				idVal = idVal.toUpperCase();
			}

			if (patientId.getType().equals(PatIdType.NHSN))
			{
				idVal = idVal.replace(" ", "");
				hql.append(" and i.value like :idValue");
				idVal += "%";
			}
			else
				hql.append(" and i.value = :idValue");
			
			markers.add("idValue");
			values.add(idVal);	
		}
		
		if(messageType != null)
		{
			if(markers.size() > 0)
				hql.append(" and ");
			
			hql.append("(hli.messageType.id = :msgType or hli.messageType.parent.id = :msgType)");
			markers.add("msgType");
			values.add(messageType.getID());
		}
		
		if(provider != null)
		{
			if(markers.size() > 0)
				hql.append(" and ");
			
			hql.append("hli.providerSystem.id = :providerId");
			markers.add("providerId");
			values.add(provider.getID_ProviderSystem());
		}
		
		if (markers.size() > 0)
			query += " where ";
		query += hql.toString();
		
		if(Boolean.TRUE.equals(viewFailedMessagesOnly))
		{
			query += (markers.size() > 0 ? " and " : " where ") + "hli.failureMessage is not null";
			
			if(Boolean.TRUE.equals(viewFailedByProviderSystem))
			{
				query += " and hli.successfulOutcome = 0";
			}	
		}
		
		query += " order by hli.messageDateTime desc";
		
		List inboundMessages = factory.find(query, markers, values);
		
		return HL7InboundVoAssembler.createHL7InboundVoCollectionFromHL7Inbound(inboundMessages).toIHL7QueryArray();
	}

	public IHL7Query[] listOutboundMessages(DateTime startDate, DateTime endDate, PatientId patientId, MessageType messageType, ProviderSystemRefVo provider, Boolean viewFailedMessagesOnly, Boolean viewFailedByProviderSystem)
	{
		DomainFactory factory = getDomainFactory();
		
		StringBuffer hql = new StringBuffer();
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		String query = "select hlo from HL7Outbound as hlo";
		
		if(startDate != null)
		{
			if(markers.size() > 0)
				hql.append(" and ");
			
			hql.append("hlo.messageSentDateTime >= :starDate");
			markers.add("starDate");
			values.add(startDate.getJavaDate());
		}
		
		if(endDate != null)
		{
			if(markers.size() > 0)
				hql.append(" and ");
			
			hql.append("hlo.messageSentDateTime <= :endDate");
			markers.add("endDate");
			values.add(endDate.getJavaDate());
		}
		
		if(patientId != null && patientId.getTypeIsNotNull() && patientId.getValueIsNotNull())
		{
			query += " left join hlo.patient as p left join p.identifiers as i left join i.type as t";
			
			if(markers.size() > 0)
				hql.append(" and ");
			
			hql.append("t.id = :pidType");
			markers.add("pidType");
			values.add(patientId.getType().getID());
			
			String idVal = patientId.getValue().trim();			
			if(!ConfigFlag.DOM.CASE_SENSITIVE_PATID.getValue())
			{
				idVal = idVal.toUpperCase();
			}

			if (patientId.getType().equals(PatIdType.NHSN))
			{
				idVal = idVal.replace(" ", "");
				hql.append(" and i.value like :idValue");
				idVal += "%";
			}
			else
				hql.append(" and i.value = :idValue");
			
			markers.add("idValue");
			values.add(idVal);	
		}
		
		if(messageType != null)
		{
			if(markers.size() > 0)
				hql.append(" and ");
			
			hql.append("(hlo.messageType.id = :msgType or hlo.messageType.parent.id = :msgType)");
			markers.add("msgType");
			values.add(messageType.getID());
		}
		
		if(provider != null)
		{
			if(markers.size() > 0)
				hql.append(" and ");
			
			hql.append("hlo.providerSystem.id = :providerId");
			markers.add("providerId");
			values.add(provider.getID_ProviderSystem());
		}
		
		if (markers.size() > 0)
			query += " where ";
		query += hql.toString();
		
		if(Boolean.TRUE.equals(viewFailedMessagesOnly))
		{
			query += (markers.size() > 0 ? " and " : " where ") + "hlo.failureMessage is not null";
			
			if(Boolean.TRUE.equals(viewFailedByProviderSystem))
			{
				query += " and hlo.successfulOutcome = 0";
			}	
		}
		
		query += " order by hlo.messageSentDateTime desc";
		
		List outboundMessages = factory.find(query, markers, values);
		
		return HL7OutboundVoAssembler.createHL7OutboundVoCollectionFromHL7Outbound(outboundMessages).toIHL7QueryArray();
	}
}
