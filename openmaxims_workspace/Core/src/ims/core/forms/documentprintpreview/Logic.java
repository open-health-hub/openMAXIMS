//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by George Cristian Josan using IMS Development Environment (version 1.80 build 4091.21781)
// Copyright (C) 1995-2011 IMS MAXIMS. All rights reserved.

package ims.core.forms.documentprintpreview;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

import com.ims.query.builder.client.QueryBuilderClient;
import com.ims.query.builder.client.exceptions.QueryBuilderClientException;

import ims.configuration.gen.ConfigFlag;
import ims.core.vo.PatientDocumentVo;
import ims.framework.enumerations.DialogResult;
import ims.framework.enumerations.PrinterScope;
import ims.framework.exceptions.PresentationLogicException;

public class Logic extends BaseLogic
{
	private static final long serialVersionUID = 1L;

	@Override
	protected void onFormOpen(Object[] args) throws PresentationLogicException
	{
		initialize();
		
		open(args);
	}

	@Override
	protected void onBtnCloseClick() throws ims.framework.exceptions.PresentationLogicException
	{
		engine.close(DialogResult.OK);
	}
	
	@Override
	protected void onChkAllPrintersValueChanged() throws ims.framework.exceptions.PresentationLogicException
	{
		if (form.chkAllPrinters().getValue())
		{
			form.ccServerPrinters().initialize(null, PrinterScope.DEFAULT, true);			
		}
		else
		{
			form.ccServerPrinters().initialize(engine.getCurrentLocation(), PrinterScope.DEFAULT, true);			
		}		
	}
	
	@Override
	protected void onBtnPrintClick() throws ims.framework.exceptions.PresentationLogicException
	{
		if (form.ccServerPrinters().getSelectedPrinter() == null)
		{
			engine.showMessage("No server printers selected");
			return;
		}
		
		printDocument(form.ccServerPrinters().getSelectedPrinter().getIPrinterName());
		
		engine.close(DialogResult.OK);//WDEV-13680
	}

	private void initialize()
	{
		// Initialise printers custom control
		form.ccServerPrinters().initialize(engine.getCurrentLocation(), PrinterScope.DEFAULT, true);
		form.ccServerPrinters().setIsRequired(true);//	WDEV-13680
	}

	/**
	 * 	Function will present (preview) the document based on arguments passed to dialog
	 */
	private void open(Object[] args) throws PresentationLogicException
	{
		if (args == null || args.length != 3)
			throw new PresentationLogicException("No valid document found in open arguments");
		
		// Check parameters type
		if (!(args[0] instanceof PatientDocumentVo) || !(args[1] instanceof String) || !(args[2] instanceof String))
			throw new PresentationLogicException("No valid path found in open arguments");

		StringBuilder filePath = new StringBuilder();
		StringBuilder previewPath = new StringBuilder();
		
		
		if (args[1] instanceof String)
		{
			filePath.append((String) args[1]);

			if (!(filePath.toString().endsWith("/") || filePath.toString().endsWith("\\")))
				filePath.append("/");
		}
		
		if (args[2] instanceof String)
		{
			previewPath.append((String) args[2]);
			
			if (!(filePath.toString().endsWith("/") || filePath.toString().endsWith("\\")))
				filePath.append("/");
		}

		if (args[0] instanceof PatientDocumentVo)
		{
			String fileName = ((PatientDocumentVo)args[0]).getServerDocument().getFileName();
			filePath.append(fileName);
			previewPath.append(fileName);
		}
		
		form.getLocalContext().setFilePath(filePath.toString());

		form.htmDocument().setHTML("<IFRAME id=\"PostFrame\" name=\"PostFrame\" width=\"100%\" height=\"100%\" frameborder=0 src='"	+ previewPath.toString() + "'></IFRAME>");
	}

	/**
	 * Function used to print document to printer (uses QueryBuilderClient but bypasses query server)
	 * @param printerName
	 */
	private void printDocument(String printerName)
	{
		String urlQueryServer = ConfigFlag.GEN.QUERY_SERVER_URL.getValue();
		String urlReportServer = ConfigFlag.GEN.REPORT_SERVER_URL.getValue();
		QueryBuilderClient client = new QueryBuilderClient(urlQueryServer, engine.getSessionId());
		
		try
		{
			client.printReport(readFile(form.getLocalContext().getFilePath()), urlReportServer, printerName, 1);
			
			engine.showMessage("Document printed to: " + printerName); //WDEV-15422
		}
		catch (QueryBuilderClientException e)
		{
			engine.showMessage("Could not print document.");
			e.printStackTrace();
		}
	}	


	/**
	 * Function will read file from filePath and returns it as a byte array - used for printing
	 */
	private byte[] readFile(String filePath)
	{
		File pdf = new File(filePath);
		long size = pdf.length();

		if (size == 0)
		{
			return null;
		}

		FileInputStream fileInputStream = null;
		byte[] buffer = null;

		try
		{
			fileInputStream = new FileInputStream(pdf);
			int bytesAvailable = fileInputStream.available();
			int maxBufferSize = (int) size;
			int bufferSize = bytesAvailable; //Math.min(bytesAvailable, maxBufferSize);
			buffer = new byte[bufferSize];
			int bytesRead = fileInputStream.read(buffer, 0, bufferSize);
			while (bytesRead > 0)
			{
				bytesAvailable = fileInputStream.available();
				bufferSize = Math.min(bytesAvailable, maxBufferSize);
				bytesRead = fileInputStream.read(buffer, 0, bufferSize);
			}

		}
		catch (IOException e)
		{
			buffer = null;
			e.printStackTrace();
		}
		finally
		{
			try
			{
				fileInputStream.close();
			}
			catch (IOException e)
			{

			}
		}

		return buffer;
	}
}
