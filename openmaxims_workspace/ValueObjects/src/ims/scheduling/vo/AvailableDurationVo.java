//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Barbara Worwood using IMS Development Environment (version 1.80 build 5007.25751)
// Copyright (C) 1995-2014 IMS MAXIMS. All rights reserved.
// WARNING: DO NOT MODIFY the content of this file

package ims.scheduling.vo;


public class AvailableDurationVo extends ims.vo.ValueObject implements ims.vo.ImsCloneable, Comparable
{
	private static final long serialVersionUID = 1L;

	public AvailableDurationVo()
	{
	}
	public AvailableDurationVo(ims.scheduling.vo.beans.AvailableDurationVoBean bean)
	{
		this.starttm = bean.getStartTm() == null ? null : bean.getStartTm().buildTime();
		this.endtm = bean.getEndTm() == null ? null : bean.getEndTm().buildTime();
		// Interface field type not supported.
	}
	public void populate(ims.vo.ValueObjectBeanMap map, ims.scheduling.vo.beans.AvailableDurationVoBean bean)
	{
		this.starttm = bean.getStartTm() == null ? null : bean.getStartTm().buildTime();
		this.endtm = bean.getEndTm() == null ? null : bean.getEndTm().buildTime();
		// Interface field type not supported.
	}
	public ims.vo.ValueObjectBean getBean()
	{
		return this.getBean(new ims.vo.ValueObjectBeanMap());
	}
	public ims.vo.ValueObjectBean getBean(ims.vo.ValueObjectBeanMap map)
	{
		ims.scheduling.vo.beans.AvailableDurationVoBean bean = null;
		if(map != null)
			bean = (ims.scheduling.vo.beans.AvailableDurationVoBean)map.getValueObjectBean(this);
		if (bean == null)
		{
			bean = new ims.scheduling.vo.beans.AvailableDurationVoBean();
			map.addValueObjectBean(this, bean);
			bean.populate(map, this);
		}
		return bean;
	}
	public boolean getStartTmIsNotNull()
	{
		return this.starttm != null;
	}
	public ims.framework.utils.Time getStartTm()
	{
		return this.starttm;
	}
	public void setStartTm(ims.framework.utils.Time value)
	{
		this.isValidated = false;
		this.starttm = value;
	}
	public boolean getEndTmIsNotNull()
	{
		return this.endtm != null;
	}
	public ims.framework.utils.Time getEndTm()
	{
		return this.endtm;
	}
	public void setEndTm(ims.framework.utils.Time value)
	{
		this.isValidated = false;
		this.endtm = value;
	}
	public boolean getConcreteTypeIsNotNull()
	{
		return this.concretetype != null;
	}
	public ims.vo.interfaces.IApptDuration getConcreteType()
	{
		return this.concretetype;
	}
	public void setConcreteType(ims.vo.interfaces.IApptDuration value)
	{
		this.isValidated = false;
		this.concretetype = value;
	}
	public final String getIItemText()
	{
		return toString();
	}
	public final Integer getBoId() 
	{
		return null;
	}
	public final String getBoClassName()
	{
		return null;
	}
	public boolean equals(Object obj)
	{
		if(obj == null)
			return false;
		if(!(obj instanceof AvailableDurationVo))
			return false;
		AvailableDurationVo compareObj = (AvailableDurationVo)obj;
		if(this.getStartTm() == null && compareObj.getStartTm() != null)
			return false;
		if(this.getStartTm() != null && compareObj.getStartTm() == null)
			return false;
		if(this.getStartTm() != null && compareObj.getStartTm() != null)
			return this.getStartTm().equals(compareObj.getStartTm());
		return super.equals(obj);
	}
	/**
	* parametrised constructor
	*/
	public AvailableDurationVo(ims.framework.utils.Time _startTm, ims.framework.utils.Time _endTm)
	{
		this.starttm = _startTm;
		this.endtm = _endTm;
	}
	/**
	* helper methods for IApptDuration
	*/
	public java.util.List<AvailableDurationVo> getAvailablDurations(java.util.List<ims.vo.interfaces.IApptDuration> appts, SessionIntermediateVo session)
	{
		//WDEV-11569 get Exclusion Times
		if(session.getExclusionTimesIsNotNull())
		{
			for(ims.scheduling.vo.Session_Exc_TimesVo voExcTime : session.getExclusionTimes())
			{
				if (this.concretetype == null)
					throw new ims.framework.exceptions.CodingRuntimeException("Concrete type is mandatory");
					
				if(this.concretetype instanceof Booking_AppointmentShortVo)
				{
					Booking_AppointmentShortVo voDummyItem = new Booking_AppointmentShortVo();
					voDummyItem.setApptStartTime(voExcTime.getStartTime());
					voDummyItem.setApptEndTime(voExcTime.getEndTime());
					voDummyItem.setAppointmentDate(session.getSessionDate());
					voDummyItem.setDummyColour(ims.framework.utils.Color.Red);
					if(appts != null)
						appts.add(voDummyItem);
				}
				else if(this.concretetype instanceof BookingAppointmentLiteVo)
				{
					BookingAppointmentLiteVo voDummyItem = new BookingAppointmentLiteVo();
					voDummyItem.setApptStartTime(voExcTime.getStartTime());
					voDummyItem.setApptEndTime(voExcTime.getEndTime());
					voDummyItem.setAppointmentDate(session.getSessionDate());
					voDummyItem.setDummyColour(ims.framework.utils.Color.Red);
					if(appts != null)
						appts.add(voDummyItem);
				}
			}
		}
		
		appts = sortIApptDurationList(appts);
		
		java.util.List<AvailableDurationVo> avails = new java.util.ArrayList<AvailableDurationVo>();
		
		//creating starting duration
		ims.framework.utils.Time sessStartTm = (ims.framework.utils.Time) session.getStartTm().clone();
		ims.framework.utils.Time startTimeMarker = (ims.framework.utils.Time) sessStartTm.clone();
		ims.framework.utils.Time endTimeMarker = null;
		
		for (ims.vo.interfaces.IApptDuration voApptItem : appts)
		{	
			endTimeMarker = (ims.framework.utils.Time) voApptItem.getIApptDurationEndTime().clone();
			if(voApptItem.getIApptDurationStartTime().isGreaterThan(startTimeMarker))
			{
				//WDEV-11569 for when exclusion period is added first
				ims.framework.utils.Time startTime = getLastApptEndTime(voApptItem, appts);
				
				//validate that the start time here is not before the end time of any previous appt in list
				startTime = checkStartTime(startTime, appts);
				
				if(startTime == null)
					startTime = sessStartTm;
					
				AvailableDurationVo duration = new AvailableDurationVo(startTime, voApptItem.getIApptDurationStartTime());
	
				addNewDuration(duration, avails, sessStartTm, session.getEndTm());
				startTimeMarker = (ims.framework.utils.Time) duration.endtm.clone();
			}
			else
			{
				startTimeMarker = endTimeMarker;				
			}
		}
	
		//creating ending duration
		ims.framework.utils.Time sessEndTm = (ims.framework.utils.Time) session.getEndTm().clone();	
		
		if(endTimeMarker == null || (endTimeMarker.isLessThan(sessStartTm)))
			endTimeMarker = sessStartTm;
		
		//WDEV-11702(WDEV-11565) to stop creatio of available durations past the session end time
		if(endTimeMarker != null && endTimeMarker.isGreaterThan(sessEndTm))
			endTimeMarker = sessEndTm;
		
		AvailableDurationVo endDuration = new AvailableDurationVo(endTimeMarker, sessEndTm);
		addNewDuration(endDuration, avails, sessStartTm, sessEndTm);
	
		// no appts booked - the whole session is available
		if (appts.size() == 0 && session != null)
		{
			AvailableDurationVo duration = new AvailableDurationVo((ims.framework.utils.Time) session.getStartTm().clone(), (ims.framework.utils.Time) session.getEndTm().clone());
			addNewDuration(duration, avails, sessStartTm, sessEndTm);
		}
		
		return avails;
	}
	private java.util.List<ims.vo.interfaces.IApptDuration> sortIApptDurationList(java.util.List<ims.vo.interfaces.IApptDuration> appts)
	{
		java.util.Collections.sort(appts);
		return appts;
	}
	private ims.framework.utils.Time checkStartTime(ims.framework.utils.Time proposedTime, java.util.List<ims.vo.interfaces.IApptDuration> appts)
	{
		if(proposedTime == null)
			return null;
	
		for (ims.vo.interfaces.IApptDuration voListItem : appts)
		{	
			if(proposedTime.isGreaterThan(voListItem.getIApptDurationStartTime()) && proposedTime.isLessThan(voListItem.getIApptDurationEndTime()))
				return voListItem.getIApptDurationEndTime();
		}
		
		return proposedTime;
	}
	private ims.framework.utils.Time getLastApptEndTime(ims.vo.interfaces.IApptDuration voApptItem, java.util.List<ims.vo.interfaces.IApptDuration> appts)
	{
		for (ims.vo.interfaces.IApptDuration voListItem : appts)
		{	
			if(voListItem.equals(voApptItem))
			{
				if((appts.indexOf(voApptItem) - 1) != -1 && (appts.indexOf(voApptItem) - 1) < (appts.size()))
					return appts.get(appts.indexOf(voApptItem) - 1).getIApptDurationEndTime();
			}
		}
		
		return null;
	}
	
	/**
	 * method will check before adding to the collection
	 * a) duration is greater than 0
	 * b) start time and end time are not equal
	 * c) availableDuration is within start and end time of session
	 * 
	 * @param availableDuration
	 * @param avails
	 * @param time2 
	 * @param sessionStartTm 
	 */
	private void addNewDuration(AvailableDurationVo availableDuration, java.util.List<AvailableDurationVo> avails, ims.framework.utils.Time sessStartTime, ims.framework.utils.Time sessEndTime)
	{
		if(avails == null || availableDuration == null)
			return;
		
		if(availableDuration.starttm != null && availableDuration.endtm != null)
		{
			//avoid duplicate add
			for(int i=0;i<avails.size();i++)
			{
				if( availableDuration.starttm.equals(avails.get(i).starttm) && availableDuration.endtm.equals(avails.get(i).endtm))
					return;
			}
			
			if(availableDuration.starttm.isLessThan(sessStartTime))
				availableDuration.starttm = sessStartTime;
			
			if(availableDuration.endtm.isGreaterThan(sessEndTime))
				availableDuration.endtm = sessEndTime;
			
			//duration endtm greater than StartTime
			if( availableDuration.starttm.isGreaterThan(availableDuration.endtm))
				return;
		
			if(!availableDuration.starttm.equals(availableDuration.endtm))
			{
				if(calculateApptDuration(availableDuration.starttm, availableDuration.endtm) > 0)
				{
					avails.add(availableDuration);
				}
			}	
		}
	}
	
	protected int calculateApptDuration(ims.framework.utils.Time apptStartTime, ims.framework.utils.Time apptEndTime)
	{
		if (apptStartTime == null || apptEndTime == null)
			throw new ims.framework.exceptions.CodingRuntimeException("apptStartTime or apptEndTime is null in method calculateApptDuration");
	
		int mins = apptEndTime.getTotalMinutes() - apptStartTime.getTotalMinutes();
		//appt has gone past midnight
		if(apptEndTime.isLessThan(apptStartTime))	
		{
			ims.framework.utils.Time midNight = new ims.framework.utils.Time(23,59);
			mins = midNight.getTotalMinutes() + 1 - apptStartTime.getTotalMinutes() + apptEndTime.getTotalMinutes(); 
		}
			
		return mins;
	}
	public boolean isValidated()
	{
		if(this.isBusy)
			return true;
		this.isBusy = true;
	
		if(!this.isValidated)
		{
			this.isBusy = false;
			return false;
		}
		this.isBusy = false;
		return true;
	}
	public String[] validate()
	{
		return validate(null);
	}
	public String[] validate(String[] existingErrors)
	{
		if(this.isBusy)
			return null;
		this.isBusy = true;
	
		java.util.ArrayList<String> listOfErrors = new java.util.ArrayList<String>();
		if(existingErrors != null)
		{
			for(int x = 0; x < existingErrors.length; x++)
			{
				listOfErrors.add(existingErrors[x]);
			}
		}
		int errorCount = listOfErrors.size();
		if(errorCount == 0)
		{
			this.isBusy = false;
			this.isValidated = true;
			return null;
		}
		String[] result = new String[errorCount];
		for(int x = 0; x < errorCount; x++)
			result[x] = (String)listOfErrors.get(x);
		this.isBusy = false;
		this.isValidated = false;
		return result;
	}
	public Object clone()
	{
		if(this.isBusy)
			return this;
		this.isBusy = true;
	
		AvailableDurationVo clone = new AvailableDurationVo();
		
		if(this.starttm == null)
			clone.starttm = null;
		else
			clone.starttm = (ims.framework.utils.Time)this.starttm.clone();
		if(this.endtm == null)
			clone.endtm = null;
		else
			clone.endtm = (ims.framework.utils.Time)this.endtm.clone();
		clone.concretetype = this.concretetype;
		clone.isValidated = this.isValidated;
		
		this.isBusy = false;
		return clone;
	}
	public int compareTo(Object obj)
	{
		return compareTo(obj, true);
	}
	public int compareTo(Object obj, boolean caseInsensitive)
	{
		if (obj == null)
		{
			return -1;
		}
		if(caseInsensitive); // this is to avoid eclipse warning only.
		if (!(AvailableDurationVo.class.isAssignableFrom(obj.getClass())))
		{
			throw new ClassCastException("A AvailableDurationVo object cannot be compared an Object of type " + obj.getClass().getName());
		}
		AvailableDurationVo compareObj = (AvailableDurationVo)obj;
		int retVal = 0;
		if (retVal == 0)
		{
			if(this.getStartTm() == null && compareObj.getStartTm() != null)
				return -1;
			if(this.getStartTm() != null && compareObj.getStartTm() == null)
				return 1;
			if(this.getStartTm() != null && compareObj.getStartTm() != null)
				retVal = this.getStartTm().compareTo(compareObj.getStartTm());
		}
		return retVal;
	}
	public synchronized static int generateValueObjectUniqueID()
	{
		return ims.vo.ValueObject.generateUniqueID();
	}
	public int countFieldsWithValue()
	{
		int count = 0;
		if(this.starttm != null)
			count++;
		if(this.endtm != null)
			count++;
		if(this.concretetype != null)
			count++;
		return count;
	}
	public int countValueObjectFields()
	{
		return 3;
	}
	protected ims.framework.utils.Time starttm;
	protected ims.framework.utils.Time endtm;
	protected ims.vo.interfaces.IApptDuration concretetype;
	private boolean isValidated = false;
	private boolean isBusy = false;
}
