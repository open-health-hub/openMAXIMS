//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Bogdan Tofei using IMS Development Environment (version 1.80 build 5007.25751)
// Copyright (C) 1995-2013 IMS MAXIMS. All rights reserved.

package ims.pathways.domain.impl;

import ims.RefMan.domain.objects.CATSReferralStatus;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.ElectiveListStatus;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.domain.objects.TCIOutcomeForPatientElectiveList;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.lookups.AdmissionOfferOutcome;
import ims.RefMan.vo.lookups.ReferralApptStatus;
import ims.RefMan.vo.lookups.TCIStatusChangeReason;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.configuration.gen.ConfigFlag;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.vo.MemberOfStaffShortVo;
import ims.core.vo.domain.MemberOfStaffShortVoAssembler;
import ims.core.vo.domain.PatientShortListVoAssembler;
import ims.core.vo.lookups.WaitingListStatus;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.domain.HL7PathwayIf;
import ims.pathways.domain.base.impl.BaseAdminEventImpl;
import ims.pathways.domain.objects.AdminEvent;
import ims.pathways.domain.objects.PathwayRTTStatus;
import ims.pathways.domain.objects.PatientJourneyStatus;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.helper.ISchedulingCancelAppt;
import ims.pathways.vo.AdminEventVo;
import ims.pathways.vo.PathwayRTTStatusVo;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.domain.AdminEventVoAssembler;
import ims.pathways.vo.domain.PathwayRTTStatusVoAssembler;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.lookups.AdminEventOutcome;
import ims.pathways.vo.lookups.EventEncounterType;
import ims.pathways.vo.lookups.EventStatus;
import ims.pathways.vo.lookups.JourneyStatus;
import ims.scheduling.domain.objects.Appointment_Status;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.lookups.Status_Reason;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

public class AdminEventImpl extends BaseAdminEventImpl
{

	private static final long serialVersionUID = 1L;

	public ims.pathways.vo.AdminEventVoCollection getAdminEvents(ims.RefMan.vo.CatsReferralRefVo referralRef)
	{
		if (referralRef == null)
			throw new CodingRuntimeException("Cannot get AdminEvents on null referralRef");

		List list = getDomainFactory().find("select admEv from CatsReferral as cats left join cats.adminEvent as admEv where cats.id =:referralID", new String[] { "referralID" }, new Object[] { referralRef.getID_CatsReferral() });

		return AdminEventVoAssembler.createAdminEventVoCollectionFromAdminEvent(list);
	}

	public AdminEventVo saveAdminEvent(AdminEventVo adminEventToSave, CatsReferralRefVo referralRef) throws DomainInterfaceException, StaleObjectException
	{
		
		if (adminEventToSave == null)
			throw new CodingRuntimeException("Cannot save null Admin Event");

		DomainFactory factory = getDomainFactory();

		AdminEvent domainAdminEvent = AdminEventVoAssembler.extractAdminEvent(factory, adminEventToSave);
		CatsReferral domReferral = (CatsReferral) factory.getDomainObject(CatsReferral.class, referralRef.getID_CatsReferral());

		if (domReferral.getAdminEvent() == null)
		{
			domReferral.setAdminEvent(new java.util.ArrayList());
		}

		domReferral.getAdminEvent().add(domainAdminEvent);

		if (ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue() && Boolean.TRUE.equals(domReferral.isRTTClockImpact()))
		{
			RTTStatusEventMapVo rttMap = getRecordWithEncounterTypeAndInstance(domainAdminEvent);

			if (rttMap != null)
			{
				updateAndCreateRecords(factory, domReferral, rttMap);
			}
			else if (domReferral.getJourney() != null && domReferral.getJourney().getCurrentClock() != null && domReferral.getJourney().getCurrentClock().getCurrentRTTStatus() != null)
			{

				rttMap = getRTTStatusEventMap(domReferral.getJourney().getCurrentClock().getCurrentRTTStatus().getRTTStatus());

				if (rttMap != null)
				{
					updateAndCreateRecords(factory, domReferral, rttMap);
				}
			}
		}
		
		//WDEV-18359
		if ((getDomLookup(AdminEventOutcome.PATIENT_REFUSES_TREATMENT)).equals(domainAdminEvent.getOutcome())
			|| (getDomLookup(AdminEventOutcome.DECISION_NOT_TO_TREAT)).equals(domainAdminEvent.getOutcome()))//wdev-18467
		{
			
			CATSReferralStatus currentReferralStatus = domReferral.getCurrentStatus();

			if (currentReferralStatus == null || (currentReferralStatus != null && currentReferralStatus.getReferralStatus() != null && !currentReferralStatus.getReferralStatus().equals(getDomLookup(ReferralApptStatus.END_OF_CARE))))
				currentReferralStatus = new CATSReferralStatus();

			// set Referral Status
			MemberOfStaff domainMOS = null;
			Object mosUser = getMosUser();

			if (mosUser instanceof MemberOfStaffShortVo)
			{
				domainMOS = MemberOfStaffShortVoAssembler.extractMemberOfStaff(factory, ((MemberOfStaffShortVo) getMosUser()));
			}

			currentReferralStatus.setAuthoringUser(domainMOS);
			currentReferralStatus.setReferralStatus(getDomLookup(ReferralApptStatus.END_OF_CARE));
			currentReferralStatus.setStatusDateTime(new java.util.Date());

			domReferral.setCurrentStatus(currentReferralStatus);
			
			//update the Referral Status history
			if (domReferral.getStatusHistory() == null)
				domReferral.setStatusHistory(new HashSet());

			domReferral.getStatusHistory().add(currentReferralStatus);

			//setReferral EndOfCareDate to now 
			domReferral.setEndOfCareDate(new java.util.Date());

			Date currentDate = new Date();
			
			//update ConsultationAppt from CatsReferral
			if (domReferral.getConsultationAppt() != null && getDomLookup(Status_Reason.BOOKED).equals(domReferral.getConsultationAppt().getApptStatus()) && currentDate.getDate().compareTo(domReferral.getConsultationAppt().getAppointmentDate()) <= 0)
			{
				
				Booking_Appointment appt = domReferral.getConsultationAppt();
				
				appt.setApptStatus(getDomLookup(Status_Reason.CANCELLED));
				appt.setApptStatusReas(getDomLookup(Status_Reason.PATIENTCANCELLED));

				if (appt.getCurrentStatusRecord() != null)
				{
					Appointment_Status newStatus = new Appointment_Status();

					newStatus = appt.getCurrentStatusRecord();

					//populate old status fields to this new status
					populateOldFields(appt, newStatus);
					
					newStatus.setStatus(getDomLookup(Status_Reason.CANCELLED));
					newStatus.setStatusChangeDateTime(new java.util.Date());

					// add this to Appointment Status History
					if (appt.getApptStatusHistory() == null)
						appt.setApptStatusHistory(new HashSet());

					appt.setCurrentStatusRecord(newStatus);
					appt.getApptStatusHistory().add(newStatus);
				}

				if (appt.getSessionSlot() != null)
				{
					appt.getSessionSlot().setStatus(getDomLookup(Status_Reason.SLOTOPENED));
				}

				Booking_AppointmentVo bookingApptVo = Booking_AppointmentVoAssembler.create(appt);
				
				try
				{
					Class<?> implClass = Class.forName("ims.scheduling.domain.impl.SessionAdminImpl");
					ISchedulingCancelAppt sessionAdminImpl = (ISchedulingCancelAppt) getDomainImpl(implClass);
					sessionAdminImpl.cancelAppt(bookingApptVo, ActionRequestType.NOTIFY_APPT_CANCEL, "Cancel Appt requested from Admin Event - Patient Refuses Treatment");
				}
				catch (ClassNotFoundException e)
				{
					//Log the exception in system, should be fine
					e.printStackTrace();
				}
			}
			
			//update Appointments from CatsReferral
			if (domReferral.getAppointments() != null)
			{
				Iterator it = domReferral.getAppointments().iterator();

				while (it.hasNext())
				{
					Booking_Appointment doBookAppt = (Booking_Appointment) it.next();

					if (doBookAppt != null && getDomLookup(Status_Reason.BOOKED).equals(doBookAppt.getApptStatus()) && currentDate.getDate().compareTo(doBookAppt.getAppointmentDate()) <= 0)
					{
						doBookAppt.setApptStatus(getDomLookup(Status_Reason.CANCELLED));

						if (doBookAppt.getCurrentStatusRecord() != null)
						{
							Appointment_Status newStatus = new Appointment_Status();

							// populate old status fields to this new status
							populateOldFields(doBookAppt, newStatus);

							// populate the new values
							newStatus.setStatus(getDomLookup(Status_Reason.CANCELLED));
							newStatus.setStatusChangeDateTime(new java.util.Date());

							// add this to Appointment Status History
							if (doBookAppt.getApptStatusHistory() == null)
								doBookAppt.setApptStatusHistory(new HashSet());

							doBookAppt.setCurrentStatusRecord(newStatus);
							doBookAppt.getApptStatusHistory().add(newStatus);
						}

						if (doBookAppt.getSessionSlot() != null)
						{
							doBookAppt.getSessionSlot().setStatus(getDomLookup(Status_Reason.SLOTOPENED));
						}

						Booking_AppointmentVo bookingApptVo = Booking_AppointmentVoAssembler.create(doBookAppt);

						try
						{
							Class<?> implClass = Class.forName("ims.scheduling.domain.impl.SessionAdminImpl");
							ISchedulingCancelAppt sessionAdminImpl = (ISchedulingCancelAppt) getDomainImpl(implClass);
							sessionAdminImpl.cancelAppt(bookingApptVo, ActionRequestType.NOTIFY_APPT_CANCEL, "Cancel Appt requested from Admin Event - Patient Refuses Treatment");
						}
						catch (ClassNotFoundException e)
						{
							//Log the exception in system, should be fine
							e.printStackTrace();
						}
					}
				}
			}
			
			//update patientElectiveLists for Current Referral
			PatientElectiveList doPatientElectiveList = null;
			
			String patientElectiveListQuery = "select electiveList from PatientElectiveList as electiveList left join electiveList.referral as cats left join electiveList.pathwayClock as pc where cats.id = :CatsId ";
			List<?> electiveList = factory.find(patientElectiveListQuery, new String[] {"CatsId"}, new Object[] {domReferral.getId()});
			
			if(electiveList != null && electiveList.size() > 0 )
			{
				for (int i=0;i<electiveList.size();i++)
				{
					doPatientElectiveList = (PatientElectiveList) electiveList.get(i);	
				
	        		if(doPatientElectiveList != null && !getDomLookup(WaitingListStatus.REMOVED).equals(doPatientElectiveList.getElectiveListStatus().getElectiveListStatus()))
	        		{
	        			//create new Elective List Status
	        			ElectiveListStatus status = new ElectiveListStatus();
	        			status.setElectiveListStatus(getDomLookup(WaitingListStatus.REMOVED));
	        			status.setAuthoringUser(domainMOS);
	        			status.setStatusDateTime(new java.util.Date());
	        			
	        			doPatientElectiveList.setElectiveListStatus(status);
	        			
	        			//add this status to the Status History
	        			if(doPatientElectiveList.getElectiveListStatusHistory() == null)
	        				doPatientElectiveList.setElectiveListStatusHistory(new ArrayList());
	        			
	        			doPatientElectiveList.getElectiveListStatusHistory().add(status);
	        			
	        			//update the future TCIs
	        			TCIForPatientElectiveList doTCIDetails = doPatientElectiveList.getTCIDetails();
	        			
	        			if(doTCIDetails != null && doTCIDetails.isIsActive() &&  doTCIDetails.getTCIDate() != null && currentDate.getDate().compareTo(doTCIDetails.getTCIDate()) <= 0)
	        			{		
	        				//create a new Outcome
	        				TCIOutcomeForPatientElectiveList newOutcome = new TCIOutcomeForPatientElectiveList();
	        				newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_PATIENT_2));
	        				
	        				newOutcome.setChangeBy(domainMOS);
	        				newOutcome.setStatusDateTime(new java.util.Date());
	        				newOutcome.setOutcomeReason(getDomLookup(TCIStatusChangeReason.CANCELLEDBYREMOVALOFELECTIVELISTRECORD));
	        			
	        				doTCIDetails.setCurrentOutcome(newOutcome);
	        				doTCIDetails.setIsActive(false);
	        				
	        				//add new outcome to Outcome History
	        				if(doTCIDetails.getOutcomeHistory() == null)
	        					doTCIDetails.setOutcomeHistory(new ArrayList());
	        				
	        				doTCIDetails.getOutcomeHistory().add(newOutcome);
	        				
	        			}
	        			
	        			factory.save(doPatientElectiveList);
	        		}
				}
			}
			
			//Stop the current clock
			PatientPathwayJourney doJourney = domReferral.getJourney();
			
			if (doJourney != null)
			{
				
				PatientJourneyStatus journeyStatus = new PatientJourneyStatus();
				journeyStatus.setDateTime(new java.util.Date());
				journeyStatus.setStatus(getDomLookup(JourneyStatus.ENDPATHWAYJOURNEY));
				
				if (doJourney.getStatusHistory() == null)
				{
					doJourney.setStatusHistory(new HashSet());
				}
				
				if (doJourney.getCurrentClock() != null)
				{
					doJourney.getCurrentClock().setStopDate(new java.util.Date());
				}
				
				doJourney.setEndedOnDate(new java.util.Date());
				doJourney.setCurrentStatus(journeyStatus);
				doJourney.getStatusHistory().add(journeyStatus);
			}
		}
		
		factory.save(domReferral);

		return AdminEventVoAssembler.create(domainAdminEvent);
	}
	
	private void populateOldFields(Booking_Appointment doBookAppt, Appointment_Status newStatus)
	{
		newStatus.setStatusReason(doBookAppt.getCurrentStatusRecord().getStatusReason());
		newStatus.setApptDate(doBookAppt.getCurrentStatusRecord().getApptDate());
		newStatus.setApptTime(doBookAppt.getCurrentStatusRecord().getApptTime());
		newStatus.setPASClinic(doBookAppt.getCurrentStatusRecord().getPASClinic());
		newStatus.setDoS(doBookAppt.getCurrentStatusRecord().getDoS());
		newStatus.setPriority(doBookAppt.getCurrentStatusRecord().getPriority());
		newStatus.setCancellationReason(doBookAppt.getCurrentStatusRecord().getCancellationReason());
		newStatus.setComment(doBookAppt.getCurrentStatusRecord().getComment());
		newStatus.setRebookSelected(doBookAppt.getCurrentStatusRecord().isRebookSelected());
		newStatus.setUniqueLineRefNo(doBookAppt.getCurrentStatusRecord().getUniqueLineRefNo());
		newStatus.setWasOutputtedToWeeklyReport(doBookAppt.getCurrentStatusRecord().isWasOutputtedToWeeklyReport());
		newStatus.setWasOutputtedToMonthlyReport(doBookAppt.getCurrentStatusRecord().isWasOutputtedToMonthlyReport());
		newStatus.setEarliestOfferedDate(doBookAppt.getCurrentStatusRecord().getEarliestOfferedDate());
	}

	private void updateAndCreateRecords(DomainFactory factory, CatsReferral domReferral, RTTStatusEventMapVo rttMap) throws StaleObjectException, DomainInterfaceException
	{
		if (ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue() && Boolean.TRUE.equals(domReferral.isRTTClockImpact()) && rttMap.getTargetRTTStatusIsNotNull())
		{
			PathwayRTTStatusVo pathwayRTTStatus = new PathwayRTTStatusVo();
			pathwayRTTStatus.setRTTStatus(rttMap.getTargetRTTStatus());
			pathwayRTTStatus.setStatusBy((MemberOfStaffRefVo) getMosUser());
			pathwayRTTStatus.setStatusDateTime(new DateTime());

			PathwayRTTStatus domainRttStatus = PathwayRTTStatusVoAssembler.extractPathwayRTTStatus(factory, pathwayRTTStatus);

			if (domReferral.getJourney() != null && domReferral.getJourney().getCurrentClock() != null)
			{
				domReferral.getJourney().getCurrentClock().setCurrentRTTStatus(domainRttStatus);

				if (domReferral.getJourney().getCurrentClock().getRTTStatusHistory() == null)
				{
					domReferral.getJourney().getCurrentClock().setRTTStatusHistory(new java.util.ArrayList());
				}

				domReferral.getJourney().getCurrentClock().getRTTStatusHistory().add(domainRttStatus);
			}
			
			domReferral.setCurrentRTTStatus(domainRttStatus);

			if (rttMap.getEvent() != null)
			{
				PatientEventVo patEvent = new PatientEventVo();
				patEvent.setPatient(PatientShortListVoAssembler.create(domReferral.getPatient()));
				patEvent.setEvent(rttMap.getEvent());
				patEvent.setEventDateTime(new DateTime());
				patEvent.setEventStatus(EventStatus.ACTIVE);
				patEvent.setJourney(PatientJourneyVoAssembler.create(domReferral.getJourney()));

				HL7PathwayIf impl = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
				impl.instantiatePatientEvent(patEvent);
			}
		}
	}

	private RTTStatusEventMapVo getRTTStatusEventMap(RTTStatusPoint rttStatusPoint)
	{
		if (rttStatusPoint == null)
			return null;

		String query = "select rttMap from RTTStatusEventMap as rttMap left join rttMap.currentRTTStatus as rtt where rtt.id = :RTTStatusPoint and rttMap.active = 1";
		List<?> listRTTMap = getDomainFactory().find(query, new String[] { "RTTStatusPoint" }, new Object[] { rttStatusPoint.getId() });

		if (listRTTMap != null && listRTTMap.size() > 0 && listRTTMap.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) listRTTMap.get(0));
		}

		return null;

	}

	private RTTStatusEventMapVo getRecordWithEncounterTypeAndInstance(AdminEvent domainAdminEvent)
	{
		if (domainAdminEvent == null)
			return null;

		String query = "select rttMap from RTTStatusEventMap as rttMap left join rttMap.encounterType as encType left join rttMap.encounterInstance as encInstance where encType.id = :eventType and encInstance.id = :encounterInstance and rttMap.active = 1";
		List<?> listRTTMap = getDomainFactory().find(query, new String[] { "eventType", "encounterInstance" }, new Object[] { EventEncounterType.ADMIN_EVENT.getID(), domainAdminEvent.getOutcome().getId() });

		if (listRTTMap != null && listRTTMap.size() > 0 && listRTTMap.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) listRTTMap.get(0));
		}

		return null;
	}

}
