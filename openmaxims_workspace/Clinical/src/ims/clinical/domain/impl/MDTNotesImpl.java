//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Rory Fitzpatrick using IMS Development Environment (version 1.42 build 2196.26417)
// Copyright (C) 1995-2006 IMS MAXIMS plc. All rights reserved.

package ims.clinical.domain.impl;


import ims.admin.domain.HcpAdmin;
import ims.admin.domain.impl.HcpAdminImpl;
import ims.clinical.domain.base.impl.BaseMDTNotesImpl;
import ims.clinical.domain.objects.MDTListandDates;
import ims.clinical.domain.objects.MDTMeeting;
import ims.clinical.vo.KeyDatesVo;
import ims.clinical.vo.KeyDatesVoCollection;
import ims.clinical.vo.MDTListAndDatesVo;
import ims.clinical.vo.MDTMeetingLiteVoCollection;
import ims.clinical.vo.MDTMeetingRefVo;
import ims.clinical.vo.MDTMeetingVo;
import ims.clinical.vo.domain.MDTListAndDatesVoAssembler;
import ims.clinical.vo.domain.MDTMeetingLiteVoAssembler;
import ims.clinical.vo.domain.MDTMeetingVoAssembler;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.domain.objects.EpisodeOfCare;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.patient.vo.PatientRefVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.CareContextVo;
import ims.core.vo.CareContextVoCollection;
import ims.core.vo.ClinicalContactShortVo;
import ims.core.vo.EpisodeofCareVo;
import ims.core.vo.HcpCollection;
import ims.core.vo.HcpFilter;
import ims.core.vo.domain.CareContextVoAssembler;
import ims.core.vo.domain.EpisodeofCareVoAssembler;
import ims.core.vo.lookups.ContactType;
import ims.core.vo.lookups.ContextType;
import ims.core.vo.lookups.KeyDateType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.generalmedical.vo.AdmisSummary;
import ims.generalmedical.vo.InjuryDetailsVoCollection;
import ims.generalmedical.vo.MSKSpinePathologyFindingVoCollection;
import ims.generalmedical.vo.NeuroInterpretVoCollection;
import ims.generalmedical.vo.NeuroMotorFindingsVoCollection;
import ims.generalmedical.vo.NeuroSenastionFindingsVoCollection;
import ims.generalmedical.vo.domain.InjuryDetailsVoAssembler;
import ims.generalmedical.vo.domain.MSKSpinePathologyFindingVoAssembler;
import ims.generalmedical.vo.domain.NeuroInterpretVoAssembler;
import ims.generalmedical.vo.domain.NeuroMotorFindingsVoAssembler;
import ims.generalmedical.vo.domain.NeuroSenastionFindingsVoAssembler;
import ims.medical.domain.objects.InjuryDetails;
import ims.medical.domain.objects.MskSpinePath;
import ims.medical.domain.objects.NeuExamMotor;
import ims.medical.domain.objects.NeuExamSens;
import ims.medical.domain.objects.NeuInterpret;
import ims.nursing.vo.MRSASitesResultsVoCollection;
import ims.nursing.vo.domain.MRSASitesResultsVoAssembler;
import ims.nursing.vo.lookups.MRSAResult;

import java.util.ArrayList;

public class MDTNotesImpl extends BaseMDTNotesImpl
{
	private static final long serialVersionUID = 1L;


	public MDTListAndDatesVo getLatestMDTListDetailsForPatient(PatientRefVo patient, CareContextRefVo careContext)
	{
		if (patient == null || patient.getID_Patient() == null)
			return null;
		
		if (careContext == null || careContext.getID_CareContext() == null)
			return null;
		
		String query = "SELECT mdtList FROM MDTListandDates AS mdtList WHERE mdtList.careContext.id = :CARE_CONTEXT ";
		
		return MDTListAndDatesVoAssembler.create((MDTListandDates) getDomainFactory().findFirst(query.toString(), "CARE_CONTEXT", careContext.getID_CareContext()));
	}

	
	public AdmisSummary getAdmissionSummaryByCareContext(CareContextShortVo careContext) {
		return getAdmissionSummary(careContext, null);
	}

	public AdmisSummary getAdmissionSummaryByClinicalContact(ClinicalContactShortVo clinicalContact) {
		return getAdmissionSummary(null, clinicalContact);
	}

	
	public MDTMeetingLiteVoCollection listMDTMeeting(PatientRefVo patient, CareContextRefVo careContext)
	{
		if (patient == null || careContext == null)
			throw new CodingRuntimeException("Patient or CareContext are mandatory");
		
		StringBuilder query = new StringBuilder();
		
		query.append("SELECT mdtMeeting FROM MDTMeeting AS mdtMeeting ");
		query.append("WHERE mdtMeeting.careContext.id = :CARE_CONTEXT ");
		query.append("ORDER BY mdtMeeting.mDTMeetingDate DESC, mdtMeeting.systemInformation.creationDateTime DESC ");
		
		return MDTMeetingLiteVoAssembler.createMDTMeetingLiteVoCollectionFromMDTMeeting(getDomainFactory().find(query.toString(), "CARE_CONTEXT", careContext.getID_CareContext()));
	}
	
	
	public MDTMeetingVo getMDTMeeting(MDTMeetingRefVo mdtMeeting)
	{
		if (mdtMeeting == null || mdtMeeting.getID_MDTMeeting() == null)
			return null;
		
		return MDTMeetingVoAssembler.create((MDTMeeting) getDomainFactory().getDomainObject(MDTMeeting.class, mdtMeeting.getID_MDTMeeting()));
	}


	public MDTMeetingVo save(MDTMeetingVo mdtMeeting, MDTListAndDatesVo mdtList) throws StaleObjectException
	{
		if (!mdtMeeting.isValidated())
			throw new DomainRuntimeException("MDT Meeting has not beed validated.");
		
		if (!mdtList.isValidated())
			throw new DomainRuntimeException("MDT List has not been validate.");
		
		
		DomainFactory factory = getDomainFactory();
		
		MDTMeeting domMDTMeeting = MDTMeetingVoAssembler.extractMDTMeeting(factory, mdtMeeting);
		
		// Check mdtMeeting to be the latest (if it was already saved)
		if (mdtMeeting.getID_MDTMeeting() != null)
		{
			MDTMeetingVo latest = getLatest(mdtMeeting);
			
			if (latest != null)
			{
				mdtList.setListPatientisOn(latest.getListPatientisOn());
				
				mdtList.setKeyDates(new KeyDatesVoCollection());
				
				for (KeyDatesVo keyDate : latest.getKeyDates())
				{
						KeyDatesVo date = new KeyDatesVo();
						date.setDate(keyDate.getDate());
						date.setDateType(keyDate.getDateType());
						
						mdtList.getKeyDates().add(date);
				}
			}
		}

		MDTListandDates domMDTList = MDTListAndDatesVoAssembler.extractMDTListandDates(factory, mdtList);
		
		factory.save(domMDTMeeting);
		factory.save(domMDTList);
		
		return MDTMeetingVoAssembler.create(domMDTMeeting);
	}
	
	private MDTMeetingVo getLatest(MDTMeetingVo mdtMeeting)
	{
		// This is supposed to work only for edit
		if (mdtMeeting == null || mdtMeeting.getID_MDTMeeting() == null)
			return null;
		
		StringBuilder query = new StringBuilder();

		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		query.append("SELECT mdtMeeting FROM MDTMeeting AS mdtMeeting WHERE mdtMeeting.id <> :MEETING_ID AND mdtMeeting.careContext.id = :CARE_CONTEXT AND ");
		query.append(" (mdtMeeting.mDTMeetingDate > :MEETING_DATE ");
		query.append(" OR (mdtMeeting.mDTMeetingDate = :MEETING_DATE AND mdtMeeting.systemInformation.creationDateTime > :CREATION_DATE)) ");
		query.append(" ORDER BY mdtMeeting.mDTMeetingDate DESC");
		
		paramNames.add("MEETING_ID");			paramValues.add(mdtMeeting.getID_MDTMeeting());
		paramNames.add("CARE_CONTEXT");			paramValues.add(mdtMeeting.getCareContext().getID_CareContext());
		paramNames.add("MEETING_DATE");			paramValues.add(mdtMeeting.getMDTMeetingDate().getDate());
		paramNames.add("CREATION_DATE");		paramValues.add(mdtMeeting.getSystemInformation().getCreationDateTime().getJavaDate());
		
		return MDTMeetingVoAssembler.create((MDTMeeting) getDomainFactory().findFirst(query.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray()));
	}


	public MDTMeetingVo save(MDTMeetingVo mdtMeeting) throws StaleObjectException
	{
		if (!mdtMeeting.isValidated())
			throw new DomainRuntimeException("MDT Meeting has not beed validated.");
		
		DomainFactory factory = getDomainFactory();
		
		MDTMeeting domMDTMeeting = MDTMeetingVoAssembler.extractMDTMeeting(factory, mdtMeeting);
		
		factory.save(domMDTMeeting);
		
		return MDTMeetingVoAssembler.create(domMDTMeeting);
	}

	public HcpCollection listHCPs(HcpFilter filter) 
	{
		HcpAdmin impl = (HcpAdmin)getDomainImpl(HcpAdminImpl.class);
		return impl.listHCPs(filter);
	}
	
	

	
	private ims.generalmedical.vo.AdmisSummary getAdmissionSummary(CareContextShortVo careContext, ClinicalContactShortVo clinicalContact)
	{
		// Get the Medical Contact, everything else can be retrieved from there.
		DomainFactory factory = getDomainFactory();
			
		AdmisSummary summaryVo = new AdmisSummary();
		
		InjuryDetailsVoCollection voCollInjuryDetails = new InjuryDetailsVoCollection();
		
		String hql = " from InjuryDetails injuryDetails "; 
		StringBuffer condStr = new StringBuffer();
		String andStr = " ";
	
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
	
		condStr.append(andStr + " injuryDetails.clinicalContact.contactType = :contactType"); 
		markers.add("contactType");
		values.add(getDomLookup(ContactType.SPINALMEDICALADMISSION));
		andStr = " and ";
				
		if(careContext!=null)
		{
			condStr.append(andStr + " injuryDetails.clinicalContact.careContext.id = :id_CareContext"); 
			markers.add("id_CareContext");
			values.add(careContext.getID_CareContext());
			andStr = " and ";
		}	
		else if(clinicalContact!=null)
		{
			condStr.append(andStr + " injuryDetails.clinicalContact.id = :id_ClinicalContact"); 
			markers.add("id_ClinicalContact");
			values.add(clinicalContact.getID_ClinicalContact());
			andStr = " and ";
		}	
		
		if (andStr.equals(" and "))
			hql += " where ";
	
		hql += condStr.toString();
		voCollInjuryDetails = InjuryDetailsVoAssembler.createInjuryDetailsVoCollectionFromInjuryDetails(factory.find(hql, markers, values));
			
		if(voCollInjuryDetails.size()>0)
		{
			InjuryDetails injury = InjuryDetailsVoAssembler.extractInjuryDetails(factory,voCollInjuryDetails.get(0));
			if (injury != null)
			{
				// 1000 - seconds, 60 - minutes, 60 - hours, 24 - days
				long dayDiff = ((((new java.util.Date().getTime() - (injury.getInjuryDate()!=null?injury.getInjuryDate().getTime():0)) /1000) /60) /60)/24;
				
				if(injury.getInjuryDate() != null)
					summaryVo.setDateOfInjury(new ims.framework.utils.Date(injury.getInjuryDate()));
				summaryVo.setDurationSinceInjury(String.valueOf(dayDiff));
				
				
				if (injury.getCauseOfInjury() != null)
					summaryVo.setCauseOfInjury(injury.getCauseOfInjury().getText());
				if (injury.getModeOfInjury() != null)
					summaryVo.setModeOfInjury(injury.getModeOfInjury().getText());
				if (injury.getMechanismOfInjury() != null)
					summaryVo.setMechanismOfInjury(injury.getMechanismOfInjury().getText());
			}
		}
		
		NeuroMotorFindingsVoCollection collNeuroMotorFindings = new NeuroMotorFindingsVoCollection();
		hql = " from NeuExamMotor neuExamMotor"; 
		condStr = new StringBuffer();
		andStr = " ";
	
		markers.clear();
		values.clear();
	
		if(careContext!=null)
		{
			condStr.append(andStr + " neuExamMotor.careContext.id = :id_CareContext"); 
			markers.add("id_CareContext");
			values.add(careContext.getID_CareContext());
			andStr = " and ";
		}	
		else if(clinicalContact!=null)
		{
			condStr.append(andStr + " neuExamMotor.clinicalContact.id = :id_ClinicalContact"); 
			markers.add("id_ClinicalContact");
			values.add(clinicalContact.getID_ClinicalContact());
			andStr = " and ";
		}	
		
		if (andStr.equals(" and "))
			hql += " where ";
	
		hql += condStr.toString();
		collNeuroMotorFindings = NeuroMotorFindingsVoAssembler.createNeuroMotorFindingsVoCollectionFromNeuExamMotor(factory.find(hql, markers, values));
		
		if(collNeuroMotorFindings.size()>0)
		{
			NeuExamMotor motor = NeuroMotorFindingsVoAssembler.extractNeuExamMotor(factory, collNeuroMotorFindings.get(0));
			if (motor != null)
			{
				if (motor.getLeftMotorLevel() != null)
					summaryVo.setMotorLeft(motor.getLeftMotorLevel().getName());
				if (motor.getRightMotorLevel() != null)
					summaryVo.setMotorRight(motor.getRightMotorLevel().getName());
				
				summaryVo.setAsiaScore(getAverrallAsiaScore(motor));
			}
		}
		
		NeuroSenastionFindingsVoCollection collNeuroSensationFindings = new NeuroSenastionFindingsVoCollection();
		hql = " from NeuExamSens neuExamSens"; 
		condStr = new StringBuffer();
		andStr = " ";
	
		markers.clear();
		values.clear();
	
		if(careContext!=null)
		{
			condStr.append(andStr + " neuExamSens.careContext.id = :id_CareContext"); 
			markers.add("id_CareContext");
			values.add(careContext.getID_CareContext());
			andStr = " and ";
		}	
		else if(clinicalContact!=null)
		{
			condStr.append(andStr + " neuExamSens.clinicalContact.id = :id_ClinicalContact"); 
			markers.add("id_ClinicalContact");
			values.add(clinicalContact.getID_ClinicalContact());
			andStr = " and ";
		}	
		
		if (andStr.equals(" and "))
			hql += " where ";
	
		hql += condStr.toString();
		collNeuroSensationFindings = NeuroSenastionFindingsVoAssembler.createNeuroSenastionFindingsVoCollectionFromNeuExamSens(factory.find(hql, markers, values));
		
		if(collNeuroSensationFindings.size()>0)
		{
			NeuExamSens sensation = NeuroSenastionFindingsVoAssembler.extractNeuExamSens(factory, collNeuroSensationFindings.get(0));
			if (sensation != null)
			{
				if (sensation.getFrankleGrade() != null)
					summaryVo.setFrankleGrade(sensation.getFrankleGrade().getText());
				if (sensation.getLeftSensoryLevel() != null)
					summaryVo.setSensoryLeft(sensation.getLeftSensoryLevel().getName());
				if (sensation.getRightSensoryLevel() != null)
					summaryVo.setSensoryRight(sensation.getRightSensoryLevel().getName());
			}
		}
		
		MSKSpinePathologyFindingVoCollection collMSKSpinePathologyFinding = new MSKSpinePathologyFindingVoCollection();
		
		hql = " from MskSpinePath mskSpinePath "; 
		condStr = new StringBuffer();
		andStr = " ";
	
		markers.clear();
		values.clear();
	
		if(careContext!=null)
		{
			condStr.append(andStr + " mskSpinePath.careContext.id = :id_CareContext"); 
			markers.add("id_CareContext");
			values.add(careContext.getID_CareContext());
			andStr = " and ";
		}	
		else if(clinicalContact!=null)
		{
			condStr.append(andStr + " mskSpinePath.clinicalContact.id = :id_ClinicalContact"); 
			markers.add("id_ClinicalContact");
			values.add(clinicalContact.getID_ClinicalContact());
			andStr = " and ";
		}	
		
		condStr.append(andStr + " mskSpinePath.isPrimaryPathology = :isprimary"); 
		markers.add("isprimary");
		values.add(Boolean.TRUE);
		andStr = " and ";						
				
		if (andStr.equals(" and "))
			hql += " where ";
	
		hql += condStr.toString();
		
		collMSKSpinePathologyFinding = MSKSpinePathologyFindingVoAssembler.createMSKSpinePathologyFindingVoCollectionFromMskSpinePath(factory.find(hql, markers, values));
		
		//java.util.List pathLst = factory.find(domContact.getMskPath(), " where this.isPrimaryPathology = :primary", new String[]{"primary"}, new Object[]{Boolean.TRUE});
		// Should only be one returned
		if (collMSKSpinePathologyFinding != null && collMSKSpinePathologyFinding.size()>0)
		{
			MskSpinePath path = MSKSpinePathologyFindingVoAssembler.extractMskSpinePath(factory, collMSKSpinePathologyFinding.get(0));
			if (path.getPathSite() != null)
				summaryVo.setLevelOfInjury(path.getPathSite().getDescription());
			if (path.getTypeOfInjury() != null)
				summaryVo.setTypeOfInjury(path.getTypeOfInjury().getText());
		}
		
		NeuroInterpretVoCollection collNeuroInterpretVo = new NeuroInterpretVoCollection();
		hql = " from NeuInterpret neuInterpret"; 
		condStr = new StringBuffer();
		andStr = " ";
	
		markers.clear();
		values.clear();
	
		if(careContext!=null)
		{
			condStr.append(andStr + " neuInterpret.careContext.id = :id_CareContext"); 
			markers.add("id_CareContext");
			values.add(careContext.getID_CareContext());
			andStr = " and ";
		}	
		else if(clinicalContact!=null)
		{
			condStr.append(andStr + " neuInterpret.clinicalContact.id = :id_ClinicalContact"); 
			markers.add("id_ClinicalContact");
			values.add(clinicalContact.getID_ClinicalContact());
			andStr = " and ";
		}	
		
		if (andStr.equals(" and "))
			hql += " where ";
	
		hql += condStr.toString();
		collNeuroInterpretVo = NeuroInterpretVoAssembler.createNeuroInterpretVoCollectionFromNeuInterpret(factory.find(hql, markers, values));
		
		if(collNeuroInterpretVo != null && collNeuroInterpretVo.size()>0){
			NeuInterpret interpret = NeuroInterpretVoAssembler.extractNeuInterpret(factory, collNeuroInterpretVo.get(0));
			if (interpret != null)
			{
				if (interpret.getSpinalSyndrome() != null)
					summaryVo.setSpineSyndrome(interpret.getSpinalSyndrome().getText());
				if (interpret.getAsiaGrade() != null)
					summaryVo.setAsiaGrade(interpret.getAsiaGrade().getText());
				if (interpret.getOverallNeuroLevel() != null)
					summaryVo.setOverallNeuro(interpret.getOverallNeuroLevel().getName());
				if (interpret.getCompleteIncomplete() != null)
					summaryVo.setCompleteIncomplete(interpret.getCompleteIncomplete().getText());
			}
		}
		
		//Get the First Admission date for this patient.
		EpisodeofCareVo voEpisodeOfCare = null;
		CareContextVoCollection collCareContextVo = null;
		markers.clear();
		values.clear();

		if(careContext!=null)
			voEpisodeOfCare = EpisodeofCareVoAssembler.create((EpisodeOfCare)factory.getDomainObject(EpisodeOfCare.class, careContext.getEpisodeOfCare().getID_EpisodeOfCare()));
		else if(clinicalContact!=null){
			CareContextVo voCareContext = CareContextVoAssembler.create((CareContext)factory.getDomainObject(CareContext.class, clinicalContact.getCareContext().getID_CareContext()));
			voEpisodeOfCare = EpisodeofCareVoAssembler.create((EpisodeOfCare)factory.getDomainObject(EpisodeOfCare.class, voCareContext.getEpisodeOfCare().getID_EpisodeOfCare()));
		}
		
		collCareContextVo = voEpisodeOfCare.getCareContexts().sort();
		
		if ( (collCareContextVo != null) && (collCareContextVo.size() > 0 ) )
			for(int i=0; i<collCareContextVo.size(); i++){
				if(collCareContextVo.get(i).getContext().equals(ContextType.INPATIENT))
					summaryVo.setFirstAdmissionDate(collCareContextVo.get(i).getStartDateTime().getDate());
			}
		
		//MRSA record.
		MRSASitesResultsVoCollection collMRSAVo = new MRSASitesResultsVoCollection();
		hql = "select siteres from MRSAAssessment t join t.sitesAndResults as siteres ";
		condStr = new StringBuffer();
		andStr = " ";

		markers.clear();
		values.clear();

		if (careContext != null)
		{
			condStr.append(andStr + " t.careContext.id like :cc");
			markers.add("cc");
			values.add(careContext.getID_CareContext());
			andStr = " and ";
		}
		else if (clinicalContact != null)
		{
			condStr.append(andStr + " t.clinicalContact.id like :cc");
			markers.add("cc");
			values.add(clinicalContact.getID_ClinicalContact());
			andStr = " and ";
		}

		condStr.append(andStr + " siteres.result = :res");
		markers.add("res");
		values.add(getDomLookup(MRSAResult.POSITIVE));
		andStr = " and ";
	
		hql += " where " + condStr.toString();

		collMRSAVo = MRSASitesResultsVoAssembler.createMRSASitesResultsVoCollectionFromMRSASitesResults(factory.find(hql, markers, values));

		if(collMRSAVo != null && collMRSAVo.size()>0)
			summaryVo.setMRSAStatus(Boolean.TRUE);
		else
			summaryVo.setMRSAStatus(Boolean.FALSE);
		
		return summaryVo;
	}
	
	//Calculates overall ASIA score
	private String getAverrallAsiaScore(NeuExamMotor motor)
	{
		//"asiaScore" value used as a flag and as a counter 
		//(if asiaScore == -1 then we don't have a value as we can't use "0" which has a different meaning)
		int asiaScore = -1;
		
		if(motor.getOverAllAsiaLeft() != null)
		{
			asiaScore = asiaScore==-1?0:asiaScore;
			asiaScore += motor.getOverAllAsiaLeft().intValue()==-1?0:motor.getOverAllAsiaLeft().intValue();
		}
		
		if(motor.getOverallAsiaRight() != null)
		{
			asiaScore = asiaScore==-1?0:asiaScore;
			asiaScore += motor.getOverallAsiaRight().intValue()==-1?0:motor.getOverallAsiaRight().intValue();
		}
		
		return asiaScore==-1?"":String.valueOf(asiaScore);
	}

}
