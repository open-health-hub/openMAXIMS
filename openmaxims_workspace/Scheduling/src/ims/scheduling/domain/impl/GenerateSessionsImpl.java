//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.30 build 2012.21169)
// Copyright (C) 1995-2005 IMS MAXIMS plc. All rights reserved.

package ims.scheduling.domain.impl;

import ims.core.clinical.domain.objects.Service;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.ServiceLiteVoCollection;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.ServiceLiteVoAssembler;
import ims.core.vo.lookups.LocationType;
import ims.domain.DomainFactory;
import ims.domain.DomainFactory.ORDERMODE;
import ims.domain.Transaction;
import ims.domain.exceptions.DomainException;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.hibernate3.IMSCriteria;
import ims.domain.impl.DomainImpl;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateFormat;
import ims.framework.utils.Time;
import ims.scheduling.domain.DateSelectionEditDialog;
import ims.scheduling.domain.DirectoryOfServiceAdmin;
import ims.scheduling.domain.ExclusionDates;
import ims.scheduling.domain.objects.ProfileParentChildSlot;
import ims.scheduling.domain.objects.ProfileTheatreTCISlot;
import ims.scheduling.domain.objects.Profile_Exc_Date;
import ims.scheduling.domain.objects.Profile_Slot;
import ims.scheduling.domain.objects.Sch_Profile;
import ims.scheduling.domain.objects.Sch_Session;
import ims.scheduling.domain.objects.SessionParentChildSlot;
import ims.scheduling.domain.objects.SessionTheatreProceduresRemanining;
import ims.scheduling.domain.objects.SessionTheatreTCISlot;
import ims.scheduling.domain.objects.Session_Exc_Time;
import ims.scheduling.domain.objects.Session_Slot;
import ims.scheduling.domain.objects.TheatreDetail;
import ims.scheduling.domain.objects.TheatreProcedure;
import ims.scheduling.helper.SlotGenerationUtils;
import ims.scheduling.vo.DirectoryOfServiceVo;
import ims.scheduling.vo.ExclusionDatesVo;
import ims.scheduling.vo.ProfileShortVo;
import ims.scheduling.vo.ProfileShortVoCollection;
import ims.scheduling.vo.Sch_ProfileRefVo;
import ims.scheduling.vo.domain.ProfileShortVoAssembler;
import ims.scheduling.vo.lookups.BookingSource;
import ims.scheduling.vo.lookups.Profile_Interval_Type;
import ims.scheduling.vo.lookups.Sched_Profile_Type;
import ims.scheduling.vo.lookups.Session_Status_and_Reason;
import ims.scheduling.vo.lookups.SlotType;
import ims.scheduling.vo.lookups.Status_Reason;
import imsmaxims.common.ImsDate;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

public class GenerateSessionsImpl extends DomainImpl implements ims.scheduling.domain.GenerateSessions, DateSelectionEditDialog, ims.domain.impl.Transactional
{
	private static final long serialVersionUID = 1L;

	public ims.scheduling.vo.DirectoryOfServiceVoCollection listDos()
	{
		DirectoryOfServiceAdmin impl = (DirectoryOfServiceAdmin) getDomainImpl(DirectoryOfServiceAdminImpl.class);
		DirectoryOfServiceVo voDosFilter = new DirectoryOfServiceVo();
		voDosFilter.setIsActive(Boolean.TRUE);
		return impl.listDirectoryOfService(voDosFilter);
	}

	public ims.scheduling.vo.ProfileShortVoCollection listProfile(ims.scheduling.vo.DirectoryOfServiceVo directoryOfService, ims.core.vo.ServiceFunctionVo function)
	{
		DomainFactory factory = getDomainFactory();

		List profiles = null;

		if (directoryOfService != null && function != null)
		{
			String hql = " Select profile from Sch_Profile profile" + " join profile.directoryOfServices as dos" + " join profile.functions as servfunc" + " where dos.id = :idDos" + " and servfunc.id = :idServFunc";

			profiles = factory.find(hql, new String[]{"idDos", "idServFunc"}, new Object[]{directoryOfService.getID_DirectoryofService(), function.getID_ServiceFunction()});
		}
		else
		{
			profiles = factory.find("from Sch_Profile", 1000);
		}
		return ProfileShortVoAssembler.createProfileShortVoCollectionFromSch_Profile(profiles).sort();
	}

	public Integer generateSessions(ProfileShortVo profile, Date fromDate, Date toDate) throws DomainInterfaceException
	{
		DomainFactory factory = getDomainFactory();
		Sch_Profile doProfile = (Sch_Profile) factory.getDomainObject(Sch_Profile.class, profile.getID_Sch_Profile());

		try
		{
			int noSessions = generateProfileSlots(factory, doProfile, fromDate, toDate, BookingSource.INTERNAL);

			return new Integer(noSessions);

		}
		catch (Exception e)
		{
			throw new DomainInterfaceException("Exception occurred generating session slots " + e.getMessage(), e);
		}
	}

	/**
	 * <p>
	 * generateSessionSlots This method will generate session slots for the
	 * given profile for the directory of service specified for the given date
	 * range
	 * 
	 * @param DOSServiceId -
	 *            The service the slots are required for
	 * @param fromDate -
	 *            The start date to generate slots from
	 * @param toDate -
	 *            The date up to which available slots are to be generated
	 *            </p>
	 * @throws Exception
	 * 
	 */
	public Integer generateSessionSlots(String dosServiceId, ims.framework.utils.Date fromDate, ims.framework.utils.Date toDate) throws DomainInterfaceException
	{
		Transaction tran = null;
		try
		{

			DomainFactory factory = getDomainFactory();

			// wdev-4687 For every profile, check if we need to generate sessions
			List profileList = factory.find(" Select p from Sch_Profile p join p.profileSlots as slots join slots.directoryOfServices as sDos where sDos.directoryOfService.doSId = :dos and slots.isActive = :active ", new String[]{"dos", "active"}, new Object[]{dosServiceId, Boolean.TRUE});
			if (profileList == null || profileList.size() == 0)
				return (new Integer(0));

			// Check to see if we need to generate some more slots
			boolean generateRequired;
			int numGenerated=0;
			tran = factory.beginTransaction();

			for (int i=0; i<profileList.size(); i++)
			{
				ims.framework.utils.Date fromDT = new ims.framework.utils.Date(fromDate);
				
				Sch_Profile prof = (Sch_Profile) profileList.get(i);
				
				generateRequired=false;
				
				List lastDateList = factory.find(" Select max(s.sessionDate) from Sch_Session s join s.sessionSlots as slots join slots.directoryOfServices as slotDos where slotDos.directoryOfService.doSId = :dos and slots.isActive = :active and s.sch_Profile = :profile", new String[]{"dos", "active", "profile"}, new Object[]{dosServiceId, Boolean.TRUE, prof});
				if (lastDateList == null || lastDateList.size() == 0)
					generateRequired = true;
				if (lastDateList.size() == 1)
				{
					java.util.Date latestDate = (java.util.Date) lastDateList.get(0);
					if (latestDate == null || latestDate.before(new ims.framework.utils.Date(toDate).getDate()))
					{
						generateRequired = true;
					// 	If latestDate > fromDate, increase fromDate to this value
						if (latestDate != null && latestDate.after(new ims.framework.utils.Date(fromDate).getDate()))
						{
							fromDT = new ims.framework.utils.Date(latestDate);
						}
					}
				}

				if (generateRequired)
				{
					// 	As this method is called from the web service, we are going
					// 	to start a transation
					numGenerated+=generateProfileSlots(factory, prof, fromDT, toDate, BookingSource.CABGW);
				}
			}
			tran.commit();
			factory.setTransaction(null); // This will prevent DomainImplProxyHandler attempting to commit again

			return new Integer(numGenerated);


		}
		catch (Exception e)
		{
			if (tran != null)
				tran.rollback();
			throw new DomainInterfaceException("Exception occurred generating session slots " + e.getMessage(), e);
		}
	}

	public int generateSlots(DomainFactory factory, String dosServiceId, ims.framework.utils.Date fromDate, ims.framework.utils.Date toDate) throws DomainException
	{
		int noRecordsGenerated = 0;
		List profileList = factory.find(" Select p from Sch_Profile p join p.profileSlots as slots join slots.directoryOfServices as sDos where sDos.doSId = :dos and slots.isActive = :active ", new String[]{"dos", "active"}, new Object[]{dosServiceId, Boolean.TRUE});

		for (int i = 0; i < profileList.size(); i++)
		{
			Sch_Profile profile = (Sch_Profile) profileList.get(i);

			noRecordsGenerated += generateProfileSlots(factory, profile, fromDate, toDate, BookingSource.CABGW);
		}

		return noRecordsGenerated;
	}

	/**
	 * createSession
	 * <p>
	 * Create a session from the profile for the given date
	 * 
	 * @param profile
	 * @param dt
	 *            </p>
	 * @param source
	 * @throws DomainException
	 */
	private Sch_Session createSession(DomainFactory factory, Sch_Profile profile, String dt, BookingSource source) throws DomainException
	{

		try
		{
			// If there is already a session generated for that day for the
			// profile we return
			List lst = factory.find("select count(*) from Sch_Session s where s.isActive = :active and s.sch_Profile.id = :profile and s.sessionDate = :sessDate", new String[]{"active", "profile", "sessDate"}, new Object[]{Boolean.TRUE, profile.getId(), new ims.framework.utils.Date(dt, DateFormat.ISO).getDate()});

			int result = ((Long) lst.get(0)).intValue();
			if (result > 0)
				return null;

			Sch_Session session = new Sch_Session();

			session.setName(profile.getName());
			//WDEV-18369
			session.setConsMediaType(profile.getConsMediaType());
			session.setDescription(profile.getDescription());
			session.setSessionDate(new ims.framework.utils.Date(dt, DateFormat.ISO).getDate());
			session.setStartTm(profile.getStartTm());
			session.setEndTm(profile.getEndTm());
			session.setService(profile.getService());
			session.setSessionStatus(factory.getLookupInstance(Session_Status_and_Reason.TYPE_ID, Session_Status_and_Reason.OPEN.getID()));
			session.setIsFixed(profile.isIsFixed());
			session.setDuration(SlotGenerationUtils.calculateDuration(profile.getStartTm(), profile.getEndTm()));
			session.setSch_Profile(profile);
			session.setSchLocation(profile.getSchLocation());
			session.setSessionType(factory.getLookupInstance(Sched_Profile_Type.TYPE_ID, Sched_Profile_Type.SINGLE.getID()));
			session.setMinInt(profile.getMinInt());
			session.setRoundAttTime(profile.getRoundAttTime());
			session.setLastAppInterval(profile.getLastAppInterval());
			session.setMaxNoAppts(profile.getMaxNoAppts());
			session.setListOwners(SlotGenerationUtils.copyListOwners(profile.getListOwners()));
			session.setBookingRights(SlotGenerationUtils.copyBookingRights(profile.getBookingRights()));
			session.setExclusionTimes(SlotGenerationUtils.copyExclusionTimes(profile.getExclusionTimes()));
			session.setIsTheatreSession(profile.isIsTheatreProfile());
			
			//WDEV-12918
			session.setSlotType(profile.getSlotType()); 
			//standard copy produced shared reference 
			session.setAnaestheticType(new ArrayList()); 
			for (Object lkp : profile.getAnaestheticType())
				session.getAnaestheticType().add(lkp);
			
			//WDEV-7323
			if(profile.isIsTheatreProfile() != null && profile.isIsTheatreProfile())
			{
				//WDEV-11777
				//WDEV-12918
				if(session.getSlotType() != null)
				{
					if(session.getSlotType().equals(getDomLookup(SlotType.THEATRETCITIME)))
						session.setTheatreSlots(generateTheatreSlots(profile.getProfileTheatreSlots(), dt, session));
					else if(session.getSlotType().equals(getDomLookup(SlotType.SLOTS)))
						session.setParentChildSlots(generateParentChildSlots(profile.getParentChildSlots(), dt, session));
				}
				
				session.setTheatreProceduresRemaining(generateTheatreDetails(profile.getTheatreDetails(), dt, session));
				session.setTheatreType(profile.getTheatreType());
				session.setTotalSlots(0);
				session.setRemainingSlots(0);	
			}	
			else
			{
				if(!profile.isIsFixed())
				{
					session.setSessionActivities(SlotGenerationUtils.copyActivities(profile.getProfileActivities()));
					session.setTotalSlots(0);
					session.setRemainingSlots(0);	
					// WDEV-8793 
					// 1)Calculate Time Remaining on Generate Sessions for Flexible Slots 
					session.setRemainingTime(SlotGenerationUtils.calculateDuration(session.getStartTm(), session.getEndTm()));
					
					//WDEV-11569 for flexible sessions reduce the time remaining by the exclusion time
					if(session.getExclusionTimes() != null)
					{
						int exclusionDuration = 0;
						Iterator it = session.getExclusionTimes().iterator();
						while(it.hasNext())
						{
							Session_Exc_Time doExclTime = (Session_Exc_Time) it.next();
							exclusionDuration += SlotGenerationUtils.calculateDuration(doExclTime.getStartTime(), doExclTime.getEndTime());
						}
						session.setRemainingTime( session.getRemainingTime() - exclusionDuration); 
					}
					
					//WDEV-11731
					session.setMaxContinuousAvailableMins(session.getRemainingTime()); 
				}
				else
				{
					session.setDirectoryofServices(SlotGenerationUtils.copyDirectoryOfServices(profile.getDirectoryOfServices()));
					session.setSessionSlots(createSlots(profile.getProfileSlots(), dt, source, session));
					session.setTotalSlots(new Integer(session.getSessionSlots().size()));
					session.setRemainingSlots(new Integer(session.getSessionSlots().size()));
				}
			}

			
			session.setIsModified(Boolean.FALSE);
			session.setIsAdHocSession(Boolean.FALSE);
			session.setIsActive(Boolean.TRUE);
			session.setPASClinic(profile.getPASClinic());
			return session;
		}
		catch (ParseException e)
		{
			throw new DomainException("ParseException occurred parsing date - " + e.getMessage(), e);
		}
	}
	
	private Set generateParentChildSlots(Set parentChildSlots, String dt, Sch_Session session) throws ParseException
	{
		Set parentChildSessionSlots = new  HashSet();
		
		Iterator it = parentChildSlots.iterator();
		while (it.hasNext())
		{
			ProfileParentChildSlot doProfTSlot = (ProfileParentChildSlot) it.next();
			int count = 0;
			if(doProfTSlot.getNoOfInstances() != null)
				count = doProfTSlot.getNoOfInstances();
			
			for(int i=0; i<count; i++)
			{
				if(doProfTSlot.isIsActive())
				{
					int startTime = new Integer(doProfTSlot.getStartTime().replaceAll(":", "")).intValue();
					String newStartTime = String.valueOf(startTime);
					if (newStartTime.length() == 3)
						newStartTime = "0" + newStartTime;
					if (i > 0)
						newStartTime = SlotGenerationUtils.calculateNextSlotTime(startTime, doProfTSlot.getDuration().intValue(), i);
					else
						newStartTime = doProfTSlot.getStartTime();
					
					//WDEV-12918
					if(isSlotTimeWithinExclusionTimes(newStartTime, session.getExclusionTimes(), doProfTSlot.getDuration()))
						continue;
					
					SessionParentChildSlot doSessTSlot = new SessionParentChildSlot();
					
					doSessTSlot.setIsActive(doProfTSlot.isIsActive());
					doSessTSlot.setProfileSlot(doProfTSlot);
					
					ims.framework.utils.Date sessDate = new ims.framework.utils.Date(dt, DateFormat.ISO);
					doSessTSlot.setSessDateTime(sessDate.getDate());
					
					doSessTSlot.setSession(session);
					doSessTSlot.setStatus(getDomLookup(Status_Reason.SLOTOPENED));
					doSessTSlot.setStatusReason(getDomLookup(Status_Reason.SLOTOPENED));
					doSessTSlot.setStartTime(newStartTime);
					doSessTSlot.setDuration(doProfTSlot.getDuration());
			
					parentChildSessionSlots.add(doSessTSlot);
				}
			}
		}
		return parentChildSessionSlots;
	}

	private Set generateTheatreSlots(Set profileTheatreSlots, String dt, Sch_Session session) throws ParseException
	{
		Set theatreSessionSlots = new  HashSet();

		Iterator it = profileTheatreSlots.iterator();
		while (it.hasNext())
		{
			ProfileTheatreTCISlot doProfTCISlot = (ProfileTheatreTCISlot) it.next();
			
			int count = 1;
			if(doProfTCISlot.getNoOfInstances() != null)
				count = doProfTCISlot.getNoOfInstances();
			
			for(int i=0; i<count; i++)
			{
				if(doProfTCISlot.isIsActive())
				{						
					SessionTheatreTCISlot doSessTSlot = new SessionTheatreTCISlot();
					
					doSessTSlot.setIsActive(doProfTCISlot.isIsActive());
					doSessTSlot.setProfileSlot(doProfTCISlot);
					
					ims.framework.utils.Date sessDate = new ims.framework.utils.Date(dt, DateFormat.ISO);
					doSessTSlot.setSessDateTime(sessDate.getDate());
					
					doSessTSlot.setSession(session);
					doSessTSlot.setStatus(getDomLookup(Status_Reason.SLOTOPENED));
					doSessTSlot.setStatusReason(getDomLookup(Status_Reason.SLOTOPENED));
					doSessTSlot.setToComeInTime(doProfTCISlot.getToComeInTime());
			
					theatreSessionSlots.add(doSessTSlot);
				}
			}
		}
		return theatreSessionSlots;
	}

	private int calculateDuration(Time startTime, Time endTime)
	{
		if (startTime == null || endTime == null)
			throw new CodingRuntimeException("startTime or endTime is null in method calculateDuration");
	
		int mins = endTime.getTotalMinutes() - startTime.getTotalMinutes();
		if(endTime.isLessThan(startTime))	
		{
			Time midNight = new Time(23,59);
			mins = midNight.getTotalMinutes() + 1 - startTime.getTotalMinutes() + endTime.getTotalMinutes(); 
		}
			
		return mins;
	}

	private SessionTheatreProceduresRemanining generateTheatreDetails(Set theatreDetails, String dt, Sch_Session session)
	{
		SessionTheatreProceduresRemanining doTheatreProcsRemaining = new SessionTheatreProceduresRemanining();
		//remaining time		
		doTheatreProcsRemaining.setRemainingTimeInMins(SlotGenerationUtils.calculateDuration(session.getStartTm(), session.getEndTm()));
		
		Iterator it = theatreDetails.iterator();
		while(it.hasNext())
		{
			TheatreDetail detail = (TheatreDetail) it.next();
			
			//WDEV-8417
			if(detail.isIsActive() != null && detail.isIsActive())
			{
				TheatreProcedure theatreProcedure = new TheatreProcedure();
				theatreProcedure.setProcedure(detail.getProcedure());
				
				if(detail.getMaxNo() != null)
				{
					theatreProcedure.setIsLimited(true);
					theatreProcedure.setNumberOfProceduresLeft(detail.getMaxNo());
				}
				else
					theatreProcedure.setIsLimited(false);
				
				doTheatreProcsRemaining.getProcedureDetails().add(theatreProcedure);
			}
		}
	
		return doTheatreProcsRemaining;
	}

	/**
	 * @param source
	 * @param profile
	 * @return
	 * @throws ParseException
	 */
	private Set createSlots(Set profileSlots, String sessionDate, BookingSource source, Sch_Session session) throws ParseException
	{
		Set sessSlots = new HashSet();
		Iterator it = profileSlots.iterator();
		while (it.hasNext())
		{
			Profile_Slot profSlot = (Profile_Slot) it.next();
			if (profSlot.isIsActive().booleanValue())
			{
				for (int i = 0; i < profSlot.getNumberSlotsReq().intValue(); i++)
				{

					int startTime = new Integer(profSlot.getStartTm().replaceAll(":", "")).intValue();
					String newStartTime = String.valueOf(startTime);
					if (newStartTime.length() == 3)
						newStartTime = "0" + newStartTime;
					if (i > 0)
						newStartTime = SlotGenerationUtils.calculateNextSlotTime(startTime, profSlot.getDuration().intValue(), i);
					else
						newStartTime = profSlot.getStartTm();
					for (int j = 0; j < profSlot.getNoOfInstances().intValue(); j++)
					{
						if(isSlotTimeWithinExclusionTimes(newStartTime, session.getExclusionTimes(), profSlot.getDuration()))
							continue;

						Session_Slot sessSlot = new Session_Slot();

						sessSlot.setIsActive(Boolean.TRUE);
						sessSlot.setActivity(profSlot.getActivity());
						sessSlot.setStartTm(newStartTime);
						// Dealloc date should be set to session date - no of
						// dealloc days
						ims.framework.utils.Date sessDate = new ims.framework.utils.Date(sessionDate, DateFormat.ISO);
						if (profSlot.getDeallocNoOfDays() != null)
						{
							ims.framework.utils.Date deallocDate = new ims.framework.utils.Date(sessDate);
							sessSlot.setDeallocDate(deallocDate.addDay(-profSlot.getDeallocNoOfDays().intValue()).getDate());
						}
						sessSlot.setDirectoryOfServices(SlotGenerationUtils.copySlotDirectoryOfServices(profSlot.getDirectoryOfServices(), sessSlot));
						sessSlot.setFunctions(SlotGenerationUtils.copyFunctions(profSlot.getFunctions()));
						sessSlot.setDuration(profSlot.getDuration());
						sessSlot.setPriority(profSlot.getPriority());
						sessSlot.setProfileSlot(profSlot);
						sessSlot.setInstanceNo(new Integer(sessSlots.size() + 1));
						sessSlot.setSessDateTime(sessDate.getDate());
						sessSlot.setBookingSource(getDomLookup(source));
						sessSlot.setDirectAccessSlot(profSlot.getDirectAccessSlot());
						sessSlot.setStatus(getDomLookup(Status_Reason.SLOTOPENED));
						sessSlot.setSession(session);

						// Get the responsible list owner from the session
						sessSlot.setSlotResp(SlotGenerationUtils.getSessionListOwner(session, profSlot.getSlotResp()));
						sessSlots.add(sessSlot);
					}
				}

			}
		}
		return sessSlots;
	}

	private boolean isSlotTimeWithinExclusionTimes(String newStartTime, Set exclusionTimes, Integer duration)
	{
		Time proposedSlotTime = new Time(newStartTime);
		Iterator it = exclusionTimes.iterator();
		while(it.hasNext())
		{
			Session_Exc_Time exTime = (Session_Exc_Time) it.next();
			Time exStartTime = new Time(exTime.getStartTime());
			Time exEndTime = new Time(exTime.getEndTime());
			
			Time proposedSlotEndTime = (Time) proposedSlotTime.clone();
			proposedSlotEndTime.addMinutes(duration);
			
			if((proposedSlotTime.isGreaterOrEqualThan(exStartTime) || proposedSlotEndTime.isGreaterThan(exStartTime)) && proposedSlotTime.isLessThan(exEndTime) )
				return true;
		}
		
		return false;
	}

	/**
	 * removeExclusions
	 * <p>
	 * This method will check the exclusion dates for the profiles, and exclude
	 * those from the list generated in the linked list.
	 * 
	 * @param profile
	 * @param generatedDays
	 *            </p>
	 * @throws DomainException
	 */
	private void removeExclusions(Sch_Profile profile, LinkedList generatedDays) throws DomainException
	{
		try
		{
			Iterator it = profile.getExclusionDates().iterator();
			while (it.hasNext())
			{
				Profile_Exc_Date exclDates = (Profile_Exc_Date) it.next();
				ImsDate startDt = new ImsDate(exclDates.getStartDate().toString());
				ImsDate endDt = new ImsDate(exclDates.getEndDate().toString());
				startDt.removeSpecifiedDates(generatedDays, startDt, endDt);
			}
		}
		catch (Exception e)
		{
			throw new DomainException("Exception occurred removing exclusion dates - " + e.getMessage(), e);
		}

	}

	/**
	 * Generate the list of days for this profile
	 * 
	 * @param profile -
	 *            profile Details
	 * @param fromDate -
	 *            Generate days from this date
	 * @param toDate -
	 *            Generate days up to this date
	 * @param generatedDays -
	 *            LinkedList to add days to
	 * @throws DomainException
	 * 
	 */
	private void generateDaysList(Sch_Profile profile, ims.framework.utils.Date fromDate, ims.framework.utils.Date toDate, LinkedList generatedDays) throws DomainException
	{
		try
		{

			if (!toDate.getDate().after(fromDate.getDate()))
				throw new DomainException("ToDate MUST be after FromDate");

			ImsDate fromDt = new ImsDate(fromDate.toString(DateFormat.ISO));
			ImsDate toDt = new ImsDate(toDate.toString(DateFormat.ISO));

			if (profile.getIntervalType().getId() == Profile_Interval_Type.WEEKLY.getId() && profile.getIntervalSize() != null)
			{
				// Call listWeeklyDates
				// Loop trough all day flag attributes and call listMonthlyDates
				// when set to true
				if (profile.isIsSchSun().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 1, profile.getIntervalSize().intValue()));
				if (profile.isIsSchMon().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 2, profile.getIntervalSize().intValue()));
				if (profile.isIsSchTue().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 3, profile.getIntervalSize().intValue()));
				if (profile.isIsSchWed().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 4, profile.getIntervalSize().intValue()));
				if (profile.isIsSchThur().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 5, profile.getIntervalSize().intValue()));
				if (profile.isIsSchFri().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 6, profile.getIntervalSize().intValue()));
				if (profile.isIsSchSat().booleanValue())
					generatedDays.addAll(fromDt.listWeeklyDates(fromDt, toDt, 7, profile.getIntervalSize().intValue()));
			}
			else if (profile.getIntervalType().getId() == Profile_Interval_Type.MONTHLY.getId())
			{
				// For Monthly Intervals, we need to check if valid for the
				// first
				// week, and if so, which days for the first week
				if (profile.isIsFirstInstance().booleanValue())
					generatedDays.addAll(checkMonthly(profile, 1, fromDt, toDt));
				if (profile.isIsSecondInstance().booleanValue())
					generatedDays.addAll(checkMonthly(profile, 2, fromDt, toDt));
				if (profile.isIsThirdInstance().booleanValue())
					generatedDays.addAll(checkMonthly(profile, 3, fromDt, toDt));
				if (profile.isIsFourthInstance().booleanValue())
					generatedDays.addAll(checkMonthly(profile, 4, fromDt, toDt));
				if (profile.isIsFifthInstance().booleanValue())
					generatedDays.addAll(checkMonthly(profile, 5, fromDt, toDt));

			}
		}
		catch (Exception e)
		{
			throw new DomainException("Exception occurred generating days list - " + e.getMessage(), e);
		}

	}

	private LinkedList checkMonthly(Sch_Profile profile, int instance, ImsDate fromDt, ImsDate toDt) throws Exception
	{
		LinkedList daysList = new LinkedList();

		if (profile.isIsSchSun().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 1, profile.getIntervalSize().intValue()));
		if (profile.isIsSchMon().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 2, profile.getIntervalSize().intValue()));
		if (profile.isIsSchTue().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 3, profile.getIntervalSize().intValue()));
		if (profile.isIsSchWed().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 4, profile.getIntervalSize().intValue()));
		if (profile.isIsSchThur().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 5, profile.getIntervalSize().intValue()));
		if (profile.isIsSchFri().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 6, profile.getIntervalSize().intValue()));
		if (profile.isIsSchSat().booleanValue())
			daysList.addAll(fromDt.listMonthlyDates(fromDt, toDt, instance, 7, profile.getIntervalSize().intValue()));

		return daysList;
	}

	/**
	 * @param sess
	 * @param profile
	 * @param source
	 * @param fromDate
	 * @param toDate
	 * @return
	 * @throws DomainException
	 */
	public int generateProfileSlots(DomainFactory factory, Sch_Profile profile, ims.framework.utils.Date fromDt, ims.framework.utils.Date toDt, BookingSource source) throws DomainException
	{
		try
		{
			//WDEV-8531
			if(profile.isIsActive() != null && !profile.isIsActive())
				return 0;
			
			// wdev-5651 - hold onto the first day of the week for this profile
			// we will need it later when  calculating the lastActualGenDate
			// this will store the last date a session was generated from
			// starting with the first day of the profile
			int firstDay=0;
			if (profile.isIsSchSun())
				firstDay=Calendar.SUNDAY;
			else if (profile.isIsSchMon())
				firstDay=Calendar.MONDAY;
			else if (profile.isIsSchTue())
				firstDay=Calendar.TUESDAY;
			else if (profile.isIsSchWed())
				firstDay=Calendar.WEDNESDAY;
			else if (profile.isIsSchThur())
				firstDay=Calendar.THURSDAY;
			else if (profile.isIsSchFri())
				firstDay=Calendar.FRIDAY;
			else if (profile.isIsSchSat())
				firstDay=Calendar.SATURDAY;
			
			Date modifiedFromDt = new ims.framework.utils.Date(profile.getEffFrm());
			
			// wdev-5925 If the toDate is later than the effective To date of the profile, we need
			// to update the toDate to the earlier value
			if(profile.getEffTo() != null)
			{
				if (toDt.getDate().after(profile.getEffTo()))
					toDt = new Date(profile.getEffTo());
			}

			// wdev-5651 we need to set the modified From Date to the last actual gen date
			// so that the date are calculated correctly - especially for those profiles with > 1 weekly intervals
			if (profile.getLastActualGenDate() != null && /* WDEV-6918 */ profile.getLastActualGenDate().after(modifiedFromDt.getDate()))
				modifiedFromDt = new Date(profile.getLastActualGenDate());

			// The fromDate should be set to the firstDay of the week to ensure correct generation
			// so if fromDate is Thursday, and first day is Tuesday, move back the from Date by 2 days
			ImsDate imsFromDt = new ImsDate(modifiedFromDt.toString(DateFormat.ISO));
			int fromDayOfWeek = imsFromDt.getDayOfWeek();
			if (fromDayOfWeek > firstDay)
			{
				imsFromDt.addValue(ImsDate.DAYS, (-1*(fromDayOfWeek - firstDay)));
				modifiedFromDt = new Date(imsFromDt.toString(true), DateFormat.ISO);
			}
			
			if (modifiedFromDt.getDate().after(toDt.getDate()))
				return 0;
			
			// Generate the list of days to generate for
			LinkedList generatedDays = new LinkedList();
			
			//WDEV-7237
			if(toDt != null && modifiedFromDt != null && toDt.isGreaterThan(modifiedFromDt))			
				generateDaysList(profile, modifiedFromDt, toDt, generatedDays);
						
			ImsDate lastActualDate=null;
			int countGeneratedSessions = 0;
			if (generatedDays.size() > 0)
			{
				//WDEV-5171
				removeGlobalExclusions(factory, generatedDays);				
				
				// Remove any exclusion dates for the profiles
				removeExclusions(profile, generatedDays);
				
				// populateSessionDetails for each day in the generatedDays list
				for (int j = 0; j < generatedDays.size(); j++)
				{
					ImsDate dt = (ImsDate) generatedDays.get(j);
					
					if (dt.before(fromDt.getDate()))  // wdev-5651
					{
						if (dt.getDayOfWeek() == Calendar.SUNDAY)	//wdev-11339
							lastActualDate = dt;
						continue;
					}
					
					// wdev-10444 as the date values seem to include time, the after doesn't work well 
					// when it's the actual last day.  Only exclude if the ISO format 'YYYYMMDD' text values
					// also don't equal i.e. it's not the same day
					if (dt.after(toDt.getDate()) && !dt.toString(true).equals(toDt.toString(DateFormat.ISO)))  // WDEV-10444 (extra check)
						continue;
					
					
					if (dt.getDayOfWeek() == Calendar.SUNDAY)	//wdev-11339
						lastActualDate = dt;
					
					Sch_Session session = createSession(factory, profile, dt.toString(true), source);
					
					
					
					// null will be returned if there is already a session for
					// this date
					if (session != null)
					{
						countGeneratedSessions++;
						factory.save(session);
					}
				}
			}
			profile.setLastGenDate(toDt.getDate());
			//WDEV-7238
			if(lastActualDate != null)
			{
				//WDEV-10530 - audit will not pick up changes if send in as ImsDate type
				profile.setLastActualGenDate(new java.util.Date(lastActualDate.getMilliSeconds()));
			}
			return countGeneratedSessions;
		}
		catch (StaleObjectException e)
		{
			throw new DomainException("StaleObjectException occurred saving session details - " + e.getMessage(), e);
		}
		catch (Exception e)
		{
			throw new DomainInterfaceException("Exception occurred generating session details - " + e.getMessage(), e);
		}
	}

	private void removeGlobalExclusions(DomainFactory factory, LinkedList generatedDays) throws DomainException
	{
		ExclusionDates impl = (ExclusionDates) getDomainImpl(ExclusionDatesImpl.class);
		ExclusionDatesVo exDate = impl.listExclusionDates();

		if(exDate == null)
			return;
		
		try
		{
			ImsDate[] dates = null;
			if (exDate.getDates() != null)
			{
				dates = new ImsDate[exDate.getDates().length];
				for (int i = 0; i < exDate.getDates().length; i++)
				{
					dates[i] = new ImsDate(exDate.getDates()[i].toString(DateFormat.ISO));
				}
			}

			ImsDate startDt = new ImsDate(new Date().toString(DateFormat.ISO));
			startDt.removeSpecifiedDates(generatedDays, dates);
		}
		catch (Exception e)
		{
			throw new DomainException("Exception occurred in removeGlobalExclusions - " + e.getMessage(), e);
		}  
	}

	public LocationLiteVoCollection loadLocations() 
	{
		DomainFactory factory=getDomainFactory();
		IMSCriteria imsc=new IMSCriteria(Location.class,factory);
		imsc.equal(Location.FieldNames.IsActive, true);
		imsc.equal(Location.FieldNames.IsVirtual, false);
		imsc.addOrder(Location.FieldNames.Name, ORDERMODE.ASC);
		imsc.notEqual(Location.FieldNames.Type + ".id", LocationType.SURGERY.getID());
		List locations=imsc.find();
		if (locations!=null&&locations.size()>0)
			return LocationLiteVoAssembler.createLocationLiteVoCollectionFromLocation(locations);
		return null;
	}

	public ProfileShortVoCollection loadProfiles(LocationRefVo location, String name) 
	{
		DomainFactory factory=getDomainFactory();
		IMSCriteria imsc=new IMSCriteria(Sch_Profile.class,factory);
		
		if (location!=null && location.getID_LocationIsNotNull())
		{
			imsc.join("this.schLocation", "location");
			imsc.equal("location.id", location.getID_Location());
		}
		if (name!=null)
			imsc.like("this.name", name + "%");
		imsc.addOrder("name", ORDERMODE.ASC);
		imsc.setMaxResults(1000);
		List profiles=imsc.find();
		if (profiles.size()>0)
			return ProfileShortVoAssembler.createProfileShortVoCollectionFromSch_Profile(profiles);
		return null;
		
		
	}

	public ProfileShortVoCollection listProfiles(LocationRefVo location,Sch_ProfileRefVo profile,ServiceRefVo service, Boolean isActive) 
	{
		DomainFactory factory=getDomainFactory();
		IMSCriteria imsc=new IMSCriteria(Sch_Profile.class,factory);
		if (location!=null && location.getID_LocationIsNotNull())
		{
			imsc.join("this.schLocation", "location");
			imsc.equal("location.id", location.getID_Location());
		}
		if (service!=null && service.getID_ServiceIsNotNull())
		{
			imsc.join("this.service", "serv");
			imsc.equal("serv.id", service.getID_Service());
		}
			
		if (profile!=null && profile.getID_Sch_ProfileIsNotNull())
			imsc.equal("this.id", profile.getID_Sch_Profile());
		if (isActive!=null&&isActive==true)
			imsc.equal("this.isActive", isActive);
		
		imsc.addOrder("name", ORDERMODE.ASC);
		imsc.setMaxResults(1000);
		List profiles=imsc.find();
		
		if (profiles.size()>0)
			return ProfileShortVoAssembler.createProfileShortVoCollectionFromSch_Profile(profiles);
		return null;
				
	}

	public ServiceLiteVoCollection listActiveServiceByName(String name)
	{
		DomainFactory factory=getDomainFactory();
		IMSCriteria imsc=new IMSCriteria(Service.class,factory);
		
		imsc.equal("this.isActive", Boolean.TRUE);
		if (name!=null)
			imsc.like("this.serviceName", name + "%");
		imsc.addOrder("serviceName", ORDERMODE.ASC);
		imsc.setMaxResults(200);
		List services=imsc.find();
		if (services.size()>0)
			return ServiceLiteVoAssembler.createServiceLiteVoCollectionFromService(services);
		return null;	
	}

	public ProfileShortVo getProfile(Sch_ProfileRefVo profile)
	{
		if (profile == null || profile.getID_Sch_Profile() == null)
			throw new CodingRuntimeException("profile is null or id not provided in method getProfile");
		
		return ProfileShortVoAssembler.create((Sch_Profile) getDomainFactory().getDomainObject(profile));
	}

	//WDEV-12664
	public Integer countSessionsForProfile(Sch_ProfileRefVo profile)
	{
		if (profile == null)
			throw new CodingRuntimeException("profile cannot be null in method countSessionsForProfile");
		
		String hql = "select count (sess.id) from Sch_Session as sess left join sess.sch_Profile as prof where prof.id = " +  profile.getID_Sch_Profile();
		List ret = getDomainFactory().find(hql);
		
		if (ret != null && ret.get(0) != null)
		{
			if (ret.get(0) instanceof Integer)
			{
				Integer iCount = (Integer) ret.get(0);
				return iCount;
			}
			else if (ret.get(0) instanceof Long)
			{
				Long lCount = (Long) ret.get(0);
				return lCount.intValue();
			}
		}
		return 0;
	}

	//WDEV-17916
	public Boolean createAdHocSession(ProfileShortVo profile, Date date) throws DomainInterfaceException, StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		Sch_Profile doProfile = (Sch_Profile) factory.getDomainObject(Sch_Profile.class, profile.getID_Sch_Profile());

		ImsDate imsDate;
		
		try
		{
			imsDate = new ImsDate(date.toString(DateFormat.ISO));
			
			Sch_Session session = createSession(factory, doProfile, imsDate.toString(true), BookingSource.INTERNAL);
			
			/* no need to update the Last Generated Date for an Ad-Hoc session
			if (doProfile.getLastGenDate() != null && profile.getLastGenDate().isLessThan(date))
			{
				doProfile.setLastGenDate(imsDate);
			}
			*/
			
			// null will be returned if there is already a session for this date
			if (session != null)
			{
				factory.save(session);
				return true;
			}
			else 
				return false;
		}
		catch (Exception e)
		{
			throw new DomainInterfaceException("Exception occurred generating session details - " + e.getMessage(), e);
		}
	}
}
