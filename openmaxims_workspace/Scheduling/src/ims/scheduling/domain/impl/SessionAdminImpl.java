//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.30 build 2012.21169)
// Copyright (C) 1995-2005 IMS MAXIMS plc. All rights reserved.

package ims.scheduling.domain.impl;

import ims.admin.domain.ApplicationUsers;
import ims.admin.domain.HcpAdmin;
import ims.admin.domain.MosAdmin;
import ims.admin.domain.impl.ApplicationUsersImpl;
import ims.admin.domain.impl.HcpAdminImpl;
import ims.admin.domain.impl.MosAdminImpl;
import ims.admin.vo.AppRoleShortVoCollection;
import ims.admin.vo.AppUserShortVo;
import ims.admin.vo.AppUserShortVoCollection;
import ims.admin.vo.domain.AppRoleShortVoAssembler;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.OrderInvAppt;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.lookups.AdditionalInvestigationAppointmentsStatus;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.configuration.gen.ConfigFlag;
import ims.core.helper.IElectiveListCancelAppt;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.resource.people.vo.HcpRefVoCollection;
import ims.core.vo.ActivityLiteVoCollection;
import ims.core.vo.HcpFilter;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.MemberOfStaffShortVo;
import ims.core.vo.MemberOfStaffShortVoCollection;
import ims.core.vo.ProcedureLiteVoCollection;
import ims.core.vo.lookups.ReferralManagementContractType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.impl.DomainImpl;
import ims.domain.lookups.LookupInstance;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;
import ims.ocrr.orderingresults.domain.objects.OcsOrderSession;
import ims.ocrr.orderingresults.domain.objects.OrderInvestigation;
import ims.ocrr.orderingresults.vo.OrderInvestigationRefVo;
import ims.ocrr.vo.lookups.Category;
import ims.ocrr.vo.lookups.OrderInvStatus;
import ims.pathways.configuration.domain.objects.Event;
import ims.pathways.configuration.vo.EventRefVo;
import ims.pathways.domain.HL7PathwayIf;
import ims.pathways.domain.impl.HL7PathwayIfImpl;
import ims.pathways.domain.objects.PatientEvent;
import ims.pathways.domain.objects.PatientJourneyTarget;
import ims.pathways.helper.ISchedulingCancelAppt;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.PatientJourneyTargetRefVo;
import ims.pathways.vo.PatientJourneyTargetVo;
import ims.pathways.vo.PatientJourneyVo;
import ims.pathways.vo.domain.PatientEventVoAssembler;
import ims.pathways.vo.domain.PatientJourneyTargetVoAssembler;
import ims.scheduling.domain.OCSExternalEvents;
import ims.scheduling.domain.Profiles;
import ims.scheduling.domain.SessionDetailsEdit;
import ims.scheduling.domain.objects.Appointment_Status;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.DirectoryOfServiceSessionSlot;
import ims.scheduling.domain.objects.Sch_Session;
import ims.scheduling.domain.objects.SessionActivityPathwayEvent;
import ims.scheduling.domain.objects.SessionParentChildSlot;
import ims.scheduling.domain.objects.SessionSlotStatus;
import ims.scheduling.domain.objects.SessionTheatreTCISlot;
import ims.scheduling.domain.objects.Session_Slot;
import ims.scheduling.domain.objects.TheatreProcedure;
import ims.scheduling.helper.CABRequests;
import ims.scheduling.vo.Appointment_StatusVo;
import ims.scheduling.vo.BookingAppointmentLiteVoCollection;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.DirectoryOfServiceVo;
import ims.scheduling.vo.DirectoryofServiceRefVo;
import ims.scheduling.vo.ProfileLiteVoCollection;
import ims.scheduling.vo.Sch_ProfileRefVo;
import ims.scheduling.vo.Sch_SessionRefVo;
import ims.scheduling.vo.SessionShortVo;
import ims.scheduling.vo.SessionSlotVo;
import ims.scheduling.vo.SessionTheatreVo;
import ims.scheduling.vo.SessionVo;
import ims.scheduling.vo.domain.BookingAppointmentLiteVoAssembler;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.DirectoryOfServiceLiteVoAssembler;
import ims.scheduling.vo.domain.ProfileLiteVoAssembler;
import ims.scheduling.vo.domain.SessionShortVoAssembler;
import ims.scheduling.vo.domain.SessionSlotVoAssembler;
import ims.scheduling.vo.domain.SessionTheatreVoAssembler;
import ims.scheduling.vo.domain.SessionVoAssembler;
import ims.scheduling.vo.lookups.SchedCABSlotType;
import ims.scheduling.vo.lookups.Session_Status_and_Reason;
import ims.scheduling.vo.lookups.Status_Reason;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

public class SessionAdminImpl extends DomainImpl implements ims.scheduling.domain.SessionAdmin, SessionDetailsEdit, ims.domain.impl.Transactional, ISchedulingCancelAppt, IElectiveListCancelAppt
{
	private static final long	serialVersionUID	= 1L;

	public ims.scheduling.vo.SessionShortVoCollection listSession(Sch_ProfileRefVo profile, DirectoryofServiceRefVo dos, Date startDate, Date endDate)
	{
		DomainFactory factory = getDomainFactory();

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		StringBuffer condStr = new StringBuffer();
		String hql = " from Sch_Session sess ";
		String andStr = " ";

		if (dos != null)
		{
			condStr.append(andStr + " left join fetch sess.directoryofServices as dos where dos.id  = :idDos");
			markers.add("idDos");
			values.add(dos.getID_DirectoryofService());
			andStr = " and ";
		}
		if (profile != null)
		{
			condStr.append(andStr + " sess.sch_Profile.id = :idProfile");
			markers.add("idProfile");
			values.add(profile.getID_Sch_Profile());
			andStr = " and ";
		}
		if (startDate != null)
		{
			condStr.append(andStr + " sess.sessionDate >= :startDate");
			markers.add("startDate");
			values.add(startDate.getDate());
			andStr = " and ";
		}
		if (endDate != null)
		{
			condStr.append(andStr + " sess.sessionDate <= :endDate");
			markers.add("endDate");
			values.add(endDate.getDate());
			andStr = " and ";
		}

		if (andStr.equals(" and ") && dos == null)
			hql += " where ";

		hql += condStr.toString();
		
		return SessionShortVoAssembler.createSessionShortVoCollectionFromSch_Session(factory.find(hql, markers, values)).sort();
	}

	// 	WDEV-15190
	public ProfileLiteVoCollection listProfile(String profileName)
	{
		if(profileName == null || profileName.length() == 0)
			throw new CodingRuntimeException("Cannot search on a null ProfileName");
		
		String query = "SELECT profile FROM Sch_Profile AS profile WHERE upper(profile.name) like :ProfileName and profile.isActive = 1 ORDER BY UPPER(profile.name) ASC";
		
		return ProfileLiteVoAssembler.createProfileLiteVoCollectionFromSch_Profile(getDomainFactory().find(query, new String[] {"ProfileName"}, new Object[] {profileName.toUpperCase() + "%"}));
	}

	// 	WDEV-15190
	public ims.scheduling.vo.DirectoryOfServiceLiteVoCollection listDos(String dosName)
	{
		if(dosName == null || dosName.length() == 0)
			throw new CodingRuntimeException("Cannot search on a null DosName");
		
		String query = "SELECT dos FROM DirectoryofService AS dos WHERE upper(dos.doSName) like :DosName and dos.isActive = 1 order by upper(dos.doSName) asc";
		
		return DirectoryOfServiceLiteVoAssembler.createDirectoryOfServiceLiteVoCollectionFromDirectoryofService(getDomainFactory().find(query, new String[] {"DosName"}, new Object[] {dosName.toUpperCase() + "%"}));
	}

	public ims.scheduling.vo.SessionShortVoCollection listSession(DirectoryOfServiceVo directoryOfService, Date startDate, Date endDate)
	{
		DomainFactory factory = getDomainFactory();

		String hql = "from Sch_Session session";

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		String andStr = " ";
		StringBuffer condStr = new StringBuffer();

		if (directoryOfService != null)
		{
			hql = " Select session from Sch_Session session" + " join session.directoryofServices as dos" + " where dos.doSId = :userDosId";
			markers.add("userDosId");
			values.add(directoryOfService.getDoSId());
			andStr = " and ";
		}
		if (startDate != null)
		{
			condStr.append(andStr + " session.sessionDate >= :startDate");
			markers.add("startDate");
			values.add(startDate.getDate());
			andStr = " and ";
		}
		if (endDate != null)
		{
			condStr.append(andStr + " session.sessionDate <= :endDate");
			markers.add("endDate");
			values.add(endDate.getDate());
			andStr = " and ";
		}

		if (directoryOfService == null)
		{
			if (andStr.equals(" and "))
				hql += " where ";

		}

		hql += condStr.toString();
		return SessionShortVoAssembler.createSessionShortVoCollectionFromSch_Session(factory.find(hql, markers, values)).sort();
	}

	/**
	 * editingSlots parameter determines if the call to save Session was made
	 * from SessionAdmin or SessionDetailsEdit if it is set to true then it was
	 * called from SessionDetailsEdit
	 */
	public SessionVo saveSession(SessionVo session, Boolean editingSlots) throws StaleObjectException
	{
		if (!session.isValidated())
			throw new DomainRuntimeException("SessionVo not Validated");

		DomainFactory factory = getDomainFactory();
		Sch_Session doSession = SessionVoAssembler.extractSch_Session(factory, session);

		factory.save(doSession);

		if (doSession.getSessionStatus().equals(getDomLookup(Session_Status_and_Reason.CANCELLED)) || doSession.getSessionStatus().equals(getDomLookup(Session_Status_and_Reason.BLOCKED)))
		{
			if (doSession.isIsActive().booleanValue())
			{
				// WDEV-5458 Blocked functionality moved up so that they are all
				// grouped together
				if (doSession.getSessionStatus().equals(getDomLookup(Session_Status_and_Reason.BLOCKED)) && ConfigFlag.GEN.ICAB_ENABLED.getValue())
				{
					// For blocked sessions, we want to build up the usrn list
					// and include it as one request
					StringBuffer slotCabMessage = new StringBuffer();
					Iterator<?> it = doSession.getSessionSlots().iterator();
					while (it.hasNext())
					{
						Session_Slot doSlot = (Session_Slot) it.next();

						// WDEV-10148 - need to look at slottype here and if its
						// local skip the c&b messaging and setting to
						// cancel_provisional etc below
						if (doSlot.getDirectAccessSlot() != null && doSlot.getDirectAccessSlot().equals(getDomLookup(SchedCABSlotType.LOCAL)))
						{
							doSlot.setIsActive(Boolean.FALSE);
							continue;
						}

						// WDEV-8887 - we dont want to cancel an already pending
						// cancelation
						if (doSlot.getStatus() != null && (doSlot.getStatus().equals(getDomLookup(Status_Reason.CANCEL_PROVISIONAL)) || doSlot.getStatus().equals(getDomLookup(Status_Reason.CANCELLED))))
							continue;

						if (doSlot.getAppointment() == null) // wdev-5726
																// ispublished
																// is now
																// checked at
																// buildCabMessage
																// level
						{
							slotCabMessage.append(doSlot.buildCabMessage());
							if (slotCabMessage.length() > 1300) // 1500 is max
																// size - send
																// if reached
																// and start
																// again
							{
								if (ims.configuration.gen.ConfigFlag.DOM.SCHEDULING_SLOTS_CREATION.getValue().equals("Choose and Book"))
								{
									CABRequests.placeOutgoingRequest(factory, getDomLookup(ActionRequestType.NOTIFY_SLOT_CANCEL), slotCabMessage.toString(), "Session Block requested through Session Admin");
								}
								slotCabMessage.setLength(0);
							}
							doSlot.setStatus(getDomLookup(Status_Reason.CANCEL_PROVISIONAL));
							doSlot.setIsActive(Boolean.FALSE);
						}
					}
					if (slotCabMessage.length() > 0)
					{
						if (ims.configuration.gen.ConfigFlag.DOM.SCHEDULING_SLOTS_CREATION.getValue().equals("Choose and Book"))
						{
							CABRequests.placeOutgoingRequest(factory, getDomLookup(ActionRequestType.NOTIFY_SLOT_CANCEL), slotCabMessage.toString(), "Session Block requested through Session Admin");
						}
					}
				}
			}
		}

		// for each slot in the collection of slots for the session
		// we need to update their individual status's and history
		// Calling Clinic list impl to update the records and send
		// cab message
		session = SessionVoAssembler.create(doSession);
		if (session.getSessionSlotsIsNotNull())
		{

			for (int i = 0; i < session.getSessionSlots().size(); i++)
			{
				if (editingSlots)
				{
					if (session.getSessionSlots().get(i).getStatus().equals(Status_Reason.CANCELLED) || session.getSessionSlots().get(i).getStatus().equals(Status_Reason.BLOCKED))
						cancelSlot(session.getSessionSlots().get(i), ActionRequestType.NOTIFY_SLOT_CANCEL, "Cancel Slot requested through SessionAdmin");
				}
				else
				{
					if (doSession.getSessionStatus().equals(getDomLookup(Session_Status_and_Reason.CANCELLED)))
					{
						if (session.getSessionSlots().get(i).getAppointmentIsNotNull())
						{
							cancelAppt(session.getSessionSlots().get(i).getAppointment(), ActionRequestType.NOTIFY_APPT_CANCEL, "Cancel Appt requested from Session Admin");
						}
						else
						{
							cancelSlot(session.getSessionSlots().get(i), ActionRequestType.NOTIFY_SLOT_CANCEL, "Cancel Slot requested through SessionAdmin");
						}
					}
				}
			}
		}

		// WDEV-11731
		saveSessionForMaxContinuousTime(session);

		return SessionVoAssembler.create(doSession);
	}

	public SessionVo getSession(SessionShortVo sessionShort)
	{
		DomainFactory factory = getDomainFactory();

		Sch_Session doSession = (Sch_Session) factory.getDomainObject(Sch_Session.class, sessionShort.getID_Sch_Session());
		SessionVo voSession = SessionVoAssembler.create(doSession);

		return voSession;
	}

	public void cancelSlot(SessionSlotVo sessionSlot, ActionRequestType requestType, String requestSource) throws StaleObjectException
	{
		if (sessionSlot == null)
			return;

		DomainFactory factory = getDomainFactory();

		// WDEV-8887 - we dont want to cancel an already pending cancelation
		Session_Slot doSlot = (Session_Slot) factory.getDomainObject(sessionSlot);
		if (doSlot.getStatus() != null && doSlot.getStatus().equals(getDomLookup(Status_Reason.CANCEL_PROVISIONAL)))
			return;

		Session_Slot doSessionSlot = SessionSlotVoAssembler.extractSession_Slot(factory, sessionSlot);

		// WDEV-10148
		if (doSessionSlot.getDirectAccessSlot() != null && doSessionSlot.getDirectAccessSlot().equals(getDomLookup(SchedCABSlotType.LOCAL)))
		{
			doSessionSlot.setIsActive(Boolean.FALSE);
		}
		else
		{
			// wdev-5726
			if (ConfigFlag.GEN.ICAB_ENABLED.getValue())
				CABRequests.sendRequestandUpdateReferences(factory, getDomLookup(requestType), doSessionSlot, requestSource);

			// //wdev-5726 doSessionSlot.setIsPublished(false);
			// // update isPublished for all DOS off the slot
			boolean publishedSlot = false;
			Iterator<?> it = doSessionSlot.getDirectoryOfServices().iterator();
			while (it.hasNext())
			{
				ims.scheduling.domain.objects.DirectoryOfServiceSessionSlot slotDos = (DirectoryOfServiceSessionSlot) it.next();
				if (slotDos.isIsPublished() != null && slotDos.isIsPublished().booleanValue() == true && slotDos.getUBRN() == null)
				{
					publishedSlot = true;
					break;
					// slotDos.setIsPublished(false);
				}
			}
			// wdev-5745
			// We will only set isPublished flag to false when we receive the
			// ACK
			// back from C&B
			// Set the current status to cancel_provisional for the slot if it
			// is
			// currently published

			if (ConfigFlag.GEN.ICAB_ENABLED.getValue() && publishedSlot &&
			// wdev-5850 Added this line as slot status should not be updated if
			// appt booked into it
			!sessionSlot.getStatus().equals(Status_Reason.APPOINTMENT_BOOKED) && !sessionSlot.getAppointmentIsNotNull())
			{
				doSessionSlot.setStatus(getDomLookup(Status_Reason.CANCEL_PROVISIONAL));
				doSessionSlot.setIsActive(Boolean.FALSE);
			}
		}

		factory.save(doSessionSlot);
	}

	private Booking_Appointment saveAppt(DomainFactory factory, Booking_AppointmentVo appt) throws StaleObjectException
	{
		Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, appt);

		// increment slots remaining if its a cancel
		// wdev-5745 only for non-icab bookings as they will get set to
		// provisional only
		if ((doAppt.isIsCABBooking() == null || doAppt.isIsCABBooking().booleanValue() == false) && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.CANCELLED)))
			doAppt.getSession().incrementRemainingSlots(1);

		// WDEV-8921 - if we are cancelling a flexible slot increment the time remaining for the session 	<- Nice try, but no
		
		// WDEV-14463 - For cancelled appointment - re add the time.
		if ((doAppt.getSession() != null && doAppt.getSession().isIsFixed() != null && !doAppt.getSession().isIsFixed()) && (doAppt.getApptStatus() != null && doAppt.getApptStatus().equals(getDomLookup(Status_Reason.CANCELLED))))
		{
			if (doAppt.getSession().getRemainingTime() != null && doAppt.getApptStartTime() != null && doAppt.getApptEndTime() != null && doAppt.getSession().getStartTm() != null && doAppt.getSession().getEndTm() != null)
			{
				Time sessionStartTime = new Time(doAppt.getSession().getStartTm());
				Time sessionEndTime = new Time(doAppt.getSession().getEndTm());
				
				Time appointmentStartTime = new Time(doAppt.getApptStartTime());
				Time appointmentEndTime = new Time(doAppt.getApptEndTime());
				
				Time startTime = sessionStartTime.isGreaterOrEqualThan(appointmentStartTime) ? sessionStartTime : appointmentStartTime;
				Time endTime = sessionEndTime.isLessOrEqualThan(appointmentEndTime) ? sessionEndTime : appointmentEndTime;
				

				if ((appointmentStartTime.isGreaterOrEqualThan(appointmentEndTime) && startTime.isGreaterOrEqualThan(endTime)) || startTime.isLessOrEqualThan(endTime))
				{
					doAppt.getSession().setRemainingTime(doAppt.getSession().getRemainingTime() + calculateApptDuration(startTime, endTime));
				}
			}
		}

		// WDEV-5745 only set to cancelled provisional at this stage
		if (doAppt.isIsCABBooking() != null && doAppt.isIsCABBooking().booleanValue() == true && ConfigFlag.GEN.ICAB_ENABLED.getValue())
			doAppt.setApptStatus(getDomLookup(Status_Reason.CANCEL_PROVISIONAL));

		// WDEV-5021
		updateJourney(doAppt, true);

		/*
		 * WDEV-11780 try { factory.save(doAppt); } catch (DomainException e) {
		 * throw new DomainRuntimeException("Domain Error occured in saveAppt "
		 * + e.getMessage(), e); }
		 */

		// WDEV-11780
		factory.save(doAppt);

		return doAppt;
	}

	private int calculateApptDuration(Time startTime, Time endTime)
	{
		if (startTime == null || endTime == null)
			throw new CodingRuntimeException("apptStartTime or apptEndTime is null in method calculateApptDuration");
	
		int mins = endTime.getTotalMinutes() - startTime.getTotalMinutes();
		//appt has gone past midnight
		if(endTime.isLessThan(startTime))	
		{
			Time midNight = new Time(23,59);
			mins = midNight.getTotalMinutes() + 1 - startTime.getTotalMinutes() + endTime.getTotalMinutes(); 
		}
			
		return mins;
	}

	public Booking_AppointmentVo cancelAppt(Booking_AppointmentVo appt, ActionRequestType requestType, String requestSource) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		Booking_Appointment doAppt = saveAppt(factory, appt);
		
		if (ConfigFlag.GEN.ICAB_ENABLED.getValue())
		{
			if (doAppt.isIsCABBooking() != null && doAppt.isIsCABBooking().booleanValue())
				doAppt = CABRequests.sendRequestandUpdateReferences(factory, getDomLookup(requestType), doAppt, requestSource);
		}

		// if the appt has been cancelled,break the link between sessionslot and
		// booking_appt
		// wdev-5745 do not clear link with slot for icab bookings
		if (requestType.equals(ActionRequestType.NOTIFY_APPT_CANCEL) && (doAppt.isIsCABBooking() == null || doAppt.isIsCABBooking().booleanValue() == false))
		{
			if (doAppt != null)
			{
				if (doAppt.getSessionSlot() != null)
				{
					doAppt.getSessionSlot().clearUBRN();
					doAppt.getSessionSlot().setStatus(getDomLookup(Status_Reason.SLOTOPENED));
					doAppt.getSessionSlot().setAppointment(null);
					doAppt.setSessionSlot(null);
				}

				factory.save(doAppt);
			}
			
			List<?> ordInvAppts = factory.find("from OrderInvAppt oia where oia.appointment.id = '" + doAppt.getId() + "'");
			if (ordInvAppts.size() > 0)
			{
				OrderInvestigation doOrderInv = ((OrderInvAppt) ordInvAppts.iterator().next()).getOrderInvestigation();

				OCSExternalEvents implE = (OCSExternalEvents) getDomainImpl(OCSExternalEventsImpl.class);
				implE.generateAppointmentCancelEvent(new Booking_AppointmentRefVo(doAppt.getId(), doAppt.getVersion()), new OrderInvestigationRefVo(doOrderInv.getId(), doOrderInv.getVersion()));

				Integer nContractTypeId = getContractTypeIdFromReferralContractForBookingId(doAppt.getId());
				if ( nContractTypeId != null 
					&& nContractTypeId == ReferralManagementContractType.DIAGNOSTIC.getId())
				{
					doOrderInv.setAppointmentDate(null);
					factory.save(doOrderInv);

					implE = (OCSExternalEvents) getDomainImpl(OCSExternalEventsImpl.class);
					implE.generateOrderUpdateEvent(new Booking_AppointmentRefVo(doAppt.getId(), doAppt.getVersion()), new OrderInvestigationRefVo(doOrderInv.getId(), doOrderInv.getVersion()));
				}
			}
		}
		else if (requestType.equals(ActionRequestType.NOTIFY_APPT_CANCEL))
		{
			if(doAppt != null && doAppt.getSessionSlot() != null) //WDEV-12348
				doAppt.getSessionSlot().setIsActive(Boolean.FALSE); // wdev-5745
		}
		
		if (doAppt.getTheatreBooking() != null)
		{
			updateProcedureNumLeftAndRemainingMins(doAppt);

			// WDEV-11777 re-open theatre slot
			if (doAppt.getTheatreSlot() != null)
			{
				SessionTheatreTCISlot doTheatreSlot = doAppt.getTheatreSlot();

				// re-open the slot that is not used now
				doTheatreSlot = reOpenTheatreTCISlot(doTheatreSlot);
			}
			
			//WDEV-12918
			if (doAppt.getParentChildSlot() != null)
			{
				SessionParentChildSlot doSlot = doAppt.getParentChildSlot();
				
				// re-open the slot that is not used now
				doSlot = reOpenTheatreFixedSlot(doSlot);
			}
			
			factory.save(doAppt);
		}

		Booking_AppointmentVo voAppt = Booking_AppointmentVoAssembler.create(doAppt);

		// WDEV-11731 - only for flexible sessions
		saveSessionForMaxContinuousTime(SessionShortVoAssembler.create(doAppt.getSession()));

		//	WDEV-15944 Is it possible to create a pathway event based on this booking?
		if (ConfigFlag.DOM.INSTANTIATE_EVENT_FROM_SCHEDULING.getValue())
		{
			ims.scheduling.domain.BookAppointment impl = (ims.scheduling.domain.BookAppointment) getDomainImpl(ims.scheduling.domain.impl.BookAppointmentImpl.class);
			impl.instantiateEvent(voAppt, "C", requestSource);
		}
		return voAppt;
	}

	private SessionParentChildSlot reOpenTheatreFixedSlot(SessionParentChildSlot doChangeFromSlot)
	{
		if (doChangeFromSlot == null)
			return null;

		doChangeFromSlot.setAppointment(null);
		doChangeFromSlot.setStatus(getDomLookup(Status_Reason.SLOTOPENED));
		
		if(doChangeFromSlot.getSession() != null)
		{
			if(doChangeFromSlot.getSession().getParentChildSlots() != null)
			{
				Iterator<?> it = doChangeFromSlot.getSession().getParentChildSlots().iterator();
				while(it.hasNext())
				{
					//release child slots
					SessionParentChildSlot doSlot = (SessionParentChildSlot) it.next();
					if(doSlot.getParentSlot() != null && doSlot.getParentSlot().equals(doChangeFromSlot))
					{
						doSlot.setParentSlot(null);
						doSlot.setStatus(getDomLookup(Status_Reason.SLOTOPENED));
					}
				}
			}
		}
		
		SessionSlotStatus doStat = new SessionSlotStatus();
		doStat.setDateTime(new java.util.Date());
		doStat.setStatus(doChangeFromSlot.getStatus());
		doStat.setStatusReason(doChangeFromSlot.getStatusReason());
		doChangeFromSlot.getStatusReasonHistory().add(doStat);
		
		return doChangeFromSlot;
	}

	private Integer getContractTypeIdFromReferralContractForBookingId(Integer nBookingId)
	{
		DomainFactory factory = getDomainFactory();
		List<?> contractId = factory.find("select cont.contractType.id from CatsReferral as cats left join cats.appointments as bk left join cats.contract as cont where (bk.id = '" + nBookingId + "')");
		if (contractId.size() > 0)
			return (Integer)contractId.get(0);
		else
			return null;
	}

	/**
	 * @param doChangeFromSlot
	 */
	public SessionTheatreTCISlot reOpenTheatreTCISlot(SessionTheatreTCISlot doChangeFromSlot)
	{
		// WDEV-11908
		if (doChangeFromSlot == null)
			return null;

		// WDEV-11908
		if (doChangeFromSlot.getAppointment() != null)
			doChangeFromSlot.getAppointment().setTheatreSlot(null);

		doChangeFromSlot.setAppointment(null);

		doChangeFromSlot.setStatus(getDomLookup(Status_Reason.SLOTOPENED));
		doChangeFromSlot.setStatusReason(getDomLookup(Status_Reason.SLOTOPENED));

		SessionSlotStatus doStat = new SessionSlotStatus();
		doStat.setDateTime(new java.util.Date());
		doStat.setStatus(doChangeFromSlot.getStatus());
		doStat.setStatusReason(doChangeFromSlot.getStatusReason());
		doChangeFromSlot.getStatusReasonHistory().add(doStat);

		return doChangeFromSlot;
	}

	private void updateProcedureNumLeftAndRemainingMins(Booking_Appointment doAppt)
	{
		int procedureMinsUsed = 0;
		Sch_Session doTheatreSession = doAppt.getSession();
		if (doAppt.getTheatreBooking() != null)
		{
			if (doAppt.getTheatreBooking().getProcedure() != null)
			{
				if (doAppt.getSession().getTheatreProceduresRemaining() != null && doAppt.getSession().getTheatreProceduresRemaining().getProcedureDetails() != null)
				{
					Iterator it1 = doAppt.getSession().getTheatreProceduresRemaining().getProcedureDetails().iterator();
					while (it1.hasNext())
					{
						TheatreProcedure doTheatreProc = (TheatreProcedure) it1.next();
						if (doTheatreProc.getProcedure() != null)
						{
							if (doTheatreProc.getProcedure().getId().equals(doAppt.getTheatreBooking().getProcedure().getId()) && (doTheatreProc.isIsLimited() != null && doTheatreProc.isIsLimited()) && doTheatreProc.getNumberOfProceduresLeft() != null)
								doTheatreProc.setNumberOfProceduresLeft(new Integer(doTheatreProc.getNumberOfProceduresLeft().intValue() + 1));
						}
					}
				}
				// WDEV-9643
				if (doAppt.getCustomProcedureDuration() != null)
					procedureMinsUsed += doAppt.getCustomProcedureDuration().intValue();
				else if (doAppt.getTheatreBooking().getProcedure().getDurationInMins() != null)
					procedureMinsUsed += doAppt.getTheatreBooking().getProcedure().getDurationInMins().intValue();

			}
		}

		if (procedureMinsUsed > 0 && doTheatreSession != null && doTheatreSession.getTheatreProceduresRemaining() != null && doTheatreSession.getTheatreProceduresRemaining().getRemainingTimeInMins() != null)
			doTheatreSession.getTheatreProceduresRemaining().setRemainingTimeInMins(new Integer(doTheatreSession.getTheatreProceduresRemaining().getRemainingTimeInMins().intValue() + procedureMinsUsed));
	}

	public AppUserShortVoCollection listUsers()
	{
		AppUserShortVo filter = new AppUserShortVo();
		filter.setIsActive(new Boolean(true));
		ApplicationUsers userAdmin = (ApplicationUsers) getDomainImpl(ApplicationUsersImpl.class);
		return userAdmin.listAppUsers(filter);
	}

	public MemberOfStaffShortVoCollection listMos(MemberOfStaffShortVo mosShort)
	{
		MosAdmin impl = (MosAdmin) getDomainImpl(MosAdminImpl.class);
		return impl.listMembersOfStaff(mosShort);
	}

	public String getLookupInstanceMapping(Integer instanceId)
	{
		DomainFactory factory = getDomainFactory();
		LookupInstance doInstance = factory.getLookupInstance(instanceId.intValue());

		if (doInstance.getMapping("PAS") != null)
			return doInstance.getMapping("PAS").getExtCode();

		return "";
	}

	public void cancelSession(Sch_SessionRefVo session,	Appointment_StatusVo voApptCancelStatus, Boolean cancelAppointment, Boolean isFlexible) throws DomainInterfaceException, StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		Sch_Session doSession = (Sch_Session) factory.getDomainObject(session);

		doSession.setSessionStatus(getDomLookup(Session_Status_and_Reason.CANCELLED));
		doSession.setStatusReason(getDomLookup(Session_Status_and_Reason.CANCELLED));
		
		//WDEV-17929
		doSession.setComment(voApptCancelStatus.getComment());
		doSession.setCancellationReason(getDomLookup(voApptCancelStatus.getCancellationReason()));

		Iterator<?> it = doSession.getSessionSlots().iterator();

		boolean publishedSlot = false;
		StringBuffer slotCabMessage = new StringBuffer();
		while (it.hasNext())
		{
			Session_Slot doSlot = (Session_Slot) it.next();

			//WDEV-18466
			//if (doSlot.getAppointment() != null)
				//throw new DomainInterfaceException("Appointments exist within this session. It cannot be cancelled, blocking is possible instead."); //WDEV-15338

			if (cancelAppointment && doSlot.getAppointment() != null && getDomLookup(Status_Reason.BOOKED).equals(doSlot.getAppointment().getApptStatus()))
			{
				Booking_Appointment doAppToBeCancelled = doSlot.getAppointment();
				doAppToBeCancelled.setApptStatus(getDomLookup(Status_Reason.CANCELLED));
				
				Appointment_Status appStatus = new Appointment_Status();
				
				appStatus.setStatus(getDomLookup(Status_Reason.CANCELLED));
				appStatus.setStatusReason(getDomLookup(Status_Reason.SLOTOPENED));
				appStatus.setStatusChangeDateTime(new java.util.Date());
				
				doAppToBeCancelled.setCurrentStatusRecord(appStatus);
				
				if (doAppToBeCancelled.getApptStatusHistory() == null)
					doAppToBeCancelled.setApptStatusHistory(new HashSet());
				
				doAppToBeCancelled.getApptStatusHistory().add(appStatus);
				
				if (doAppToBeCancelled.getSessionSlot() != null)
				{
					doAppToBeCancelled.getSessionSlot().setStatus(getDomLookup(Status_Reason.SLOTOPENED));
				}
				
				Booking_AppointmentVo appToBeCancelledVo = Booking_AppointmentVoAssembler.create(doAppToBeCancelled);
				cancelAppt(appToBeCancelledVo, ActionRequestType.NOTIFY_SLOT_CANCEL, "Cancel Appt requested from Session Admin" );
			}
			
			
			// WDEV-8887 - we dont want to cancel an already pending cancelation
			if (doSlot.getStatus() != null && doSlot.getStatus().equals(getDomLookup(Status_Reason.CANCEL_PROVISIONAL)))
				continue;

			// wdev-5726 - Set dos slots to unpublished
			// update isPublished for all DOS off the slot
			if (!publishedSlot)
			{
				Iterator<?> it2 = doSlot.getDirectoryOfServices().iterator();
				while (it2.hasNext())
				{
					ims.scheduling.domain.objects.DirectoryOfServiceSessionSlot slotDos = (DirectoryOfServiceSessionSlot) it2.next();
					if (slotDos.isIsPublished() != null && slotDos.isIsPublished().booleanValue() == true)
					{
						publishedSlot = true;
						break;
						// wdev-5745 - set this
						// laterslotDos.setIsPublished(false);
					}
				}
			}

			if (publishedSlot)
			{
				doSlot.setStatus(getDomLookup(Status_Reason.CANCEL_PROVISIONAL));
				doSlot.setIsActive(Boolean.FALSE); // wdev-6713
			}
			else
				doSlot.setStatus(getDomLookup(Status_Reason.CANCELLED));
			doSlot.setStatusReason(getDomLookup(voApptCancelStatus.getStatusReason()));
			SessionSlotStatus doSlotStatus = new SessionSlotStatus();
			doSlotStatus.setDateTime(new DateTime(new Date(), new Time()).getJavaDate());
			doSlotStatus.setStatus(getDomLookup(voApptCancelStatus.getStatus()));
			doSlotStatus.setStatusReason(getDomLookup(voApptCancelStatus.getStatusReason()));
			doSlot.getStatusReasonHistory().add(doSlotStatus);

			// Do not send request if the slot status is now
			// cancelled_pending_appt as that request will be sent when
			// confirmation
			// of appointment cancellation is received from CAB
			if (ConfigFlag.GEN.ICAB_ENABLED.getValue() && doSlot.getStatus().getId() != Status_Reason.CANCELLED_PENDING_APPT.getId())
			{
				slotCabMessage.append(doSlot.buildCabMessage());
				if (slotCabMessage.length() > 1300) // 1500 is max size - send
													// if reached and start
													// again
				{
					if (ims.configuration.gen.ConfigFlag.DOM.SCHEDULING_SLOTS_CREATION.getValue().equals("Choose and Book"))
					{
						CABRequests.placeOutgoingRequest(factory, getDomLookup(ActionRequestType.NOTIFY_SLOT_CANCEL), slotCabMessage.toString(), "Slot Cancel requested through Session Admin");
					}
					slotCabMessage.setLength(0);
				}
			}

		}
		if (publishedSlot)
		{
			doSession.setSessionStatus(getDomLookup(Session_Status_and_Reason.CANCEL_PROVISIONAL));
			doSession.setStatusReason(getDomLookup(Session_Status_and_Reason.CANCEL_PROVISIONAL));
		}

		factory.save(doSession);

		if (ConfigFlag.GEN.ICAB_ENABLED.getValue() && slotCabMessage.length() > 0)
		{
			if (ims.configuration.gen.ConfigFlag.DOM.SCHEDULING_SLOTS_CREATION.getValue().equals("Choose and Book"))
			{
				CABRequests.placeOutgoingRequest(factory, getDomLookup(ActionRequestType.NOTIFY_SLOT_CANCEL), slotCabMessage.toString(), "Slot Cancel requested through Session Admin");
			}
		}

		// update Journey
		Iterator<?> it1 = doSession.getSessionSlots().iterator();
		while (it1.hasNext())
		{
			Session_Slot doSlot = (Session_Slot) it1.next();
			if (doSlot.getAppointment() != null)
				updateJourney(doSlot.getAppointment(), true);
		}
	}

	public void updateJourney(Booking_Appointment doAppt, Boolean isCancel) throws StaleObjectException
	{
		if (!ConfigFlag.DOM.SCHEDULING_LINKED_TO_PATHWAYS.getValue())
			return;

		DomainFactory factory = getDomainFactory();
		PatientEventVo voEvent = null;
		if (doAppt.getPathwayEvents() != null && doAppt.getPathwayEvents().size() > 0)
		{
			Iterator<?> it = doAppt.getSession().getActivityPathwayEvents().iterator();
			while (it.hasNext())
			{

				SessionActivityPathwayEvent doActPathEv = (SessionActivityPathwayEvent) it.next();
				if (doActPathEv.getActivity().getId().equals(doAppt.getActivity().getId()) && doActPathEv.getAppointmentStatus().equals(isCancel ? doAppt.getApptStatusReas() : doAppt.getApptStatus()))
				{
					try
					{
						voEvent = createAndSaveEvent(doActPathEv.getEvent(), doAppt, null);
					}
					catch (DomainInterfaceException e)
					{
						throw new DomainRuntimeException("Domain Error occured in save Appointment " + e.getMessage(), e);
					}
				}
			}
		}

		if (voEvent != null)
			doAppt.getPathwayEvents().add(PatientEventVoAssembler.extractPatientEvent(factory, voEvent));
	}

	public PatientEventVo createAndSaveEvent(Event event, Booking_Appointment doAppt, PatientJourneyVo voJourney) throws DomainInterfaceException, StaleObjectException
	{
		PatientEventVo voEvent = new PatientEventVo();
		voEvent.setEventDateTime(new DateTime());
		voEvent.setEvent(new EventRefVo(event.getId(), event.getVersion()));
		voEvent.setScheduledDate(new DateTime(new Date(doAppt.getAppointmentDate()), new Time(doAppt.getApptStartTime())));

		// called from this class
		if (voJourney == null)
		{
			PatientJourneyTargetVo voPatientJourneyTarget = PatientJourneyTargetVoAssembler.create(getFirstPathwayEvent(doAppt.getPathwayEvents()));
			if (voPatientJourneyTarget != null)
			{
				voEvent.setJourney(voPatientJourneyTarget.getPathwayJourney());
				if (voPatientJourneyTarget.getPathwayJourneyIsNotNull())
					voEvent.setPatient(voPatientJourneyTarget.getPathwayJourney().getPatient());

				voEvent.setPatientTarget(voPatientJourneyTarget);
				if (voPatientJourneyTarget.getPathwayJourney().getPathwayIsNotNull())
					voEvent.setSpecialty(voPatientJourneyTarget.getPathwayJourney().getPathway().getSpecialty());
			}
		}
		else
		{
			// called from Booking Screen
			voEvent.setJourney(voJourney);
			voEvent.setPatient(voJourney.getPatient());
			voEvent.setPatientTarget(getPatientTarget(event, voJourney));
			if (voJourney.getPathwayIsNotNull())
				voEvent.setSpecialty(voJourney.getPathway().getSpecialty());
		}

		HL7PathwayIf impl = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
		return impl.instantiatePatientEvent(voEvent);
	}

	private PatientJourneyTargetRefVo getPatientTarget(Event event, PatientJourneyVo voJourney)
	{
		String hql = "select pjt from PatientJourneyTarget as pjt left join pjt.pathwayTarget as pt left join pt.target as target1 left join pjt.pathwayJourney as pj, EventTarget as et left join et.target as target2 left join et.event as event where " + "(pj.id = :idJourney and event.id = :idEvent)";

		List<?> pjts = getDomainFactory().find(hql, new String[]{"idJourney", "idEvent"}, new Object[]{event.getId(), voJourney.getID_PatientPathwayJourney()});
		if (pjts != null && pjts.size() > 0)
			PatientJourneyTargetVoAssembler.create((PatientJourneyTarget) pjts.get(0));

		return null;
	}

	private PatientJourneyTarget getFirstPathwayEvent(Set pathwayEvents)
	{
		Iterator<?> it = pathwayEvents.iterator();
		PatientEvent pe;
		if (it.hasNext())
		{
			pe = (PatientEvent) it.next();
			return pe.getPatientTarget();
		}
		return null;
	}

	public HcpLiteVoCollection listHcpLite(HcpFilter filter)
	{
		HcpAdmin impl = (HcpAdmin) getDomainImpl(HcpAdminImpl.class);
		return impl.listHcpLite(filter);
	}

	public AppRoleShortVoCollection listRoles()
	{
		String query = "SELECT role FROM AppRole AS role WHERE role.isActive = 1 ORDER BY UPPER(role.name) ASC";

		return AppRoleShortVoAssembler.createAppRoleShortVoCollectionFromAppRole(getDomainFactory().find(query));
	}

	// WDEV-6050
	public void updateCatsReferralAdditionalInvStatus(CatsReferralRefVo catsReferral) throws StaleObjectException
	{
		if (catsReferral == null || catsReferral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsReferral is null or id not provided in method updateCatsReferralAdditionalInvStatus");

		DomainFactory factory = getDomainFactory();

		CatsReferral doCatsReferral = (CatsReferral) factory.getDomainObject(catsReferral);

		// 1. DNA & 2. CANCEL
		if (doCatsReferral.getAppointments().size() > 0)
		{
			boolean bSave = false;
			boolean bReview = false;
			Iterator it = doCatsReferral.getAppointments().iterator();
			while (it.hasNext())
			{
				Booking_Appointment doAppt = (Booking_Appointment) it.next();

				if (doAppt.getApptStatus() != null && (doAppt.getApptStatus().equals(getDomLookup(Status_Reason.DNA)) || doAppt.getApptStatus().equals(getDomLookup(Status_Reason.CANCELLED))))
				{
					bSave = true;
					doCatsReferral.setAdditionalInvApptsStatus(getDomLookup(AdditionalInvestigationAppointmentsStatus.DNA));

					// WDEV-11958
					if (doAppt.getApptStatus().equals(getDomLookup(Status_Reason.CANCELLED)) && (doAppt.isWasReviewed() == null || !doAppt.isWasReviewed()))
						bReview = true;
					
					//wdev-15779
					if( doAppt.getApptStatus().equals(getDomLookup(Status_Reason.CANCELLED)) && Boolean.TRUE.equals(doAppt.isIsCABBooking()) && doCatsReferral.getICABReferral() != null && doCatsReferral.getICABReferral().getUBRN() != null) //wdev-15779
					{
						if( existsNonCanceledAppointmentsInCatsReferral(doCatsReferral) == true)
							bReview = false;
					}

				}
			}
			if (bSave)
			{
				if (bReview)
					doCatsReferral.setHasCancelledApptsForReview(Boolean.TRUE); // CAB
																				// Cancellations.
																				// wdev-8288
				factory.save(doCatsReferral);
			}

			// WDEV-11878
			// final check to see are there actually any cancelled appts if not
			// set the setHasCancelledApptsForReview back to false
			int countOfCancelledAppts = 0;
			int countOfDnaAppts = 0;
			Iterator it1 = doCatsReferral.getAppointments().iterator();
			while (it1.hasNext())
			{
				Booking_Appointment doAppt = (Booking_Appointment) it1.next();
				if (doAppt.getApptStatus() != null)
				{
					if (doAppt.getApptStatus().equals(getDomLookup(Status_Reason.CANCELLED)))
						if (doAppt.isWasReviewed() == null || !doAppt.isWasReviewed())
							countOfCancelledAppts++;

					/*if (doAppt.getApptStatus().equals(getDomLookup(Status_Reason.DNA)))
						if (doAppt.isWasReviewed() == null || !doAppt.isWasReviewed())
							countOfDnaAppts++;*/
				}
			}

			if (countOfCancelledAppts == 0)
			{
				doCatsReferral.setHasCancelledApptsForReview(Boolean.FALSE);
				factory.save(doCatsReferral);
			}
			/*if (countOfDnaAppts == 0)
			{
				doCatsReferral.setHasDNAApptsForReview(Boolean.FALSE);
				factory.save(doCatsReferral);
			}*/

		}
		// 3. TOBEBOOKED
		if (doCatsReferral.getInvestigationOrders().size() > 0)
		{
			Iterator itOrd = doCatsReferral.getInvestigationOrders().iterator();
			while (itOrd.hasNext())
			{
				OcsOrderSession doOcsOrder = (OcsOrderSession) itOrd.next();// 	WDEV-16232
				// a)
				if (doOcsOrder.getInvestigations().size() > 0)
				{
					Iterator itOrdInv = doOcsOrder.getInvestigations().iterator();
					while (itOrdInv.hasNext())
					{
						OrderInvestigation doOrdInv = (OrderInvestigation) itOrdInv.next();
						if (doOrdInv.getInvestigation() != null && doOrdInv.getInvestigation().getInvestigationIndex() != null)
						{
							// canbescheduled
							if (doOrdInv.getInvestigation().getProviderService() != null && doOrdInv.getInvestigation().getProviderService().getLocationService() != null && doOrdInv.getInvestigation().getProviderService().getLocationService().getService() != null && doOrdInv.getInvestigation().getProviderService().getLocationService().getService().isCanBeScheduled() != null && doOrdInv.getInvestigation().getProviderService().getLocationService().getService().isCanBeScheduled())
							{
								// if category is not pathology
								if (doOrdInv.getInvestigation().getInvestigationIndex().getCategory() != null && !doOrdInv.getInvestigation().getInvestigationIndex().getCategory().equals(getDomLookup(Category.PATHOLOGY)))
								{
									// if status is not cancelled or
									// cancelRequested
									if (doOrdInv.getOrdInvCurrentStatus() != null && doOrdInv.getOrdInvCurrentStatus().getOrdInvStatus() != null && !doOrdInv.getOrdInvCurrentStatus().getOrdInvStatus().equals(getDomLookup(OrderInvStatus.CANCELLED)) && !doOrdInv.getOrdInvCurrentStatus().getOrdInvStatus().equals(getDomLookup(OrderInvStatus.CANCEL_REQUEST)))
									{
										// if orderinv is not in ordinvappts
										if (!isOrderInvAssociatedWithAppt(doOrdInv, doCatsReferral.getOrderInvAppts()))
										{
											doCatsReferral.setAdditionalInvApptsStatus(getDomLookup(AdditionalInvestigationAppointmentsStatus.TOBEBOOKED));
											factory.save(doCatsReferral);
											return;
										}
									}
								}
							}
							// WDEV-6161
							else if (doOrdInv.getInvestigation().getInvestigationIndex().isNoInterface() == true && (doOrdInv.getInvestigation().getInvestigationIndex().getCategory() != null && doOrdInv.getInvestigation().getInvestigationIndex().getCategory().equals(getDomLookup(Category.CLINICAL))) && doOrdInv.getAppointmentDate() == null)
							{
								doCatsReferral.setAdditionalInvApptsStatus(getDomLookup(AdditionalInvestigationAppointmentsStatus.TOBEBOOKED));
								factory.save(doCatsReferral);
								return;
							}
							// b) category is pathology --- (WDEV-6852 code
							// moved to disregard canbescheduled for this
							// check)---
							if (doOrdInv.getInvestigation().getInvestigationIndex().getCategory() != null && doOrdInv.getInvestigation().getInvestigationIndex().getCategory().equals(getDomLookup(Category.PATHOLOGY)))
							{
								// if status is not cancelled or cancelRequested
								if (doOrdInv.getOrdInvCurrentStatus() != null && doOrdInv.getOrdInvCurrentStatus().getOrdInvStatus() != null && !doOrdInv.getOrdInvCurrentStatus().getOrdInvStatus().equals(getDomLookup(OrderInvStatus.CANCELLED)) && !doOrdInv.getOrdInvCurrentStatus().getOrdInvStatus().equals(getDomLookup(OrderInvStatus.CANCEL_REQUEST)))
								{
									if (doesInCompleteSpecimenWorkListItemExist(doOrdInv))
									{
										doCatsReferral.setAdditionalInvApptsStatus(getDomLookup(AdditionalInvestigationAppointmentsStatus.TOBEBOOKED));
										factory.save(doCatsReferral);
										return;
									}
								}
							}
						}
					}
				}
			}
		}

		// 4. ALLBOOKED
		int notBookedCount = 0;
		if (doCatsReferral.getOrderInvAppts().size() > 0)
		{
			Iterator itOrdInvAppt = doCatsReferral.getOrderInvAppts().iterator();
			while (itOrdInvAppt.hasNext())
			{
				OrderInvAppt doOrdInvAppt = (OrderInvAppt) itOrdInvAppt.next();
				if (doOrdInvAppt.getAppointment() != null && doOrdInvAppt.getAppointment().getApptStatus() != null && (doOrdInvAppt.getAppointment().getApptStatus().equals(getDomLookup(Status_Reason.CANCELLED)) || doOrdInvAppt.getAppointment().getApptStatus().equals(getDomLookup(Status_Reason.CANCEL_PROVISIONAL))))
					notBookedCount++;
			}
		}
		// WDEV-6161
		if (doCatsReferral.getInvestigationOrders().size() > 0)
		{
			Iterator itOrd = doCatsReferral.getInvestigationOrders().iterator();
			while (itOrd.hasNext())
			{
				OcsOrderSession doOcsOrder = (OcsOrderSession) itOrd.next();// 	WDEV-16232
				if (doOcsOrder.getInvestigations().size() > 0)
				{
					Iterator itOrdInv = doOcsOrder.getInvestigations().iterator();
					while (itOrdInv.hasNext())
					{
						OrderInvestigation doOrdInv = (OrderInvestigation) itOrdInv.next();
						if (doOrdInv.getInvestigation().getInvestigationIndex().isNoInterface() == true && (doOrdInv.getInvestigation().getInvestigationIndex().getCategory() != null && doOrdInv.getInvestigation().getInvestigationIndex().getCategory().equals(getDomLookup(Category.CLINICAL))) && doOrdInv.getAppointmentDate() == null)
							notBookedCount++;
					}
				}
			}
		}

		if (notBookedCount > 0)
			doCatsReferral.setAdditionalInvApptsStatus(getDomLookup(AdditionalInvestigationAppointmentsStatus.NONE));
		else
			doCatsReferral.setAdditionalInvApptsStatus(getDomLookup(AdditionalInvestigationAppointmentsStatus.ALLBOOKED));

		factory.save(doCatsReferral);
	}
	//----------wdev-15779
	private boolean existsNonCanceledAppointmentsInCatsReferral(CatsReferral doCatsReferral)
	{
		if( doCatsReferral == null || doCatsReferral.getAppointments() == null)
			return false;
		
		if (doCatsReferral.getAppointments().size() > 0)
		{
			
			Iterator it = doCatsReferral.getAppointments().iterator();
			while (it.hasNext())
			{
				Booking_Appointment doAppt = (Booking_Appointment) it.next();

				if( doAppt.getApptStatus() != null && !doAppt.getApptStatus().equals(getDomLookup(Status_Reason.CANCELLED)))
					return true;
								
				
			}
			return false;
		}
		return false;
	}
	
	//---------------


	private boolean isOrderInvAssociatedWithAppt(OrderInvestigation doOrdInv, Set orderInvAppts)
	{
		if (orderInvAppts.size() == 0)
			return false;

		String tes = "";
		Iterator it = orderInvAppts.iterator();
		while (it.hasNext())
		{
			OrderInvAppt ordInvAppt = (OrderInvAppt) it.next();
			if (ordInvAppt.getOrderInvestigation().getId().equals(doOrdInv.getId()))
				return true;
		}

		return false;

	}

	// This code is suspected to be obsolete
	@Deprecated
	private boolean doesInCompleteSpecimenWorkListItemExist(OrderInvestigation doOrdInv)
	{
		if (doOrdInv == null || doOrdInv.getSpecimen() == null)
			return false;

		DomainFactory factory = getDomainFactory();

		StringBuilder query = new StringBuilder();
		query.append("SELECT COUNT(specWork.id) FROM SpecimenWorkListItem AS specWork LEFT JOIN specWork.specimen AS specimen LEFT JOIN specimen.investigations AS specInvest ");
		query.append(" WHERE specWork.dateToCollect is null AND specWork.ward is null AND specInvest.id = :ID_INVESTIGATION AND specInvest is not null");
		
		long count = factory.countWithHQL(query.toString(), new String[] {"ID_INVESTIGATION"}, new Object[] { doOrdInv.getId() });

		// Return true if more than one record (SpecimenWorklistItem) is found
		return count > 0;
	}

	public ProcedureLiteVoCollection listProcedureByHcpAndName(HcpRefVoCollection hcps, String name)
	{
		Profiles impl = (Profiles) getDomainImpl(ProfilesImpl.class);
		return impl.listProcedureByHcpAndName(hcps, name);
	}

	public ActivityLiteVoCollection listActivity()
	{
		Profiles impl = (Profiles) getDomainImpl(ProfilesImpl.class);
		return impl.listActivity();
	}

	/**
	 * method will get all the theatre appts for the session - retrieve the appt
	 * length / custom procedure duration returns a total of these times
	 */
	public Integer getUsedMins(Sch_SessionRefVo session)
	{
		DomainFactory factory = getDomainFactory();

		Integer total = 0;

		String hql = "select appt.customProcedureDuration, proc.durationInMins from Booking_Appointment as appt left join appt.theatreBooking as tb left join tb.procedure as proc left join appt.apptStatus as apptStat where  (appt.session.id = :idSession and apptStat.id <> :Cancelled) ";
		List times = factory.find(hql, new String[]{"idSession", "Cancelled"}, new Object[]{session.getID_Sch_Session(), Status_Reason.CANCELLED.getID()});

		if (times != null)
		{
			Iterator it = times.iterator();
			while (it.hasNext())
			{
				Object[] item = (Object[]) it.next();
				// customlength
				Integer customProcDuration = (Integer) item[0];
				// length
				Integer procLength = (Integer) item[1];

				if (customProcDuration != null && customProcDuration > 0)
					total += customProcDuration;
				else if (procLength != null)
					total += procLength;
			}
		}

		return total;
	}

	public Boolean hasSelectedOwnerProcedures(HcpRefVo ownerId, String procedureList)
	{
		if (ownerId == null || !ownerId.getID_HcpIsNotNull())
			throw new CodingRuntimeException("Cannot count performed procedures on null HCP id.");

		if (procedureList == null || procedureList.length() == 0)
			return true;

		DomainFactory factory = getDomainFactory();
		String query = "select count(pp.id) from ProceduresPerformedByHCP as pp left join pp.procedures as p where (pp.performingHCP.id = :hcpId and p.id in (" + procedureList + "))";

		Object[] count = factory.find(query, new String[]{"hcpId"}, new Object[]{ownerId.getID_Hcp()}).toArray();

		if (count != null && count.length > 0 && ((Long) count[0]).intValue() > 0)
			return true;

		return false;
	}

	public BookingAppointmentLiteVoCollection listNonCancelledAppointmentsForSession(Sch_SessionRefVo session)
	{
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not provided in method listNonCancelledAppointmentsForSession");

		List lstAppts = getDomainFactory().find("from Booking_Appointment appt where appt.session.id = " + session.getID_Sch_Session() + " and appt.apptStatus.id <> " + Integer.valueOf(Status_Reason.CANCELLED.getID()) + " and (appt.session.isTheatreSession is null or appt.session.isTheatreSession = false) order by appt.apptStartTime ");
		return BookingAppointmentLiteVoAssembler.createBookingAppointmentLiteVoCollectionFromBooking_Appointment(lstAppts);
	}

	public void saveSessionForMaxContinuousTime(SessionShortVo session) throws StaleObjectException
	{
		if (session.getIsFixedIsNotNull() && !session.getIsFixed())
		{
			// WDEV-11731 - do update here by getting all appointments - only
			// for flexible sessions
			BookingAppointmentLiteVoCollection voCollAvailAppts = listNonCancelledAppointmentsForSession(session);
			int maxDuration = voCollAvailAppts.getMaxAvailableDuration(voCollAvailAppts.getAvailableDurations(session));
			Sch_Session doSession1 = (Sch_Session) getDomainFactory().getDomainObject(session);
			doSession1.setMaxContinuousAvailableMins(maxDuration);
			getDomainFactory().save(doSession1);
		}
	}

	public SessionTheatreVo getTheatreSession(Sch_SessionRefVo session)
	{
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not provided in method getTheatreSession");
		
		return SessionTheatreVoAssembler.create((Sch_Session) getDomainFactory().getDomainObject(session));
	}
}
