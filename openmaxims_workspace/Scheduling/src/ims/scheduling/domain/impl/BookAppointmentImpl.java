//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.30 build 2012.21169)
// Copyright (C) 1995-2005 IMS MAXIMS plc. All rights reserved.

package ims.scheduling.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.RefMan.domain.objects.CATSReferralStatus;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.vo.lookups.ICABReferralStatus;
import ims.RefMan.vo.lookups.ReferralApptStatus;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.ICABReferral;
import ims.core.admin.domain.objects.ProviderSystem;
import ims.core.clinical.domain.objects.TaxonomyMap;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.patient.domain.objects.Patient;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.place.vo.ActivityRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.ActivitySchedVoCollection;
import ims.core.vo.ActivityVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.PatientShort;
import ims.core.vo.ServiceShortVo;
import ims.core.vo.domain.ActivitySchedVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.lookups.ActivityType;
import ims.core.vo.lookups.ReferralType;
import ims.core.vo.lookups.TaxonomyType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.hibernate3.IMSCriteria;
import ims.domain.impl.DomainImpl;
import ims.domain.impl.DomainImplFlyweightFactory;
import ims.domain.lookups.LookupMapping;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.IAppRole;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;
import ims.ocrr.vo.ProviderSystemVo;
import ims.ocrr.vo.domain.ProviderSystemVoAssembler;
import ims.pathways.domain.HL7PathwayIf;
import ims.pathways.domain.impl.HL7PathwayIfImpl;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.vo.EventLiteVoCollection;
import ims.pathways.vo.EventVo;
import ims.pathways.vo.ExternalEventMappingVo;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.PatientJourneyVo;
import ims.pathways.vo.PatientJourneyVoCollection;
import ims.pathways.vo.domain.EventLiteVoAssembler;
import ims.pathways.vo.domain.PatientEventVoAssembler;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.lookups.PathwaysDetail;
import ims.pathways.vo.lookups.PathwaysGroup;
import ims.scheduling.domain.ClinicList;
import ims.scheduling.domain.DirectoryOfServiceAdmin;
import ims.scheduling.domain.SessionAdmin;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.Sch_Booking;
import ims.scheduling.domain.objects.Sch_Profile;
import ims.scheduling.domain.objects.Sch_Session;
import ims.scheduling.domain.objects.Session_Slot;
import ims.scheduling.vo.BookingAppointmentLiteVoCollection;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.Booking_AppointmentVoCollection;
import ims.scheduling.vo.ProfileLiteVo;
import ims.scheduling.vo.ProfileLiteVoCollection;
import ims.scheduling.vo.Sch_BookingVo;
import ims.scheduling.vo.Sch_ProfileRefVo;
import ims.scheduling.vo.Sch_SessionRefVo;
import ims.scheduling.vo.SessionIntermediateVo;
import ims.scheduling.vo.SessionShortVo;
import ims.scheduling.vo.SessionShortVoCollection;
import ims.scheduling.vo.SessionSlotVo;
import ims.scheduling.vo.SlotEventPathwayVo;
import ims.scheduling.vo.SlotEventPathwayVoCollection;
import ims.scheduling.vo.domain.BookingAppointmentLiteVoAssembler;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.ProfileLiteVoAssembler;
import ims.scheduling.vo.domain.Sch_BookingVoAssembler;
import ims.scheduling.vo.domain.SessionIntermediateVoAssembler;
import ims.scheduling.vo.domain.SessionShortVoAssembler;
import ims.scheduling.vo.domain.SessionSlotVoAssembler;
import ims.scheduling.vo.lookups.SchedCABSlotType;
import ims.scheduling.vo.lookups.Session_Status_and_Reason;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.vo.interfaces.IMos;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

public class BookAppointmentImpl extends DomainImpl implements ims.scheduling.domain.BookAppointment, ims.domain.impl.Transactional
{
	private static final long serialVersionUID = 1L;

	public ims.scheduling.vo.SessionSlotVoCollection listSessionSlot(ims.scheduling.vo.SessionShortVo session)
	{
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not provided in method listSessionSlot");
			
		DomainFactory factory = getDomainFactory();
		List slots = factory.find("from Session_Slot as slot where slot.session.id = " + session.getID_Sch_Session() + " and (slot.directAccessSlot.id != " + SchedCABSlotType.CAB.getId() + " or slot.directAccessSlot is null)");
		return SessionSlotVoAssembler.createSessionSlotVoCollectionFromSession_Slot(slots).sort();
	}

	public ims.core.vo.ServiceShortVoCollection listActiveService()
	{
		DirectoryOfServiceAdmin impl = (DirectoryOfServiceAdmin) getDomainImpl(DirectoryOfServiceAdminImpl.class);
		ServiceShortVo voService = new ServiceShortVo();
		voService.setIsActive(Boolean.TRUE);
		return impl.listService(voService);
	}

	// WDEV-15944
	public void instantiateEvent(Booking_AppointmentVo apptVo, String prepend, String refSource) 
	{
		DomainFactory factory = getDomainFactory();
		
		Booking_Appointment appt = Booking_AppointmentVoAssembler.extractBooking_Appointment(factory, apptVo);
		
		
		// If the prepend = 'A', i.e. this comes from the Outcome form, we want to see if there is a PAS
		// mapping against the outcome lookup and use this instead of the activity lookup - for this scenario only
		// so that we can create an event for a specific outcome
		String outcomeMap=null;
		if (prepend != null && prepend.equals("A") && appt.getOutcome() != null)
		{
			LookupMapping mp=appt.getOutcome().getMapping("PAS");
			if (mp != null)
				outcomeMap=mp.getExtCode();
		}

		
//		 First get the activity from the booking and see if a PAS mapping exists for it
		String activityMap=null;
		if (appt != null && appt.getActivity() != null)
		{

			List lst = appt.getActivity().getCodeMappings();
			if (lst != null)
			for (int i=0; i<lst.size(); i++)
			{
				TaxonomyMap mp = (TaxonomyMap) lst.get(i);
				if (mp.getTaxonomyName().getId() == TaxonomyType.PAS.getID())
				{
					activityMap=mp.getTaxonomyCode();
					break;
				}
					
			}
			
			if (activityMap == null)
			{
				factory.getDomainSession().createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, "Mapping not found for activity " + appt.getActivity().getName());
				return;
			}
				
		
			// Get the rkey associated with the latest journey for this patient
			String hql = " select j from PatientPathwayJourney j, Referral r where r.patient = :patient and j.referral = r.id order by j.systemInformation.creationDateTime desc";
			ArrayList<String> names = new ArrayList<String>();
			ArrayList<Object> values = new ArrayList<Object>();

			names.add("patient");
			values.add(appt.getPatient());
			List l = factory.find(hql, names, values);
			if (l == null || l.size() == 0)
			{
				factory.getDomainSession().createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, "No Patient Journey found for patient " + appt.getPatient().getId());
				return;
			}
		
		
			PatientJourneyVo voJourney = PatientJourneyVoAssembler.create((PatientPathwayJourney) l.get(0));
			PatientEventVo patientEvent = new PatientEventVo();
			patientEvent.setActionCode("UP");
			patientEvent.setDescription(refSource); 
		
			patientEvent.setEventDateTime(new DateTime());
			patientEvent.setJourney(voJourney);
			patientEvent.setMessageId("FromMaxims");
			patientEvent.setExternalEventId(Integer.valueOf(appt.getId()));
			patientEvent.setPatient(voJourney.getPatient());
			patientEvent.setScheduledDate(new DateTime(appt.getAppointmentDate()));

			// Get the PAS Provider System
			ProviderSystemVo voProv = ProviderSystemVoAssembler.create(ProviderSystem.getProviderSystemFromHl7Application(factory, "HEARTS"));
			if (voProv == null)
			{
				factory.getDomainSession().createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, "Provider System not found with HL7App = HEARTS");
				return;
			}
		
			// 	Get the lookup with the external mapping the same as the negative value for ACTIVITY
			// As this impl uses dto for lookupService, we want to get the localLookupService too in order to get the PathwaysDetails value
			ims.domain.lookups.LookupService localLookupService;
			try {
				localLookupService = (ims.domain.lookups.LookupService) DomainImplFlyweightFactory.getInstance().create(ims.domain.lookups.impl.LookupServiceImpl.class, getDomainFactory().getDomainSession(), getDomainFactory());
			} catch (InstantiationException e) 
			{
				factory.getDomainSession().createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, "InstantiationException occurred creating localLookupService - " + e.getMessage());
				return;
			} catch (IllegalAccessException e) {
				factory.getDomainSession().createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, "IllegalAccessException occurred creating localLookupService - " + e.getMessage());
				return;
			}
		
			PathwaysDetail pthDetailLkp=null;
			if (outcomeMap != null)
			{
				pthDetailLkp =(PathwaysDetail) localLookupService.getLocalLookup(PathwaysDetail.class, PathwaysDetail.TYPE_ID, voProv.getCodeSystem().getText(), prepend+outcomeMap);
				if (pthDetailLkp == null)
				{
					factory.getDomainSession().createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, "PathwaysDetails lookup not found for outcome " + outcomeMap + " will try for activity.");
				}
			}
			
			if (pthDetailLkp == null)
			{
				pthDetailLkp =(PathwaysDetail) localLookupService.getLocalLookup(PathwaysDetail.class, PathwaysDetail.TYPE_ID, voProv.getCodeSystem().getText(), prepend+activityMap);
				if (pthDetailLkp == null)
				{
					factory.getDomainSession().createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, "PathwaysDetails lookup not found for activity " + appt.getActivity().getName());
					return;
				}
			}
		
			HL7PathwayIf impl = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
		
			try
			{
				// Get the External Event
				ExternalEventMappingVo extMap = new ExternalEventMappingVo();
				extMap.setDetail(pthDetailLkp);
				extMap.setGroup(PathwaysGroup.OPD);
				extMap.setProviderSystem(voProv);
				ExternalEventMappingVo extEvt = impl.getExternalEventMappings(extMap);
				if (extEvt == null)
				{
					return;
				}
		
				// 	Get the Actual Event
				EventVo event = impl.getEventByExternalMappings(extEvt);
				if (event == null)
				{
					return;
				}
				patientEvent.setEvent(event);
				patientEvent.setExternalEvent(extEvt);
		
				impl.instantiatePatientEvent(patientEvent);
				
			}
			catch (Exception e)
			{
				factory.getDomainSession().createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, "Exception occurred instantiating pathway event - " + e.getMessage());
				
			}
		}
	}

	
	public PatientShort getPatient(Integer patientId)
	{
		DomainFactory factory = getDomainFactory();
		return PatientShortAssembler.create((Patient) factory.getDomainObject(Patient.class, patientId));
	}

	/**
	 * !! Take Caution if modifying this method as it is used by Choose and Book via WebServices
	 */
	public Sch_BookingVo saveBooking(Sch_BookingVo voBooking, SlotEventPathwayVoCollection voCollSlotEvPathway, SessionShortVo session) throws DomainInterfaceException, StaleObjectException 
	{
		if (voBooking == null)
			throw new CodingRuntimeException("voBooking is null in method saveBooking");

		DomainFactory factory = getDomainFactory();
		
		Sch_Booking doBooking = Sch_BookingVoAssembler.extractSch_Booking(factory, voBooking);

		//WDEV-11731
		Sch_Session doSession = null;
		
		if (doBooking.getAppointments() != null)
		{
			Iterator it = doBooking.getAppointments().iterator();
			Booking_Appointment doEarliestAppt = null;
			
			while (it.hasNext())
			{
				Booking_Appointment doBookAppt = (Booking_Appointment) it.next();

				// Set patient at this level if not already set
				if (doBookAppt.getPatient() == null)
					doBookAppt.setPatient(doBooking.getPatient());

				if (doEarliestAppt != null && doEarliestAppt.getAppointmentDate().before(doBookAppt.getAppointmentDate()))
					doEarliestAppt = doBookAppt;

				if (doBookAppt.getSessionSlot() != null)
				{
					doBookAppt.getSessionSlot().setAppointment(doBookAppt);
					doBookAppt.getSessionSlot().setStatus(getDomLookup(Status_Reason.APPOINTMENT_BOOKED));
				}

				if (doEarliestAppt == null)
					doEarliestAppt = doBookAppt;
				
				//WDEV-11731
				if(doSession == null)
					doSession = doBookAppt.getSession();
				
				reduceRemainingSlotsOrTimes(doBookAppt);	//	WDEV-10598
			}
			doBooking.setFirstAppointment(doEarliestAppt);

			// if the first appointment is no longer associated with this
			// booking ie. was cancelled
			if (!doBooking.getAppointments().contains(doEarliestAppt))
			{
				doBooking.setFirstAppointment(null);
			}
		}

		factory.save(doBooking);
			
		// get latest
		voBooking = Sch_BookingVoAssembler.create(doBooking);

		for (Booking_AppointmentVo voAppt : voBooking.getAppointments())
		{
			ClinicList impl = (ClinicList) getDomainImpl(ClinicListImpl.class);
			SlotEventPathwayVo voSlotEventPathway = getSlotEventPathwayRecord(voAppt.getSessionSlot(), voCollSlotEvPathway);

			if (voSlotEventPathway != null && (voSlotEventPathway.getEventIsNotNull() && voSlotEventPathway.getJourneyIsNotNull()))
			{
				Booking_Appointment doAppt = Booking_AppointmentVoAssembler.extractBooking_Appointment(getDomainFactory(), voAppt);
				PatientEventVo voPatEvent = impl.createAndSaveEvent(EventLiteVoAssembler.extractEvent(getDomainFactory(), voSlotEventPathway.getEvent()), doAppt, voSlotEventPathway.getJourney());
				doAppt.getPathwayEvents().add(PatientEventVoAssembler.extractPatientEvent(factory, voPatEvent));
				factory.save(doAppt);
			}
		}
		
		voBooking = Sch_BookingVoAssembler.create(doBooking); 

		//WDEV-11731 - only for flexible sessions
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		impl.saveSessionForMaxContinuousTime(session);
		
		return voBooking;	
	}


	private void reduceRemainingSlotsOrTimes(Booking_Appointment doBookAppt) 
	{
		if (doBookAppt.getSession() != null)
		{
			getDomainFactory().refresh(doBookAppt.getSession());
			
			//if flexible decrement TimeRemaining
			if(doBookAppt.getSession().isIsFixed() != null && !doBookAppt.getSession().isIsFixed())
			{
				if (doBookAppt.getApptStartTime() != null && doBookAppt.getApptEndTime() != null && doBookAppt.getSession().getStartTm() != null && doBookAppt.getSession().getEndTm() != null && doBookAppt.getSession().getRemainingTime() != null)
				{
					Time sessionStartTime = new Time(doBookAppt.getSession().getStartTm());
					Time sessionEndTime = new Time(doBookAppt.getSession().getEndTm());
					
					Time appointmentStartTime = new Time(doBookAppt.getApptStartTime());
					Time appointmentEndTime = new Time(doBookAppt.getApptEndTime());
					
					if (appointmentOverlapsInterval(doBookAppt, sessionStartTime, sessionEndTime))
					{
    					Time startTime = sessionStartTime.isGreaterOrEqualThan(appointmentStartTime) ? sessionStartTime : appointmentStartTime;
    					Time endTime = sessionEndTime.isLessOrEqualThan(appointmentEndTime) ? sessionEndTime : appointmentEndTime;
    					
						int remainingMinutes = doBookAppt.getSession().getRemainingTime();
						remainingMinutes -= calculateApptDuration(startTime, endTime);
						
						doBookAppt.getSession().setRemainingTime(remainingMinutes);
					}
				}
			}
			else
			{
				int remainingSlots = doBookAppt.getSession().getRemainingSlots();
				remainingSlots -= 1;
				
				if(remainingSlots < 0)
					remainingSlots = 0;
				
				doBookAppt.getSession().setRemainingSlots(remainingSlots);	
			}
		}
	}
	
	private boolean appointmentOverlapsInterval(Booking_Appointment appointment, Time sessionStartTime, Time sessionEndTime)
	{
		if (appointment == null || appointment.getApptStartTime() == null || appointment.getApptEndTime() == null)
			return false;
			
		if (sessionStartTime == null || sessionEndTime == null)
			return false;
		
		Time appointmentStartTime = new Time(appointment.getApptStartTime());
		Time appointmentEndTime = new Time(appointment.getApptEndTime());
		
		if (appointmentStartTime.isLessOrEqualThan(sessionStartTime) && appointmentEndTime.isLessOrEqualThan(sessionStartTime))
			return false;
		
		if (appointmentStartTime.isGreaterOrEqualThan(sessionEndTime) && appointmentEndTime.isGreaterOrEqualThan(sessionEndTime))
			return false;
		
		return true;
	}

	private int calculateApptDuration(Time startTime, Time endTime)
	{
		if (startTime == null || endTime == null)
			throw new CodingRuntimeException("apptStartTime or apptEndTime is null in method calculateApptDuration");
	
		int mins = endTime.getTotalMinutes() - startTime.getTotalMinutes();
		//appt has gone past midnight
		if(endTime.isLessThan(startTime))	
		{
			Time midNight = new Time(23,59);
			mins = midNight.getTotalMinutes() + 1 - startTime.getTotalMinutes() + endTime.getTotalMinutes(); 
		}
			
		return mins;
	}


	/**
	 * checkReferral
	 * @param factory
	 * @param doBooking  The booking we just saved
	 * This method will check if an open referral already exists for this patient and UBRN. If it does
	 * the appointment will be saved alongside it.  If not, a new referral will be created with the
	 * given appointment associated with it.  
	 * @throws StaleObjectException 
	 */
	private void checkReferral(DomainFactory factory, Sch_Booking doBooking) throws StaleObjectException 
	{
		if (!ConfigFlag.GEN.ICAB_ENABLED.getValue())
			return;
		
		
		CatsReferral catsReferral=null;
		List lst = CatsReferral.listCatsReferralByPatient(factory, doBooking.getPatient());
		if (lst != null && lst.size() > 0)
		{
			Iterator it = lst.iterator();
			while (it.hasNext())
			{
				CatsReferral domRef = (CatsReferral) it.next();
				if (domRef instanceof CatsReferral)
				{
					ICABReferral tmpRef = ((CatsReferral) domRef).getICABReferral();
					if (tmpRef.getUBRN() != null && tmpRef.getUBRN().equals(doBooking.getUBRN()) 
								&& tmpRef.getStatus().getId() != ICABReferralStatus.COMPLETED.getId())
					{
						catsReferral=domRef;
						break;
					}
				}
			}
		}
		
		if (catsReferral == null)
			catsReferral=createNewReferral(doBooking);
		else
		{
			// Add a new status
			CATSReferralStatus refStat = new CATSReferralStatus();
			refStat.setStatusDateTime(new java.util.Date());
			refStat.setReferralStatus(getDomLookup(ReferralApptStatus.APPOINTMENTBOOKED));
			catsReferral.setCurrentStatus(refStat);
			catsReferral.getStatusHistory().add(refStat);
			
		}
		catsReferral.getAppointments().add(doBooking.getFirstAppointment());
		factory.save(catsReferral);
		
	}
	
	private CatsReferral createNewReferral(Sch_Booking doBooking)
	{
		CatsReferral catsRef = new CatsReferral();
		ICABReferral domReferral = new ICABReferral();
		domReferral.setAuthoringDateTime(new java.util.Date());
		domReferral.setReferralType(getDomLookup(ReferralType.EXTERNAL));
		domReferral.setPatient(doBooking.getPatient());
		domReferral.setUBRN(doBooking.getUBRN());
		domReferral.setStatus(getDomLookup(ICABReferralStatus.CHOOSEANDBOOK));

		catsRef.setICABReferral(domReferral);
		catsRef.setPatient(doBooking.getPatient());

		CATSReferralStatus refStat = new CATSReferralStatus();
		refStat.setStatusDateTime(new java.util.Date());
		refStat.setReferralStatus(getDomLookup(ReferralApptStatus.REFERRAL_RECEIVED));
		catsRef.setCurrentStatus(refStat);
		catsRef.setStatusHistory(new HashSet());
		catsRef.getStatusHistory().add(refStat);
		
		return catsRef;
	}

	private void cancelPublishedSlots(Session_Slot sessionSlot) throws StaleObjectException
	{
		ClinicList impl = (ClinicList) getDomainImpl(ClinicListImpl.class);
		impl.cancelSlot( SessionSlotVoAssembler.create(sessionSlot), ActionRequestType.NOTIFY_SLOT_CANCEL, "Cancel Slot requested as Appointment Booked");
	}

	private SlotEventPathwayVo getSlotEventPathwayRecord(SessionSlotVo sessionSlot, SlotEventPathwayVoCollection voCollSlotEvPathway)
	{
		if (sessionSlot == null || voCollSlotEvPathway == null)
			return null;

		for (int i = 0; i < voCollSlotEvPathway.size(); i++)
		{
			if (voCollSlotEvPathway.get(i).getSlotIsNotNull())
			{
				if (voCollSlotEvPathway.get(i).getSlot().equals(sessionSlot))
				{
					return voCollSlotEvPathway.get(i);
				}
			}
		}
		return null;
	}

	public ActivitySchedVoCollection listActivitiesForType(ActivityType actType)
	{
		DomainFactory factory = getDomainFactory();
		return ActivitySchedVoAssembler.createActivitySchedVoCollectionFromActivity(factory.find("from Activity act where act.activityType = :actType and act.isActive = :isActive", new String[]{"actType", "isActive"}, new Object[]{getDomLookup(actType), Boolean.TRUE}));
	}

	public Booking_AppointmentVoCollection listBookingAppointment(SessionShortVo session)
	{
		DomainFactory factory = getDomainFactory();
		return Booking_AppointmentVoAssembler.createBooking_AppointmentVoCollectionFromBooking_Appointment(factory.find(" from Booking_Appointment book where book.session.id = :sessionId", new String[]{"sessionId"}, new Object[]{session.getID_Sch_Session()})).sort();
	}

	public EventLiteVoCollection listEvents(Status_Reason statusReason, ActivityRefVo activity)
	{
		DomainFactory factory = getDomainFactory();
		//TODO new implementation
		String hql = "select event from ActivityStatusToPathwayEvent as aspe where (aspe.appointmentStatus.id = :idStatusReason and aspe.activity.id =:idActivity)";
		List events = factory.find(hql, new String[]{"idStatusReason", "idActivity"}, new Object[]{(getDomLookup(Status_Reason.BOOKED)).getId(), activity.getID_Activity()});
		EventLiteVoCollection eventColl = EventLiteVoAssembler.createEventLiteVoCollectionFromEvent(events);

		return eventColl;
	}

	public PatientJourneyVoCollection listJourneyByPatient(PatientRefVo voPatient)
	{
		if (voPatient == null)
			throw new CodingRuntimeException("voPatient parameter is null in method listJourneyByPatient");

		DomainFactory factory = getDomainFactory();

		IMSCriteria imsc = new IMSCriteria(PatientPathwayJourney.class, factory);
		imsc.isNull("endedOnDate");
		imsc.equal("patient.id", voPatient.getID_Patient());
		List pathways = imsc.find();
		PatientJourneyVoCollection pathColl = PatientJourneyVoAssembler.createPatientJourneyVoCollectionFromPatientPathwayJourney(pathways);
		return pathColl;
	}

	public Boolean hasBookingRights(IAppRole role, Sch_SessionRefVo session)
	{
		if (role == null)
			throw new CodingRuntimeException("role is null in method hasBookingRights");
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not provided in method hasBookingRights");

		DomainFactory factory = getDomainFactory();
		String hql = "select count(bookRight.id) from Sch_Session as session left join session.bookingRights as bookRight where (session.id = :idSession and bookRight.role.id = :idRole)";

		int count = -1;
		List lstCount = factory.find(hql, new String[]{"idSession", "idRole"}, new Object[]{session.getID_Sch_Session(), role.getId()});
		Iterator it = lstCount.iterator();
		if (it.hasNext())
		{
			Long res = (Long) it.next();
			count = res.intValue();
		}

		return count > 0;
	}

	public ProfileLiteVoCollection listProfileLiteByService(ServiceRefVo service)
	{
		if (service == null || service.getID_Service() == null)
			throw new CodingRuntimeException("service parameter null or id not provided for listSessionLiteByService");

		DomainFactory factory = getDomainFactory();
		List profiles = factory.find("from Sch_Profile prof where prof.service.id = :idService", new String[]{"idService"}, new Object[]{service.getID_Service()});
		return ProfileLiteVoAssembler.createProfileLiteVoCollectionFromSch_Profile(profiles);
	}
	
	public ProfileLiteVoCollection listTemplateByProfile(ProfileLiteVo profile)
	{
		if (profile == null || profile.getID_Sch_Profile() == null)
			throw new CodingRuntimeException("profile parameter null or id not provided for listTemplateByProfile");

		DomainFactory factory = getDomainFactory();
		List profiles = factory.find("from ProfileTemplate pt where pt.profile.id = :idProfile", new String[]{"idProfile"}, new Object[]{profile.getID_Sch_Profile()});
		return ProfileLiteVoAssembler.createProfileLiteVoCollectionFromSch_Profile(profiles);
	}
	
	
	public Date getCurrentMonth(Sch_ProfileRefVo profile, ActivityVo activity, ServiceRefVo service, LocationRefVo location, IMos hcp, Boolean findFirstAvailable) 
	{
		if (activity == null)
			throw new DomainRuntimeException("Not all mandatory search params set in method listGenericSession");

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		
		String listOwnerJoin = "";
		String listOwnerCriteria = "";
		String serviceCriteria = "";
		String locationCriteria = "";
		String profileCriteria = "";
		
		markers.add("activityId");		
		markers.add("open");
		markers.add("today");
		
		values.add(activity.getID_Activity());				
		values.add(getDomLookup(Session_Status_and_Reason.OPEN));
		values.add(new Date().getDate());
		

		if (hcp != null)
		{
			listOwnerJoin = " left join session.listOwners as listOwn ";
			listOwnerCriteria = " and (listOwn.hcp.id = :hcpId) ";
			markers.add("hcpId");
			values.add(hcp.getIMosId());
		}
		if (service != null)
		{
			markers.add("idService");
			values.add(service.getID_Service());
			serviceCriteria = " and session.service.id = :idService";
		}
		if(location != null)
		{
			markers.add("idLocation");
			values.add(location.getID_Location());
			locationCriteria = " and session.schLocation.id = :idLocation";
		}
		if (profile != null)
		{
			markers.add("idProfile");
			values.add(profile.getID_Sch_Profile());
			profileCriteria = " and session.sch_Profile.id = :idProfile";
		}
		
		DomainFactory factory = getDomainFactory();
		
		List date = factory.find(" Select min (session.sessionDate) from Sch_Session as session " + 
				" left join session.sessionSlots as slot left join session.sessionActivities as sessAct " + listOwnerJoin + " where ( slot.activity.id = :activityId or sessAct.activity.id = :activityId) " + 
				listOwnerCriteria + serviceCriteria + profileCriteria + locationCriteria + " and session.sessionStatus = :open and session.sessionDate >= :today", markers, values, 1000);
		
		if (date != null &&
				date.get(0) != null)		
					return  new ims.framework.utils.Date((java.util.Date)date.get(0));
		
		return null;
	}
	

	public SessionShortVoCollection listGenericSession(Date startDate, Date endDate, Sch_ProfileRefVo profile, ActivityVo activity,	ServiceRefVo service, LocationRefVo location, IMos hcp, Boolean findFirstAvailable, Boolean allowOverBook) 
	{
		// all params must be set
		if (startDate == null || endDate == null || activity == null)
			throw new DomainRuntimeException("Not all mandatory search params set in method listGenericSession");

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		
		String listOwnerJoin = "";
		String listOwnerCriteria = "";
		String serviceCriteria = "";
		String locationCriteria = "";
		String profileCriteria = "";
				
		//mandatory fields
		markers.add("activityId");		
		markers.add("open");
		values.add(activity.getID_Activity());				
		values.add(getDomLookup(Session_Status_and_Reason.OPEN));
		markers.add("startDate");
		markers.add("endDate");
		
		values.add(startDate.getDate());
		values.add(endDate.getDate());	
		
		if (hcp != null)
		{
			listOwnerJoin = " left join session.listOwners as listOwn ";
			listOwnerCriteria = " and (listOwn.hcp.id = :hcpId) ";
			markers.add("hcpId");
			values.add(hcp.getIMosHcpId()); //WDEV-9946
		}
		if (service != null)
		{
			markers.add("idService");
			values.add(service.getID_Service());
			serviceCriteria = " and session.service.id = :idService";
		}
		if(location != null)
		{
			markers.add("idLocation");
			values.add(location.getID_Location());
			locationCriteria = " and session.schLocation.id = :idLocation";
		}
		if (profile != null)
		{
			markers.add("idProfile");
			values.add(profile.getID_Sch_Profile());
			profileCriteria = " and session.sch_Profile.id = :idProfile";
		}
		
		DomainFactory factory = getDomainFactory();
		SessionShortVoCollection voCollSessionShort = new SessionShortVoCollection();
		
		//WDEV-9395
		String activityDurationCriteria = "0";
		if(activity.getTmReqIsNotNull())
			activityDurationCriteria = "'" + activity.getTmReq() + "' ";
		
		//WDEV-8793
		String overBookCriteria = "";
		//WDEV-11731
		String flexibleCriteria = "";
		if(!allowOverBook)
		{
			overBookCriteria = " and (session.remainingTime >= " + activityDurationCriteria + " or session.remainingTime = null or session.remainingTime <= 0)"; 	//WDEV-12209
			flexibleCriteria = " and ((session.isFixed = 0 and (session.maxContinuousAvailableMins >= " + activityDurationCriteria + "  or session.maxContinuousAvailableMins is null or session.maxContinuousAvailableMins = 0)) or (session.isFixed = 1 or session.isFixed is null)) ";	//	WDEV-12209
		}

		List sessions = factory.find(" Select distinct session from Sch_Session as session " + 
			" left join session.sessionSlots as slot left join session.sessionActivities as sessAct " + listOwnerJoin + " where ( slot.activity.id = :activityId or sessAct.activity.id = :activityId) " + 
			listOwnerCriteria + " and session.sessionDate >= :startDate and session.sessionDate <= :endDate " + serviceCriteria + profileCriteria + locationCriteria + " and session.sessionStatus = :open" + overBookCriteria + flexibleCriteria + " and (slot.isActive = 1 or sessAct.isActive = 1) ", markers, values, 1000); //wdev-11757		
			
		voCollSessionShort = SessionShortVoAssembler.createSessionShortVoCollectionFromSch_Session(sessions);
		
		return voCollSessionShort.sort();		
	}
	
	public LocationLiteVoCollection listLocationLite()
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listLocationByName(null);
	}

	public Sch_ProfileRefVo getProfileForSession(Sch_SessionRefVo session)
	{
		if(session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("mandatory session paramter or id not provided for method getProfileForSession");
			
		List profiles = getDomainFactory().find("select sess.sch_Profile from Sch_Session as sess where sess.id = " + session.getID_Sch_Session());
		if(profiles != null && profiles.size() == 1)
			return ProfileLiteVoAssembler.create((Sch_Profile) profiles.get(0));
			
		return null;
	}
	
	public Sch_BookingVo getSch_BookingByAppt(Booking_AppointmentRefVo appt)
	{
		if (appt == null || appt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("appt is null or id not provude for method getSch_BookingByAppt");

		List bookings = getDomainFactory().find("select book from Sch_Booking book left join book.appointments as appt where appt.id = '" + appt.getID_Booking_Appointment() + "'");
		if (bookings != null && bookings.size() == 1)
			return Sch_BookingVoAssembler.create((Sch_Booking) bookings.get(0));

		return null;

	}

	/**
	 * listNonCancelledAppointmentsForSession - a list of appts that are not cancelled for the session - this is used to validate booking another flexible appt
	 */
	public BookingAppointmentLiteVoCollection listNonCancelledAppointmentsForSession(Sch_SessionRefVo session)
	{
		if (session == null || session.getID_Sch_Session() == null)
			throw new CodingRuntimeException("session is null or id not provided in method listFlexibleAppointmentsForSession");
		
		List lstAppts = getDomainFactory().find("from Booking_Appointment appt where appt.session.id = " + session.getID_Sch_Session() + " and appt.apptStatus.id <> " + Integer.valueOf(Status_Reason.CANCELLED.getID()) + " order by appt.apptStartTime ");
		return BookingAppointmentLiteVoAssembler.createBookingAppointmentLiteVoCollectionFromBooking_Appointment(lstAppts);
	}

	/**
	 * Function used to retrieve session slot
	 */
	public SessionIntermediateVo getSessionIntermediate(Sch_SessionRefVo session)
	{
		if (session == null || !session.getID_Sch_SessionIsNotNull())
			throw new DomainRuntimeException("Session can not be null");
		
		return SessionIntermediateVoAssembler.create((Sch_Session) getDomainFactory().getDomainObject(Sch_Session.class, session.getID_Sch_Session()));
	}
}
