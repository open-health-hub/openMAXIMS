//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Cristian Belciug using IMS Development Environment (version 1.80 build 4091.21781)
// Copyright (C) 1995-2011 IMS MAXIMS. All rights reserved.

package ims.correspondence.forms.checkedoutdocuments;

import ims.configuration.gen.ConfigFlag;
import ims.correspondence.forms.checkedoutdocuments.GenForm.grdDocumentsRow;
import ims.correspondence.vo.CheckedOutDocumentVo;
import ims.correspondence.vo.CheckedOutDocumentVoCollection;
import ims.correspondence.vo.PatientDocumentErrorVo;
import ims.correspondence.vo.PatientDocumentErrorVoCollection;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.enumerations.FormMode;
import ims.framework.enumerations.SortOrder;
import ims.framework.exceptions.PresentationLogicException;
import ims.framework.utils.DateTime;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.SecureRandom;
import java.util.Comparator;

public class Logic extends BaseLogic
{
	private static final long serialVersionUID = 1L;
	
	private static final int LOCKED_DATE_COL_INDEX = 3;
	private static final String CHECKOUT_FOLDER = "CheckOut"; //WDEV-13366

	@Override
	protected void onFormOpen(Object[] args) throws ims.framework.exceptions.PresentationLogicException
	{
		initialize();
		open();
	}
	
	private void initialize() 
	{
		form.getLocalContext().setSortOrderLockedDate(SortOrder.ASCENDING);
	}

	private void open() 
	{
		populateGrid(domain.listCheckedOutDocuments());
		updateControlsState();
	}
	
	private void populateGrid(CheckedOutDocumentVoCollection listCheckedOutDocuments) 
	{
		form.grdDocuments().getRows().clear();
		
		if(listCheckedOutDocuments == null || listCheckedOutDocuments.size() == 0)
			return;
		
		for(int i=0; i<listCheckedOutDocuments.size(); i++)
		{
			addDocumentRow(listCheckedOutDocuments.get(i));
		}
	}

	private void addDocumentRow(CheckedOutDocumentVo checkedOutDocumentVo) 
	{
		if(checkedOutDocumentVo == null)
			return;
		
		grdDocumentsRow newRow = form.grdDocuments().getRows().newRow();
		
		newRow.setColDoc(checkedOutDocumentVo.getName());
		newRow.setColPat((checkedOutDocumentVo.getPatientIsNotNull() && checkedOutDocumentVo.getPatient().getNameIsNotNull())? checkedOutDocumentVo.getPatient().getName().toString() : null);
		newRow.setColDate(checkedOutDocumentVo.getLockedOnDateTimeIsNotNull() ? checkedOutDocumentVo.getLockedOnDateTime().toString() : null);
		newRow.setColUser(checkedOutDocumentVo.getLockedByUserIsNotNull() ? checkedOutDocumentVo.getLockedByUser().getIMosName() : null);
		newRow.setColSelect(checkedOutDocumentVo.getIsCheckedIsNotNull() ? checkedOutDocumentVo.getIsChecked() : false);
		newRow.setValue(checkedOutDocumentVo);
	}

	@Override
	protected void onBtnCheckInClick() throws ims.framework.exceptions.PresentationLogicException
	{
		PatientDocumentErrorVoCollection errors = new PatientDocumentErrorVoCollection();
		
		for(int i=0; i<form.grdDocuments().getRows().size(); i++)
		{
			if (form.grdDocuments().getRows().get(i).getColSelect())
			{
				String error = checkIn(form.grdDocuments().getRows().get(i).getValue());
				
				if(error != null && error.length() > 0)
					errors.add(getDocumentError(form.grdDocuments().getRows().get(i).getValue(), error));
			}
		}
		
		if (errors.size() >0)
		{
			engine.open(form.getForms().Core.PatientDocumentErrors,new Object[]{errors});
		}
		
		open();
	}
	
	@Override
	protected void onBtnUndoCheckOutClick() throws ims.framework.exceptions.PresentationLogicException
	{
		PatientDocumentErrorVoCollection errors = new PatientDocumentErrorVoCollection();
		
		for(int i=0; i<form.grdDocuments().getRows().size(); i++)
		{
			if (form.grdDocuments().getRows().get(i).getColSelect())
			{
				String error = undoCheckOut(form.grdDocuments().getRows().get(i).getValue());
				
				if(error != null && error.length() > 0)
					errors.add(getDocumentError(form.grdDocuments().getRows().get(i).getValue(), error));
			}
		}
		
		if (errors.size() >0)
		{
			engine.open(form.getForms().Core.PatientDocumentErrors,new Object[]{errors});
		}
		
		open();
	}

	@Override
	protected void onGrdDocumentsGridCheckBoxClicked(int column, grdDocumentsRow row, boolean isChecked) throws PresentationLogicException 
	{
		if(row.getValue() instanceof CheckedOutDocumentVo)
		{
			CheckedOutDocumentVo currentValue = row.getValue();
			
			currentValue.setIsChecked(isChecked);
			row.setValue(currentValue);
		}
		
		updateControlsState();
	}

	private void updateControlsState() 
	{
		boolean isViewMode = form.getMode().equals(FormMode.VIEW);
		boolean areDocumentsSelected = areDocumentsSelected();
		
		form.btnCheckIn().setEnabled(isViewMode && areDocumentsSelected);
		form.btnUndoCheckOut().setEnabled(isViewMode && areDocumentsSelected);
	}

	private boolean areDocumentsSelected() 
	{
		for (int i = 0; i < form.grdDocuments().getRows().size(); i++)
		{
			if (form.grdDocuments().getRows().get(i).getColSelect())
				return true;
		}
		
		return false;
	}
	
	private String undoCheckOut(CheckedOutDocumentVo doc)
	{
		if(doc == null || doc.getServerDocument() == null)
			return null;
		
		String fileName = doc.getServerDocument().getFileName();
		StringBuilder newFileName = new StringBuilder();
		
		if (!deleteFile((getCheckOutWorkArea() + fileName).replace("/", "\\")))//WDEV-13366
		{
			if (isStale(doc))
			{
				return ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue();
			}
			
			String forceCheckOutError = forceCheckOut(fileName, newFileName);
			
			if(forceCheckOutError != null && forceCheckOutError.length() > 0)
				return forceCheckOutError;
		}

		if(newFileName.length() > 0)
		{
			doc.getServerDocument().setFileName(newFileName.toString());
		}
		
		doc.setIsLockedForEditing(false);
		doc.setLockedByUser(null);
		doc.setLockedOnDateTime(null);
		doc.validate();

		try 
		{
			domain.savePatientDocument(doc);
		} 
		catch (StaleObjectException e) 
		{
			return "Could not save Patient Document.\nThe document has been modified by another user";
		} 
		
		return null;
	}
	
	private String forceCheckOut(String oldFileName, StringBuilder newFileName) 
	{
		if(oldFileName == null || oldFileName.length() == 0)
			return null;
		
		String fullOldFileName  = (getWorkAreaPath() + oldFileName).replace("/", "\\");	//WDEV-13366
		newFileName.append(generateName() + ".rtf");//WDEV-13366
		String fullNewFileName = (getWorkAreaPath() + newFileName).replace("/", "\\");//WDEV-13366
		
		String copyError = copyFile(fullOldFileName, fullNewFileName);
		
		if(copyError == null)
		{
			deleteFile((getWorkAreaPath() + oldFileName).replace("/", "\\"));		//WDEV-13366
			return null;
		}
		
		return copyError;
	}

	private String getWorkAreaPath()
	{
		String storePath = ConfigFlag.GEN.MAXIMS_DOCUMENT_WORK_AREA.getValue();

		if (!(storePath.endsWith("/") || storePath.endsWith("\\")))
			storePath = storePath + "/";

		return storePath;
	}
	
	//WDEV-13366
	private String getCheckOutWorkArea()
	{
		String checkOutPath = getWorkAreaPath() + CHECKOUT_FOLDER;
		
		File checkout = new File(checkOutPath);
		
		if(!checkout.exists())
			checkout.mkdirs();
		
		String newCheckOutPath = checkout.getPath();
		
		if (!(newCheckOutPath.endsWith("/") || newCheckOutPath.endsWith("\\")))
			newCheckOutPath = newCheckOutPath + "/";

		return newCheckOutPath;
	}
	
	private boolean deleteFile(String fileToDelete)
	{
		File file = new File(fileToDelete);
		
		if(!file.exists())
			return true;
		
		return file.delete();
	}
	
	private boolean isStale(CheckedOutDocumentVo patientDocument)
	{
		if (patientDocument == null || !patientDocument.getServerDocumentIsNotNull() || !patientDocument.getServerDocument().getFileNameIsNotNull())
			return false;
		
		File rtfFile = new File(patientDocument.getServerDocument().getFileName());

		if (!rtfFile.exists())
		{
			if (domain.isStaleObjectException(patientDocument))
				return true;
		}

		return false;
	}
	
	private PatientDocumentErrorVo getDocumentError(CheckedOutDocumentVo docP, String errorS)
	{
		PatientDocumentErrorVo errorVo = new PatientDocumentErrorVo();
		errorVo.setDocumentDate(docP.getDocumentDate());
		errorVo.setDocumentName(docP.getName());
		errorVo.setPatient(docP.getPatient().getName());
		errorVo.setError(errorS);
		return errorVo;
	}
	
	private String checkIn(CheckedOutDocumentVo doc)
	{
		if(doc == null)
			return null;
		
		doc.setIsLockedForEditing(false);
		doc.setLockedByUser(null);
		doc.setLockedOnDateTime(null);

		String copyError = copyToStoreArea(doc);
		if(copyError != null)
			return copyError;
		
		String fileName = doc.getServerDocument().getFileName();
		StringBuilder newFileName = new StringBuilder();
		
		if (!deleteFile((getCheckOutWorkArea() + fileName).replace("/", "\\")))//WDEV-13366
		{
			String forceCheckInError = forceCheckIn(fileName, newFileName);
			
			if(forceCheckInError != null && forceCheckInError.length() > 0)
				return forceCheckInError;
		}
		
		if(newFileName.length() > 0)
		{
			doc.getServerDocument().setFileName(newFileName.toString());
		}
		
		doc.validate();
		
		try
		{
			domain.savePatientDocument(doc);
		}
		catch (StaleObjectException e)
		{
			return "Could not save Patient Document.\nThe document has been modified by another user";
		}
		
		return null;
	}
	
	private String forceCheckIn(String oldFileName, StringBuilder newFileName) 
	{
		if(oldFileName == null || oldFileName.length() == 0)
			return null;
		
		String fullOldFileName  = (getCheckOutWorkArea() + oldFileName).replace("/", "\\");	//WDEV-13366
		newFileName.append(generateName() + ".rtf");//WDEV-13366
		String fullNewFileName = (getWorkAreaPath() + newFileName).replace("/", "\\");//WDEV-13366
		
		String copyError = copyFile(fullOldFileName, fullNewFileName);
		
		if(copyError == null)
		{
			deleteFile((getWorkAreaPath() + oldFileName).replace("/", "\\"));		//WDEV-13366
			return null;
		}
		
		return copyError;
	}

	private String copyToStoreArea(CheckedOutDocumentVo doc)
	{
		String fileName = doc.getServerDocument().getFileName();
		String destinationFilePath = (getWorkAreaPath() + fileName).replace("/", "\\");//WDEV-13366
		String sourceFilePath = (getCheckOutWorkArea() + fileName).replace("/", "\\");//WDEV-13366
		return copyFile(sourceFilePath, destinationFilePath);
	}
	
	private String copyFile(String sourceFilePath, String destinationFilePath)
	{
		File sourceFile = new File(sourceFilePath);
		
		if (!sourceFile.exists())
			return "Could not find the document on work area.";
		
		File destinationFile = new File(destinationFilePath);
		if (!destinationFile.exists())
		{
			try
			{
				File parentDir = destinationFile.getParentFile();
				if (!parentDir.exists())
					parentDir.mkdirs();
				destinationFile.createNewFile();
			}
			catch (IOException e)
			{
				return "Could not create the document on store area. An I/O error occurred";
			}
		}
		
		FileInputStream in = null;
		FileOutputStream out = null;

		try
		{
			in = new FileInputStream(sourceFile);
			out = new FileOutputStream(destinationFile, false);
			byte[] buffer = new byte[1024 * 64];
			int bytesRead;
			while ((bytesRead = in.read(buffer)) != -1)
			{
				out.write(buffer, 0, bytesRead);
			}

		}
		catch (FileNotFoundException e)
		{
			return "An error occured while copying the file on store area!";
		}
		catch (IOException e)
		{
			return "An I/O error occured while copying the file on store area!";
		}
		finally
		{
			try
			{
				if (in != null)
					in.close();
			}
			catch (IOException e)
			{
				// no action
			}
			try
			{
				if (out != null)
					out.close();
			}
			catch (IOException e)
			{
				// no action
			}
		}
		
		return null;
	}

	@Override
	protected void onGrdDocumentsGridHeaderClicked(int column) throws PresentationLogicException 
	{
		if(column == LOCKED_DATE_COL_INDEX)
		{
			if (form.getLocalContext().getSortOrderLockedDate() == null || !form.getLocalContext().getSortOrderLockedDate().equals(SortOrder.ASCENDING))
				form.getLocalContext().setSortOrderLockedDate(SortOrder.ASCENDING);
			else
				form.getLocalContext().setSortOrderLockedDate(SortOrder.DESCENDING);
			
			populateGrid(sortDocumentsByLockedDate(form.grdDocuments().getValues()));
		}
		
		updateControlsState();
	}
	
	private CheckedOutDocumentVoCollection sortDocumentsByLockedDate(CheckedOutDocumentVoCollection documents) 
	{
		if(documents == null || documents.size() == 0)
			return null;
		
		return documents.sort(new DateTimeComparator(form.getLocalContext().getSortOrderLockedDate()));
	}

	@Override
	protected void onImbRefreshClick() throws PresentationLogicException 
	{
		open();
	}
	
	private String generateName() 
	{
		String str = "";

		try
		{
			//Get Random Segment
			SecureRandom prng = SecureRandom.getInstance("SHA1PRNG");
			str += Integer.toHexString(prng.nextInt());
			while (str.length() < 8)
			{
				str = '0' + str;
			}

			//Get CurrentTimeMillis() segment
			str += Long.toHexString(System.currentTimeMillis());
			while (str.length() < 12)
			{
				str = '0' + str;
			}

			//Get Random Segment
			SecureRandom secondPrng = SecureRandom.getInstance("SHA1PRNG");
			str += Integer.toHexString(secondPrng.nextInt());
			while (str.length() < 8)
			{
				str = '0' + str;
			}

			//Get IdentityHash() segment
			str += Long.toHexString(System.identityHashCode((Object) this));
			while (str.length() < 8)
			{
				str = '0' + str;
			}
			//Get Third Random Segment
			byte bytes[] = new byte[16];
			SecureRandom thirdPrng = SecureRandom.getInstance("SHA1PRNG");
			thirdPrng.nextBytes(bytes);
			str += Integer.toHexString(thirdPrng.nextInt());
			while (str.length() < 8)
			{
				str = '0' + str;
			}
		}
		catch (java.security.NoSuchAlgorithmException ex)
		{
			ex.getMessage();
		}

		return str;
	}
	
	public class DateTimeComparator implements Comparator
	{
		private int direction = 1;
		
		public DateTimeComparator()
		{
			this(SortOrder.ASCENDING);
		}
		
		public DateTimeComparator(SortOrder order)
		{
			if (order == SortOrder.DESCENDING)
			{
				direction = -1;
			}
		}
		
		public int compare(Object o1, Object o2)
		{
			DateTime startDate1 = null;
			DateTime startDate2 = null;
			
			if(o1 instanceof CheckedOutDocumentVo)
			{
				CheckedOutDocumentVo doc1 = ((CheckedOutDocumentVo) o1);
				startDate1 = doc1.getLockedOnDateTime();
			}
			
			if(o2 instanceof CheckedOutDocumentVo)
			{
				CheckedOutDocumentVo doc2 = ((CheckedOutDocumentVo) o2);
				startDate2 = doc2.getLockedOnDateTime();
			}
			
			if(startDate1 == null)
				return -1*direction;
			
			if(startDate2 == null)
				return direction;
			
			return startDate1.compareTo(startDate2)*direction;
		}
	}
}
