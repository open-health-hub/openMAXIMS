//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by George Cristian Josan using IMS Development Environment (version 1.80 build 4342.23748)
// Copyright (C) 1995-2012 IMS MAXIMS. All rights reserved.

package ims.icp.forms.bringstagephaseintoscope;

import java.util.ArrayList;

import ims.configuration.gen.ConfigFlag;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.controls.TreeNode;
import ims.framework.enumerations.DialogResult;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.exceptions.PresentationLogicException;
import ims.framework.utils.Color;
import ims.icp.vo.ICPAction_StatusChangeVo;
import ims.icp.vo.ICPPhase_StatusChangeVo;
import ims.icp.vo.ICPStage_StatusChangeVo;
import ims.icp.vo.ICP_StatusChangeVo;
import ims.icp.vo.PatientICPAction_StatusChangeVo;
import ims.icp.vo.PatientICPPhase_StatusChangeVo;
import ims.icp.vo.PatientICPStage_StatusChangeVo;
import ims.icp.vo.PatientICP_StatusChangeVo;
import ims.icp.vo.lookups.ICPPhaseStatus;
import ims.icp.vo.lookups.ICPStageStatus;
import ims.icps.configuration.vo.ICPActionRefVo;
import ims.icps.configuration.vo.ICPPhaseRefVo;
import ims.icps.configuration.vo.ICPStageRefVo;
import ims.icps.instantiation.domain.objects.PatientICP;

public class Logic extends BaseLogic
{
	private static final long serialVersionUID = 1L;

	//------------------------------------------------------------------------------------------------------------------------------------------------------------
	//	Event handlers region
	//------------------------------------------------------------------------------------------------------------------------------------------------------------

	@Override
	protected void onFormOpen(Object[] args) throws ims.framework.exceptions.PresentationLogicException
	{
		open();
	}

	@Override
	protected void onTreICPTreeViewCheck(TreeNode node) throws PresentationLogicException
	{
		updateControlsState();
	}

	@Override
	protected void onBtnActivateClick() throws ims.framework.exceptions.PresentationLogicException
	{
		if (save())
			engine.close(DialogResult.OK);
	}
	
	@Override
	protected void onBtnCancelClick() throws ims.framework.exceptions.PresentationLogicException
	{
		engine.close(DialogResult.CANCEL);
	}

	
	
	//------------------------------------------------------------------------------------------------------------------------------------------------------------
	//	Form presentation functions
	//------------------------------------------------------------------------------------------------------------------------------------------------------------

	public void open() throws PresentationLogicException
	{
		PatientICP_StatusChangeVo patientICP = domain.getPatientICP(form.getGlobalContext().ICP.getPatientICPRecord());
		
		// Check for a stale or completed Patient ICP object
		if (patientICP.getVersion_PatientICP() > form.getGlobalContext().ICP.getPatientICPRecord().getVersion_PatientICP()
				&& patientICP.getCompletedDateTime() != null)
		{
			engine.showMessage(ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue());
			engine.close(DialogResult.CANCEL);
			return;
		}
		
		populateTreeInstanceControl(patientICP.getICP(), patientICP);
		
		updateControlsState();
	}

	public boolean save() throws PresentationLogicException
	{
		try
		{
			// Get checked nodes
			ArrayList<Object> checkedNodes = populateCheckedNodesCollection();

			// Prepare stage or phases to be brought into scope
			if (engine.getFormName().equals(form.getForms().ICP.BringStageIntoScope))
			{
				domain.bringStagesIntoScope(form.getGlobalContext().ICP.getPatientICPRecord(), checkedNodes);
			}
			else if (engine.getFormName().equals(form.getForms().ICP.BringPhaseIntoScope))
			{
				domain.bringPhasesIntoScope(form.getGlobalContext().ICP.getPatientICPRecord(), checkedNodes);
			}

			return true;
		}
		catch (StaleObjectException e)
		{
			engine.showMessage(ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue());
			e.printStackTrace();
			
			if (e.getStaleObject() instanceof PatientICP)
			{
				if (((PatientICP) e.getStaleObject()).getCompletedDateTime() != null)
				{
					engine.close(DialogResult.CANCEL);
					return false;
				}
			}
			
			open();
			return false;
		}
	}

	private ArrayList<Object> populateCheckedNodesCollection()
	{
		// Hold all checked stages / phases
		ArrayList<Object> checkedIdentifiers = new ArrayList<Object>();
		
		// Iterate all Stage nodes
		for (int i = 0; i < form.treICP().getNodes().size(); i++)
		{
			TreeNode stageNode = form.treICP().getNodes().get(i);
			
			// If the stage node is checked add the stage to the collection of items to be brought into scope
			if (stageNode.isChecked())
				checkedIdentifiers.add(stageNode.getIdentifier());

			// For a Stage node iterate all Phase nodes
			if (stageNode.getNodes() != null && stageNode.getNodes().size() > 0)
			{
				for (int j = 0; j < stageNode.getNodes().size(); j++)
				{
					TreeNode phaseNode = stageNode.getNodes().get(j);
					
					// If the phase is checked add the phase to the collection of items to be brought into scope
					if (phaseNode.isChecked())
						checkedIdentifiers.add(phaseNode.getIdentifier());
				}
			}
		}

		// Return items to be brought into scope
		return checkedIdentifiers;
	}

	public void updateControlsState()
	{
		// Get the number of checked nodes
		form.btnActivate().setEnabled(isNodesChecked());
	}

	private boolean isNodesChecked()
	{
		for (int i = 0; i < form.treICP().getNodes().size(); i++)
		{
			TreeNode stageNode = form.treICP().getNodes().get(i);

			if (stageNode.isChecked())
				return true;
			
			if (stageNode.getNodes() != null && stageNode.getNodes().size() > 0)
			{
				for (int j = 0; j < stageNode.getNodes().size(); j++)
				{
					TreeNode phaseNode = stageNode.getNodes().get(j);
					
					if (phaseNode.isChecked())
						return true;
				}
			}
		}

		return false;
	}

	private void populateTreeInstanceControl(ICP_StatusChangeVo icp, PatientICP_StatusChangeVo patientICP)
	{
		// Clear tree
		form.treICP().clear();
		
		// Order stages in ICP (Configuration) after sequence
		icp.getStages().sort();
		
		// Populate ICP Stages
		for (ICPStage_StatusChangeVo stage : icp.getStages())
		{
			populateICPStage(stage);
		}
		
		// Populate Patient ICP Stages
		for (PatientICPStage_StatusChangeVo stage : patientICP.getStages())
		{
			populatePatientICPStage(stage);
		}
	}

	private void populatePatientICPStage(PatientICPStage_StatusChangeVo stage)
	{
		// Check stage parameter
		if (stage == null)
			return;
		
		// Get node from tree
		TreeNode stageNode = form.treICP().getNodeByValue(stage.getStage());
		
		if (stageNode == null)
			throw new CodingRuntimeException("Error");
		
		// Update node identifier
		stageNode.setIdentifier(stage);
		
		
		// Determine if the node should still be selectable
		if (engine.getFormName().equals(form.getForms().ICP.BringStageIntoScope))
		{
			if (ICPStageStatus.OUTSTANDING.equals(stage.getCurrentStatus().getStatus()))
			{
				stageNode.setCheckBoxVisible(false);
			}
		}

		
		// Populate Patient ICP Phases
		for (PatientICPPhase_StatusChangeVo phase : stage.getStagePhases())
		{
			populatePatientICPPhase(phase);
		}
	}

	private void populatePatientICPPhase(PatientICPPhase_StatusChangeVo phase)
	{
		// Check phase parameter
		if (phase == null)
			return;
		
		// Get node from tree
		TreeNode phaseNode = form.treICP().getNodeByValue(phase.getPhase());
		
		if (phaseNode == null)
			throw new CodingRuntimeException("Error");
		
		// Update node identifier
		phaseNode.setIdentifier(phase);
		
		
		// Determine if the node should still be selectable
		if (engine.getFormName().equals(form.getForms().ICP.BringPhaseIntoScope))
		{
			if (ICPPhaseStatus.INPROGRESS.equals(phase.getCurrentStatus().getStatus()))
			{
				phaseNode.setCheckBoxVisible(false);
			}
		}
		
		// Populate Patient ICP Actions
		for (PatientICPAction_StatusChangeVo action : phase.getPhaseActions())
		{
			populatePatientICPAction(action);
		}
	}

	private void populatePatientICPAction(PatientICPAction_StatusChangeVo action)
	{
		// Check action parameter
		if (action == null)
			return;
		
		// Get node from tree
		TreeNode actionNode = form.treICP().getNodeByValue((ICPActionRefVo) action.getAction());
		
		if (actionNode == null)
			throw new CodingRuntimeException("Error");
		
		// Update node identifier
		actionNode.setIdentifier(action);
	}

	/**
	 * Function used to populate node with ICP Stage 
	 */
	private void populateICPStage(ICPStage_StatusChangeVo stage)
	{
		// Check stage parameter
		if (stage == null)
			return;
		
		// Create node for stage
		TreeNode stageNode = form.treICP().getNodes().add((ICPStageRefVo) stage, stage.getName());
		
		// Set node attributes
		stageNode.setCollapsedImage(form.getImages().ICP.Stage);
		stageNode.setExpandedImage(form.getImages().ICP.Stage);
		stageNode.setSelectedImage(form.getImages().ICP.Stage);
		
		stageNode.setTextColor(PreActiveActiveInactiveStatus.INACTIVE.equals(stage.getStatus()) ? Color.Gray : Color.Black);

		// Set node value (ICPStageRef) & node identifier
		stageNode.setValue((ICPStageRefVo) stage);
		stageNode.setIdentifier(stage);
		
		
		// Sort stage phase
		stage.getPhases().sort();

		boolean hasActivePhasesWithActiveActions = false;
		
		// Populate ICP Phases for stage
		for (ICPPhase_StatusChangeVo phase : stage.getPhases())
		{
			hasActivePhasesWithActiveActions = populateICPPhase(phase, stageNode) || hasActivePhasesWithActiveActions;
		}
		
		
		// Determine if stage node should be selectable
		boolean isActive = PreActiveActiveInactiveStatus.ACTIVE.equals(stage.getStatus());
		boolean selectStages = engine.getFormName().equals(form.getForms().ICP.BringStageIntoScope);
		
		stageNode.setCheckBoxVisible(selectStages && isActive && hasActivePhasesWithActiveActions);
		stageNode.setExpanded(true); 
	}

	
	/**
	 *	Function used to populate nodes with ICP Phase 
	 */
	private boolean populateICPPhase(ICPPhase_StatusChangeVo phase, TreeNode stageNode)
	{
		// Check phase parameter
		if (phase == null)
			return false;
	
		// Create node for phase
		TreeNode phaseNode = stageNode.getNodes().add((ICPPhaseRefVo) phase, phase.getName());
		
		// Set node attributes
		phaseNode.setCollapsedImage(form.getImages().ICP.Phase);
		phaseNode.setExpandedImage(form.getImages().ICP.Phase);
		phaseNode.setSelectedImage(form.getImages().ICP.Phase);
		
		phaseNode.setTextColor(PreActiveActiveInactiveStatus.INACTIVE.equals(phase.getStatus()) ? Color.Gray : Color.Black);
		
		// Set node value (ICPPhaseRef) & node identifier
		phaseNode.setValue((ICPPhaseRefVo) phase);
		phaseNode.setIdentifier(phase);
		
		
		// Sort phase actions
		phase.getActions().sort();
		
		
		boolean hasActiveActions = false;
		
		// Populate ICP Actions for phase
		for (ICPAction_StatusChangeVo action : phase.getActions())
		{
			hasActiveActions = populateICPAction(action, phaseNode) || hasActiveActions;
		}
		
		
		// Determine if the phase can be brought into scope
		boolean isActive = PreActiveActiveInactiveStatus.ACTIVE.equals(phase.getStatus());
		boolean selectPhases = engine.getFormName().equals(form.getForms().ICP.BringPhaseIntoScope);
		
		phaseNode.setCheckBoxVisible(selectPhases && isActive && hasActiveActions);
			
		return isActive && hasActiveActions;
	}

	
	/**
	 *	Function used to populate nodes with ICP Action
	 */
	private boolean populateICPAction(ICPAction_StatusChangeVo action, TreeNode phaseNode)
	{
		// Check action parameter
		if (action == null)
			return false;
		
		// Create node for action
		TreeNode actionNode = phaseNode.getNodes().add((ICPActionRefVo) action, action.getName());
		
		// Set node attributes
		actionNode.setCollapsedImage(form.getImages().ICP.Action);
		actionNode.setExpandedImage(form.getImages().ICP.Action);
		actionNode.setSelectedImage(form.getImages().ICP.Action);
		
		actionNode.setTextColor(PreActiveActiveInactiveStatus.INACTIVE.equals(action.getStatus()) ? Color.Gray : Color.Black);
		
		actionNode.setCheckBoxVisible(false);
		
		// Set node value (ICPActionRef) & node identifier
		actionNode.setValue((ICPActionRefVo) action);
		actionNode.setIdentifier(action);
		
		return PreActiveActiveInactiveStatus.ACTIVE.equals(action.getStatus());
	}
}
